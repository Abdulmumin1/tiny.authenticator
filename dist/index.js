#!/usr/bin/env node
import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod2, isNodeMode, target) => {
  target = mod2 != null ? __create(__getProtoOf(mod2)) : {};
  const to = isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod2))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod2[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod2) => () => (mod2 || cb((mod2 = { exports: {} }).exports, mod2), mod2.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS((exports, module) => {
  (function() {
    function defineDeprecationWarning(methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function() {
          console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
        }
      });
    }
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object")
        return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return typeof maybeIterable === "function" ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
      publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
      var warningKey = publicInstance + "." + callerName;
      didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, publicInstance), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
    }
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function noop() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch (e) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE)
        return "<>";
      if (typeof type === "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return dispatcher === null ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning)
          return false;
      }
      return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return componentName !== undefined ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
      var refProp = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props,
        _owner: owner
      };
      (refProp !== undefined ? refProp : null) !== null ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      newKey = ReactElement(oldElement.type, newKey, oldElement.props, oldElement._owner, oldElement._debugStack, oldElement._debugTask);
      oldElement._store && (newKey._store.validated = oldElement._store.validated);
      return newKey;
    }
    function validateChildKeys(node) {
      isValidElement(node) ? node._store && (node._store.validated = 1) : typeof node === "object" && node !== null && node.$$typeof === REACT_LAZY_TYPE && (node._payload.status === "fulfilled" ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
      return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    function getElementKey(element, index) {
      return typeof element === "object" && element !== null && element.key != null ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch (typeof thenable.status === "string" ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
            thenable.status === "pending" && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
          }, function(error) {
            thenable.status === "pending" && (thenable.status = "rejected", thenable.reason = error);
          })), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if (type === "undefined" || type === "boolean")
        children = null;
      var invokeCallback = false;
      if (children === null)
        invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
            }
        }
      if (invokeCallback) {
        invokeCallback = children;
        callback = callback(invokeCallback);
        var childKey = nameSoFar === "" ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
        isArrayImpl(callback) ? (escapedPrefix = "", childKey != null && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
          return c;
        })) : callback != null && (isValidElement(callback) && (callback.key != null && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(callback, escapedPrefix + (callback.key == null || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + childKey), nameSoFar !== "" && invokeCallback != null && isValidElement(invokeCallback) && invokeCallback.key == null && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
        return 1;
      }
      invokeCallback = 0;
      childKey = nameSoFar === "" ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0;i < children.length; i++)
          nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
      else if (i = getIteratorFn(children), typeof i === "function")
        for (i === children.entries && (didWarnAboutMaps || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = true), children = i.call(children), i = 0;!(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
      else if (type === "object") {
        if (typeof children.then === "function")
          return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
        array = String(children);
        throw Error("Objects are not valid as a React child (found: " + (array === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (children == null)
        return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (payload._status === -1) {
        var ioInfo = payload._ioInfo;
        ioInfo != null && (ioInfo.start = ioInfo.end = performance.now());
        ioInfo = payload._result;
        var thenable = ioInfo();
        thenable.then(function(moduleObject) {
          if (payload._status === 0 || payload._status === -1) {
            payload._status = 1;
            payload._result = moduleObject;
            var _ioInfo = payload._ioInfo;
            _ioInfo != null && (_ioInfo.end = performance.now());
            thenable.status === undefined && (thenable.status = "fulfilled", thenable.value = moduleObject);
          }
        }, function(error) {
          if (payload._status === 0 || payload._status === -1) {
            payload._status = 2;
            payload._result = error;
            var _ioInfo2 = payload._ioInfo;
            _ioInfo2 != null && (_ioInfo2.end = performance.now());
            thenable.status === undefined && (thenable.status = "rejected", thenable.reason = error);
          }
        });
        ioInfo = payload._ioInfo;
        if (ioInfo != null) {
          ioInfo.value = thenable;
          var displayName = thenable.displayName;
          typeof displayName === "string" && (ioInfo.name = displayName);
        }
        payload._status === -1 && (payload._status = 0, payload._result = thenable);
      }
      if (payload._status === 1)
        return ioInfo = payload._result, ioInfo === undefined && console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, ioInfo), "default" in ioInfo || console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, ioInfo), ioInfo.default;
      throw payload._result;
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      dispatcher === null && console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return dispatcher;
    }
    function releaseAsyncTransition() {
      ReactSharedInternals.asyncTransitions--;
    }
    function enqueueTask(task) {
      if (enqueueTaskImpl === null)
        try {
          var requireString = ("require" + Math.random()).slice(0, 7);
          enqueueTaskImpl = (module && module[requireString]).call(module, "timers").setImmediate;
        } catch (_err) {
          enqueueTaskImpl = function(callback) {
            didWarnAboutMessageChannel === false && (didWarnAboutMessageChannel = true, typeof MessageChannel === "undefined" && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
            var channel = new MessageChannel;
            channel.port1.onmessage = callback;
            channel.port2.postMessage(undefined);
          };
        }
      return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors) {
      return 1 < errors.length && typeof AggregateError === "function" ? new AggregateError(errors) : errors[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
      prevActScopeDepth !== actScopeDepth - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
      actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve2, reject2) {
      var queue = ReactSharedInternals.actQueue;
      if (queue !== null)
        if (queue.length !== 0)
          try {
            flushActQueue(queue);
            enqueueTask(function() {
              return recursivelyFlushAsyncActWork(returnValue, resolve2, reject2);
            });
            return;
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
        else
          ReactSharedInternals.actQueue = null;
      0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject2(queue)) : resolve2(returnValue);
    }
    function flushActQueue(queue) {
      if (!isFlushing) {
        isFlushing = true;
        var i = 0;
        try {
          for (;i < queue.length; i++) {
            var callback = queue[i];
            do {
              ReactSharedInternals.didUsePromise = false;
              var continuation = callback(false);
              if (continuation !== null) {
                if (ReactSharedInternals.didUsePromise) {
                  queue[i] = callback;
                  queue.splice(0, i);
                  return;
                }
                callback = continuation;
              } else
                break;
            } while (1);
          }
          queue.length = 0;
        } catch (error) {
          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
        } finally {
          isFlushing = false;
        }
      }
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function(publicInstance) {
        warnNoop(publicInstance, "forceUpdate");
      },
      enqueueReplaceState: function(publicInstance) {
        warnNoop(publicInstance, "replaceState");
      },
      enqueueSetState: function(publicInstance) {
        warnNoop(publicInstance, "setState");
      }
    }, assign = Object.assign, emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null)
        throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
      isMounted: [
        "isMounted",
        "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
      ],
      replaceState: [
        "replaceState",
        "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
      ]
    };
    for (fnName in deprecatedAPIs)
      deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy;
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = true;
    var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
      H: null,
      A: null,
      T: null,
      S: null,
      actQueue: null,
      asyncTransitions: 0,
      isBatchingLegacy: false,
      didScheduleLegacyUpdate: false,
      didUsePromise: false,
      thrownErrors: [],
      getCurrentStack: null,
      recentlyCreatedOwnerStacks: 0
    }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    deprecatedAPIs = {
      react_stack_bottom_frame: function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(deprecatedAPIs, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = typeof reportError === "function" ? reportError : function(error) {
      if (typeof window === "object" && typeof window.ErrorEvent === "function") {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event))
          return;
      } else if (typeof process === "object" && typeof process.emit === "function") {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = typeof queueMicrotask === "function" ? function(callback) {
      queueMicrotask(function() {
        return queueMicrotask(callback);
      });
    } : enqueueTask;
    deprecatedAPIs = Object.freeze({
      __proto__: null,
      c: function(size) {
        return resolveDispatcher().useMemoCache(size);
      }
    });
    var fnName = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      },
      count: function(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw Error("React.Children.only expected to receive a single React element child.");
        return children;
      }
    };
    exports.Activity = REACT_ACTIVITY_TYPE;
    exports.Children = fnName;
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.__COMPILER_RUNTIME = deprecatedAPIs;
    exports.act = function(callback) {
      var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
      actScopeDepth++;
      var queue = ReactSharedInternals.actQueue = prevActQueue !== null ? prevActQueue : [], didAwaitActCall = false;
      try {
        var result = callback();
      } catch (error) {
        ReactSharedInternals.thrownErrors.push(error);
      }
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      if (result !== null && typeof result === "object" && typeof result.then === "function") {
        var thenable = result;
        queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
        });
        return {
          then: function(resolve2, reject2) {
            didAwaitActCall = true;
            thenable.then(function(returnValue) {
              popActScope(prevActQueue, prevActScopeDepth);
              if (prevActScopeDepth === 0) {
                try {
                  flushActQueue(queue), enqueueTask(function() {
                    return recursivelyFlushAsyncActWork(returnValue, resolve2, reject2);
                  });
                } catch (error$0) {
                  ReactSharedInternals.thrownErrors.push(error$0);
                }
                if (0 < ReactSharedInternals.thrownErrors.length) {
                  var _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
                  ReactSharedInternals.thrownErrors.length = 0;
                  reject2(_thrownError);
                }
              } else
                resolve2(returnValue);
            }, function(error) {
              popActScope(prevActQueue, prevActScopeDepth);
              0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject2(error)) : reject2(error);
            });
          }
        };
      }
      var returnValue$jscomp$0 = result;
      popActScope(prevActQueue, prevActScopeDepth);
      prevActScopeDepth === 0 && (flushActQueue(queue), queue.length !== 0 && queueSeveralMicrotasks(function() {
        didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
      }), ReactSharedInternals.actQueue = null);
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      return {
        then: function(resolve2, reject2) {
          didAwaitActCall = true;
          prevActScopeDepth === 0 ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
            return recursivelyFlushAsyncActWork(returnValue$jscomp$0, resolve2, reject2);
          })) : resolve2(returnValue$jscomp$0);
        }
      };
    };
    exports.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    exports.cacheSignal = function() {
      return null;
    };
    exports.captureOwnerStack = function() {
      var getCurrentStack = ReactSharedInternals.getCurrentStack;
      return getCurrentStack === null ? null : getCurrentStack();
    };
    exports.cloneElement = function(element, config, children) {
      if (element === null || element === undefined)
        throw Error("The argument must be a React element, but you passed " + element + ".");
      var props = assign({}, element.props), key = element.key, owner = element._owner;
      if (config != null) {
        var JSCompiler_inline_result;
        a: {
          if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(config, "ref").get) && JSCompiler_inline_result.isReactWarning) {
            JSCompiler_inline_result = false;
            break a;
          }
          JSCompiler_inline_result = config.ref !== undefined;
        }
        JSCompiler_inline_result && (owner = getOwner());
        hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
        for (propName in config)
          !hasOwnProperty.call(config, propName) || propName === "key" || propName === "__self" || propName === "__source" || propName === "ref" && config.ref === undefined || (props[propName] = config[propName]);
      }
      var propName = arguments.length - 2;
      if (propName === 1)
        props.children = children;
      else if (1 < propName) {
        JSCompiler_inline_result = Array(propName);
        for (var i = 0;i < propName; i++)
          JSCompiler_inline_result[i] = arguments[i + 2];
        props.children = JSCompiler_inline_result;
      }
      props = ReactElement(element.type, key, props, owner, element._debugStack, element._debugTask);
      for (key = 2;key < arguments.length; key++)
        validateChildKeys(arguments[key]);
      return props;
    };
    exports.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      defaultValue._currentRenderer = null;
      defaultValue._currentRenderer2 = null;
      return defaultValue;
    };
    exports.createElement = function(type, config, children) {
      for (var i = 2;i < arguments.length; i++)
        validateChildKeys(arguments[i]);
      i = {};
      var key = null;
      if (config != null)
        for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), config)
          hasOwnProperty.call(config, propName) && propName !== "key" && propName !== "__self" && propName !== "__source" && (i[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1)
        i.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), _i = 0;_i < childrenLength; _i++)
          childArray[_i] = arguments[_i + 2];
        Object.freeze && Object.freeze(childArray);
        i.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          i[propName] === undefined && (i[propName] = childrenLength[propName]);
      key && defineKeyPropWarningGetter(i, typeof type === "function" ? type.displayName || type.name || "Unknown" : type);
      var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return ReactElement(type, key, i, getOwner(), propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack, propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.createRef = function() {
      var refObject = { current: null };
      Object.seal(refObject);
      return refObject;
    };
    exports.forwardRef = function(render) {
      render != null && render.$$typeof === REACT_MEMO_TYPE ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof render !== "function" ? console.error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render) : render.length !== 0 && render.length !== 2 && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
      render != null && render.defaultProps != null && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
      Object.defineProperty(elementType, "displayName", {
        enumerable: false,
        configurable: true,
        get: function() {
          return ownName;
        },
        set: function(name) {
          ownName = name;
          render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
        }
      });
      return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function(ctor) {
      ctor = { _status: -1, _result: ctor };
      var lazyType = {
        $$typeof: REACT_LAZY_TYPE,
        _payload: ctor,
        _init: lazyInitializer
      }, ioInfo = {
        name: "lazy",
        start: -1,
        end: -1,
        value: null,
        owner: null,
        debugStack: Error("react-stack-top-frame"),
        debugTask: console.createTask ? console.createTask("lazy()") : null
      };
      ctor._ioInfo = ioInfo;
      lazyType._debugInfo = [{ awaited: ioInfo }];
      return lazyType;
    };
    exports.memo = function(type, compare) {
      type == null && console.error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
      compare = {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: compare === undefined ? null : compare
      };
      var ownName;
      Object.defineProperty(compare, "displayName", {
        enumerable: false,
        configurable: true,
        get: function() {
          return ownName;
        },
        set: function(name) {
          ownName = name;
          type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
        }
      });
      return compare;
    };
    exports.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      currentTransition._updatedFibers = new Set;
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
        typeof returnValue === "object" && returnValue !== null && typeof returnValue.then === "function" && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop, reportGlobalError));
      } catch (error) {
        reportGlobalError(error);
      } finally {
        prevTransition === null && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), prevTransition !== null && currentTransition.types !== null && (prevTransition.types !== null && prevTransition.types !== currentTransition.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    };
    exports.unstable_useCacheRefresh = function() {
      return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function(usable) {
      return resolveDispatcher().use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
      return resolveDispatcher().useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
      return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function(Context) {
      var dispatcher = resolveDispatcher();
      Context.$$typeof === REACT_CONSUMER_TYPE && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?");
      return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function(value, formatterFn) {
      return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function(value, initialValue) {
      return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function(create, deps) {
      create == null && console.warn("React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useEffect(create, deps);
    };
    exports.useEffectEvent = function(callback) {
      return resolveDispatcher().useEffectEvent(callback);
    };
    exports.useId = function() {
      return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function(ref, create, deps) {
      return resolveDispatcher().useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function(create, deps) {
      create == null && console.warn("React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function(create, deps) {
      create == null && console.warn("React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function(create, deps) {
      return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
      return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArg, init) {
      return resolveDispatcher().useReducer(reducer, initialArg, init);
    };
    exports.useRef = function(initialValue) {
      return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function(initialState) {
      return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return resolveDispatcher().useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    };
    exports.useTransition = function() {
      return resolveDispatcher().useTransition();
    };
    exports.version = "19.2.3";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// node_modules/react/index.js
var require_react = __commonJS((exports, module) => {
  var react_development = __toESM(require_react_development());
  if (false) {} else {
    module.exports = react_development;
  }
});

// node_modules/signal-exit/signals.js
var require_signals = __commonJS((exports, module) => {
  module.exports = [
    "SIGABRT",
    "SIGALRM",
    "SIGHUP",
    "SIGINT",
    "SIGTERM"
  ];
  if (process.platform !== "win32") {
    module.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
  }
  if (process.platform === "linux") {
    module.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS((exports, module) => {
  var process3 = global.process;
  var processOk = function(process4) {
    return process4 && typeof process4 === "object" && typeof process4.removeListener === "function" && typeof process4.emit === "function" && typeof process4.reallyExit === "function" && typeof process4.listeners === "function" && typeof process4.kill === "function" && typeof process4.pid === "number" && typeof process4.on === "function";
  };
  if (!processOk(process3)) {
    module.exports = function() {
      return function() {};
    };
  } else {
    assert = __require("assert");
    signals = require_signals();
    isWin = /^win/i.test(process3.platform);
    EE = __require("events");
    if (typeof EE !== "function") {
      EE = EE.EventEmitter;
    }
    if (process3.__signal_exit_emitter__) {
      emitter = process3.__signal_exit_emitter__;
    } else {
      emitter = process3.__signal_exit_emitter__ = new EE;
      emitter.count = 0;
      emitter.emitted = {};
    }
    if (!emitter.infinite) {
      emitter.setMaxListeners(Infinity);
      emitter.infinite = true;
    }
    module.exports = function(cb, opts) {
      if (!processOk(global.process)) {
        return function() {};
      }
      assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
      if (loaded === false) {
        load();
      }
      var ev = "exit";
      if (opts && opts.alwaysLast) {
        ev = "afterexit";
      }
      var remove = function() {
        emitter.removeListener(ev, cb);
        if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
          unload();
        }
      };
      emitter.on(ev, cb);
      return remove;
    };
    unload = function unload() {
      if (!loaded || !processOk(global.process)) {
        return;
      }
      loaded = false;
      signals.forEach(function(sig) {
        try {
          process3.removeListener(sig, sigListeners[sig]);
        } catch (er) {}
      });
      process3.emit = originalProcessEmit;
      process3.reallyExit = originalProcessReallyExit;
      emitter.count -= 1;
    };
    module.exports.unload = unload;
    emit = function emit(event, code, signal) {
      if (emitter.emitted[event]) {
        return;
      }
      emitter.emitted[event] = true;
      emitter.emit(event, code, signal);
    };
    sigListeners = {};
    signals.forEach(function(sig) {
      sigListeners[sig] = function listener() {
        if (!processOk(global.process)) {
          return;
        }
        var listeners = process3.listeners(sig);
        if (listeners.length === emitter.count) {
          unload();
          emit("exit", null, sig);
          emit("afterexit", null, sig);
          if (isWin && sig === "SIGHUP") {
            sig = "SIGINT";
          }
          process3.kill(process3.pid, sig);
        }
      };
    });
    module.exports.signals = function() {
      return signals;
    };
    loaded = false;
    load = function load() {
      if (loaded || !processOk(global.process)) {
        return;
      }
      loaded = true;
      emitter.count += 1;
      signals = signals.filter(function(sig) {
        try {
          process3.on(sig, sigListeners[sig]);
          return true;
        } catch (er) {
          return false;
        }
      });
      process3.emit = processEmit;
      process3.reallyExit = processReallyExit;
    };
    module.exports.load = load;
    originalProcessReallyExit = process3.reallyExit;
    processReallyExit = function processReallyExit(code) {
      if (!processOk(global.process)) {
        return;
      }
      process3.exitCode = code || 0;
      emit("exit", process3.exitCode, null);
      emit("afterexit", process3.exitCode, null);
      originalProcessReallyExit.call(process3, process3.exitCode);
    };
    originalProcessEmit = process3.emit;
    processEmit = function processEmit(ev, arg) {
      if (ev === "exit" && processOk(global.process)) {
        if (arg !== undefined) {
          process3.exitCode = arg;
        }
        var ret = originalProcessEmit.apply(this, arguments);
        emit("exit", process3.exitCode, null);
        emit("afterexit", process3.exitCode, null);
        return ret;
      } else {
        return originalProcessEmit.apply(this, arguments);
      }
    };
  }
  var assert;
  var signals;
  var isWin;
  var EE;
  var emitter;
  var unload;
  var emit;
  var sigListeners;
  var loaded;
  var load;
  var originalProcessReallyExit;
  var processReallyExit;
  var originalProcessEmit;
  var processEmit;
});

// node_modules/react-reconciler/cjs/react-reconciler-constants.development.js
var require_react_reconciler_constants_development = __commonJS((exports) => {
  exports.ConcurrentRoot = 1, exports.ContinuousEventPriority = 8, exports.DefaultEventPriority = 32, exports.DiscreteEventPriority = 2, exports.IdleEventPriority = 268435456, exports.LegacyRoot = 0, exports.NoEventPriority = 0;
});

// node_modules/react-reconciler/constants.js
var require_constants = __commonJS((exports, module) => {
  if (false) {} else {
    module.exports = require_react_reconciler_constants_development();
  }
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS((exports, module) => {
  module.exports = () => {
    return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
  };
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS((exports) => {
  (function() {
    function performWorkUntilDeadline() {
      needsPaint = false;
      if (isMessageLoopRunning) {
        var currentTime = exports.unstable_now();
        startTime = currentTime;
        var hasMoreWork = true;
        try {
          a: {
            isHostCallbackScheduled = false;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue);currentTask !== null && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                  var callback = currentTask.callback;
                  if (typeof callback === "function") {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                    currentTime = exports.unstable_now();
                    if (typeof continuationCallback === "function") {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = true;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else
                    pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (currentTask !== null)
                  hasMoreWork = true;
                else {
                  var firstTimer = peek(timerQueue);
                  firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                  hasMoreWork = false;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
            }
            hasMoreWork = undefined;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
        }
      }
    }
    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      a:
        for (;0 < index; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node))
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          else
            break a;
        }
    }
    function peek(heap) {
      return heap.length === 0 ? null : heap[0];
    }
    function pop(heap) {
      if (heap.length === 0)
        return null;
      var first = heap[0], last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a:
          for (var index = 0, length = heap.length, halfLength = length >>> 1;index < halfLength; ) {
            var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
            else if (rightIndex < length && 0 > compare(right, last))
              heap[index] = right, heap[rightIndex] = last, index = rightIndex;
            else
              break a;
          }
      }
      return first;
    }
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return diff !== 0 ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue);timer !== null; ) {
        if (timer.callback === null)
          pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        else
          break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (peek(taskQueue) !== null)
          isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
        else {
          var firstTimer = peek(timerQueue);
          firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    function shouldYieldToHost() {
      return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
    }
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports.unstable_now());
      }, ms);
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    exports.unstable_now = undefined;
    if (typeof performance === "object" && typeof performance.now === "function") {
      var localPerformance = performance;
      exports.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      var localDate = Date, initialTime = localDate.now();
      exports.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = typeof setTimeout === "function" ? setTimeout : null, localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null, localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
    if (typeof localSetImmediate === "function")
      var schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if (typeof MessageChannel !== "undefined") {
      var channel = new MessageChannel, port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function() {
        port.postMessage(null);
      };
    } else
      schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports.unstable_forceFrameRate = function(fps) {
      0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1000 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports.unstable_next = function(eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_requestPaint = function() {
      needsPaint = true;
    };
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      var currentTime = exports.unstable_now();
      typeof options === "object" && options !== null ? (options = options.delay, options = typeof options === "number" && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5000;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), peek(taskQueue) === null && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS((exports, module) => {
  var scheduler_development = __toESM(require_scheduler_development());
  if (false) {} else {
    module.exports = scheduler_development;
  }
});

// node_modules/react-reconciler/cjs/react-reconciler.development.js
var require_react_reconciler_development = __commonJS((exports, module) => {
  var React = __toESM(require_react());
  var Scheduler = __toESM(require_scheduler());
  module.exports = function($$$config) {
    function findHook(fiber, id) {
      for (fiber = fiber.memoizedState;fiber !== null && 0 < id; )
        fiber = fiber.next, id--;
      return fiber;
    }
    function copyWithSetImpl(obj, path, index, value) {
      if (index >= path.length)
        return value;
      var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
      return updated;
    }
    function copyWithRename(obj, oldPath, newPath) {
      if (oldPath.length !== newPath.length)
        console.warn("copyWithRename() expects paths of the same length");
      else {
        for (var i = 0;i < newPath.length - 1; i++)
          if (oldPath[i] !== newPath[i]) {
            console.warn("copyWithRename() expects paths to be the same except for the deepest key");
            return;
          }
        return copyWithRenameImpl(obj, oldPath, newPath, 0);
      }
    }
    function copyWithRenameImpl(obj, oldPath, newPath, index) {
      var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);
      return updated;
    }
    function copyWithDeleteImpl(obj, path, index) {
      var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      if (index + 1 === path.length)
        return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
      updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
      return updated;
    }
    function shouldSuspendImpl() {
      return false;
    }
    function shouldErrorImpl() {
      return null;
    }
    function createFiber(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function scheduleRoot(root, element) {
      root.context === emptyContextObject && (updateContainerSync(element, root, null, null), flushSyncWork());
    }
    function scheduleRefresh(root, update) {
      if (resolveFamily !== null) {
        var staleFamilies = update.staleFamilies;
        update = update.updatedFamilies;
        flushPendingEffects();
        scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);
        flushSyncWork();
      }
    }
    function setRefreshHandler(handler) {
      resolveFamily = handler;
    }
    function warnInvalidHookAccess() {
      console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
    }
    function warnInvalidContextAccess() {
      console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    }
    function noop() {}
    function warnForMissingKey() {}
    function setToSortedString(set) {
      var array = [];
      set.forEach(function(value) {
        array.push(value);
      });
      return array.sort().join(", ");
    }
    function getNearestMountedFiber(fiber) {
      var node = fiber, nearestMounted = fiber;
      if (fiber.alternate)
        for (;node.return; )
          node = node.return;
      else {
        fiber = node;
        do
          node = fiber, (node.flags & 4098) !== 0 && (nearestMounted = node.return), fiber = node.return;
        while (fiber);
      }
      return node.tag === 3 ? nearestMounted : null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error("Unable to find node on an unmounted component.");
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (alternate === null)
          throw Error("Unable to find node on an unmounted component.");
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b = alternate;; ) {
        var parentA = a.return;
        if (parentA === null)
          break;
        var parentB = parentA.alternate;
        if (parentB === null) {
          b = parentA.return;
          if (b !== null) {
            a = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child;parentB; ) {
            if (parentB === a)
              return assertIsMounted(parentA), fiber;
            if (parentB === b)
              return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (a.return !== b.return)
          a = parentA, b = parentB;
        else {
          for (var didFindChild = false, _child = parentA.child;_child; ) {
            if (_child === a) {
              didFindChild = true;
              a = parentA;
              b = parentB;
              break;
            }
            if (_child === b) {
              didFindChild = true;
              b = parentA;
              a = parentB;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) {
            for (_child = parentB.child;_child; ) {
              if (_child === a) {
                didFindChild = true;
                a = parentB;
                b = parentA;
                break;
              }
              if (_child === b) {
                didFindChild = true;
                b = parentB;
                a = parentA;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild)
              throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (a.alternate !== b)
          throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (a.tag !== 3)
        throw Error("Unable to find node on an unmounted component.");
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiber(parent) {
      parent = findCurrentFiberUsingSlowPath(parent);
      return parent !== null ? findCurrentHostFiberImpl(parent) : null;
    }
    function findCurrentHostFiberImpl(node) {
      var tag = node.tag;
      if (tag === 5 || tag === 26 || tag === 27 || tag === 6)
        return node;
      for (node = node.child;node !== null; ) {
        tag = findCurrentHostFiberImpl(node);
        if (tag !== null)
          return tag;
        node = node.sibling;
      }
      return null;
    }
    function findCurrentHostFiberWithNoPortalsImpl(node) {
      var tag = node.tag;
      if (tag === 5 || tag === 26 || tag === 27 || tag === 6)
        return node;
      for (node = node.child;node !== null; ) {
        if (node.tag !== 4 && (tag = findCurrentHostFiberWithNoPortalsImpl(node), tag !== null))
          return tag;
        node = node.sibling;
      }
      return null;
    }
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object")
        return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return typeof maybeIterable === "function" ? maybeIterable : null;
    }
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function getComponentNameFromFiber(fiber) {
      var type = fiber.type;
      switch (fiber.tag) {
        case 31:
          return "Activity";
        case 24:
          return "Cache";
        case 9:
          return (type._context.displayName || "Context") + ".Consumer";
        case 10:
          return type.displayName || "Context";
        case 18:
          return "DehydratedFragment";
        case 11:
          return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || (fiber !== "" ? "ForwardRef(" + fiber + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return type;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return getComponentNameFromType(type);
        case 8:
          return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if (typeof type === "function")
            return type.displayName || type.name || null;
          if (typeof type === "string")
            return type;
          break;
        case 29:
          type = fiber._debugInfo;
          if (type != null) {
            for (var i = type.length - 1;0 <= i; i--)
              if (typeof type[i].name === "string")
                return type[i].name;
          }
          if (fiber.return !== null)
            return getComponentNameFromFiber(fiber.return);
      }
      return null;
    }
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    function pop(cursor, fiber) {
      0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
    }
    function push(cursor, value, fiber) {
      index$jscomp$0++;
      valueStack[index$jscomp$0] = cursor.current;
      fiberStack[index$jscomp$0] = fiber;
      cursor.current = value;
    }
    function clz32Fallback(x) {
      x >>>= 0;
      return x === 0 ? 32 : 31 - (log$1(x) / LN2 | 0) | 0;
    }
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (pendingSyncLanes !== 0)
        return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
          return lanes & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), lanes;
      }
    }
    function getNextLanes(root, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root.pendingLanes;
      if (pendingLanes === 0)
        return 0;
      var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;
      root = root.warmLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      nonIdlePendingLanes !== 0 ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, pendingLanes !== 0 ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, pingedLanes !== 0 ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root, rootHasPendingCommit !== 0 && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, nonIdlePendingLanes !== 0 ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : pingedLanes !== 0 ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root, rootHasPendingCommit !== 0 && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
      return nextLanes === 0 ? 0 : wipLanes !== 0 && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === 0 && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || suspendedLanes === 32 && (rootHasPendingCommit & 4194048) !== 0) ? wipLanes : nextLanes;
    }
    function checkIfRootIsPrerendering(root, renderLanes2) {
      return (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes2) === 0;
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5000;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), -1;
      }
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      (nextRetryLane & 62914560) === 0 && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0;31 > i; i++)
        laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root, updateLane) {
      root.pendingLanes |= updateLane;
      updateLane !== 268435456 && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);
    }
    function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      var previouslyPendingLanes = root.pendingLanes;
      root.pendingLanes = remainingLanes;
      root.suspendedLanes = 0;
      root.pingedLanes = 0;
      root.warmLanes = 0;
      root.expiredLanes &= remainingLanes;
      root.entangledLanes &= remainingLanes;
      root.errorRecoveryDisabledLanes &= remainingLanes;
      root.shellSuspendCounter = 0;
      var { entanglements, expirationTimes, hiddenUpdates } = root;
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes;0 < remainingLanes; ) {
        var index = 31 - clz32(remainingLanes), lane = 1 << index;
        entanglements[index] = 0;
        expirationTimes[index] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index];
        if (hiddenUpdatesForLane !== null)
          for (hiddenUpdates[index] = null, index = 0;index < hiddenUpdatesForLane.length; index++) {
            var update = hiddenUpdatesForLane[index];
            update !== null && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      spawnedLane !== 0 && markSpawnedDeferredLane(root, spawnedLane, 0);
      suspendedRetryLanes !== 0 && updatedLanes === 0 && root.tag !== 0 && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
      root.pendingLanes |= spawnedLane;
      root.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root.entangledLanes |= spawnedLane;
      root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
    }
    function markRootEntangled(root, entangledLanes) {
      var rootEntangledLanes = root.entangledLanes |= entangledLanes;
      for (root = root.entanglements;rootEntangledLanes; ) {
        var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
        lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function getBumpedLaneForHydration(root, renderLanes2) {
      var renderLane = renderLanes2 & -renderLanes2;
      renderLane = (renderLane & 42) !== 0 ? 1 : getBumpedLaneForHydrationByLane(renderLane);
      return (renderLane & (root.suspendedLanes | renderLanes2)) !== 0 ? 0 : renderLane;
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1;
          break;
        case 8:
          lane = 4;
          break;
        case 32:
          lane = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128;
          break;
        case 268435456:
          lane = 134217728;
          break;
        default:
          lane = 0;
      }
      return lane;
    }
    function addFiberToLanesMap(root, fiber, lanes) {
      if (isDevToolsPresent)
        for (root = root.pendingUpdatersLaneMap;0 < lanes; ) {
          var index = 31 - clz32(lanes), lane = 1 << index;
          root[index].add(fiber);
          lanes &= ~lane;
        }
    }
    function movePendingFibersToMemoized(root, lanes) {
      if (isDevToolsPresent)
        for (var { pendingUpdatersLaneMap, memoizedUpdaters } = root;0 < lanes; ) {
          var index = 31 - clz32(lanes);
          root = 1 << index;
          index = pendingUpdatersLaneMap[index];
          0 < index.size && (index.forEach(function(fiber) {
            var alternate = fiber.alternate;
            alternate !== null && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
          }), index.clear());
          lanes &= ~root;
        }
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 2 < lanes ? 8 < lanes ? (lanes & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
    }
    function injectInternals(internals) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined")
        return false;
      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (hook.isDisabled)
        return true;
      if (!hook.supportsFiber)
        return console.error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"), true;
      try {
        rendererID = hook.inject(internals), injectedHook = hook;
      } catch (err) {
        console.error("React instrumentation encountered an error: %o.", err);
      }
      return hook.checkDCE ? true : false;
    }
    function setIsStrictModeForDevtools(newIsStrictMode) {
      typeof log2 === "function" && unstable_setDisableYieldValue2(newIsStrictMode);
      if (injectedHook && typeof injectedHook.setStrictMode === "function")
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
          hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
        }
    }
    function is(x, y) {
      return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function getArrayKind(array) {
      for (var kind = 0, i = 0;i < array.length; i++) {
        var value = array[i];
        if (typeof value === "object" && value !== null)
          if (isArrayImpl(value) && value.length === 2 && typeof value[0] === "string") {
            if (kind !== 0 && kind !== 3)
              return 1;
            kind = 3;
          } else
            return 1;
        else {
          if (typeof value === "function" || typeof value === "string" && 50 < value.length || kind !== 0 && kind !== 2)
            return 1;
          kind = 2;
        }
      }
      return kind;
    }
    function addObjectToProperties(object, properties, indent, prefix2) {
      for (var key in object)
        hasOwnProperty.call(object, key) && key[0] !== "_" && addValueToProperties(key, object[key], properties, indent, prefix2);
    }
    function addValueToProperties(propertyName, value, properties, indent, prefix2) {
      switch (typeof value) {
        case "object":
          if (value === null) {
            value = "null";
            break;
          } else {
            if (value.$$typeof === REACT_ELEMENT_TYPE) {
              var typeName = getComponentNameFromType(value.type) || "", key = value.key;
              value = value.props;
              var propsKeys = Object.keys(value), propsLength = propsKeys.length;
              if (key == null && propsLength === 0) {
                value = "<" + typeName + " />";
                break;
              }
              if (3 > indent || propsLength === 1 && propsKeys[0] === "children" && key == null) {
                value = "<" + typeName + "  />";
                break;
              }
              properties.push([
                prefix2 + "".repeat(indent) + propertyName,
                "<" + typeName
              ]);
              key !== null && addValueToProperties("key", key, properties, indent + 1, prefix2);
              propertyName = false;
              for (var propKey in value)
                propKey === "children" ? value.children != null && (!isArrayImpl(value.children) || 0 < value.children.length) && (propertyName = true) : hasOwnProperty.call(value, propKey) && propKey[0] !== "_" && addValueToProperties(propKey, value[propKey], properties, indent + 1, prefix2);
              properties.push([
                "",
                propertyName ? "></" + typeName + ">" : "/>"
              ]);
              return;
            }
            typeName = Object.prototype.toString.call(value);
            typeName = typeName.slice(8, typeName.length - 1);
            if (typeName === "Array") {
              if (propKey = getArrayKind(value), propKey === 2 || propKey === 0) {
                value = JSON.stringify(value);
                break;
              } else if (propKey === 3) {
                properties.push([
                  prefix2 + "".repeat(indent) + propertyName,
                  ""
                ]);
                for (propertyName = 0;propertyName < value.length; propertyName++)
                  typeName = value[propertyName], addValueToProperties(typeName[0], typeName[1], properties, indent + 1, prefix2);
                return;
              }
            }
            if (typeName === "Promise") {
              if (value.status === "fulfilled") {
                if (typeName = properties.length, addValueToProperties(propertyName, value.value, properties, indent, prefix2), properties.length > typeName) {
                  properties = properties[typeName];
                  properties[1] = "Promise<" + (properties[1] || "Object") + ">";
                  return;
                }
              } else if (value.status === "rejected" && (typeName = properties.length, addValueToProperties(propertyName, value.reason, properties, indent, prefix2), properties.length > typeName)) {
                properties = properties[typeName];
                properties[1] = "Rejected Promise<" + properties[1] + ">";
                return;
              }
              properties.push([
                "".repeat(indent) + propertyName,
                "Promise"
              ]);
              return;
            }
            typeName === "Object" && (propKey = Object.getPrototypeOf(value)) && typeof propKey.constructor === "function" && (typeName = propKey.constructor.name);
            properties.push([
              prefix2 + "".repeat(indent) + propertyName,
              typeName === "Object" ? 3 > indent ? "" : "" : typeName
            ]);
            3 > indent && addObjectToProperties(value, properties, indent + 1, prefix2);
            return;
          }
        case "function":
          value = value.name === "" ? "() => {}" : value.name + "() {}";
          break;
        case "string":
          value = value === "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects." ? "" : JSON.stringify(value);
          break;
        case "undefined":
          value = "undefined";
          break;
        case "boolean":
          value = value ? "true" : "false";
          break;
        default:
          value = String(value);
      }
      properties.push([
        prefix2 + "".repeat(indent) + propertyName,
        value
      ]);
    }
    function addObjectDiffToProperties(prev, next, properties, indent) {
      var isDeeplyEqual = true;
      for (key in prev)
        key in next || (properties.push([
          "" + "".repeat(indent) + key,
          ""
        ]), isDeeplyEqual = false);
      for (var _key in next)
        if (_key in prev) {
          var key = prev[_key];
          var nextValue = next[_key];
          if (key !== nextValue) {
            if (indent === 0 && _key === "children")
              isDeeplyEqual = "".repeat(indent) + _key, properties.push(["" + isDeeplyEqual, ""], ["+" + isDeeplyEqual, ""]);
            else {
              if (!(3 <= indent)) {
                if (typeof key === "object" && typeof nextValue === "object" && key !== null && nextValue !== null && key.$$typeof === nextValue.$$typeof)
                  if (nextValue.$$typeof === REACT_ELEMENT_TYPE) {
                    if (key.type === nextValue.type && key.key === nextValue.key) {
                      key = getComponentNameFromType(nextValue.type) || "";
                      isDeeplyEqual = "".repeat(indent) + _key;
                      key = "<" + key + "  />";
                      properties.push(["" + isDeeplyEqual, key], ["+" + isDeeplyEqual, key]);
                      isDeeplyEqual = false;
                      continue;
                    }
                  } else {
                    var prevKind = Object.prototype.toString.call(key), nextKind = Object.prototype.toString.call(nextValue);
                    if (prevKind === nextKind && (nextKind === "[object Object]" || nextKind === "[object Array]")) {
                      prevKind = [
                        "" + "".repeat(indent) + _key,
                        nextKind === "[object Array]" ? "Array" : ""
                      ];
                      properties.push(prevKind);
                      nextKind = properties.length;
                      addObjectDiffToProperties(key, nextValue, properties, indent + 1) ? nextKind === properties.length && (prevKind[1] = "Referentially unequal but deeply equal objects. Consider memoization.") : isDeeplyEqual = false;
                      continue;
                    }
                  }
                else if (typeof key === "function" && typeof nextValue === "function" && key.name === nextValue.name && key.length === nextValue.length && (prevKind = Function.prototype.toString.call(key), nextKind = Function.prototype.toString.call(nextValue), prevKind === nextKind)) {
                  key = nextValue.name === "" ? "() => {}" : nextValue.name + "() {}";
                  properties.push([
                    "" + "".repeat(indent) + _key,
                    key + " Referentially unequal function closure. Consider memoization."
                  ]);
                  continue;
                }
              }
              addValueToProperties(_key, key, properties, indent, "");
              addValueToProperties(_key, nextValue, properties, indent, "+");
            }
            isDeeplyEqual = false;
          }
        } else
          properties.push([
            "+" + "".repeat(indent) + _key,
            ""
          ]), isDeeplyEqual = false;
      return isDeeplyEqual;
    }
    function setCurrentTrackFromLanes(lanes) {
      currentTrack = lanes & 63 ? "Blocking" : lanes & 64 ? "Gesture" : lanes & 4194176 ? "Transition" : lanes & 62914560 ? "Suspense" : lanes & 2080374784 ? "Idle" : "Other";
    }
    function logComponentTrigger(fiber, startTime, endTime, trigger) {
      supportsUserTiming && (reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = trigger, reusableComponentDevToolDetails.properties = null, (fiber = fiber._debugTask) ? fiber.run(performance.measure.bind(performance, trigger, reusableComponentOptions)) : performance.measure(trigger, reusableComponentOptions));
    }
    function logComponentReappeared(fiber, startTime, endTime) {
      logComponentTrigger(fiber, startTime, endTime, "Reconnect");
    }
    function logComponentRender(fiber, startTime, endTime, wasHydrated, committedLanes) {
      var name = getComponentNameFromFiber(fiber);
      if (name !== null && supportsUserTiming) {
        var { alternate, actualDuration: selfTime } = fiber;
        if (alternate === null || alternate.child !== fiber.child)
          for (var child = fiber.child;child !== null; child = child.sibling)
            selfTime -= child.actualDuration;
        wasHydrated = 0.5 > selfTime ? wasHydrated ? "tertiary-light" : "primary-light" : 10 > selfTime ? wasHydrated ? "tertiary" : "primary" : 100 > selfTime ? wasHydrated ? "tertiary-dark" : "primary-dark" : "error";
        var props = fiber.memoizedProps;
        selfTime = fiber._debugTask;
        props !== null && alternate !== null && alternate.memoizedProps !== props ? (child = [resuableChangedPropsEntry], props = addObjectDiffToProperties(alternate.memoizedProps, props, child, 0), 1 < child.length && (props && !alreadyWarnedForDeepEquality && (alternate.lanes & committedLanes) === 0 && 100 < fiber.actualDuration ? (alreadyWarnedForDeepEquality = true, child[0] = reusableDeeplyEqualPropsEntry, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.") : (reusableComponentDevToolDetails.color = wasHydrated, reusableComponentDevToolDetails.tooltipText = name), reusableComponentDevToolDetails.properties = child, reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, selfTime != null ? selfTime.run(performance.measure.bind(performance, "" + name, reusableComponentOptions)) : performance.measure("" + name, reusableComponentOptions))) : selfTime != null ? selfTime.run(console.timeStamp.bind(console, name, startTime, endTime, "Components ", undefined, wasHydrated)) : console.timeStamp(name, startTime, endTime, "Components ", undefined, wasHydrated);
      }
    }
    function logComponentErrored(fiber, startTime, endTime, errors) {
      if (supportsUserTiming) {
        var name = getComponentNameFromFiber(fiber);
        if (name !== null) {
          for (var debugTask = null, properties = [], i = 0;i < errors.length; i++) {
            var capturedValue = errors[i];
            debugTask == null && capturedValue.source !== null && (debugTask = capturedValue.source._debugTask);
            capturedValue = capturedValue.value;
            properties.push([
              "Error",
              typeof capturedValue === "object" && capturedValue !== null && typeof capturedValue.message === "string" ? String(capturedValue.message) : String(capturedValue)
            ]);
          }
          fiber.key !== null && addValueToProperties("key", fiber.key, properties, 0, "");
          fiber.memoizedProps !== null && addObjectToProperties(fiber.memoizedProps, properties, 0, "");
          debugTask == null && (debugTask = fiber._debugTask);
          fiber = {
            start: startTime,
            end: endTime,
            detail: {
              devtools: {
                color: "error",
                track: "Components ",
                tooltipText: fiber.tag === 13 ? "Hydration failed" : "Error boundary caught an error",
                properties
              }
            }
          };
          debugTask ? debugTask.run(performance.measure.bind(performance, "" + name, fiber)) : performance.measure("" + name, fiber);
        }
      }
    }
    function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {
      if (errors !== null) {
        if (supportsUserTiming) {
          var name = getComponentNameFromFiber(fiber);
          if (name !== null) {
            selfTime = [];
            for (var i = 0;i < errors.length; i++) {
              var error = errors[i].value;
              selfTime.push([
                "Error",
                typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error)
              ]);
            }
            fiber.key !== null && addValueToProperties("key", fiber.key, selfTime, 0, "");
            fiber.memoizedProps !== null && addObjectToProperties(fiber.memoizedProps, selfTime, 0, "");
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "error",
                  track: "Components ",
                  tooltipText: "A lifecycle or effect errored",
                  properties: selfTime
                }
              }
            };
            (fiber = fiber._debugTask) ? fiber.run(performance.measure.bind(performance, "" + name, startTime)) : performance.measure("" + name, startTime);
          }
        }
      } else
        name = getComponentNameFromFiber(fiber), name !== null && supportsUserTiming && (errors = 1 > selfTime ? "secondary-light" : 100 > selfTime ? "secondary" : 500 > selfTime ? "secondary-dark" : "error", (fiber = fiber._debugTask) ? fiber.run(console.timeStamp.bind(console, name, startTime, endTime, "Components ", undefined, errors)) : console.timeStamp(name, startTime, endTime, "Components ", undefined, errors));
    }
    function logRenderPhase(startTime, endTime, lanes, debugTask) {
      if (supportsUserTiming && !(endTime <= startTime)) {
        var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark";
        lanes = (lanes & 536870912) === lanes ? "Prepared" : (lanes & 201326741) === lanes ? "Hydrated" : "Render";
        debugTask ? debugTask.run(console.timeStamp.bind(console, lanes, startTime, endTime, currentTrack, "Scheduler ", color)) : console.timeStamp(lanes, startTime, endTime, currentTrack, "Scheduler ", color);
      }
    }
    function logSuspendedRenderPhase(startTime, endTime, lanes, debugTask) {
      !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(console.timeStamp.bind(console, "Prewarm", startTime, endTime, currentTrack, "Scheduler ", lanes)) : console.timeStamp("Prewarm", startTime, endTime, currentTrack, "Scheduler ", lanes));
    }
    function logSuspendedWithDelayPhase(startTime, endTime, lanes, debugTask) {
      !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(console.timeStamp.bind(console, "Suspended", startTime, endTime, currentTrack, "Scheduler ", lanes)) : console.timeStamp("Suspended", startTime, endTime, currentTrack, "Scheduler ", lanes));
    }
    function logRecoveredRenderPhase(startTime, endTime, lanes, recoverableErrors, hydrationFailed, debugTask) {
      if (supportsUserTiming && !(endTime <= startTime)) {
        lanes = [];
        for (var i = 0;i < recoverableErrors.length; i++) {
          var error = recoverableErrors[i].value;
          lanes.push([
            "Recoverable Error",
            typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error)
          ]);
        }
        startTime = {
          start: startTime,
          end: endTime,
          detail: {
            devtools: {
              color: "primary-dark",
              track: currentTrack,
              trackGroup: "Scheduler ",
              tooltipText: hydrationFailed ? "Hydration Failed" : "Recovered after Error",
              properties: lanes
            }
          }
        };
        debugTask ? debugTask.run(performance.measure.bind(performance, "Recovered", startTime)) : performance.measure("Recovered", startTime);
      }
    }
    function logErroredRenderPhase(startTime, endTime, lanes, debugTask) {
      !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(console.timeStamp.bind(console, "Errored", startTime, endTime, currentTrack, "Scheduler ", "error")) : console.timeStamp("Errored", startTime, endTime, currentTrack, "Scheduler ", "error"));
    }
    function logSuspendedCommitPhase(startTime, endTime, reason, debugTask) {
      !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(console.timeStamp.bind(console, reason, startTime, endTime, currentTrack, "Scheduler ", "secondary-light")) : console.timeStamp(reason, startTime, endTime, currentTrack, "Scheduler ", "secondary-light"));
    }
    function logCommitErrored(startTime, endTime, errors, passive, debugTask) {
      if (supportsUserTiming && !(endTime <= startTime)) {
        for (var properties = [], i = 0;i < errors.length; i++) {
          var error = errors[i].value;
          properties.push([
            "Error",
            typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error)
          ]);
        }
        startTime = {
          start: startTime,
          end: endTime,
          detail: {
            devtools: {
              color: "error",
              track: currentTrack,
              trackGroup: "Scheduler ",
              tooltipText: passive ? "Remaining Effects Errored" : "Commit Errored",
              properties
            }
          }
        };
        debugTask ? debugTask.run(performance.measure.bind(performance, "Errored", startTime)) : performance.measure("Errored", startTime);
      }
    }
    function disabledLog() {}
    function disableLogs() {
      if (disabledDepth === 0) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {
          configurable: true,
          enumerable: true,
          value: disabledLog,
          writable: true
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (disabledDepth === 0) {
        var props = { configurable: true, enumerable: true, writable: true };
        Object.defineProperties(console, {
          log: assign({}, props, { value: prevLog }),
          info: assign({}, props, { value: prevInfo }),
          warn: assign({}, props, { value: prevWarn }),
          error: assign({}, props, { value: prevError }),
          group: assign({}, props, { value: prevGroup }),
          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
          groupEnd: assign({}, props, { value: prevGroupEnd })
        });
      }
      0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function formatOwnerStack(error) {
      var prevPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = undefined;
      error = error.stack;
      Error.prepareStackTrace = prevPrepareStackTrace;
      error.startsWith(`Error: react-stack-top-frame
`) && (error = error.slice(29));
      prevPrepareStackTrace = error.indexOf(`
`);
      prevPrepareStackTrace !== -1 && (error = error.slice(prevPrepareStackTrace + 1));
      prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
      prevPrepareStackTrace !== -1 && (prevPrepareStackTrace = error.lastIndexOf(`
`, prevPrepareStackTrace));
      if (prevPrepareStackTrace !== -1)
        error = error.slice(0, prevPrepareStackTrace);
      else
        return "";
      return error;
    }
    function describeBuiltInComponentFrame(name) {
      if (prefix === undefined)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = match && match[1] || "";
          suffix = -1 < x.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry)
        return "";
      var frame = componentFrameCache.get(fn);
      if (frame !== undefined)
        return frame;
      reentry = true;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = undefined;
      var previousDispatcher = null;
      previousDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) && typeof Fake.catch === "function" && Fake.catch(function() {});
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string")
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split(`
`), controlLines = controlStack.split(`
`);
          for (_RunInRootFrame$Deter = namePropDescriptor = 0;namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot"); )
            namePropDescriptor++;
          for (;_RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot"); )
            _RunInRootFrame$Deter++;
          if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
            for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
              _RunInRootFrame$Deter--;
          for (;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
            if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
              if (namePropDescriptor !== 1 || _RunInRootFrame$Deter !== 1) {
                do
                  if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    var _frame = `
` + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                    fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                    typeof fn === "function" && componentFrameCache.set(fn, _frame);
                    return _frame;
                  }
                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
              }
              break;
            }
        }
      } finally {
        reentry = false, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
      typeof fn === "function" && componentFrameCache.set(fn, sampleLines);
      return sampleLines;
    }
    function describeFiber(fiber, childFiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return fiber.child !== childFiber && childFiber !== null ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, false);
        case 11:
          return describeNativeComponentFrame(fiber.type.render, false);
        case 1:
          return describeNativeComponentFrame(fiber.type, true);
        case 31:
          return describeBuiltInComponentFrame("Activity");
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress2) {
      try {
        var info = "", previous = null;
        do {
          info += describeFiber(workInProgress2, previous);
          var debugInfo = workInProgress2._debugInfo;
          if (debugInfo)
            for (var i = debugInfo.length - 1;0 <= i; i--) {
              var entry = debugInfo[i];
              if (typeof entry.name === "string") {
                var JSCompiler_temp_const = info;
                a: {
                  var { name, env: env2, debugLocation: location } = entry;
                  if (location != null) {
                    var childStack = formatOwnerStack(location), idx = childStack.lastIndexOf(`
`), lastLine = idx === -1 ? childStack : childStack.slice(idx + 1);
                    if (lastLine.indexOf(name) !== -1) {
                      var JSCompiler_inline_result = `
` + lastLine;
                      break a;
                    }
                  }
                  JSCompiler_inline_result = describeBuiltInComponentFrame(name + (env2 ? " [" + env2 + "]" : ""));
                }
                info = JSCompiler_temp_const + JSCompiler_inline_result;
              }
            }
          previous = workInProgress2;
          workInProgress2 = workInProgress2.return;
        } while (workInProgress2);
        return info;
      } catch (x) {
        return `
Error generating stack: ` + x.message + `
` + x.stack;
      }
    }
    function describeFunctionComponentFrameWithoutLineNumber(fn) {
      return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
    }
    function createCapturedValueAtFiber(value, source) {
      if (typeof value === "object" && value !== null) {
        var existing = CapturedStacks.get(value);
        if (existing !== undefined)
          return existing;
        source = {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    function pushTreeFork(workInProgress2, totalChildren) {
      warnIfNotHydrating();
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress2;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress2, totalChildren, index) {
      warnIfNotHydrating();
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress2;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress2 = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress2;
      } else
        treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
    }
    function pushMaterializedTreeId(workInProgress2) {
      warnIfNotHydrating();
      workInProgress2.return !== null && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
    }
    function popTreeContext(workInProgress2) {
      for (;workInProgress2 === treeForkProvider; )
        treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (;workInProgress2 === treeContextProvider; )
        treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    function getSuspendedTreeContext() {
      warnIfNotHydrating();
      return treeContextProvider !== null ? { id: treeContextId, overflow: treeContextOverflow } : null;
    }
    function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
      warnIfNotHydrating();
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextId = suspendedContext.id;
      treeContextOverflow = suspendedContext.overflow;
      treeContextProvider = workInProgress2;
    }
    function warnIfNotHydrating() {
      isHydrating || console.error("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    function requiredContext(c) {
      c === null && console.error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return c;
    }
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance, fiber);
      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor, null, fiber);
      nextRootInstance = getRootHostContext(nextRootInstance);
      pop(contextStackCursor, fiber);
      push(contextStackCursor, nextRootInstance, fiber);
    }
    function popHostContainer(fiber) {
      pop(contextStackCursor, fiber);
      pop(contextFiberStackCursor, fiber);
      pop(rootInstanceStackCursor, fiber);
    }
    function getHostContext() {
      return requiredContext(contextStackCursor.current);
    }
    function pushHostContext(fiber) {
      fiber.memoizedState !== null && push(hostTransitionProviderCursor, fiber, fiber);
      var context = requiredContext(contextStackCursor.current), nextContext = getChildHostContext(context, fiber.type);
      context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
      hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), isPrimaryRenderer ? HostTransitionContext._currentValue = NotPendingTransition : HostTransitionContext._currentValue2 = NotPendingTransition);
    }
    function findNotableNode(node, indent) {
      return node.serverProps === undefined && node.serverTail.length === 0 && node.children.length === 1 && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
    }
    function indentation(indent) {
      return "  " + "  ".repeat(indent);
    }
    function added(indent) {
      return "+ " + "  ".repeat(indent);
    }
    function removed(indent) {
      return "- " + "  ".repeat(indent);
    }
    function describeFiberType(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return fiber.type;
        case 16:
          return "Lazy";
        case 31:
          return "Activity";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return fiber = fiber.type, fiber.displayName || fiber.name || null;
        case 11:
          return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
        case 1:
          return fiber = fiber.type, fiber.displayName || fiber.name || null;
        default:
          return null;
      }
    }
    function describeTextNode(content, maxLength) {
      return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
    }
    function describeTextDiff(clientText, serverProps, indent) {
      var maxLength = 120 - 2 * indent;
      if (serverProps === null)
        return added(indent) + describeTextNode(clientText, maxLength) + `
`;
      if (typeof serverProps === "string") {
        for (var firstDiff = 0;firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++)
          ;
        firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
        return added(indent) + describeTextNode(clientText, maxLength) + `
` + removed(indent) + describeTextNode(serverProps, maxLength) + `
`;
      }
      return indentation(indent) + describeTextNode(clientText, maxLength) + `
`;
    }
    function objectName(object) {
      return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
        return p0;
      });
    }
    function describeValue(value, maxLength) {
      switch (typeof value) {
        case "string":
          return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
        case "object":
          if (value === null)
            return "null";
          if (isArrayImpl(value))
            return "[...]";
          if (value.$$typeof === REACT_ELEMENT_TYPE)
            return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
          var name = objectName(value);
          if (name === "Object") {
            name = "";
            maxLength -= 2;
            for (var propName in value)
              if (value.hasOwnProperty(propName)) {
                var jsonPropName = JSON.stringify(propName);
                jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                maxLength -= propName.length - 2;
                jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);
                maxLength -= jsonPropName.length;
                if (0 > maxLength) {
                  name += name === "" ? "..." : ", ...";
                  break;
                }
                name += (name === "" ? "" : ",") + propName + ":" + jsonPropName;
              }
            return "{" + name + "}";
          }
          return name;
        case "function":
          return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
        default:
          return String(value);
      }
    }
    function describePropValue(value, maxLength) {
      return typeof value !== "string" || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
    }
    function describeExpandedElement(type, props, rowPrefix) {
      var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
      for (propName in props)
        if (props.hasOwnProperty(propName) && propName !== "children") {
          var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);
          remainingRowLength -= propName.length + propValue.length + 2;
          properties.push(propName + "=" + propValue);
        }
      return properties.length === 0 ? rowPrefix + "<" + type + `>
` : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + `>
` : rowPrefix + "<" + type + `
` + rowPrefix + "  " + properties.join(`
` + rowPrefix + "  ") + `
` + rowPrefix + `>
`;
    }
    function describePropertiesDiff(clientObject, serverObject, indent) {
      var properties = "", remainingServerProperties = assign({}, serverObject), propName;
      for (propName in clientObject)
        if (clientObject.hasOwnProperty(propName)) {
          delete remainingServerProperties[propName];
          var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
          serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + `
`, properties += removed(indent) + propName + ": " + maxLength + `
`) : properties += added(indent) + propName + ": " + clientPropValue + `
`;
        }
      for (var _propName in remainingServerProperties)
        remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + ": " + clientObject + `
`);
      return properties;
    }
    function describeElementDiff(type, clientProps, serverProps, indent) {
      var content = "", serverPropNames = new Map;
      for (propName$jscomp$0 in serverProps)
        serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);
      if (serverPropNames.size === 1 && serverPropNames.has("children"))
        content += describeExpandedElement(type, clientProps, indentation(indent));
      else {
        for (var _propName2 in clientProps)
          if (clientProps.hasOwnProperty(_propName2) && _propName2 !== "children") {
            var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
            if (serverPropName !== undefined) {
              serverPropNames.delete(_propName2.toLowerCase());
              var propName$jscomp$0 = clientProps[_propName2];
              serverPropName = serverProps[serverPropName];
              var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);
              maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);
              typeof propName$jscomp$0 === "object" && propName$jscomp$0 !== null && typeof serverPropName === "object" && serverPropName !== null && objectName(propName$jscomp$0) === "Object" && objectName(serverPropName) === "Object" && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + `={{
` + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + `}}
` : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + `
`, content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + `
`);
            } else
              content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + `
`;
          }
        serverPropNames.forEach(function(propName) {
          if (propName !== "children") {
            var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
            content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + `
`;
          }
        });
        content = content === "" ? indentation(indent) + "<" + type + `>
` : indentation(indent) + "<" + type + `
` + content + indentation(indent) + `>
`;
      }
      type = serverProps.children;
      clientProps = clientProps.children;
      if (typeof type === "string" || typeof type === "number" || typeof type === "bigint") {
        serverPropNames = "";
        if (typeof clientProps === "string" || typeof clientProps === "number" || typeof clientProps === "bigint")
          serverPropNames = "" + clientProps;
        content += describeTextDiff(serverPropNames, "" + type, indent + 1);
      } else if (typeof clientProps === "string" || typeof clientProps === "number" || typeof clientProps === "bigint")
        content = type == null ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, undefined, indent + 1);
      return content;
    }
    function describeSiblingFiber(fiber, indent) {
      var type = describeFiberType(fiber);
      if (type === null) {
        type = "";
        for (fiber = fiber.child;fiber; )
          type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
        return type;
      }
      return indentation(indent) + "<" + type + `>
`;
    }
    function describeNode(node, indent) {
      var skipToNode = findNotableNode(node, indent);
      if (skipToNode !== node && (node.children.length !== 1 || node.children[0] !== skipToNode))
        return indentation(indent) + `...
` + describeNode(skipToNode, indent + 1);
      skipToNode = "";
      var debugInfo = node.fiber._debugInfo;
      if (debugInfo)
        for (var i = 0;i < debugInfo.length; i++) {
          var serverComponentName = debugInfo[i].name;
          typeof serverComponentName === "string" && (skipToNode += indentation(indent) + "<" + serverComponentName + `>
`, indent++);
        }
      debugInfo = "";
      i = node.fiber.pendingProps;
      if (node.fiber.tag === 6)
        debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;
      else if (serverComponentName = describeFiberType(node.fiber), serverComponentName !== null)
        if (node.serverProps === undefined) {
          debugInfo = indent;
          var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
          for (propName in i)
            if (i.hasOwnProperty(propName) && propName !== "children") {
              var propValue = describePropValue(i[propName], 15);
              maxLength -= propName.length + propValue.length + 2;
              if (0 > maxLength) {
                content += " ...";
                break;
              }
              content += " " + propName + "=" + propValue;
            }
          debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + `>
`;
          indent++;
        } else
          node.serverProps === null ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : typeof node.serverProps === "string" ? console.error("Should not have matched a non HostText fiber to a Text node. This is a bug in React.") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);
      var propName = "";
      i = node.fiber.child;
      for (serverComponentName = 0;i && serverComponentName < node.children.length; )
        maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
      i && 0 < node.children.length && (propName += indentation(indent) + `...
`);
      i = node.serverTail;
      node.serverProps === null && indent--;
      for (node = 0;node < i.length; node++)
        serverComponentName = i[node], propName = typeof serverComponentName === "string" ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + `
`) : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));
      return skipToNode + debugInfo + propName;
    }
    function describeDiff(rootNode) {
      try {
        return `

` + describeNode(rootNode, 0);
      } catch (x) {
        return "";
      }
    }
    function getCurrentFiberStackInDev() {
      if (current === null)
        return "";
      var workInProgress2 = current;
      try {
        var info = "";
        workInProgress2.tag === 6 && (workInProgress2 = workInProgress2.return);
        switch (workInProgress2.tag) {
          case 26:
          case 27:
          case 5:
            info += describeBuiltInComponentFrame(workInProgress2.type);
            break;
          case 13:
            info += describeBuiltInComponentFrame("Suspense");
            break;
          case 19:
            info += describeBuiltInComponentFrame("SuspenseList");
            break;
          case 31:
            info += describeBuiltInComponentFrame("Activity");
            break;
          case 30:
          case 0:
          case 15:
          case 1:
            workInProgress2._debugOwner || info !== "" || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress2.type));
            break;
          case 11:
            workInProgress2._debugOwner || info !== "" || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress2.type.render));
        }
        for (;workInProgress2; )
          if (typeof workInProgress2.tag === "number") {
            var fiber = workInProgress2;
            workInProgress2 = fiber._debugOwner;
            var debugStack = fiber._debugStack;
            if (workInProgress2 && debugStack) {
              var formattedStack = formatOwnerStack(debugStack);
              formattedStack !== "" && (info += `
` + formattedStack);
            }
          } else if (workInProgress2.debugStack != null) {
            var ownerStack = workInProgress2.debugStack;
            (workInProgress2 = workInProgress2.owner) && ownerStack && (info += `
` + formatOwnerStack(ownerStack));
          } else
            break;
        var JSCompiler_inline_result = info;
      } catch (x) {
        JSCompiler_inline_result = `
Error generating stack: ` + x.message + `
` + x.stack;
      }
      return JSCompiler_inline_result;
    }
    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
      var previousFiber = current;
      setCurrentFiber(fiber);
      try {
        return fiber !== null && fiber._debugTask ? fiber._debugTask.run(callback.bind(null, arg0, arg1, arg2, arg3, arg4)) : callback(arg0, arg1, arg2, arg3, arg4);
      } finally {
        setCurrentFiber(previousFiber);
      }
      throw Error("runWithFiberInDEV should never be called in production. This is a bug in React.");
    }
    function setCurrentFiber(fiber) {
      ReactSharedInternals.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
      isRendering = false;
      current = fiber;
    }
    function buildHydrationDiffNode(fiber, distanceFromLeaf) {
      if (fiber.return === null) {
        if (hydrationDiffRootDEV === null)
          hydrationDiffRootDEV = {
            fiber,
            children: [],
            serverProps: undefined,
            serverTail: [],
            distanceFromLeaf
          };
        else {
          if (hydrationDiffRootDEV.fiber !== fiber)
            throw Error("Saw multiple hydration diff roots in a pass. This is a bug in React.");
          hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
        }
        return hydrationDiffRootDEV;
      }
      var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;
      if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
        return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
      distanceFromLeaf = {
        fiber,
        children: [],
        serverProps: undefined,
        serverTail: [],
        distanceFromLeaf
      };
      siblings.push(distanceFromLeaf);
      return distanceFromLeaf;
    }
    function warnIfHydrating() {
      isHydrating && console.error("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function warnNonHydratedInstance(fiber, rejectedCandidate) {
      didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, rejectedCandidate !== null && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
    }
    function throwOnHydrationMismatch(fiber) {
      var fromText = 1 < arguments.length && arguments[1] !== undefined ? arguments[1] : false, diff = "", diffRoot = hydrationDiffRootDEV;
      diffRoot !== null && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
      queueHydrationError(createCapturedValueAtFiber(Error("Hydration failed because the server rendered " + (fromText ? "text" : "HTML") + ` didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch` + diff), fiber));
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber, hostContext) {
      if (!supportsHydration)
        throw Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      hydrateInstance(fiber.stateNode, fiber.type, fiber.memoizedProps, hostContext, fiber) || throwOnHydrationMismatch(fiber, true);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return;hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 5:
          case 31:
          case 13:
            rootOrSingletonContext = false;
            return;
          case 27:
          case 3:
            rootOrSingletonContext = true;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
      if (!supportsHydration || fiber !== hydrationParentFiber)
        return false;
      if (!isHydrating)
        return popToNextHostParent(fiber), isHydrating = true, false;
      var tag = fiber.tag;
      supportsSingletons ? tag !== 3 && tag !== 27 && (tag !== 5 || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && nextHydratableInstance && (warnIfUnhydratedTailNodes(fiber), throwOnHydrationMismatch(fiber)) : tag !== 3 && (tag !== 5 || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && nextHydratableInstance && (warnIfUnhydratedTailNodes(fiber), throwOnHydrationMismatch(fiber));
      popToNextHostParent(fiber);
      if (tag === 13) {
        if (!supportsHydration)
          throw Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
        fiber = fiber.memoizedState;
        fiber = fiber !== null ? fiber.dehydrated : null;
        if (!fiber)
          throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
      } else if (tag === 31) {
        fiber = fiber.memoizedState;
        fiber = fiber !== null ? fiber.dehydrated : null;
        if (!fiber)
          throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        nextHydratableInstance = getNextHydratableInstanceAfterActivityInstance(fiber);
      } else
        nextHydratableInstance = supportsSingletons && tag === 27 ? getNextHydratableSiblingAfterSingleton(fiber.type, nextHydratableInstance) : hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
      return true;
    }
    function warnIfUnhydratedTailNodes(fiber) {
      for (var nextInstance = nextHydratableInstance;nextInstance; ) {
        var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(nextInstance);
        diffNode.serverTail.push(description);
        nextInstance = description.type === "Suspense" ? getNextHydratableInstanceAfterSuspenseInstance(nextInstance) : getNextHydratableSibling(nextInstance);
      }
    }
    function resetHydrationState() {
      supportsHydration && (nextHydratableInstance = hydrationParentFiber = null, didSuspendOrErrorDEV = isHydrating = false);
    }
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors;
      queuedErrors !== null && (workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors), hydrationErrors = null);
      return queuedErrors;
    }
    function queueHydrationError(error) {
      hydrationErrors === null ? hydrationErrors = [error] : hydrationErrors.push(error);
    }
    function emitPendingHydrationWarnings() {
      var diffRoot = hydrationDiffRootDEV;
      if (diffRoot !== null) {
        hydrationDiffRootDEV = null;
        for (var diff = describeDiff(diffRoot);0 < diffRoot.children.length; )
          diffRoot = diffRoot.children[0];
        runWithFiberInDEV(diffRoot.fiber, function() {
          console.error(`A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

%s%s`, "https://react.dev/link/hydration-mismatch", diff);
        });
      }
    }
    function resetContextDependencies() {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      isDisallowedContextReadInDEV = false;
    }
    function pushProvider(providerFiber, context, nextValue) {
      isPrimaryRenderer ? (push(valueCursor, context._currentValue, providerFiber), context._currentValue = nextValue, push(rendererCursorDEV, context._currentRenderer, providerFiber), context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer = rendererSigil) : (push(valueCursor, context._currentValue2, providerFiber), context._currentValue2 = nextValue, push(renderer2CursorDEV, context._currentRenderer2, providerFiber), context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer2 = rendererSigil);
    }
    function popProvider(context, providerFiber) {
      var currentValue = valueCursor.current;
      isPrimaryRenderer ? (context._currentValue = currentValue, currentValue = rendererCursorDEV.current, pop(rendererCursorDEV, providerFiber), context._currentRenderer = currentValue) : (context._currentValue2 = currentValue, currentValue = renderer2CursorDEV.current, pop(renderer2CursorDEV, providerFiber), context._currentRenderer2 = currentValue);
      pop(valueCursor, providerFiber);
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
      for (;parent !== null; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, alternate !== null && (alternate.childLanes |= renderLanes2)) : alternate !== null && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
        if (parent === propagationRoot)
          break;
        parent = parent.return;
      }
      parent !== propagationRoot && console.error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
      var fiber = workInProgress2.child;
      fiber !== null && (fiber.return = workInProgress2);
      for (;fiber !== null; ) {
        var list = fiber.dependencies;
        if (list !== null) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a:
            for (;list !== null; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0;i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  dependency !== null && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(list.return, renderLanes2, workInProgress2);
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
        } else if (fiber.tag === 18) {
          nextFiber = fiber.return;
          if (nextFiber === null)
            throw Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          nextFiber.lanes |= renderLanes2;
          list = nextFiber.alternate;
          list !== null && (list.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
          nextFiber = null;
        } else
          nextFiber = fiber.child;
        if (nextFiber !== null)
          nextFiber.return = fiber;
        else
          for (nextFiber = fiber;nextFiber !== null; ) {
            if (nextFiber === workInProgress2) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (fiber !== null) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
      current2 = null;
      for (var parent = workInProgress2, isInsidePropagationBailout = false;parent !== null; ) {
        if (!isInsidePropagationBailout) {
          if ((parent.flags & 524288) !== 0)
            isInsidePropagationBailout = true;
          else if ((parent.flags & 262144) !== 0)
            break;
        }
        if (parent.tag === 10) {
          var currentParent = parent.alternate;
          if (currentParent === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          currentParent = currentParent.memoizedProps;
          if (currentParent !== null) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) || (current2 !== null ? current2.push(context) : current2 = [context]);
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (currentParent === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (current2 !== null ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
        }
        parent = parent.return;
      }
      current2 !== null && propagateContextChanges(workInProgress2, current2, renderLanes2, forcePropagateEntireTree);
      workInProgress2.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext;currentDependencies !== null; ) {
        var context = currentDependencies.context;
        if (!objectIs(isPrimaryRenderer ? context._currentValue : context._currentValue2, currentDependencies.memoizedValue))
          return true;
        currentDependencies = currentDependencies.next;
      }
      return false;
    }
    function prepareToReadContext(workInProgress2) {
      currentlyRenderingFiber$1 = workInProgress2;
      lastContextDependency = null;
      workInProgress2 = workInProgress2.dependencies;
      workInProgress2 !== null && (workInProgress2.firstContext = null);
    }
    function readContext(context) {
      isDisallowedContextReadInDEV && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      currentlyRenderingFiber$1 === null && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;
      context = { context, memoizedValue: value, next: null };
      if (lastContextDependency === null) {
        if (consumer === null)
          throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        lastContextDependency = context;
        consumer.dependencies = {
          lanes: 0,
          firstContext: context,
          _debugThenableState: null
        };
        consumer.flags |= 524288;
      } else
        lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    function createCache() {
      return {
        controller: new AbortControllerLocal,
        data: new Map,
        refCount: 0
      };
    }
    function retainCache(cache) {
      cache.controller.signal.aborted && console.warn("A cache instance was retained after it was already freed. This likely indicates a bug in React.");
      cache.refCount++;
    }
    function releaseCache(cache) {
      cache.refCount--;
      0 > cache.refCount && console.warn("A cache instance was released after it was already freed. This likely indicates a bug in React.");
      cache.refCount === 0 && scheduleCallback$2(NormalPriority, function() {
        cache.controller.abort();
      });
    }
    function startUpdateTimerByLane(lane, method, fiber) {
      if ((lane & 127) !== 0)
        0 > blockingUpdateTime && (blockingUpdateTime = now(), blockingUpdateTask = createTask(method), blockingUpdateMethodName = method, fiber != null && (blockingUpdateComponentName = getComponentNameFromFiber(fiber)), isAlreadyRendering() && (componentEffectSpawnedUpdate = true, blockingUpdateType = 1), lane = resolveEventTimeStamp(), method = resolveEventType(), lane !== blockingEventRepeatTime || method !== blockingEventType ? blockingEventRepeatTime = -1.1 : method !== null && (blockingUpdateType = 1), blockingEventTime = lane, blockingEventType = method);
      else if ((lane & 4194048) !== 0 && 0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = createTask(method), transitionUpdateMethodName = method, fiber != null && (transitionUpdateComponentName = getComponentNameFromFiber(fiber)), 0 > transitionStartTime)) {
        lane = resolveEventTimeStamp();
        method = resolveEventType();
        if (lane !== transitionEventRepeatTime || method !== transitionEventType)
          transitionEventRepeatTime = -1.1;
        transitionEventTime = lane;
        transitionEventType = method;
      }
    }
    function startHostActionTimer(fiber) {
      if (0 > blockingUpdateTime) {
        blockingUpdateTime = now();
        blockingUpdateTask = fiber._debugTask != null ? fiber._debugTask : null;
        isAlreadyRendering() && (blockingUpdateType = 1);
        var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
        newEventTime !== blockingEventRepeatTime || newEventType !== blockingEventType ? blockingEventRepeatTime = -1.1 : newEventType !== null && (blockingUpdateType = 1);
        blockingEventTime = newEventTime;
        blockingEventType = newEventType;
      }
      if (0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = fiber._debugTask != null ? fiber._debugTask : null, 0 > transitionStartTime)) {
        fiber = resolveEventTimeStamp();
        newEventTime = resolveEventType();
        if (fiber !== transitionEventRepeatTime || newEventTime !== transitionEventType)
          transitionEventRepeatTime = -1.1;
        transitionEventTime = fiber;
        transitionEventType = newEventTime;
      }
    }
    function pushNestedEffectDurations() {
      var prevEffectDuration = profilerEffectDuration;
      profilerEffectDuration = 0;
      return prevEffectDuration;
    }
    function popNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration = prevEffectDuration;
      return elapsedTime;
    }
    function bubbleNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration += prevEffectDuration;
      return elapsedTime;
    }
    function resetComponentEffectTimers() {
      componentEffectEndTime = componentEffectStartTime = -1.1;
    }
    function pushComponentEffectStart() {
      var prevEffectStart = componentEffectStartTime;
      componentEffectStartTime = -1.1;
      return prevEffectStart;
    }
    function popComponentEffectStart(prevEffectStart) {
      0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
    }
    function pushComponentEffectDuration() {
      var prevEffectDuration = componentEffectDuration;
      componentEffectDuration = -0;
      return prevEffectDuration;
    }
    function popComponentEffectDuration(prevEffectDuration) {
      0 <= prevEffectDuration && (componentEffectDuration = prevEffectDuration);
    }
    function pushComponentEffectErrors() {
      var prevErrors = componentEffectErrors;
      componentEffectErrors = null;
      return prevErrors;
    }
    function pushComponentEffectDidSpawnUpdate() {
      var prev = componentEffectSpawnedUpdate;
      componentEffectSpawnedUpdate = false;
      return prev;
    }
    function startProfilerTimer(fiber) {
      profilerStartTime = now();
      0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
    }
    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        fiber.selfBaseDuration = elapsedTime;
        profilerStartTime = -1;
      }
    }
    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        profilerStartTime = -1;
      }
    }
    function recordEffectDuration() {
      if (0 <= profilerStartTime) {
        var endTime = now(), elapsedTime = endTime - profilerStartTime;
        profilerStartTime = -1;
        profilerEffectDuration += elapsedTime;
        componentEffectDuration += elapsedTime;
        componentEffectEndTime = endTime;
      }
    }
    function recordEffectError(errorInfo) {
      componentEffectErrors === null && (componentEffectErrors = []);
      componentEffectErrors.push(errorInfo);
      commitErrors === null && (commitErrors = []);
      commitErrors.push(errorInfo);
    }
    function startEffectTimer() {
      profilerStartTime = now();
      0 > componentEffectStartTime && (componentEffectStartTime = profilerStartTime);
    }
    function transferActualDuration(fiber) {
      for (var child = fiber.child;child; )
        fiber.actualDuration += child.actualDuration, child = child.sibling;
    }
    function noop$1() {}
    function ensureRootIsScheduled(root) {
      root !== lastScheduledRoot && root.next === null && (lastScheduledRoot === null ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);
      mightHavePendingSyncWork = true;
      ReactSharedInternals.actQueue !== null ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = true;
        do {
          var didPerformSomeWork = false;
          for (var root = firstScheduledRoot;root !== null; ) {
            if (!onlyLegacy)
              if (syncTransitionLanes !== 0) {
                var pendingLanes = root.pendingLanes;
                if (pendingLanes === 0)
                  var nextLanes = 0;
                else {
                  var { suspendedLanes, pingedLanes } = root;
                  nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                  nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                  nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                }
                nextLanes !== 0 && (didPerformSomeWork = true, performSyncWorkOnRoot(root, nextLanes));
              } else
                nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0, root.cancelPendingCommit !== null || root.timeoutHandle !== noTimeout), (nextLanes & 3) === 0 || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root, nextLanes));
            root = root.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = false;
      }
    }
    function processRootScheduleInImmediateTask() {
      trackSchedulerEvent();
      processRootScheduleInMicrotask();
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
      var syncTransitionLanes = 0;
      currentEventTransitionLane !== 0 && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
      for (var currentTime = now$1(), prev = null, root = firstScheduledRoot;root !== null; ) {
        var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
        if (nextLanes === 0)
          root.next = null, prev === null ? firstScheduledRoot = next : prev.next = next, next === null && (lastScheduledRoot = prev);
        else if (prev = root, syncTransitionLanes !== 0 || (nextLanes & 3) !== 0)
          mightHavePendingSyncWork = true;
        root = next;
      }
      pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
      currentEventTransitionLane !== 0 && (currentEventTransitionLane = 0);
    }
    function scheduleTaskForRootDuringMicrotask(root, currentTime) {
      for (var { suspendedLanes, pingedLanes, expirationTimes } = root, lanes = root.pendingLanes & -62914561;0 < lanes; ) {
        var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
        if (expirationTime === -1) {
          if ((lane & suspendedLanes) === 0 || (lane & pingedLanes) !== 0)
            expirationTimes[index] = computeExpirationTime(lane, currentTime);
        } else
          expirationTime <= currentTime && (root.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0, root.cancelPendingCommit !== null || root.timeoutHandle !== noTimeout);
      pingedLanes = root.callbackNode;
      if (suspendedLanes === 0 || root === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || root.cancelPendingCommit !== null)
        return pingedLanes !== null && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;
      if ((suspendedLanes & 3) === 0 || checkIfRootIsPrerendering(root, suspendedLanes)) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime !== root.callbackPriority || ReactSharedInternals.actQueue !== null && pingedLanes !== fakeActCallbackNode$1)
          cancelCallback(pingedLanes);
        else
          return currentTime;
        switch (lanesToEventPriority(suspendedLanes)) {
          case 2:
          case 8:
            suspendedLanes = UserBlockingPriority;
            break;
          case 32:
            suspendedLanes = NormalPriority$1;
            break;
          case 268435456:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
        ReactSharedInternals.actQueue !== null ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode$1) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
        root.callbackPriority = currentTime;
        root.callbackNode = suspendedLanes;
        return currentTime;
      }
      pingedLanes !== null && cancelCallback(pingedLanes);
      root.callbackPriority = 2;
      root.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root, didTimeout) {
      nestedUpdateScheduled = currentUpdateIsNested = false;
      trackSchedulerEvent();
      if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
        return root.callbackNode = null, root.callbackPriority = 0, null;
      var originalCallbackNode = root.callbackNode;
      pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
      if (flushPendingEffects() && root.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0, root.cancelPendingCommit !== null || root.timeoutHandle !== noTimeout);
      if (workInProgressRootRenderLanes$jscomp$0 === 0)
        return null;
      performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
      scheduleTaskForRootDuringMicrotask(root, now$1());
      return root.callbackNode != null && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;
    }
    function performSyncWorkOnRoot(root, lanes) {
      if (flushPendingEffects())
        return null;
      currentUpdateIsNested = nestedUpdateScheduled;
      nestedUpdateScheduled = false;
      performWorkOnRoot(root, lanes, true);
    }
    function cancelCallback(callbackNode) {
      callbackNode !== fakeActCallbackNode$1 && callbackNode !== null && cancelCallback$1(callbackNode);
    }
    function scheduleImmediateRootScheduleTask() {
      ReactSharedInternals.actQueue !== null && ReactSharedInternals.actQueue.push(function() {
        processRootScheduleInMicrotask();
        return null;
      });
      supportsMicrotasks ? scheduleMicrotask(function() {
        (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask) : processRootScheduleInMicrotask();
      }) : scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask);
    }
    function requestTransitionLane() {
      if (currentEventTransitionLane === 0) {
        var actionScopeLane = currentEntangledLane;
        actionScopeLane === 0 && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, (nextTransitionUpdateLane & 261888) === 0 && (nextTransitionUpdateLane = 256));
        currentEventTransitionLane = actionScopeLane;
      }
      return currentEventTransitionLane;
    }
    function entangleAsyncAction(transition, thenable) {
      if (currentEntangledListeners === null) {
        var entangledListeners = currentEntangledListeners = [];
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: undefined,
          then: function(resolve2) {
            entangledListeners.push(resolve2);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (--currentEntangledPendingCount === 0 && (-1 < transitionUpdateTime || (transitionStartTime = -1.1), currentEntangledListeners !== null)) {
        currentEntangledActionThenable !== null && (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i = 0;i < listeners.length; i++)
          (0, listeners[i])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [], thenableWithOverride = {
        status: "pending",
        value: null,
        reason: null,
        then: function(resolve2) {
          listeners.push(resolve2);
        }
      };
      thenable.then(function() {
        thenableWithOverride.status = "fulfilled";
        thenableWithOverride.value = result;
        for (var i = 0;i < listeners.length; i++)
          (0, listeners[i])(result);
      }, function(error) {
        thenableWithOverride.status = "rejected";
        thenableWithOverride.reason = error;
        for (error = 0;error < listeners.length; error++)
          (0, listeners[error])(undefined);
      });
      return thenableWithOverride;
    }
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return cacheResumedFromPreviousRender !== null ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      prevCachePool === null ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return cacheFromPool === null ? null : {
        parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,
        pool: cacheFromPool
      };
    }
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB))
        return true;
      if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null)
        return false;
      var keysA = Object.keys(objA), keysB = Object.keys(objB);
      if (keysA.length !== keysB.length)
        return false;
      for (keysB = 0;keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
          return false;
      }
      return true;
    }
    function createThenableState() {
      return { didWarnAboutUncachedPromise: false, thenables: [] };
    }
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return thenable === "fulfilled" || thenable === "rejected";
    }
    function trackUsedThenable(thenableState2, thenable, index) {
      ReactSharedInternals.actQueue !== null && (ReactSharedInternals.didUsePromise = true);
      var trackedThenables = thenableState2.thenables;
      index = trackedThenables[index];
      index === undefined ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error("A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.")), thenable.then(noop$1, noop$1), thenable = index);
      if (thenable._debugInfo === undefined) {
        thenableState2 = performance.now();
        trackedThenables = thenable.displayName;
        var ioInfo = {
          name: typeof trackedThenables === "string" ? trackedThenables : "Promise",
          start: thenableState2,
          end: thenableState2,
          value: thenable
        };
        thenable._debugInfo = [{ awaited: ioInfo }];
        thenable.status !== "fulfilled" && thenable.status !== "rejected" && (thenableState2 = function() {
          ioInfo.end = performance.now();
        }, thenable.then(thenableState2, thenableState2));
      }
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
        default:
          if (typeof thenable.status === "string")
            thenable.then(noop$1, noop$1);
          else {
            thenableState2 = workInProgressRoot;
            if (thenableState2 !== null && 100 < thenableState2.shellSuspendCounter)
              throw Error("An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
            thenableState2 = thenable;
            thenableState2.status = "pending";
            thenableState2.then(function(fulfilledValue) {
              if (thenable.status === "pending") {
                var fulfilledThenable = thenable;
                fulfilledThenable.status = "fulfilled";
                fulfilledThenable.value = fulfilledValue;
              }
            }, function(error) {
              if (thenable.status === "pending") {
                var rejectedThenable = thenable;
                rejectedThenable.status = "rejected";
                rejectedThenable.reason = error;
              }
            });
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          }
          suspendedThenable = thenable;
          needsToResetSuspendedThenableDEV = true;
          throw SuspenseException;
      }
    }
    function resolveLazy(lazyType) {
      try {
        return callLazyInitInDEV(lazyType);
      } catch (x) {
        if (x !== null && typeof x === "object" && typeof x.then === "function")
          throw suspendedThenable = x, needsToResetSuspendedThenableDEV = true, SuspenseException;
        throw x;
      }
    }
    function getSuspendedThenable() {
      if (suspendedThenable === null)
        throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
      var thenable = suspendedThenable;
      suspendedThenable = null;
      needsToResetSuspendedThenableDEV = false;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
        throw Error("Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
    }
    function pushDebugInfo(debugInfo) {
      var previousDebugInfo = currentDebugInfo;
      debugInfo != null && (currentDebugInfo = previousDebugInfo === null ? debugInfo : previousDebugInfo.concat(debugInfo));
      return previousDebugInfo;
    }
    function getCurrentDebugTask() {
      var debugInfo = currentDebugInfo;
      if (debugInfo != null) {
        for (var i = debugInfo.length - 1;0 <= i; i--)
          if (debugInfo[i].name != null) {
            var debugTask = debugInfo[i].debugTask;
            if (debugTask != null)
              return debugTask;
          }
      }
      return null;
    }
    function validateFragmentProps(element, fiber, returnFiber) {
      for (var keys = Object.keys(element.props), i = 0;i < keys.length; i++) {
        var key = keys[i];
        if (key !== "children" && key !== "key") {
          fiber === null && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
          runWithFiberInDEV(fiber, function(erroredKey) {
            console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", erroredKey);
          }, key);
          break;
        }
      }
    }
    function unwrapThenable(thenable) {
      var index = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      thenableState$1 === null && (thenableState$1 = createThenableState());
      return trackUsedThenable(thenableState$1, thenable, index);
    }
    function coerceRef(workInProgress2, element) {
      element = element.props.ref;
      workInProgress2.ref = element !== undefined ? element : null;
    }
    function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(`A React Element from an older version of React was rendered. This is not supported. It can happen if:
- Multiple copies of the "react" package is used.
- A library pre-bundled an old copy of "react" or "react/jsx-runtime".
- A compiler tries to "inline" JSX instead of using the runtime.`);
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error("Objects are not valid as a React child (found: " + (returnFiber === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead.");
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
      var debugTask = getCurrentDebugTask();
      debugTask !== null ? debugTask.run(throwOnInvalidObjectTypeImpl.bind(null, returnFiber, newChild)) : throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    function warnOnFunctionTypeImpl(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", returnFiber.tag === 3 ? console.error(`Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  root.render(%s)`, invalidChild, invalidChild, invalidChild) : console.error(`Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  <%s>{%s}</%s>`, invalidChild, invalidChild, parentName, invalidChild, parentName));
    }
    function warnOnFunctionType(returnFiber, invalidChild) {
      var debugTask = getCurrentDebugTask();
      debugTask !== null ? debugTask.run(warnOnFunctionTypeImpl.bind(null, returnFiber, invalidChild)) : warnOnFunctionTypeImpl(returnFiber, invalidChild);
    }
    function warnOnSymbolTypeImpl(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), returnFiber.tag === 3 ? console.error(`Symbols are not valid as a React child.
  root.render(%s)`, invalidChild) : console.error(`Symbols are not valid as a React child.
  <%s>%s</%s>`, parentName, invalidChild, parentName));
    }
    function warnOnSymbolType(returnFiber, invalidChild) {
      var debugTask = getCurrentDebugTask();
      debugTask !== null ? debugTask.run(warnOnSymbolTypeImpl.bind(null, returnFiber, invalidChild)) : warnOnSymbolTypeImpl(returnFiber, invalidChild);
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          deletions === null ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects)
          return null;
        for (;currentFirstChild !== null; )
          deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = new Map;currentFirstChild !== null; )
          currentFirstChild.key !== null ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return newFiber.flags |= 1048576, lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (newIndex !== null)
          return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
        newFiber.flags |= 67108866;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects && newFiber.alternate === null && (newFiber.flags |= 67108866);
        return newFiber;
      }
      function updateTextNode(returnFiber, current2, textContent, lanes) {
        if (current2 === null || current2.tag !== 6)
          return current2 = createFiberFromText(textContent, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
        current2 = useFiber(current2, textContent);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function updateElement(returnFiber, current2, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return current2 = updateFragment(returnFiber, current2, element.props.children, lanes, element.key), validateFragmentProps(element, current2, returnFiber), current2;
        if (current2 !== null && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type))
          return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
        current2 = createFiberFromElement(element, returnFiber.mode, lanes);
        coerceRef(current2, element);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function updatePortal(returnFiber, current2, portal, lanes) {
        if (current2 === null || current2.tag !== 4 || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
          return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
        current2 = useFiber(current2, portal.children || []);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function updateFragment(returnFiber, current2, fragment, lanes, key) {
        if (current2 === null || current2.tag !== 7)
          return current2 = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
        current2 = useFiber(current2, fragment);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function createChild(returnFiber, newChild, lanes) {
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
            case REACT_PORTAL_TYPE:
              return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
            case REACT_LAZY_TYPE:
              var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              newChild = resolveLazy(newChild);
              returnFiber = createChild(returnFiber, newChild, lanes);
              currentDebugInfo = _prevDebugInfo;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
          if (typeof newChild.then === "function")
            return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = oldFiber !== null ? oldFiber.key : null;
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return key !== null ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_LAZY_TYPE:
              return key = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
            if (key !== null)
              return null;
            key = pushDebugInfo(newChild._debugInfo);
            returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            currentDebugInfo = key;
            return returnFiber;
          }
          if (typeof newChild.then === "function")
            return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newIdx = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;
            case REACT_PORTAL_TYPE:
              return existingChildren = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
            case REACT_LAZY_TYPE:
              var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
              newChild = resolveLazy(newChild);
              returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
              currentDebugInfo = _prevDebugInfo7;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;
          if (typeof newChild.then === "function")
            return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
        if (typeof child !== "object" || child === null)
          return knownKeys;
        switch (child.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            warnForMissingKey(returnFiber, workInProgress2, child);
            var key = child.key;
            if (typeof key !== "string")
              break;
            if (knownKeys === null) {
              knownKeys = new Set;
              knownKeys.add(key);
              break;
            }
            if (!knownKeys.has(key)) {
              knownKeys.add(key);
              break;
            }
            runWithFiberInDEV(workInProgress2, function() {
              console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", key);
            });
            break;
          case REACT_LAZY_TYPE:
            child = resolveLazy(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
        }
        return knownKeys;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null;oldFiber !== null && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
          if (newFiber === null) {
            oldFiber === null && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);
          shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (oldFiber === null) {
          for (;newIdx < newChildren.length; newIdx++)
            oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), oldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber);newIdx < newChildren.length; newIdx++)
          nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), nextOldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && nextOldFiber.alternate !== null && oldFiber.delete(nextOldFiber.key === null ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (newChildren == null)
          throw Error("An iterable object provided no iterator.");
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next();oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (newFiber === null) {
            oldFiber === null && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);
          shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (oldFiber === null) {
          for (;!step.done; newIdx++, step = newChildren.next())
            oldFiber = createChild(returnFiber, step.value, lanes), oldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber);!step.done; newIdx++, step = newChildren.next())
          nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), nextOldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && nextOldFiber.alternate !== null && oldFiber.delete(nextOldFiber.key === null ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              a: {
                for (var key = newChild.key;currentFirstChild !== null; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (currentFirstChild.tag === 7) {
                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                        lanes = useFiber(currentFirstChild, newChild.props.children);
                        lanes.return = returnFiber;
                        lanes._debugOwner = newChild._owner;
                        lanes._debugInfo = currentDebugInfo;
                        validateFragmentProps(newChild, lanes, returnFiber);
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || typeof key === "object" && key !== null && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      lanes._debugOwner = newChild._owner;
                      lanes._debugInfo = currentDebugInfo;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else
                    deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
              }
              returnFiber = placeSingleChild(returnFiber);
              currentDebugInfo = prevDebugInfo;
              return returnFiber;
            case REACT_PORTAL_TYPE:
              a: {
                prevDebugInfo = newChild;
                for (newChild = prevDebugInfo.key;currentFirstChild !== null; ) {
                  if (currentFirstChild.key === newChild)
                    if (currentFirstChild.tag === 4 && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else
                    deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          }
          if (isArrayImpl(newChild))
            return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          if (getIteratorFn(newChild)) {
            prevDebugInfo = pushDebugInfo(newChild._debugInfo);
            key = getIteratorFn(newChild);
            if (typeof key !== "function")
              throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            var newChildren = key.call(newChild);
            if (newChildren === newChild) {
              if (returnFiber.tag !== 0 || Object.prototype.toString.call(returnFiber.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(newChildren) !== "[object Generator]")
                didWarnAboutGenerators || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators = true;
            } else
              newChild.entries !== key || didWarnAboutMaps || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = true);
            returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);
            currentDebugInfo = prevDebugInfo;
            return returnFiber;
          }
          if (typeof newChild.then === "function")
            return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return prevDebugInfo = "" + newChild, currentFirstChild !== null && currentFirstChild.tag === 6 ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function(returnFiber, currentFirstChild, newChild, lanes) {
        var prevDebugInfo = currentDebugInfo;
        currentDebugInfo = null;
        try {
          thenableIndexCounter$1 = 0;
          var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
          thenableState$1 = null;
          return firstChildFiber;
        } catch (x) {
          if (x === SuspenseException || x === SuspenseActionException)
            throw x;
          var fiber = createFiber(29, x, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          var debugInfo = fiber._debugInfo = currentDebugInfo;
          fiber._debugOwner = returnFiber._debugOwner;
          fiber._debugTask = returnFiber._debugTask;
          if (debugInfo != null) {
            for (var i = debugInfo.length - 1;0 <= i; i--)
              if (typeof debugInfo[i].stack === "string") {
                fiber._debugOwner = debugInfo[i];
                fiber._debugTask = debugInfo[i].debugTask;
                break;
              }
          }
          return fiber;
        } finally {
          currentDebugInfo = prevDebugInfo;
        }
      };
    }
    function validateSuspenseListNestedChild(childSlot, index) {
      var isAnArray = isArrayImpl(childSlot);
      childSlot = !isAnArray && typeof getIteratorFn(childSlot) === "function";
      return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", isAnArray, index, isAnArray), false) : true;
    }
    function finishQueueingConcurrentUpdates() {
      for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0;i < endIndex; ) {
        var fiber = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var queue = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var update = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var lane = concurrentQueues[i];
        concurrentQueues[i++] = null;
        if (queue !== null && update !== null) {
          var pending = queue.pending;
          pending === null ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        lane !== 0 && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      fiber !== null && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      alternate !== null && (alternate.lanes |= lane);
      for (var isHidden = false, parent = sourceFiber.return;parent !== null; )
        parent.childLanes |= lane, alternate = parent.alternate, alternate !== null && (alternate.childLanes |= lane), parent.tag === 22 && (sourceFiber = parent.stateNode, sourceFiber === null || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
      return sourceFiber.tag === 3 ? (parent = sourceFiber.stateNode, isHidden && update !== null && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], alternate === null ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
        throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
      sourceFiber.alternate === null && (sourceFiber.flags & 4098) !== 0 && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
      for (var node = sourceFiber, parent = node.return;parent !== null; )
        node.alternate === null && (node.flags & 4098) !== 0 && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
      return node.tag === 3 ? node.stateNode : null;
    }
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current2, workInProgress2) {
      current2 = current2.updateQueue;
      workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
        baseState: current2.baseState,
        firstBaseUpdate: current2.firstBaseUpdate,
        lastBaseUpdate: current2.lastBaseUpdate,
        shared: current2.shared,
        callbacks: null
      });
    }
    function createUpdate(lane) {
      return {
        lane,
        tag: UpdateState,
        payload: null,
        callback: null,
        next: null
      };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (updateQueue === null)
        return null;
      updateQueue = updateQueue.shared;
      if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
        var componentName2 = getComponentNameFromFiber(fiber);
        console.error(`An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.

Please update the following component: %s`, componentName2);
        didWarnUpdateInsideUpdate = true;
      }
      if ((executionContext & RenderContext) !== NoContext)
        return componentName2 = updateQueue.pending, componentName2 === null ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root, fiber, lane) {
      fiber = fiber.updateQueue;
      if (fiber !== null && (fiber = fiber.shared, (lane & 4194048) !== 0)) {
        var queueLanes = fiber.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
      var { updateQueue: queue, alternate: current2 } = workInProgress2;
      if (current2 !== null && (current2 = current2.updateQueue, queue === current2)) {
        var newFirst = null, newLast = null;
        queue = queue.firstBaseUpdate;
        if (queue !== null) {
          do {
            var clone = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            newLast === null ? newFirst = newLast = clone : newLast = newLast.next = clone;
            queue = queue.next;
          } while (queue !== null);
          newLast === null ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
        } else
          newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current2.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current2.shared,
          callbacks: current2.callbacks
        };
        workInProgress2.updateQueue = queue;
        return;
      }
      workInProgress2 = queue.lastBaseUpdate;
      workInProgress2 === null ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
      queue.lastBaseUpdate = capturedUpdate;
    }
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (entangledActionThenable !== null)
          throw entangledActionThenable;
      }
    }
    function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
      didReadFromEntangledAsyncAction = false;
      var queue = workInProgress2.updateQueue;
      hasForceUpdate = false;
      currentlyProcessingQueue = queue.shared;
      var { firstBaseUpdate, lastBaseUpdate } = queue, pendingQueue = queue.shared.pending;
      if (pendingQueue !== null) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        lastBaseUpdate === null ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
        lastBaseUpdate = lastPendingUpdate;
        var current2 = workInProgress2.alternate;
        current2 !== null && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (pendingQueue === null ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
      }
      if (firstBaseUpdate !== null) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current2 = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
            updateLane !== 0 && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
            current2 !== null && (current2 = current2.next = {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
            a: {
              updateLane = workInProgress2;
              var partialState = pendingQueue;
              var nextProps = props, instance = instance$jscomp$0;
              switch (partialState.tag) {
                case ReplaceState:
                  partialState = partialState.payload;
                  if (typeof partialState === "function") {
                    isDisallowedContextReadInDEV = true;
                    var nextState = partialState.call(instance, newState, nextProps);
                    if (updateLane.mode & 8) {
                      setIsStrictModeForDevtools(true);
                      try {
                        partialState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    isDisallowedContextReadInDEV = false;
                    newState = nextState;
                    break a;
                  }
                  newState = partialState;
                  break a;
                case CaptureUpdate:
                  updateLane.flags = updateLane.flags & -65537 | 128;
                case UpdateState:
                  nextState = partialState.payload;
                  if (typeof nextState === "function") {
                    isDisallowedContextReadInDEV = true;
                    partialState = nextState.call(instance, newState, nextProps);
                    if (updateLane.mode & 8) {
                      setIsStrictModeForDevtools(true);
                      try {
                        nextState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    isDisallowedContextReadInDEV = false;
                  } else
                    partialState = nextState;
                  if (partialState === null || partialState === undefined)
                    break a;
                  newState = assign({}, newState, partialState);
                  break a;
                case ForceUpdate:
                  hasForceUpdate = true;
              }
            }
            updateLane = pendingQueue.callback;
            updateLane !== null && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, isHiddenUpdate === null ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
          } else
            isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }, current2 === null ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
          pendingQueue = pendingQueue.next;
          if (pendingQueue === null)
            if (pendingQueue = queue.shared.pending, pendingQueue === null)
              break;
            else
              isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
        } while (1);
        current2 === null && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current2;
        firstBaseUpdate === null && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress2.lanes = lastBaseUpdate;
        workInProgress2.memoizedState = newState;
      }
      currentlyProcessingQueue = null;
    }
    function callCallback(callback, context) {
      if (typeof callback !== "function")
        throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
      callback.call(context);
    }
    function commitHiddenCallbacks(updateQueue, context) {
      var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
      if (hiddenCallbacks !== null)
        for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0;updateQueue < hiddenCallbacks.length; updateQueue++)
          callCallback(hiddenCallbacks[updateQueue], context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (callbacks !== null)
        for (updateQueue.callbacks = null, updateQueue = 0;updateQueue < callbacks.length; updateQueue++)
          callCallback(callbacks[updateQueue], context);
    }
    function pushHiddenContext(fiber, context) {
      var prevEntangledRenderLanes = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, context, fiber);
      entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
    }
    function reuseHiddenContextOnStack(fiber) {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);
    }
    function popHiddenContext(fiber) {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor, fiber);
      pop(prevEntangledRenderLanesCursor, fiber);
    }
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current2 = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);
      push(suspenseHandlerStackCursor, handler, handler);
      shellBoundary === null && (current2 === null || currentTreeHiddenStackCursor.current !== null ? shellBoundary = handler : current2.memoizedState !== null && (shellBoundary = handler));
    }
    function pushDehydratedActivitySuspenseHandler(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
      push(suspenseHandlerStackCursor, fiber, fiber);
      shellBoundary === null && (shellBoundary = fiber);
    }
    function pushOffscreenSuspenseHandler(fiber) {
      fiber.tag === 22 ? (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), shellBoundary === null && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
    }
    function reuseSuspenseHandlerOnStack(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor, fiber);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor, fiber);
    }
    function findFirstSuspended(row) {
      for (var node = row;node !== null; ) {
        if (node.tag === 13) {
          var state = node.memoizedState;
          if (state !== null && (state = state.dehydrated, state === null || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
            return node;
        } else if (node.tag === 19 && (node.memoizedProps.revealOrder === "forwards" || node.memoizedProps.revealOrder === "backwards" || node.memoizedProps.revealOrder === "unstable_legacy-backwards" || node.memoizedProps.revealOrder === "together")) {
          if ((node.flags & 128) !== 0)
            return node;
        } else if (node.child !== null) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row)
          break;
        for (;node.sibling === null; ) {
          if (node.return === null || node.return === row)
            return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    function mountHookTypesDev() {
      var hookName = currentHookNameInDev;
      hookTypesDev === null ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
    }
    function updateHookTypesDev() {
      var hookName = currentHookNameInDev;
      if (hookTypesDev !== null && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
        var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
        if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), hookTypesDev !== null)) {
          for (var table = "", i = 0;i <= hookTypesUpdateIndexDev; i++) {
            var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
            for (oldHookName = i + 1 + ". " + oldHookName;30 > oldHookName.length; )
              oldHookName += " ";
            oldHookName += newHookName + `
`;
            table += oldHookName;
          }
          console.error(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, componentName2, table);
        }
      }
    }
    function checkDepsAreArrayDev(deps) {
      deps === undefined || deps === null || isArrayImpl(deps) || console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
    }
    function warnOnUseFormStateInDev() {
      var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
      didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error("ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.", componentName2));
    }
    function throwInvalidHookError() {
      throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (ignorePreviousDependencies)
        return false;
      if (prevDeps === null)
        return console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), false;
      nextDeps.length !== prevDeps.length && console.error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
      for (var i = 0;i < prevDeps.length && i < nextDeps.length; i++)
        if (!objectIs(nextDeps[i], prevDeps[i]))
          return false;
      return true;
    }
    function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress2;
      hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
      if (Object.prototype.toString.call(Component) === "[object AsyncFunction]" || Object.prototype.toString.call(Component) === "[object AsyncGeneratorFunction]")
        nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error("%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.", nextRenderLanes === null ? "An unknown Component" : "<" + nextRenderLanes + ">"));
      workInProgress2.memoizedState = null;
      workInProgress2.updateQueue = null;
      workInProgress2.lanes = 0;
      ReactSharedInternals.H = current2 !== null && current2.memoizedState !== null ? HooksDispatcherOnUpdateInDEV : hookTypesDev !== null ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
      shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & 8) !== NoMode;
      var children = callComponentInDEV(Component, props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress2, Component, props, secondArg));
      if (nextRenderLanes) {
        setIsStrictModeForDevtools(true);
        try {
          children = renderWithHooksAgain(workInProgress2, Component, props, secondArg);
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      finishRenderingHooks(current2, workInProgress2);
      return children;
    }
    function finishRenderingHooks(current2, workInProgress2) {
      workInProgress2._debugHookTypes = hookTypesDev;
      workInProgress2.dependencies === null ? thenableState !== null && (workInProgress2.dependencies = {
        lanes: 0,
        firstContext: null,
        _debugThenableState: thenableState
      }) : workInProgress2.dependencies._debugThenableState = thenableState;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
      renderLanes = 0;
      hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
      hookTypesUpdateIndexDev = -1;
      current2 !== null && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error("Internal React error: Expected static flag was missing. Please notify the React team.");
      didScheduleRenderPhaseUpdate = false;
      thenableIndexCounter = 0;
      thenableState = null;
      if (didRenderTooFewHooks)
        throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      current2 === null || didReceiveUpdate || (current2 = current2.dependencies, current2 !== null && checkIfContextChanged(current2) && (didReceiveUpdate = true));
      needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
      current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error("`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.")));
    }
    function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
      currentlyRenderingFiber = workInProgress2;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
        thenableIndexCounter = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (numberOfReRenders >= RE_RENDER_LIMIT)
          throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        numberOfReRenders += 1;
        ignorePreviousDependencies = false;
        workInProgressHook = currentHook = null;
        if (workInProgress2.updateQueue != null) {
          var children = workInProgress2.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          children.memoCache != null && (children.memoCache.index = 0);
        }
        hookTypesUpdateIndexDev = -1;
        ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
        children = callComponentInDEV(Component, props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
      maybeThenable = typeof maybeThenable.then === "function" ? useThenable(maybeThenable) : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (currentHook !== null ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = localIdCounter !== 0;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current2, workInProgress2, lanes) {
      workInProgress2.updateQueue = current2.updateQueue;
      workInProgress2.flags = (workInProgress2.mode & 16) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
      current2.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress2) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress2 = workInProgress2.memoizedState;workInProgress2 !== null; ) {
          var queue = workInProgress2.queue;
          queue !== null && (queue.pending = null);
          workInProgress2 = workInProgress2.next;
        }
        didScheduleRenderPhaseUpdate = false;
      }
      renderLanes = 0;
      hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
      hookTypesUpdateIndexDev = -1;
      currentHookNameInDev = null;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      thenableIndexCounter = localIdCounter = 0;
      thenableState = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      workInProgressHook === null ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (currentHook === null) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook = nextCurrentHook !== null ? nextCurrentHook.memoizedState : null;
      } else
        nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook = workInProgressHook === null ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
      if (nextWorkInProgressHook !== null)
        workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
      else {
        if (nextCurrentHook === null) {
          if (currentlyRenderingFiber.alternate === null)
            throw Error("Update hook called on initial render. This is likely a bug in React. Please file an issue.");
          throw Error("Rendered more hooks than during the previous render.");
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        workInProgressHook === null ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
      }
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function useThenable(thenable) {
      var index = thenableIndexCounter;
      thenableIndexCounter += 1;
      thenableState === null && (thenableState = createThenableState());
      thenable = trackUsedThenable(thenableState, thenable, index);
      index = currentlyRenderingFiber;
      (workInProgressHook === null ? index.memoizedState : workInProgressHook.next) === null && (index = index.alternate, ReactSharedInternals.H = index !== null && index.memoizedState !== null ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
      return thenable;
    }
    function use(usable) {
      if (usable !== null && typeof usable === "object") {
        if (typeof usable.then === "function")
          return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE)
          return readContext(usable);
      }
      throw Error("An unsupported type was passed to use(): " + String(usable));
    }
    function useMemoCache(size) {
      var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
      updateQueue !== null && (memoCache = updateQueue.memoCache);
      if (memoCache == null) {
        var current2 = currentlyRenderingFiber.alternate;
        current2 !== null && (current2 = current2.updateQueue, current2 !== null && (current2 = current2.memoCache, current2 != null && (memoCache = {
          data: current2.data.map(function(array) {
            return array.slice();
          }),
          index: 0
        })));
      }
      memoCache == null && (memoCache = { data: [], index: 0 });
      updateQueue === null && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (updateQueue === undefined || ignorePreviousDependencies)
        for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0;current2 < size; current2++)
          updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
      else
        updateQueue.length !== size && console.error("Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.", updateQueue.length, size);
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return typeof action === "function" ? action(state) : action;
    }
    function mountReducer(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (init !== undefined) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      } else
        initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, reducer);
      return [hook.memoizedState, reducer];
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current2, reducer) {
      var queue = hook.queue;
      if (queue === null)
        throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
      if (pendingQueue !== null) {
        if (baseQueue !== null) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current2.baseQueue !== baseQueue && console.error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
        current2.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (baseQueue === null)
        hook.memoizedState = pendingQueue;
      else {
        current2 = baseQueue.next;
        var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
        do {
          var updateLane = update.lane & -536870913;
          if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            var revertLane = update.revertLane;
            if (revertLane === 0)
              newBaseQueueLast !== null && (newBaseQueueLast = newBaseQueueLast.next = {
                lane: 0,
                revertLane: 0,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
              continue;
            } else
              updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, newBaseQueueLast === null ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
          } else
            revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              gesture: update.gesture,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, newBaseQueueLast === null ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
          update = update.next;
        } while (update !== null && update !== current2);
        newBaseQueueLast === null ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
        if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, reducer !== null)))
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      baseQueue === null && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(), queue = hook.queue;
      if (queue === null)
        throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      queue.lastRenderedReducer = reducer;
      var { dispatch, pending: lastRenderPhaseUpdate } = queue, newState = hook.memoizedState;
      if (lastRenderPhaseUpdate !== null) {
        queue.pending = null;
        var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        do
          newState = reducer(newState, update.action), update = update.next;
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
        hook.memoizedState = newState;
        hook.baseQueue === null && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (getServerSnapshot === undefined)
          throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        var nextSnapshot = getServerSnapshot();
        didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error("The result of getServerSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = true);
      } else {
        nextSnapshot = getSnapshot();
        didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = true));
        if (workInProgressRoot === null)
          throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        (workInProgressRootRenderLanes & 127) !== 0 || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
      }
      hook.memoizedState = nextSnapshot;
      getServerSnapshot = { value: nextSnapshot, getSnapshot };
      hook.queue = getServerSnapshot;
      mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [subscribe]);
      fiber.flags |= 2048;
      pushSimpleEffect(HasEffect | Passive, { destroy: undefined }, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), null);
      return nextSnapshot;
    }
    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (getServerSnapshot === undefined)
          throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        getServerSnapshot = getServerSnapshot();
      } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
        var cachedSnapshot = getSnapshot();
        objectIs(getServerSnapshot, cachedSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = true);
      }
      if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot))
        hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
      hook = hook.queue;
      var create = subscribeToStore.bind(null, fiber, hook, subscribe);
      updateEffectImpl(2048, Passive, create, [subscribe]);
      if (hook.getSnapshot !== getSnapshot || cachedSnapshot || workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
        fiber.flags |= 2048;
        pushSimpleEffect(HasEffect | Passive, { destroy: undefined }, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), null);
        if (workInProgressRoot === null)
          throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        isHydrating$jscomp$0 || (renderLanes & 127) !== 0 || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      getSnapshot === null ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, renderedSnapshot === null ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function() {
        checkIfSnapshotChanged(inst) && (startUpdateTimerByLane(2, "updateSyncExternalStore()", fiber), forceStoreRerender(fiber));
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function forceStoreRerender(fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      root !== null && scheduleUpdateOnFiber(root, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if (typeof initialState === "function") {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function mountState(initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    }
    function mountOptimistic(passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, true, queue);
      queue.dispatch = hook;
      return [passthrough, hook];
    }
    function updateOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    }
    function updateOptimisticImpl(hook, current2, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(hook, currentHook, typeof reducer === "function" ? reducer : basicStateReducer);
    }
    function rerenderOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      if (currentHook !== null)
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber))
        throw Error("Cannot update form state while rendering.");
      fiber = actionQueue.action;
      if (fiber !== null) {
        var actionNode = {
          payload,
          action: fiber,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(listener) {
            actionNode.listeners.push(listener);
          }
        };
        ReactSharedInternals.T !== null ? setPendingState(true) : actionNode.isTransition = false;
        setState(actionNode);
        setPendingState = actionQueue.pending;
        setPendingState === null ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
      }
    }
    function runActionStateAction(actionQueue, node) {
      var { action, payload } = node, prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        currentTransition._updatedFibers = new Set;
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
          onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          prevTransition !== null && currentTransition.types !== null && (prevTransition.types !== null && prevTransition.types !== currentTransition.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, prevTransition === null && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
        }
      } else
        try {
          currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
        } catch (error$2) {
          onActionError(actionQueue, node, error$2);
        }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
      returnValue !== null && typeof returnValue === "object" && typeof returnValue.then === "function" ? (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(function(nextState) {
        onActionSuccess(actionQueue, node, nextState);
      }, function(error) {
        return onActionError(actionQueue, node, error);
      }), node.isTransition || console.error("An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop.")) : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      actionNode !== null && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (last !== null) {
        last = last.next;
        do
          actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
        while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i = 0;i < actionNode.length; i++)
        (0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (ssrFormState !== null) {
          a: {
            var isMatching = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);
                if (markerInstance) {
                  nextHydratableInstance = getNextHydratableSibling(markerInstance);
                  isMatching = isFormStateMarkerMatching(markerInstance);
                  break a;
                }
              }
              throwOnHydrationMismatch(isMatching);
            }
            isMatching = false;
          }
          isMatching && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      isMatching = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = isMatching;
      ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber, isMatching);
      isMatching.dispatch = ssrFormState;
      isMatching = mountStateImpl(false);
      var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, false, isMatching.queue);
      isMatching = mountWorkInProgressHook();
      markerInstance = {
        state: initialStateProp,
        dispatch: null,
        action,
        pending: null
      };
      isMatching.queue = markerInstance;
      ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber, markerInstance, setPendingState, ssrFormState);
      markerInstance.dispatch = ssrFormState;
      isMatching.memoizedState = action;
      return [initialStateProp, ssrFormState, false];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if (typeof currentStateHook === "object" && currentStateHook !== null && typeof currentStateHook.then === "function")
        try {
          var state = useThenable(currentStateHook);
        } catch (x) {
          if (x === SuspenseException)
            throw SuspenseActionException;
          throw x;
        }
      else
        state = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
      action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(HasEffect | Passive, { destroy: undefined }, actionStateActionEffect.bind(null, actionQueue, action), null));
      return [state, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
      if (currentStateHook !== null)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, false];
    }
    function pushSimpleEffect(tag, inst, create, deps) {
      tag = { tag, create, deps, inst, next: null };
      inst = currentlyRenderingFiber.updateQueue;
      inst === null && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
      create = inst.lastEffect;
      create === null ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
      return tag;
    }
    function mountRef(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return hook.memoizedState = initialValue;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = mountWorkInProgressHook();
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, { destroy: undefined }, create, deps === undefined ? null : deps);
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      var inst = hook.memoizedState.inst;
      currentHook !== null && deps !== null && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, inst, create, deps));
    }
    function mountEffect(create, deps) {
      (currentlyRenderingFiber.mode & 16) !== NoMode ? mountEffectImpl(276826112, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);
    }
    function useEffectEventImpl(payload) {
      currentlyRenderingFiber.flags |= 4;
      var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
      if (componentUpdateQueue === null)
        componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
      else {
        var events = componentUpdateQueue.events;
        events === null ? componentUpdateQueue.events = [payload] : events.push(payload);
      }
    }
    function mountEvent(callback) {
      var hook = mountWorkInProgressHook(), ref = { impl: callback };
      hook.memoizedState = ref;
      return function() {
        if ((executionContext & RenderContext) !== NoContext)
          throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
        return ref.impl.apply(undefined, arguments);
      };
    }
    function updateEvent(callback) {
      var ref = updateWorkInProgressHook().memoizedState;
      useEffectEventImpl({ ref, nextImpl: callback });
      return function() {
        if ((executionContext & RenderContext) !== NoContext)
          throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
        return ref.impl.apply(undefined, arguments);
      };
    }
    function mountLayoutEffect(create, deps) {
      var fiberFlags = 4194308;
      (currentlyRenderingFiber.mode & 16) !== NoMode && (fiberFlags |= 134217728);
      return mountEffectImpl(fiberFlags, Layout, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
      if (typeof ref === "function") {
        create = create();
        var refCleanup = ref(create);
        return function() {
          typeof refCleanup === "function" ? refCleanup() : ref(null);
        };
      }
      if (ref !== null && ref !== undefined)
        return ref.hasOwnProperty("current") || console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(ref).join(", ") + "}"), create = create(), ref.current = create, function() {
          ref.current = null;
        };
    }
    function mountImperativeHandle(ref, create, deps) {
      typeof create !== "function" && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
      deps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
      var fiberFlags = 4194308;
      (currentlyRenderingFiber.mode & 16) !== NoMode && (fiberFlags |= 134217728);
      mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function updateImperativeHandle(ref, create, deps) {
      typeof create !== "function" && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
      deps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
      updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function mountCallback(callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        deps === undefined ? null : deps
      ];
      return callback;
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      var prevState = hook.memoizedState;
      if (deps !== null && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function mountMemo(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      var prevState = hook.memoizedState;
      if (deps !== null && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValue(value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    }
    function updateDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function rerenderDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return currentHook === null ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (initialValue === undefined || (renderLanes & 1073741824) !== 0 && (workInProgressRootRenderLanes & 261930) === 0)
        return hook.memoizedState = value;
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue))
        return value;
      if (currentTreeHiddenStackCursor.current !== null)
        return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
      if ((renderLanes & 42) === 0 || (renderLanes & 1073741824) !== 0 && (workInProgressRootRenderLanes & 261930) === 0)
        return didReceiveUpdate = true, hook.memoizedState = value;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function releaseAsyncTransition() {
      ReactSharedInternals.asyncTransitions--;
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      var previousPriority = getCurrentUpdatePriority();
      setCurrentUpdatePriority(previousPriority !== 0 && 8 > previousPriority ? previousPriority : 8);
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      currentTransition._updatedFibers = new Set;
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, false, queue, pendingState);
      try {
        var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
        onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
        if (returnValue !== null && typeof returnValue === "object" && typeof returnValue.then === "function") {
          ReactSharedInternals.asyncTransitions++;
          returnValue.then(releaseAsyncTransition, releaseAsyncTransition);
          var thenableForFinishedState = chainThenableValue(returnValue, finishedState);
          dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));
        } else
          dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
      } catch (error) {
        dispatchSetStateInternal(fiber, queue, { then: function() {}, status: "rejected", reason: error }, requestUpdateLane(fiber));
      } finally {
        setCurrentUpdatePriority(previousPriority), prevTransition !== null && currentTransition.types !== null && (prevTransition.types !== null && prevTransition.types !== currentTransition.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, prevTransition === null && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
      }
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (existingStateHook !== null)
        return existingStateHook;
      existingStateHook = {
        memoizedState: NotPendingTransition,
        baseState: NotPendingTransition,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: NotPendingTransition
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      formFiber !== null && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function mountTransition() {
      var stateHook = mountStateImpl(false);
      stateHook = startTransition.bind(null, currentlyRenderingFiber, stateHook.queue, true, false);
      mountWorkInProgressHook().memoizedState = stateHook;
      return [false, stateHook];
    }
    function updateTransition() {
      var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        typeof booleanOrThenable === "boolean" ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    }
    function rerenderTransition() {
      var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        typeof booleanOrThenable === "boolean" ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function mountId() {
      var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var treeId = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
        identifierPrefix = "_" + identifierPrefix + "R_" + treeId;
        treeId = localIdCounter++;
        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
        identifierPrefix += "_";
      } else
        treeId = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + treeId.toString(32) + "_";
      return hook.memoizedState = identifierPrefix;
    }
    function mountRefresh() {
      return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber);
    }
    function refreshCache(fiber, seedKey) {
      for (var provider = fiber.return;provider !== null; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane(provider), refreshUpdate = createUpdate(lane), root = enqueueUpdate(provider, refreshUpdate, lane);
            root !== null && (startUpdateTimerByLane(lane, "refresh()", fiber), scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));
            fiber = createCache();
            seedKey !== null && seedKey !== undefined && root !== null && console.error("The seed argument is not enabled outside experimental channels.");
            refreshUpdate.payload = { cache: fiber };
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      var args = arguments;
      typeof args[3] === "function" && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      args = requestUpdateLane(fiber);
      var update = {
        lane: args,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), update !== null && (startUpdateTimerByLane(args, "dispatch()", fiber), scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
    }
    function dispatchSetState(fiber, queue, action) {
      var args = arguments;
      typeof args[3] === "function" && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      args = requestUpdateLane(fiber);
      dispatchSetStateInternal(fiber, queue, action, args) && startUpdateTimerByLane(args, "setState()", fiber);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber))
        enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (fiber.lanes === 0 && (alternate === null || alternate.lanes === 0) && (alternate = queue.lastRenderedReducer, alternate !== null)) {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
            update.hasEagerState = true;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return enqueueUpdate$1(fiber, queue, update, 0), workInProgressRoot === null && finishQueueingConcurrentUpdates(), false;
          } catch (error) {} finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (action !== null)
          return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
      }
      return false;
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
      ReactSharedInternals.T === null && currentEntangledLane === 0 && console.error("An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.");
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender)
          throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else
        throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), throwIfDuringRender !== null && (startUpdateTimerByLane(2, "setOptimistic()", fiber), scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber || alternate !== null && alternate === currentlyRenderingFiber;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
      var pending = queue.pending;
      pending === null ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    function entangleTransitionUpdate(root, queue, lane) {
      if ((lane & 4194048) !== 0) {
        var queueLanes = queue.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function warnOnInvalidCallback(callback) {
      if (callback !== null && typeof callback !== "function") {
        var key = String(callback);
        didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
      }
    }
    function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
      var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
      if (workInProgress2.mode & 8) {
        setIsStrictModeForDevtools(true);
        try {
          partialState = getDerivedStateFromProps(nextProps, prevState);
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      partialState === undefined && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", ctor)));
      prevState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
      workInProgress2.memoizedState = prevState;
      workInProgress2.lanes === 0 && (workInProgress2.updateQueue.baseState = prevState);
    }
    function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
      var instance = workInProgress2.stateNode;
      if (typeof instance.shouldComponentUpdate === "function") {
        oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
        if (workInProgress2.mode & 8) {
          setIsStrictModeForDevtools(true);
          try {
            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        oldProps === undefined && console.error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
        return oldProps;
      }
      return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
    }
    function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
      var oldState = instance.state;
      typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps(newProps, nextContext);
      typeof instance.UNSAFE_componentWillReceiveProps === "function" && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", workInProgress2)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          propName !== "ref" && (newProps[propName] = baseProps[propName]);
      }
      if (Component = Component.defaultProps) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (var _propName in Component)
          newProps[_propName] === undefined && (newProps[_propName] = Component[_propName]);
      }
      return newProps;
    }
    function logUncaughtError(root, errorInfo) {
      try {
        componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
        errorBoundaryName = null;
        var error = errorInfo.value;
        if (ReactSharedInternals.actQueue !== null)
          ReactSharedInternals.thrownErrors.push(error);
        else {
          var onUncaughtError = root.onUncaughtError;
          onUncaughtError(error, { componentStack: errorInfo.stack });
        }
      } catch (e) {
        setTimeout(function() {
          throw e;
        });
      }
    }
    function logCaughtError(root, boundary, errorInfo) {
      try {
        componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
        errorBoundaryName = getComponentNameFromFiber(boundary);
        var onCaughtError = root.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: boundary.tag === 1 ? boundary.stateNode : null
        });
      } catch (e) {
        setTimeout(function() {
          throw e;
        });
      }
    }
    function createRootErrorUpdate(root, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      lane.payload = { element: null };
      lane.callback = function() {
        runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      return lane;
    }
    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if (typeof getDerivedStateFromError === "function") {
        var error = errorInfo.value;
        update.payload = function() {
          return getDerivedStateFromError(error);
        };
        update.callback = function() {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      inst !== null && typeof inst.componentDidCatch === "function" && (update.callback = function() {
        markFailedErrorBoundaryForHotReloading(fiber);
        runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);
        typeof getDerivedStateFromError !== "function" && (legacyErrorBoundariesThatAlreadyFailed === null ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        callComponentDidCatchInDEV(this, errorInfo);
        typeof getDerivedStateFromError === "function" || (fiber.lanes & 2) === 0 && console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
      });
    }
    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
      sourceFiber.flags |= 32768;
      isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);
      if (value !== null && typeof value === "object" && typeof value.then === "function") {
        returnFiber = sourceFiber.alternate;
        returnFiber !== null && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, true);
        isHydrating && (didSuspendOrErrorDEV = true);
        sourceFiber = suspenseHandlerStackCursor.current;
        if (sourceFiber !== null) {
          switch (sourceFiber.tag) {
            case 31:
            case 13:
              return shellBoundary === null ? renderDidSuspendDelayIfPossible() : sourceFiber.alternate === null && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, returnFiber === null ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), false;
            case 22:
              return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, returnFiber === null ? (returnFiber = {
                transitions: null,
                markerInstances: null,
                retryQueue: new Set([value])
              }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, sourceFiber === null ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), false;
          }
          throw Error("Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React.");
        }
        attachPingListener(root, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return false;
      }
      if (isHydrating)
        return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, returnFiber !== null ? ((returnFiber.flags & 65536) === 0 && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.", { cause: value }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering the entire root.", { cause: value }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
      var error = createCapturedValueAtFiber(Error("There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.", { cause: value }), sourceFiber);
      workInProgressRootConcurrentErrors === null ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
      workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
      if (returnFiber === null)
        return true;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), false;
          case 1:
            if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, (sourceFiber.flags & 128) === 0 && (typeof returnFiber.getDerivedStateFromError === "function" || error !== null && typeof error.componentDidCatch === "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
              return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
        }
        sourceFiber = sourceFiber.return;
      } while (sourceFiber !== null);
      return false;
    }
    function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
      workInProgress2.child = current2 === null ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
    }
    function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
      Component = Component.render;
      var ref = workInProgress2.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          key !== "ref" && (propsWithoutRef[key] = nextProps[key]);
      } else
        propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress2);
      nextProps = renderWithHooks(current2, workInProgress2, Component, propsWithoutRef, ref, renderLanes2);
      key = checkDidRenderIdHook();
      if (current2 !== null && !didReceiveUpdate)
        return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      isHydrating && key && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (current2 === null) {
        var type = Component.type;
        if (typeof type === "function" && !shouldConstruct(type) && type.defaultProps === undefined && Component.compare === null)
          return Component = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
        current2 = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
        current2.ref = workInProgress2.ref;
        current2.return = workInProgress2;
        return workInProgress2.child = current2;
      }
      type = current2.child;
      if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
        var prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = Component !== null ? Component : shallowEqual;
        if (Component(prevProps, nextProps) && current2.ref === workInProgress2.ref)
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      workInProgress2.flags |= 1;
      current2 = createWorkInProgress(type, nextProps);
      current2.ref = workInProgress2.ref;
      current2.return = workInProgress2;
      return workInProgress2.child = current2;
    }
    function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (current2 !== null) {
        var prevProps = current2.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
          if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
            (current2.flags & 131072) !== 0 && (didReceiveUpdate = true);
          else
            return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
    }
    function updateOffscreenComponent(current2, workInProgress2, renderLanes2, nextProps) {
      var nextChildren = nextProps.children, prevState = current2 !== null ? current2.memoizedState : null;
      current2 === null && workInProgress2.stateNode === null && (workInProgress2.stateNode = {
        _visibility: OffscreenVisible,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      if (nextProps.mode === "hidden") {
        if ((workInProgress2.flags & 128) !== 0) {
          prevState = prevState !== null ? prevState.baseLanes | renderLanes2 : renderLanes2;
          if (current2 !== null) {
            nextProps = workInProgress2.child = current2.child;
            for (nextChildren = 0;nextProps !== null; )
              nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
            nextProps = nextChildren & ~prevState;
          } else
            nextProps = 0, workInProgress2.child = null;
          return deferHiddenOffscreenComponent(current2, workInProgress2, prevState, renderLanes2, nextProps);
        }
        if ((renderLanes2 & 536870912) !== 0)
          workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, current2 !== null && pushTransition(workInProgress2, prevState !== null ? prevState.cachePool : null), prevState !== null ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
        else
          return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(current2, workInProgress2, prevState !== null ? prevState.baseLanes | renderLanes2 : renderLanes2, renderLanes2, nextProps);
      } else
        prevState !== null ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (current2 !== null && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
      reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function bailoutOffscreenComponent(current2, workInProgress2) {
      current2 !== null && current2.tag === 22 || workInProgress2.stateNode !== null || (workInProgress2.stateNode = {
        _visibility: OffscreenVisible,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      return workInProgress2.sibling;
    }
    function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result = JSCompiler_inline_result === null ? null : {
        parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,
        pool: JSCompiler_inline_result
      };
      workInProgress2.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      current2 !== null && pushTransition(workInProgress2, null);
      reuseHiddenContextOnStack(workInProgress2);
      pushOffscreenSuspenseHandler(workInProgress2);
      current2 !== null && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
      workInProgress2.childLanes = remainingChildLanes;
      return null;
    }
    function mountActivityChildren(workInProgress2, nextProps) {
      var hiddenProp = nextProps.hidden;
      hiddenProp !== undefined && console.error(`<Activity> doesn't accept a hidden prop. Use mode="hidden" instead.
- <Activity %s>
+ <Activity %s>`, hiddenProp === true ? "hidden" : hiddenProp === false ? "hidden={false}" : "hidden={...}", hiddenProp ? 'mode="hidden"' : 'mode="visible"');
      nextProps = mountWorkInProgressOffscreenFiber({ mode: nextProps.mode, children: nextProps.children }, workInProgress2.mode);
      nextProps.ref = workInProgress2.ref;
      workInProgress2.child = nextProps;
      nextProps.return = workInProgress2;
      return nextProps;
    }
    function retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
      current2 = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
      current2.flags |= 2;
      popSuspenseHandler(workInProgress2);
      workInProgress2.memoizedState = null;
      return current2;
    }
    function updateActivityComponent(current2, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, didSuspend = (workInProgress2.flags & 128) !== 0;
      workInProgress2.flags &= -129;
      if (current2 === null) {
        if (isHydrating) {
          if (nextProps.mode === "hidden")
            return current2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current2);
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateActivityInstance(current2, rootOrSingletonContext), renderLanes2 !== null && (nextProps = {
            dehydrated: renderLanes2,
            treeContext: getSuspendedTreeContext(),
            retryLane: 536870912,
            hydrationErrors: null
          }, workInProgress2.memoizedState = nextProps, nextProps = createFiberFromDehydratedFragment(renderLanes2), nextProps.return = workInProgress2, workInProgress2.child = nextProps, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
          if (renderLanes2 === null)
            throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
          workInProgress2.lanes = 536870912;
          return null;
        }
        return mountActivityChildren(workInProgress2, nextProps);
      }
      var prevState = current2.memoizedState;
      if (prevState !== null) {
        var activityInstance = prevState.dehydrated;
        pushDehydratedActivitySuspenseHandler(workInProgress2);
        if (didSuspend)
          if (workInProgress2.flags & 256)
            workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
          else if (workInProgress2.memoizedState !== null)
            workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null;
          else
            throw Error("Client rendering an Activity suspended it again. This is a bug in React.");
        else if (warnIfHydrating(), (renderLanes2 & 536870912) !== 0 && markRenderDerivedCause(workInProgress2), didReceiveUpdate || propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), didSuspend = (renderLanes2 & current2.childLanes) !== 0, didReceiveUpdate || didSuspend) {
          nextProps = workInProgressRoot;
          if (nextProps !== null && (activityInstance = getBumpedLaneForHydration(nextProps, renderLanes2), activityInstance !== 0 && activityInstance !== prevState.retryLane))
            throw prevState.retryLane = activityInstance, enqueueConcurrentRenderForLane(current2, activityInstance), scheduleUpdateOnFiber(nextProps, current2, activityInstance), SelectiveHydrationException;
          renderDidSuspendDelayIfPossible();
          workInProgress2 = retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
        } else
          current2 = prevState.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinActivityInstance(activityInstance), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, current2 !== null && restoreSuspendedTreeContext(workInProgress2, current2)), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
        return workInProgress2;
      }
      prevState = current2.child;
      nextProps = { mode: nextProps.mode, children: nextProps.children };
      (renderLanes2 & 536870912) !== 0 && (renderLanes2 & current2.lanes) !== 0 && markRenderDerivedCause(workInProgress2);
      current2 = createWorkInProgress(prevState, nextProps);
      current2.ref = workInProgress2.ref;
      workInProgress2.child = current2;
      current2.return = workInProgress2;
      return current2;
    }
    function markRef(current2, workInProgress2) {
      var ref = workInProgress2.ref;
      if (ref === null)
        current2 !== null && current2.ref !== null && (workInProgress2.flags |= 4194816);
      else {
        if (typeof ref !== "function" && typeof ref !== "object")
          throw Error("Expected ref to be a function, an object returned by React.createRef(), or undefined/null.");
        if (current2 === null || current2.ref !== ref)
          workInProgress2.flags |= 4194816;
      }
    }
    function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (Component.prototype && typeof Component.prototype.render === "function") {
        var componentName2 = getComponentNameFromType(Component) || "Unknown";
        didWarnAboutBadClass[componentName2] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName2, componentName2), didWarnAboutBadClass[componentName2] = true);
      }
      workInProgress2.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
      current2 === null && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component.contextTypes && (componentName2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", componentName2))));
      prepareToReadContext(workInProgress2);
      Component = renderWithHooks(current2, workInProgress2, Component, nextProps, undefined, renderLanes2);
      nextProps = checkDidRenderIdHook();
      if (current2 !== null && !didReceiveUpdate)
        return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current2, workInProgress2, Component, renderLanes2);
      return workInProgress2.child;
    }
    function replayFunctionComponent(current2, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
      prepareToReadContext(workInProgress2);
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
      workInProgress2.updateQueue = null;
      nextProps = renderWithHooksAgain(workInProgress2, Component, nextProps, secondArg);
      finishRenderingHooks(current2, workInProgress2);
      Component = checkDidRenderIdHook();
      if (current2 !== null && !didReceiveUpdate)
        return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      isHydrating && Component && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      switch (shouldErrorImpl(workInProgress2)) {
        case false:
          var _instance = workInProgress2.stateNode, state = new workInProgress2.type(workInProgress2.memoizedProps, _instance.context).state;
          _instance.updater.enqueueSetState(_instance, state, null);
          break;
        case true:
          workInProgress2.flags |= 128;
          workInProgress2.flags |= 65536;
          _instance = Error("Simulated error coming from DevTools");
          var lane = renderLanes2 & -renderLanes2;
          workInProgress2.lanes |= lane;
          state = workInProgressRoot;
          if (state === null)
            throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          lane = createClassErrorUpdate(lane);
          initializeClassErrorUpdate(lane, state, workInProgress2, createCapturedValueAtFiber(_instance, workInProgress2));
          enqueueCapturedUpdate(workInProgress2, lane);
      }
      prepareToReadContext(workInProgress2);
      if (workInProgress2.stateNode === null) {
        state = emptyContextObject;
        _instance = Component.contextType;
        "contextType" in Component && _instance !== null && (_instance === undefined || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = _instance === undefined ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof _instance !== "object" ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(Component) || "Component", lane));
        typeof _instance === "object" && _instance !== null && (state = readContext(_instance));
        _instance = new Component(nextProps, state);
        if (workInProgress2.mode & 8) {
          setIsStrictModeForDevtools(true);
          try {
            _instance = new Component(nextProps, state);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        state = workInProgress2.memoizedState = _instance.state !== null && _instance.state !== undefined ? _instance.state : null;
        _instance.updater = classComponentUpdater;
        workInProgress2.stateNode = _instance;
        _instance._reactInternals = workInProgress2;
        _instance._reactInternalInstance = fakeInternalInstance;
        typeof Component.getDerivedStateFromProps === "function" && state === null && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", state, _instance.state === null ? "null" : "undefined", state)));
        if (typeof Component.getDerivedStateFromProps === "function" || typeof _instance.getSnapshotBeforeUpdate === "function") {
          var foundWillUpdateName = lane = state = null;
          typeof _instance.componentWillMount === "function" && _instance.componentWillMount.__suppressDeprecationWarning !== true ? state = "componentWillMount" : typeof _instance.UNSAFE_componentWillMount === "function" && (state = "UNSAFE_componentWillMount");
          typeof _instance.componentWillReceiveProps === "function" && _instance.componentWillReceiveProps.__suppressDeprecationWarning !== true ? lane = "componentWillReceiveProps" : typeof _instance.UNSAFE_componentWillReceiveProps === "function" && (lane = "UNSAFE_componentWillReceiveProps");
          typeof _instance.componentWillUpdate === "function" && _instance.componentWillUpdate.__suppressDeprecationWarning !== true ? foundWillUpdateName = "componentWillUpdate" : typeof _instance.UNSAFE_componentWillUpdate === "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
          if (state !== null || lane !== null || foundWillUpdateName !== null) {
            _instance = getComponentNameFromType(Component) || "Component";
            var newApiName = typeof Component.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`, _instance, newApiName, state !== null ? `
  ` + state : "", lane !== null ? `
  ` + lane : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
          }
        }
        _instance = workInProgress2.stateNode;
        state = getComponentNameFromType(Component) || "Component";
        _instance.render || (Component.prototype && typeof Component.prototype.render === "function" ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", state) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", state));
        !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", state);
        _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", state);
        _instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", state);
        Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", state));
        Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", state));
        typeof _instance.componentShouldUpdate === "function" && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", state);
        Component.prototype && Component.prototype.isPureReactComponent && typeof _instance.shouldComponentUpdate !== "undefined" && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(Component) || "A pure component");
        typeof _instance.componentDidUnmount === "function" && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", state);
        typeof _instance.componentDidReceiveProps === "function" && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", state);
        typeof _instance.componentWillRecieveProps === "function" && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", state);
        typeof _instance.UNSAFE_componentWillRecieveProps === "function" && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", state);
        lane = _instance.props !== nextProps;
        _instance.props !== undefined && lane && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", state);
        _instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", state, state);
        typeof _instance.getSnapshotBeforeUpdate !== "function" || typeof _instance.componentDidUpdate === "function" || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(Component)));
        typeof _instance.getDerivedStateFromProps === "function" && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
        typeof _instance.getDerivedStateFromError === "function" && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
        typeof Component.getSnapshotBeforeUpdate === "function" && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", state);
        (lane = _instance.state) && (typeof lane !== "object" || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
        typeof _instance.getChildContext === "function" && typeof Component.childContextTypes !== "object" && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", state);
        _instance = workInProgress2.stateNode;
        _instance.props = nextProps;
        _instance.state = workInProgress2.memoizedState;
        _instance.refs = {};
        initializeUpdateQueue(workInProgress2);
        state = Component.contextType;
        _instance.context = typeof state === "object" && state !== null ? readContext(state) : emptyContextObject;
        _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", state)));
        workInProgress2.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, _instance);
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, _instance);
        _instance.state = workInProgress2.memoizedState;
        state = Component.getDerivedStateFromProps;
        typeof state === "function" && (applyDerivedStateFromProps(workInProgress2, Component, state, nextProps), _instance.state = workInProgress2.memoizedState);
        typeof Component.getDerivedStateFromProps === "function" || typeof _instance.getSnapshotBeforeUpdate === "function" || typeof _instance.UNSAFE_componentWillMount !== "function" && typeof _instance.componentWillMount !== "function" || (state = _instance.state, typeof _instance.componentWillMount === "function" && _instance.componentWillMount(), typeof _instance.UNSAFE_componentWillMount === "function" && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
        typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4194308);
        (workInProgress2.mode & 16) !== NoMode && (workInProgress2.flags |= 134217728);
        _instance = true;
      } else if (current2 === null) {
        _instance = workInProgress2.stateNode;
        var unresolvedOldProps = workInProgress2.memoizedProps;
        lane = resolveClassComponentProps(Component, unresolvedOldProps);
        _instance.props = lane;
        var oldContext = _instance.context;
        foundWillUpdateName = Component.contextType;
        state = emptyContextObject;
        typeof foundWillUpdateName === "object" && foundWillUpdateName !== null && (state = readContext(foundWillUpdateName));
        newApiName = Component.getDerivedStateFromProps;
        foundWillUpdateName = typeof newApiName === "function" || typeof _instance.getSnapshotBeforeUpdate === "function";
        unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
        foundWillUpdateName || typeof _instance.UNSAFE_componentWillReceiveProps !== "function" && typeof _instance.componentWillReceiveProps !== "function" || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress2, _instance, nextProps, state);
        hasForceUpdate = false;
        var oldState = workInProgress2.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress2.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? (typeof newApiName === "function" && (applyDerivedStateFromProps(workInProgress2, Component, newApiName, nextProps), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress2, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || typeof _instance.UNSAFE_componentWillMount !== "function" && typeof _instance.componentWillMount !== "function" || (typeof _instance.componentWillMount === "function" && _instance.componentWillMount(), typeof _instance.UNSAFE_componentWillMount === "function" && _instance.UNSAFE_componentWillMount()), typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4194308), (workInProgress2.mode & 16) !== NoMode && (workInProgress2.flags |= 134217728)) : (typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4194308), (workInProgress2.mode & 16) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : (typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4194308), (workInProgress2.mode & 16) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
      } else {
        _instance = workInProgress2.stateNode;
        cloneUpdateQueue(current2, workInProgress2);
        state = workInProgress2.memoizedProps;
        foundWillUpdateName = resolveClassComponentProps(Component, state);
        _instance.props = foundWillUpdateName;
        newApiName = workInProgress2.pendingProps;
        oldState = _instance.context;
        oldContext = Component.contextType;
        lane = emptyContextObject;
        typeof oldContext === "object" && oldContext !== null && (lane = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext = typeof unresolvedOldProps === "function" || typeof _instance.getSnapshotBeforeUpdate === "function") || typeof _instance.UNSAFE_componentWillReceiveProps !== "function" && typeof _instance.componentWillReceiveProps !== "function" || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress2, _instance, nextProps, lane);
        hasForceUpdate = false;
        oldState = workInProgress2.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress2.memoizedState;
        state !== newApiName || oldState !== newState || hasForceUpdate || current2 !== null && current2.dependencies !== null && checkIfContextChanged(current2.dependencies) ? (typeof unresolvedOldProps === "function" && (applyDerivedStateFromProps(workInProgress2, Component, unresolvedOldProps, nextProps), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress2, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || current2 !== null && current2.dependencies !== null && checkIfContextChanged(current2.dependencies)) ? (oldContext || typeof _instance.UNSAFE_componentWillUpdate !== "function" && typeof _instance.componentWillUpdate !== "function" || (typeof _instance.componentWillUpdate === "function" && _instance.componentWillUpdate(nextProps, newState, lane), typeof _instance.UNSAFE_componentWillUpdate === "function" && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), typeof _instance.componentDidUpdate === "function" && (workInProgress2.flags |= 4), typeof _instance.getSnapshotBeforeUpdate === "function" && (workInProgress2.flags |= 1024)) : (typeof _instance.componentDidUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), typeof _instance.getSnapshotBeforeUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : (typeof _instance.componentDidUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), typeof _instance.getSnapshotBeforeUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
      }
      lane = _instance;
      markRef(current2, workInProgress2);
      state = (workInProgress2.flags & 128) !== 0;
      if (lane || state) {
        lane = workInProgress2.stateNode;
        setCurrentFiber(workInProgress2);
        if (state && typeof Component.getDerivedStateFromError !== "function")
          Component = null, profilerStartTime = -1;
        else if (Component = callRenderInDEV(lane), workInProgress2.mode & 8) {
          setIsStrictModeForDevtools(true);
          try {
            callRenderInDEV(lane);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        workInProgress2.flags |= 1;
        current2 !== null && state ? (workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2), workInProgress2.child = reconcileChildFibers(workInProgress2, null, Component, renderLanes2)) : reconcileChildren(current2, workInProgress2, Component, renderLanes2);
        workInProgress2.memoizedState = lane.state;
        current2 = workInProgress2.child;
      } else
        current2 = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      renderLanes2 = workInProgress2.stateNode;
      _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component"), didWarnAboutReassigningProps = true);
      return current2;
    }
    function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
      resetHydrationState();
      workInProgress2.flags |= 256;
      reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function validateFunctionComponentInDev(workInProgress2, Component) {
      Component && Component.childContextTypes && console.error(`childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`, Component.displayName || Component.name || "Component");
      typeof Component.getDerivedStateFromProps === "function" && (workInProgress2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error("%s: Function components do not support getDerivedStateFromProps.", workInProgress2), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
      typeof Component.contextType === "object" && Component.contextType !== null && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error("%s: Function components do not support contextType.", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = true));
    }
    function mountSuspenseOffscreenState(renderLanes2) {
      return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
      current2 = current2 !== null ? current2.childLanes & ~renderLanes2 : 0;
      primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
      return current2;
    }
    function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps;
      shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
      var showFallback = false, didSuspend = (workInProgress2.flags & 128) !== 0, JSCompiler_temp;
      (JSCompiler_temp = didSuspend) || (JSCompiler_temp = current2 !== null && current2.memoizedState === null ? false : (suspenseStackCursor.current & ForceSuspenseFallback) !== 0);
      JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
      JSCompiler_temp = (workInProgress2.flags & 32) !== 0;
      workInProgress2.flags &= -33;
      if (current2 === null) {
        if (isHydrating) {
          showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
          (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateSuspenseInstance(current2, rootOrSingletonContext), renderLanes2 !== null && (JSCompiler_temp = {
            dehydrated: renderLanes2,
            treeContext: getSuspendedTreeContext(),
            retryLane: 536870912,
            hydrationErrors: null
          }, workInProgress2.memoizedState = JSCompiler_temp, JSCompiler_temp = createFiberFromDehydratedFragment(renderLanes2), JSCompiler_temp.return = workInProgress2, workInProgress2.child = JSCompiler_temp, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
          if (renderLanes2 === null)
            throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
          isSuspenseInstanceFallback(renderLanes2) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
          return null;
        }
        var nextPrimaryChildren = nextProps.children;
        nextProps = nextProps.fallback;
        if (showFallback)
          return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber({ mode: "hidden", children: nextPrimaryChildren }, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes2, null), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(current2, JSCompiler_temp, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
      }
      var prevState = current2.memoizedState;
      if (prevState !== null && (nextPrimaryChildren = prevState.dehydrated, nextPrimaryChildren !== null)) {
        if (didSuspend)
          workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2)) : workInProgress2.memoizedState !== null ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber({ mode: "visible", children: nextProps.children }, showFallback), nextPrimaryChildren = createFiberFromFragment(nextPrimaryChildren, showFallback, renderLanes2, null), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(current2, JSCompiler_temp, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
        else if (pushPrimaryTreeSuspenseHandler(workInProgress2), warnIfHydrating(), (renderLanes2 & 536870912) !== 0 && markRenderDerivedCause(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren))
          showFallback = getSuspenseInstanceFallbackErrorDetails(nextPrimaryChildren), JSCompiler_temp = showFallback.digest, nextPrimaryChildren = showFallback.message, nextProps = showFallback.stack, showFallback = showFallback.componentStack, nextPrimaryChildren = nextPrimaryChildren ? Error(nextPrimaryChildren) : Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."), nextPrimaryChildren.stack = nextProps || "", nextPrimaryChildren.digest = JSCompiler_temp, JSCompiler_temp = showFallback === undefined ? null : showFallback, nextProps = {
            value: nextPrimaryChildren,
            source: null,
            stack: JSCompiler_temp
          }, typeof JSCompiler_temp === "string" && CapturedStacks.set(nextPrimaryChildren, nextProps), queueHydrationError(nextProps), workInProgress2 = retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
        else if (didReceiveUpdate || propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), JSCompiler_temp = (renderLanes2 & current2.childLanes) !== 0, didReceiveUpdate || JSCompiler_temp) {
          JSCompiler_temp = workInProgressRoot;
          if (JSCompiler_temp !== null && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), nextProps !== 0 && nextProps !== prevState.retryLane))
            throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current2, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current2, nextProps), SelectiveHydrationException;
          isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
          workInProgress2 = retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
        } else
          isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(nextPrimaryChildren), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, current2 !== null && restoreSuspendedTreeContext(workInProgress2, current2)), workInProgress2 = mountSuspensePrimaryChildren(workInProgress2, nextProps.children), workInProgress2.flags |= 4096);
        return workInProgress2;
      }
      if (showFallback)
        return reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current2.child, didSuspend = prevState.sibling, nextProps = createWorkInProgress(prevState, {
          mode: "hidden",
          children: nextProps.children
        }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, didSuspend !== null ? nextPrimaryChildren = createWorkInProgress(didSuspend, nextPrimaryChildren) : (nextPrimaryChildren = createFiberFromFragment(nextPrimaryChildren, showFallback, renderLanes2, null), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current2.child.memoizedState, nextPrimaryChildren === null ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, showFallback !== null ? (prevState = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
          baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
          cachePool: showFallback
        }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(current2, JSCompiler_temp, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current2.child, nextProps);
      prevState !== null && (renderLanes2 & 62914560) === renderLanes2 && (renderLanes2 & current2.lanes) !== 0 && markRenderDerivedCause(workInProgress2);
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      renderLanes2 = current2.child;
      current2 = renderLanes2.sibling;
      renderLanes2 = createWorkInProgress(renderLanes2, {
        mode: "visible",
        children: nextProps.children
      });
      renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
      current2 !== null && (JSCompiler_temp = workInProgress2.deletions, JSCompiler_temp === null ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_temp.push(current2));
      workInProgress2.child = renderLanes2;
      workInProgress2.memoizedState = null;
      return renderLanes2;
    }
    function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber({ mode: "visible", children: primaryChildren }, workInProgress2.mode);
      primaryChildren.return = workInProgress2;
      return workInProgress2.child = primaryChildren;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiber(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      return offscreenProps;
    }
    function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
      current2 = mountSuspensePrimaryChildren(workInProgress2, workInProgress2.pendingProps.children);
      current2.flags |= 2;
      workInProgress2.memoizedState = null;
      return current2;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
      fiber.lanes |= renderLanes2;
      var alternate = fiber.alternate;
      alternate !== null && (alternate.lanes |= renderLanes2);
      scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
    }
    function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
      var renderState = workInProgress2.memoizedState;
      renderState === null ? workInProgress2.memoizedState = {
        isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail,
        tailMode,
        treeForkCount: treeForkCount2
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
    }
    function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail, newChildren = nextProps.children, suspenseContext = suspenseStackCursor.current;
      (nextProps = (suspenseContext & ForceSuspenseFallback) !== 0) ? (suspenseContext = suspenseContext & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128) : suspenseContext &= SubtreeSuspenseContextMask;
      push(suspenseStackCursor, suspenseContext, workInProgress2);
      suspenseContext = revealOrder == null ? "null" : revealOrder;
      if (revealOrder !== "forwards" && revealOrder !== "unstable_legacy-backwards" && revealOrder !== "together" && revealOrder !== "independent" && !didWarnAboutRevealOrder[suspenseContext])
        if (didWarnAboutRevealOrder[suspenseContext] = true, revealOrder == null)
          console.error('The default for the <SuspenseList revealOrder="..."> prop is changing. To be future compatible you must explictly specify either "independent" (the current default), "together", "forwards" or "legacy_unstable-backwards".');
        else if (revealOrder === "backwards")
          console.error('The rendering order of <SuspenseList revealOrder="backwards"> is changing. To be future compatible you must specify revealOrder="legacy_unstable-backwards" instead.');
        else if (typeof revealOrder === "string")
          switch (revealOrder.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards":
            case "independent":
              console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
              break;
            case "forward":
            case "backward":
              console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
              break;
            default:
              console.error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?', revealOrder);
          }
        else
          console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?', revealOrder);
      suspenseContext = tailMode == null ? "null" : tailMode;
      if (!didWarnAboutTailOptions[suspenseContext])
        if (tailMode == null) {
          if (revealOrder === "forwards" || revealOrder === "backwards" || revealOrder === "unstable_legacy-backwards")
            didWarnAboutTailOptions[suspenseContext] = true, console.error('The default for the <SuspenseList tail="..."> prop is changing. To be future compatible you must explictly specify either "visible" (the current default), "collapsed" or "hidden".');
        } else
          tailMode !== "visible" && tailMode !== "collapsed" && tailMode !== "hidden" ? (didWarnAboutTailOptions[suspenseContext] = true, console.error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "visible", "collapsed" or "hidden"?', tailMode)) : revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "unstable_legacy-backwards" && (didWarnAboutTailOptions[suspenseContext] = true, console.error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode));
      a:
        if ((revealOrder === "forwards" || revealOrder === "backwards" || revealOrder === "unstable_legacy-backwards") && newChildren !== undefined && newChildren !== null && newChildren !== false)
          if (isArrayImpl(newChildren))
            for (suspenseContext = 0;suspenseContext < newChildren.length; suspenseContext++) {
              if (!validateSuspenseListNestedChild(newChildren[suspenseContext], suspenseContext))
                break a;
            }
          else if (suspenseContext = getIteratorFn(newChildren), typeof suspenseContext === "function") {
            if (suspenseContext = suspenseContext.call(newChildren))
              for (var step = suspenseContext.next(), _i = 0;!step.done; step = suspenseContext.next()) {
                if (!validateSuspenseListNestedChild(step.value, _i))
                  break a;
                _i++;
              }
          } else
            console.error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
      reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
      isHydrating ? (warnIfNotHydrating(), newChildren = treeForkCount) : newChildren = 0;
      if (!nextProps && current2 !== null && (current2.flags & 128) !== 0)
        a:
          for (current2 = workInProgress2.child;current2 !== null; ) {
            if (current2.tag === 13)
              current2.memoizedState !== null && scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
            else if (current2.tag === 19)
              scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
            else if (current2.child !== null) {
              current2.child.return = current2;
              current2 = current2.child;
              continue;
            }
            if (current2 === workInProgress2)
              break a;
            for (;current2.sibling === null; ) {
              if (current2.return === null || current2.return === workInProgress2)
                break a;
              current2 = current2.return;
            }
            current2.sibling.return = current2.return;
            current2 = current2.sibling;
          }
      switch (revealOrder) {
        case "forwards":
          renderLanes2 = workInProgress2.child;
          for (revealOrder = null;renderLanes2 !== null; )
            current2 = renderLanes2.alternate, current2 !== null && findFirstSuspended(current2) === null && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
          renderLanes2 = revealOrder;
          renderLanes2 === null ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
          initSuspenseListRenderState(workInProgress2, false, revealOrder, renderLanes2, tailMode, newChildren);
          break;
        case "backwards":
        case "unstable_legacy-backwards":
          renderLanes2 = null;
          revealOrder = workInProgress2.child;
          for (workInProgress2.child = null;revealOrder !== null; ) {
            current2 = revealOrder.alternate;
            if (current2 !== null && findFirstSuspended(current2) === null) {
              workInProgress2.child = revealOrder;
              break;
            }
            current2 = revealOrder.sibling;
            revealOrder.sibling = renderLanes2;
            renderLanes2 = revealOrder;
            revealOrder = current2;
          }
          initSuspenseListRenderState(workInProgress2, true, renderLanes2, null, tailMode, newChildren);
          break;
        case "together":
          initSuspenseListRenderState(workInProgress2, false, null, null, undefined, newChildren);
          break;
        default:
          workInProgress2.memoizedState = null;
      }
      return workInProgress2.child;
    }
    function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
      current2 !== null && (workInProgress2.dependencies = current2.dependencies);
      profilerStartTime = -1;
      workInProgressRootSkippedLanes |= workInProgress2.lanes;
      if ((renderLanes2 & workInProgress2.childLanes) === 0)
        if (current2 !== null) {
          if (propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), (renderLanes2 & workInProgress2.childLanes) === 0)
            return null;
        } else
          return null;
      if (current2 !== null && workInProgress2.child !== current2.child)
        throw Error("Resuming work not yet implemented.");
      if (workInProgress2.child !== null) {
        current2 = workInProgress2.child;
        renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
        workInProgress2.child = renderLanes2;
        for (renderLanes2.return = workInProgress2;current2.sibling !== null; )
          current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
      }
      return workInProgress2.child;
    }
    function checkScheduledUpdateOrContext(current2, renderLanes2) {
      if ((current2.lanes & renderLanes2) !== 0)
        return true;
      current2 = current2.dependencies;
      return current2 !== null && checkIfContextChanged(current2) ? true : false;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
      switch (workInProgress2.tag) {
        case 3:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          pushProvider(workInProgress2, CacheContext, current2.memoizedState.cache);
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress2);
          break;
        case 4:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          break;
        case 10:
          pushProvider(workInProgress2, workInProgress2.type, workInProgress2.memoizedProps.value);
          break;
        case 12:
          (renderLanes2 & workInProgress2.childLanes) !== 0 && (workInProgress2.flags |= 4);
          workInProgress2.flags |= 2048;
          var stateNode = workInProgress2.stateNode;
          stateNode.effectDuration = -0;
          stateNode.passiveEffectDuration = -0;
          break;
        case 31:
          if (workInProgress2.memoizedState !== null)
            return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
          break;
        case 13:
          stateNode = workInProgress2.memoizedState;
          if (stateNode !== null) {
            if (stateNode.dehydrated !== null)
              return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
            if ((renderLanes2 & workInProgress2.child.childLanes) !== 0)
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            current2 = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            return current2 !== null ? current2.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          break;
        case 19:
          var didSuspendBefore = (current2.flags & 128) !== 0;
          stateNode = (renderLanes2 & workInProgress2.childLanes) !== 0;
          stateNode || (propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), stateNode = (renderLanes2 & workInProgress2.childLanes) !== 0);
          if (didSuspendBefore) {
            if (stateNode)
              return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
            workInProgress2.flags |= 128;
          }
          didSuspendBefore = workInProgress2.memoizedState;
          didSuspendBefore !== null && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
          push(suspenseStackCursor, suspenseStackCursor.current, workInProgress2);
          if (stateNode)
            break;
          else
            return null;
        case 22:
          return workInProgress2.lanes = 0, updateOffscreenComponent(current2, workInProgress2, renderLanes2, workInProgress2.pendingProps);
        case 24:
          pushProvider(workInProgress2, CacheContext, current2.memoizedState.cache);
      }
      return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
    }
    function beginWork(current2, workInProgress2, renderLanes2) {
      if (workInProgress2._debugNeedsRemount && current2 !== null) {
        renderLanes2 = createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes);
        renderLanes2._debugStack = workInProgress2._debugStack;
        renderLanes2._debugTask = workInProgress2._debugTask;
        var returnFiber = workInProgress2.return;
        if (returnFiber === null)
          throw Error("Cannot swap the root fiber.");
        current2.alternate = null;
        workInProgress2.alternate = null;
        renderLanes2.index = workInProgress2.index;
        renderLanes2.sibling = workInProgress2.sibling;
        renderLanes2.return = workInProgress2.return;
        renderLanes2.ref = workInProgress2.ref;
        renderLanes2._debugInfo = workInProgress2._debugInfo;
        if (workInProgress2 === returnFiber.child)
          returnFiber.child = renderLanes2;
        else {
          var prevSibling = returnFiber.child;
          if (prevSibling === null)
            throw Error("Expected parent to have a child.");
          for (;prevSibling.sibling !== workInProgress2; )
            if (prevSibling = prevSibling.sibling, prevSibling === null)
              throw Error("Expected to find the previous sibling.");
          prevSibling.sibling = renderLanes2;
        }
        workInProgress2 = returnFiber.deletions;
        workInProgress2 === null ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
        renderLanes2.flags |= 2;
        return renderLanes2;
      }
      if (current2 !== null)
        if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
          didReceiveUpdate = true;
        else {
          if (!checkScheduledUpdateOrContext(current2, renderLanes2) && (workInProgress2.flags & 128) === 0)
            return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
          didReceiveUpdate = (current2.flags & 131072) !== 0 ? true : false;
        }
      else {
        didReceiveUpdate = false;
        if (returnFiber = isHydrating)
          warnIfNotHydrating(), returnFiber = (workInProgress2.flags & 1048576) !== 0;
        returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
      }
      workInProgress2.lanes = 0;
      switch (workInProgress2.tag) {
        case 16:
          a:
            if (returnFiber = workInProgress2.pendingProps, current2 = resolveLazy(workInProgress2.elementType), workInProgress2.type = current2, typeof current2 === "function")
              shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(current2, returnFiber), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(null, workInProgress2, current2, returnFiber, renderLanes2)) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(null, workInProgress2, current2, returnFiber, renderLanes2));
            else {
              if (current2 !== undefined && current2 !== null) {
                if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                  workInProgress2.tag = 11;
                  workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                  workInProgress2 = updateForwardRef(null, workInProgress2, current2, returnFiber, renderLanes2);
                  break a;
                } else if (prevSibling === REACT_MEMO_TYPE) {
                  workInProgress2.tag = 14;
                  workInProgress2 = updateMemoComponent(null, workInProgress2, current2, returnFiber, renderLanes2);
                  break a;
                }
              }
              workInProgress2 = "";
              current2 !== null && typeof current2 === "object" && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
              current2 = getComponentNameFromType(current2) || current2;
              throw Error("Element type is invalid. Received a promise that resolves to: " + current2 + ". Lazy element type must resolve to a class or function." + workInProgress2);
            }
          return workInProgress2;
        case 0:
          return updateFunctionComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        case 1:
          return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress2.pendingProps), updateClassComponent(current2, workInProgress2, returnFiber, prevSibling, renderLanes2);
        case 3:
          a: {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            if (current2 === null)
              throw Error("Should have a current fiber. This is a bug in React.");
            var nextProps = workInProgress2.pendingProps;
            prevSibling = workInProgress2.memoizedState;
            returnFiber = prevSibling.element;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            nextProps = nextState.cache;
            pushProvider(workInProgress2, CacheContext, nextProps);
            nextProps !== prevSibling.cache && propagateContextChanges(workInProgress2, [CacheContext], renderLanes2, true);
            suspendIfUpdateReadFromEntangledAsyncAction();
            nextProps = nextState.element;
            if (supportsHydration && prevSibling.isDehydrated)
              if (prevSibling = {
                element: nextProps,
                isDehydrated: false,
                cache: nextState.cache
              }, workInProgress2.updateQueue.baseState = prevSibling, workInProgress2.memoizedState = prevSibling, workInProgress2.flags & 256) {
                workInProgress2 = mountHostRootWithoutHydrating(current2, workInProgress2, nextProps, renderLanes2);
                break a;
              } else if (nextProps !== returnFiber) {
                returnFiber = createCapturedValueAtFiber(Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
                queueHydrationError(returnFiber);
                workInProgress2 = mountHostRootWithoutHydrating(current2, workInProgress2, nextProps, renderLanes2);
                break a;
              } else
                for (supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinContainer(workInProgress2.stateNode.containerInfo), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = true), current2 = mountChildFibers(workInProgress2, null, nextProps, renderLanes2), workInProgress2.child = current2;current2; )
                  current2.flags = current2.flags & -3 | 4096, current2 = current2.sibling;
            else {
              resetHydrationState();
              if (nextProps === returnFiber) {
                workInProgress2 = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                break a;
              }
              reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
            }
            workInProgress2 = workInProgress2.child;
          }
          return workInProgress2;
        case 26:
          if (supportsResources)
            return markRef(current2, workInProgress2), current2 === null ? (current2 = getResource(workInProgress2.type, null, workInProgress2.pendingProps, null)) ? workInProgress2.memoizedState = current2 : isHydrating || (workInProgress2.stateNode = createHoistableInstance(workInProgress2.type, workInProgress2.pendingProps, requiredContext(rootInstanceStackCursor.current), workInProgress2)) : workInProgress2.memoizedState = getResource(workInProgress2.type, current2.memoizedProps, workInProgress2.pendingProps, current2.memoizedState), null;
        case 27:
          if (supportsSingletons)
            return pushHostContext(workInProgress2), current2 === null && supportsSingletons && isHydrating && (prevSibling = requiredContext(rootInstanceStackCursor.current), returnFiber = getHostContext(), prevSibling = workInProgress2.stateNode = resolveSingletonInstance(workInProgress2.type, workInProgress2.pendingProps, prevSibling, returnFiber, false), didSuspendOrErrorDEV || (returnFiber = diffHydratedPropsForDevWarnings(prevSibling, workInProgress2.type, workInProgress2.pendingProps, returnFiber), returnFiber !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, nextHydratableInstance = getFirstHydratableChildWithinSingleton(workInProgress2.type, prevSibling, nextHydratableInstance)), reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), markRef(current2, workInProgress2), current2 === null && (workInProgress2.flags |= 4194304), workInProgress2.child;
        case 5:
          return current2 === null && isHydrating && (nextProps = getHostContext(), returnFiber = validateHydratableInstance(workInProgress2.type, workInProgress2.pendingProps, nextProps), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress2.type, workInProgress2.pendingProps, rootOrSingletonContext), nextState !== null ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedPropsForDevWarnings(nextState, workInProgress2.type, workInProgress2.pendingProps, nextProps), nextProps !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getFirstHydratableChild(nextState), rootOrSingletonContext = false, nextProps = true) : nextProps = false, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, nextProps = workInProgress2.pendingProps, nextState = current2 !== null ? current2.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : nextState !== null && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), workInProgress2.memoizedState !== null && (prevSibling = renderWithHooks(current2, workInProgress2, TransitionAwareHostComponent, null, null, renderLanes2), isPrimaryRenderer ? HostTransitionContext._currentValue = prevSibling : HostTransitionContext._currentValue2 = prevSibling), markRef(current2, workInProgress2), reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2), workInProgress2.child;
        case 6:
          return current2 === null && isHydrating && (current2 = workInProgress2.pendingProps, renderLanes2 = getHostContext(), current2 = validateHydratableTextInstance(current2, renderLanes2), renderLanes2 = nextHydratableInstance, (returnFiber = !renderLanes2) || (returnFiber = canHydrateTextInstance(renderLanes2, workInProgress2.pendingProps, rootOrSingletonContext), returnFiber !== null ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (current2 && warnNonHydratedInstance(workInProgress2, renderLanes2), throwOnHydrationMismatch(workInProgress2))), null;
        case 13:
          return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
        case 4:
          return pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo), returnFiber = workInProgress2.pendingProps, current2 === null ? workInProgress2.child = reconcileChildFibers(workInProgress2, null, returnFiber, renderLanes2) : reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2), workInProgress2.child;
        case 11:
          return updateForwardRef(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        case 7:
          return reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps, renderLanes2), workInProgress2.child;
        case 8:
          return reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), workInProgress2.child;
        case 12:
          return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), workInProgress2.child;
        case 10:
          return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, nextProps = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")), pushProvider(workInProgress2, returnFiber, nextProps), reconcileChildren(current2, workInProgress2, prevSibling.children, renderLanes2), workInProgress2.child;
        case 9:
          return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, typeof returnFiber !== "function" && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), returnFiber = callComponentInDEV(returnFiber, prevSibling, undefined), workInProgress2.flags |= 1, reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2), workInProgress2.child;
        case 14:
          return updateMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        case 15:
          return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        case 19:
          return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
        case 31:
          return updateActivityComponent(current2, workInProgress2, renderLanes2);
        case 22:
          return updateOffscreenComponent(current2, workInProgress2, renderLanes2, workInProgress2.pendingProps);
        case 24:
          return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), current2 === null ? (prevSibling = peekCacheFromPool(), prevSibling === null && (prevSibling = workInProgressRoot, nextProps = createCache(), prevSibling.pooledCache = nextProps, retainCache(nextProps), nextProps !== null && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = nextProps), workInProgress2.memoizedState = {
            parent: returnFiber,
            cache: prevSibling
          }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : ((current2.lanes & renderLanes2) !== 0 && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, nextProps = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
            parent: returnFiber,
            cache: returnFiber
          }, workInProgress2.memoizedState = prevSibling, workInProgress2.lanes === 0 && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress2, [CacheContext], renderLanes2, true))), reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), workInProgress2.child;
        case 29:
          throw workInProgress2.pendingProps;
      }
      throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function markUpdate(workInProgress2) {
      workInProgress2.flags |= 4;
    }
    function markCloned(workInProgress2) {
      supportsPersistence && (workInProgress2.flags |= 8);
    }
    function doesRequireClone(current2, completedWork) {
      if (current2 !== null && current2.child === completedWork.child)
        return false;
      if ((completedWork.flags & 16) !== 0)
        return true;
      for (current2 = completedWork.child;current2 !== null; ) {
        if ((current2.flags & 8218) !== 0 || (current2.subtreeFlags & 8218) !== 0)
          return true;
        current2 = current2.sibling;
      }
      return false;
    }
    function appendAllChildren(parent, workInProgress2, needsVisibilityToggle, isHidden) {
      if (supportsMutation)
        for (needsVisibilityToggle = workInProgress2.child;needsVisibilityToggle !== null; ) {
          if (needsVisibilityToggle.tag === 5 || needsVisibilityToggle.tag === 6)
            appendInitialChild(parent, needsVisibilityToggle.stateNode);
          else if (!(needsVisibilityToggle.tag === 4 || supportsSingletons && needsVisibilityToggle.tag === 27) && needsVisibilityToggle.child !== null) {
            needsVisibilityToggle.child.return = needsVisibilityToggle;
            needsVisibilityToggle = needsVisibilityToggle.child;
            continue;
          }
          if (needsVisibilityToggle === workInProgress2)
            break;
          for (;needsVisibilityToggle.sibling === null; ) {
            if (needsVisibilityToggle.return === null || needsVisibilityToggle.return === workInProgress2)
              return;
            needsVisibilityToggle = needsVisibilityToggle.return;
          }
          needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;
          needsVisibilityToggle = needsVisibilityToggle.sibling;
        }
      else if (supportsPersistence)
        for (var _node = workInProgress2.child;_node !== null; ) {
          if (_node.tag === 5) {
            var instance = _node.stateNode;
            needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, _node.type, _node.memoizedProps));
            appendInitialChild(parent, instance);
          } else if (_node.tag === 6)
            instance = _node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, _node.memoizedProps)), appendInitialChild(parent, instance);
          else if (_node.tag !== 4) {
            if (_node.tag === 22 && _node.memoizedState !== null)
              instance = _node.child, instance !== null && (instance.return = _node), appendAllChildren(parent, _node, true, true);
            else if (_node.child !== null) {
              _node.child.return = _node;
              _node = _node.child;
              continue;
            }
          }
          if (_node === workInProgress2)
            break;
          for (;_node.sibling === null; ) {
            if (_node.return === null || _node.return === workInProgress2)
              return;
            _node = _node.return;
          }
          _node.sibling.return = _node.return;
          _node = _node.sibling;
        }
    }
    function appendAllChildrenToContainer(containerChildSet, workInProgress2, needsVisibilityToggle, isHidden) {
      var hasOffscreenComponentChild = false;
      if (supportsPersistence)
        for (var node = workInProgress2.child;node !== null; ) {
          if (node.tag === 5) {
            var instance = node.stateNode;
            needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, node.type, node.memoizedProps));
            appendChildToContainerChildSet(containerChildSet, instance);
          } else if (node.tag === 6)
            instance = node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, node.memoizedProps)), appendChildToContainerChildSet(containerChildSet, instance);
          else if (node.tag !== 4) {
            if (node.tag === 22 && node.memoizedState !== null)
              hasOffscreenComponentChild = node.child, hasOffscreenComponentChild !== null && (hasOffscreenComponentChild.return = node), appendAllChildrenToContainer(containerChildSet, node, true, true), hasOffscreenComponentChild = true;
            else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
          }
          if (node === workInProgress2)
            break;
          for (;node.sibling === null; ) {
            if (node.return === null || node.return === workInProgress2)
              return hasOffscreenComponentChild;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      return hasOffscreenComponentChild;
    }
    function updateHostContainer(current2, workInProgress2) {
      if (supportsPersistence && doesRequireClone(current2, workInProgress2)) {
        current2 = workInProgress2.stateNode;
        var container = current2.containerInfo, newChildSet = createContainerChildSet();
        appendAllChildrenToContainer(newChildSet, workInProgress2, false, false);
        current2.pendingChildren = newChildSet;
        markUpdate(workInProgress2);
        finalizeContainerChildren(container, newChildSet);
      }
    }
    function updateHostComponent(current2, workInProgress2, type, newProps) {
      if (supportsMutation)
        current2.memoizedProps !== newProps && markUpdate(workInProgress2);
      else if (supportsPersistence) {
        var { stateNode: currentInstance, memoizedProps: _oldProps } = current2;
        if ((current2 = doesRequireClone(current2, workInProgress2)) || _oldProps !== newProps) {
          var currentHostContext = getHostContext();
          _oldProps = cloneInstance(currentInstance, type, _oldProps, newProps, !current2, null);
          _oldProps === currentInstance ? workInProgress2.stateNode = currentInstance : (markCloned(workInProgress2), finalizeInitialChildren(_oldProps, type, newProps, currentHostContext) && markUpdate(workInProgress2), workInProgress2.stateNode = _oldProps, current2 && appendAllChildren(_oldProps, workInProgress2, false, false));
        } else
          workInProgress2.stateNode = currentInstance;
      }
    }
    function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
      if ((workInProgress2.mode & 32) !== NoMode && (oldProps === null ? maySuspendCommit(type, newProps) : maySuspendCommitOnUpdate(type, oldProps, newProps))) {
        if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2 || maySuspendCommitInSyncRender(type, newProps))
          if (preloadInstance(workInProgress2.stateNode, type, newProps))
            workInProgress2.flags |= 8192;
          else if (shouldRemainOnPreviousScreen())
            workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      } else
        workInProgress2.flags &= -16777217;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
      if (mayResourceSuspendCommit(resource)) {
        if (workInProgress2.flags |= 16777216, !preloadResource(resource))
          if (shouldRemainOnPreviousScreen())
            workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      } else
        workInProgress2.flags &= -16777217;
    }
    function scheduleRetryEffect(workInProgress2, retryQueue) {
      retryQueue !== null && (workInProgress2.flags |= 4);
      workInProgress2.flags & 16384 && (retryQueue = workInProgress2.tag !== 22 ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null;hasRenderedATailFallback !== null; )
              hasRenderedATailFallback.alternate !== null && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
            lastTailNode === null ? renderState.tail = null : lastTailNode.sibling = null;
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var _lastTailNode = null;lastTailNode !== null; )
              lastTailNode.alternate !== null && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
            _lastTailNode === null ? hasRenderedATailFallback || renderState.tail === null ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
      if (didBailout)
        if ((completedWork.mode & 2) !== NoMode) {
          for (var { selfBaseDuration: _treeBaseDuration, child: _child2 } = completedWork;_child2 !== null; )
            newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
          completedWork.treeBaseDuration = _treeBaseDuration;
        } else
          for (_treeBaseDuration = completedWork.child;_treeBaseDuration !== null; )
            newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
      else if ((completedWork.mode & 2) !== NoMode) {
        _treeBaseDuration = completedWork.actualDuration;
        _child2 = completedWork.selfBaseDuration;
        for (var child = completedWork.child;child !== null; )
          newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
        completedWork.actualDuration = _treeBaseDuration;
        completedWork.treeBaseDuration = _child2;
      } else
        for (_treeBaseDuration = completedWork.child;_treeBaseDuration !== null; )
          newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current2, workInProgress2, renderLanes2) {
      var newProps = workInProgress2.pendingProps;
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress2), null;
        case 1:
          return bubbleProperties(workInProgress2), null;
        case 3:
          renderLanes2 = workInProgress2.stateNode;
          newProps = null;
          current2 !== null && (newProps = current2.memoizedState.cache);
          workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
          popProvider(CacheContext, workInProgress2);
          popHostContainer(workInProgress2);
          renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
          if (current2 === null || current2.child === null)
            popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : current2 === null || current2.memoizedState.isDehydrated && (workInProgress2.flags & 256) === 0 || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
          updateHostContainer(current2, workInProgress2);
          bubbleProperties(workInProgress2);
          return null;
        case 26:
          if (supportsResources) {
            var { type, memoizedState: nextResource } = workInProgress2;
            current2 === null ? (markUpdate(workInProgress2), nextResource !== null ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(workInProgress2, type, null, newProps, renderLanes2))) : nextResource ? nextResource !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (nextResource = current2.memoizedProps, supportsMutation ? nextResource !== newProps && markUpdate(workInProgress2) : updateHostComponent(current2, workInProgress2, type, newProps), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(workInProgress2, type, nextResource, newProps, renderLanes2));
            return null;
          }
        case 27:
          if (supportsSingletons) {
            popHostContext(workInProgress2);
            renderLanes2 = requiredContext(rootInstanceStackCursor.current);
            type = workInProgress2.type;
            if (current2 !== null && workInProgress2.stateNode != null)
              supportsMutation ? current2.memoizedProps !== newProps && markUpdate(workInProgress2) : updateHostComponent(current2, workInProgress2, type, newProps);
            else {
              if (!newProps) {
                if (workInProgress2.stateNode === null)
                  throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                bubbleProperties(workInProgress2);
                return null;
              }
              current2 = getHostContext();
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(type, newProps, renderLanes2, current2, true), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            return null;
          }
        case 5:
          popHostContext(workInProgress2);
          type = workInProgress2.type;
          if (current2 !== null && workInProgress2.stateNode != null)
            updateHostComponent(current2, workInProgress2, type, newProps);
          else {
            if (!newProps) {
              if (workInProgress2.stateNode === null)
                throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              bubbleProperties(workInProgress2);
              return null;
            }
            nextResource = getHostContext();
            if (popHydrationState(workInProgress2))
              prepareToHydrateHostInstance(workInProgress2, nextResource), finalizeHydratedChildren(workInProgress2.stateNode, type, newProps, nextResource) && (workInProgress2.flags |= 64);
            else {
              var _rootContainerInstance = requiredContext(rootInstanceStackCursor.current);
              _rootContainerInstance = createInstance(type, newProps, _rootContainerInstance, nextResource, workInProgress2);
              markCloned(workInProgress2);
              appendAllChildren(_rootContainerInstance, workInProgress2, false, false);
              workInProgress2.stateNode = _rootContainerInstance;
              finalizeInitialChildren(_rootContainerInstance, type, newProps, nextResource) && markUpdate(workInProgress2);
            }
          }
          bubbleProperties(workInProgress2);
          preloadInstanceAndSuspendIfNeeded(workInProgress2, workInProgress2.type, current2 === null ? null : current2.memoizedProps, workInProgress2.pendingProps, renderLanes2);
          return null;
        case 6:
          if (current2 && workInProgress2.stateNode != null)
            renderLanes2 = current2.memoizedProps, supportsMutation ? renderLanes2 !== newProps && markUpdate(workInProgress2) : supportsPersistence && (renderLanes2 !== newProps ? (current2 = requiredContext(rootInstanceStackCursor.current), renderLanes2 = getHostContext(), markCloned(workInProgress2), workInProgress2.stateNode = createTextInstance(newProps, current2, renderLanes2, workInProgress2)) : workInProgress2.stateNode = current2.stateNode);
          else {
            if (typeof newProps !== "string" && workInProgress2.stateNode === null)
              throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            current2 = requiredContext(rootInstanceStackCursor.current);
            renderLanes2 = getHostContext();
            if (popHydrationState(workInProgress2)) {
              if (!supportsHydration)
                throw Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
              current2 = workInProgress2.stateNode;
              renderLanes2 = workInProgress2.memoizedProps;
              type = !didSuspendOrErrorDEV;
              newProps = null;
              nextResource = hydrationParentFiber;
              if (nextResource !== null)
                switch (nextResource.tag) {
                  case 3:
                    type && (type = diffHydratedTextForDevWarnings(current2, renderLanes2, newProps), type !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = type));
                    break;
                  case 27:
                  case 5:
                    newProps = nextResource.memoizedProps, type && (type = diffHydratedTextForDevWarnings(current2, renderLanes2, newProps), type !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = type));
                }
              hydrateTextInstance(current2, renderLanes2, workInProgress2, newProps) || throwOnHydrationMismatch(workInProgress2, true);
            } else
              markCloned(workInProgress2), workInProgress2.stateNode = createTextInstance(newProps, current2, renderLanes2, workInProgress2);
          }
          bubbleProperties(workInProgress2);
          return null;
        case 31:
          renderLanes2 = workInProgress2.memoizedState;
          if (current2 === null || current2.memoizedState !== null) {
            newProps = popHydrationState(workInProgress2);
            if (renderLanes2 !== null) {
              if (current2 === null) {
                if (!newProps)
                  throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (!supportsHydration)
                  throw Error("Expected prepareToHydrateHostActivityInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
                current2 = workInProgress2.memoizedState;
                current2 = current2 !== null ? current2.dehydrated : null;
                if (!current2)
                  throw Error("Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue.");
                hydrateActivityInstance(current2, workInProgress2);
                bubbleProperties(workInProgress2);
                (workInProgress2.mode & 2) !== NoMode && renderLanes2 !== null && (current2 = workInProgress2.child, current2 !== null && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              } else
                emitPendingHydrationWarnings(), resetHydrationState(), (workInProgress2.flags & 128) === 0 && (renderLanes2 = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & 2) !== NoMode && renderLanes2 !== null && (current2 = workInProgress2.child, current2 !== null && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              current2 = false;
            } else
              renderLanes2 = upgradeHydrationErrorsToRecoverable(), current2 !== null && current2.memoizedState !== null && (current2.memoizedState.hydrationErrors = renderLanes2), current2 = true;
            if (!current2) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
            if ((workInProgress2.flags & 128) !== 0)
              throw Error("Client rendering an Activity suspended it again. This is a bug in React.");
          }
          bubbleProperties(workInProgress2);
          return null;
        case 13:
          newProps = workInProgress2.memoizedState;
          if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
            type = newProps;
            nextResource = popHydrationState(workInProgress2);
            if (type !== null && type.dehydrated !== null) {
              if (current2 === null) {
                if (!nextResource)
                  throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (!supportsHydration)
                  throw Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
                nextResource = workInProgress2.memoizedState;
                nextResource = nextResource !== null ? nextResource.dehydrated : null;
                if (!nextResource)
                  throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
                hydrateSuspenseInstance(nextResource, workInProgress2);
                bubbleProperties(workInProgress2);
                (workInProgress2.mode & 2) !== NoMode && type !== null && (type = workInProgress2.child, type !== null && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
              } else
                emitPendingHydrationWarnings(), resetHydrationState(), (workInProgress2.flags & 128) === 0 && (type = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & 2) !== NoMode && type !== null && (type = workInProgress2.child, type !== null && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
              type = false;
            } else
              type = upgradeHydrationErrorsToRecoverable(), current2 !== null && current2.memoizedState !== null && (current2.memoizedState.hydrationErrors = type), type = true;
            if (!type) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
          }
          popSuspenseHandler(workInProgress2);
          if ((workInProgress2.flags & 128) !== 0)
            return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
          renderLanes2 = newProps !== null;
          current2 = current2 !== null && current2.memoizedState !== null;
          renderLanes2 && (newProps = workInProgress2.child, type = null, newProps.alternate !== null && newProps.alternate.memoizedState !== null && newProps.alternate.memoizedState.cachePool !== null && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, newProps.memoizedState !== null && newProps.memoizedState.cachePool !== null && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
          renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
          scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
          bubbleProperties(workInProgress2);
          (workInProgress2.mode & 2) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, current2 !== null && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
          return null;
        case 4:
          return popHostContainer(workInProgress2), updateHostContainer(current2, workInProgress2), current2 === null && preparePortalMount(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
        case 10:
          return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
        case 19:
          pop(suspenseStackCursor, workInProgress2);
          newProps = workInProgress2.memoizedState;
          if (newProps === null)
            return bubbleProperties(workInProgress2), null;
          type = (workInProgress2.flags & 128) !== 0;
          nextResource = newProps.rendering;
          if (nextResource === null)
            if (type)
              cutOffTailIfNeeded(newProps, false);
            else {
              if (workInProgressRootExitStatus !== RootInProgress || current2 !== null && (current2.flags & 128) !== 0)
                for (current2 = workInProgress2.child;current2 !== null; ) {
                  nextResource = findFirstSuspended(current2);
                  if (nextResource !== null) {
                    workInProgress2.flags |= 128;
                    cutOffTailIfNeeded(newProps, false);
                    current2 = nextResource.updateQueue;
                    workInProgress2.updateQueue = current2;
                    scheduleRetryEffect(workInProgress2, current2);
                    workInProgress2.subtreeFlags = 0;
                    current2 = renderLanes2;
                    for (renderLanes2 = workInProgress2.child;renderLanes2 !== null; )
                      resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                    push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2);
                    isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                    return workInProgress2.child;
                  }
                  current2 = current2.sibling;
                }
              newProps.tail !== null && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            }
          else {
            if (!type)
              if (current2 = findFirstSuspended(nextResource), current2 !== null) {
                if (workInProgress2.flags |= 128, type = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(newProps, true), newProps.tail === null && newProps.tailMode === "hidden" && !nextResource.alternate && !isHydrating)
                  return bubbleProperties(workInProgress2), null;
              } else
                2 * now$1() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && renderLanes2 !== 536870912 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current2 = newProps.last, current2 !== null ? current2.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
          }
          if (newProps.tail !== null)
            return current2 = newProps.tail, newProps.rendering = current2, newProps.tail = current2.sibling, newProps.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = type ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current2;
          bubbleProperties(workInProgress2);
          return null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = workInProgress2.memoizedState !== null, current2 !== null ? current2.memoizedState !== null !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? (renderLanes2 & 536870912) !== 0 && (workInProgress2.flags & 128) === 0 && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, renderLanes2 !== null && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, current2 !== null && current2.memoizedState !== null && current2.memoizedState.cachePool !== null && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, workInProgress2.memoizedState !== null && workInProgress2.memoizedState.cachePool !== null && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), current2 !== null && pop(resumedCache, workInProgress2), null;
        case 24:
          return renderLanes2 = null, current2 !== null && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function unwindWork(current2, workInProgress2) {
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 1:
          return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        case 3:
          return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, (current2 & 65536) !== 0 && (current2 & 128) === 0 ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress2), null;
        case 31:
          if (workInProgress2.memoizedState !== null) {
            popSuspenseHandler(workInProgress2);
            if (workInProgress2.alternate === null)
              throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            resetHydrationState();
          }
          current2 = workInProgress2.flags;
          return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        case 13:
          popSuspenseHandler(workInProgress2);
          current2 = workInProgress2.memoizedState;
          if (current2 !== null && current2.dehydrated !== null) {
            if (workInProgress2.alternate === null)
              throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            resetHydrationState();
          }
          current2 = workInProgress2.flags;
          return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        case 19:
          return pop(suspenseStackCursor, workInProgress2), null;
        case 4:
          return popHostContainer(workInProgress2), null;
        case 10:
          return popProvider(workInProgress2.type, workInProgress2), null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), current2 !== null && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & 2) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        case 24:
          return popProvider(CacheContext, workInProgress2), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current2, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext, interruptedWork);
          popHostContainer(interruptedWork);
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer(interruptedWork);
          break;
        case 31:
          interruptedWork.memoizedState !== null && popSuspenseHandler(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor, interruptedWork);
          break;
        case 10:
          popProvider(interruptedWork.type, interruptedWork);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext(interruptedWork);
          current2 !== null && pop(resumedCache, interruptedWork);
          break;
        case 24:
          popProvider(CacheContext, interruptedWork);
      }
    }
    function shouldProfile(current2) {
      return (current2.mode & 2) !== NoMode;
    }
    function commitHookLayoutEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags && (lastEffect = undefined, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), lastEffect !== undefined && typeof lastEffect !== "function")) {
              var hookName = undefined;
              hookName = (updateQueue.tag & Layout) !== 0 ? "useLayoutEffect" : (updateQueue.tag & Insertion) !== 0 ? "useInsertionEffect" : "useEffect";
              var addendum = undefined;
              addendum = lastEffect === null ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof lastEffect.then === "function" ? `

It looks like you wrote ` + hookName + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + hookName + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching` : " You returned: " + lastEffect;
              runWithFiberInDEV(finishedWork, function(n, a) {
                console.error("%s must not return anything besides a function, which is used for clean-up.%s", n, a);
              }, hookName, addendum);
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst, destroy = inst.destroy;
              destroy !== undefined && (inst.destroy = undefined, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(lastEffect, callDestroyInDEV, lastEffect, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false));
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookPassiveMountEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (updateQueue !== null) {
        var instance = finishedWork.stateNode;
        finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
        try {
          runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
      return instance.getSnapshotBeforeUpdate(prevProps, prevState);
    }
    function commitClassSnapshot(finishedWork, current2) {
      var { memoizedProps: prevProps, memoizedState: prevState } = current2;
      current2 = finishedWork.stateNode;
      finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), current2.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
      try {
        var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps);
        var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current2, resolvedPrevProps, prevState);
        prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
        snapshot !== undefined || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
          console.error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
        }));
        current2.__reactInternalSnapshotBeforeUpdate = snapshot;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(current2.type, current2.memoizedProps);
      instance.state = current2.memoizedState;
      shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(current2, callComponentWillUnmountInDEV, current2, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current2, callComponentWillUnmountInDEV, current2, nearestMountedAncestor, instance);
    }
    function commitAttachRef(finishedWork) {
      var ref = finishedWork.ref;
      if (ref !== null) {
        switch (finishedWork.tag) {
          case 26:
          case 27:
          case 5:
            var instanceToUse = getPublicInstance(finishedWork.stateNode);
            break;
          case 30:
            instanceToUse = finishedWork.stateNode;
            break;
          default:
            instanceToUse = finishedWork.stateNode;
        }
        if (typeof ref === "function")
          if (shouldProfile(finishedWork))
            try {
              startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
            } finally {
              recordEffectDuration();
            }
          else
            finishedWork.refCleanup = ref(instanceToUse);
        else
          typeof ref === "string" ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork)), ref.current = instanceToUse;
      }
    }
    function safelyAttachRef(current2, nearestMountedAncestor) {
      try {
        runWithFiberInDEV(current2, commitAttachRef, current2);
      } catch (error) {
        captureCommitPhaseError(current2, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current2, nearestMountedAncestor) {
      var { ref, refCleanup } = current2;
      if (ref !== null)
        if (typeof refCleanup === "function")
          try {
            if (shouldProfile(current2))
              try {
                startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
              } finally {
                recordEffectDuration(current2);
              }
            else
              runWithFiberInDEV(current2, refCleanup);
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          } finally {
            current2.refCleanup = null, current2 = current2.alternate, current2 != null && (current2.refCleanup = null);
          }
        else if (typeof ref === "function")
          try {
            if (shouldProfile(current2))
              try {
                startEffectTimer(), runWithFiberInDEV(current2, ref, null);
              } finally {
                recordEffectDuration(current2);
              }
            else
              runWithFiberInDEV(current2, ref, null);
          } catch (error$3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error$3);
          }
        else
          ref.current = null;
    }
    function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
      var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
      _finishedWork$memoize = _finishedWork$memoize.onRender;
      current2 = current2 === null ? "mount" : "update";
      currentUpdateIsNested && (current2 = "nested-update");
      typeof _finishedWork$memoize === "function" && _finishedWork$memoize(id, current2, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime2);
      typeof onCommit === "function" && onCommit(id, current2, effectDuration, commitStartTime2);
    }
    function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
      var _finishedWork$memoize2 = finishedWork.memoizedProps;
      finishedWork = _finishedWork$memoize2.id;
      _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
      current2 = current2 === null ? "mount" : "update";
      currentUpdateIsNested && (current2 = "nested-update");
      typeof _finishedWork$memoize2 === "function" && _finishedWork$memoize2(finishedWork, current2, passiveEffectDuration, commitStartTime2);
    }
    function commitHostMount(finishedWork) {
      var { type, memoizedProps: props, stateNode: instance } = finishedWork;
      try {
        runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return fiber.tag === 5 || fiber.tag === 3 || (supportsResources ? fiber.tag === 26 : false) || (supportsSingletons ? fiber.tag === 27 && isSingletonScope(fiber.type) : false) || fiber.tag === 4;
    }
    function getHostSibling(fiber) {
      a:
        for (;; ) {
          for (;fiber.sibling === null; ) {
            if (fiber.return === null || isHostParent(fiber.return))
              return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling;fiber.tag !== 5 && fiber.tag !== 6 && fiber.tag !== 18; ) {
            if (supportsSingletons && fiber.tag === 27 && isSingletonScope(fiber.type))
              continue a;
            if (fiber.flags & 2)
              continue a;
            if (fiber.child === null || fiber.tag === 4)
              continue a;
            else
              fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2))
            return fiber.stateNode;
        }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      var tag = node.tag;
      if (tag === 5 || tag === 6)
        node = node.stateNode, before ? insertInContainerBefore(parent, node, before) : appendChildToContainer(parent, node);
      else if (tag !== 4 && (supportsSingletons && tag === 27 && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, node !== null))
        for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;node !== null; )
          insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
    }
    function insertOrAppendPlacementNode(node, before, parent) {
      var tag = node.tag;
      if (tag === 5 || tag === 6)
        node = node.stateNode, before ? insertBefore(parent, node, before) : appendChild(parent, node);
      else if (tag !== 4 && (supportsSingletons && tag === 27 && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, node !== null))
        for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling;node !== null; )
          insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
    }
    function commitPlacement(finishedWork) {
      for (var hostParentFiber, parentFiber = finishedWork.return;parentFiber !== null; ) {
        if (isHostParent(parentFiber)) {
          hostParentFiber = parentFiber;
          break;
        }
        parentFiber = parentFiber.return;
      }
      if (supportsMutation) {
        if (hostParentFiber == null)
          throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        switch (hostParentFiber.tag) {
          case 27:
            if (supportsSingletons) {
              hostParentFiber = hostParentFiber.stateNode;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, parentFiber, hostParentFiber);
              break;
            }
          case 5:
            parentFiber = hostParentFiber.stateNode;
            hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
            hostParentFiber = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, hostParentFiber, parentFiber);
            break;
          case 3:
          case 4:
            hostParentFiber = hostParentFiber.stateNode.containerInfo;
            parentFiber = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, hostParentFiber);
            break;
          default:
            throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function commitHostPortalContainerChildren(portal, finishedWork, pendingChildren) {
      portal = portal.containerInfo;
      try {
        runWithFiberInDEV(finishedWork, replaceContainerChildren, portal, pendingChildren);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostSingletonAcquisition(finishedWork) {
      var { stateNode: singleton, memoizedProps: props } = finishedWork;
      try {
        runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, props, singleton, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHydratingParent(current2, finishedWork) {
      return finishedWork.tag === 31 ? (finishedWork = finishedWork.memoizedState, current2.memoizedState !== null && finishedWork === null) : finishedWork.tag === 13 ? (current2 = current2.memoizedState, finishedWork = finishedWork.memoizedState, current2 !== null && current2.dehydrated !== null && (finishedWork === null || finishedWork.dehydrated === null)) : finishedWork.tag === 3 ? current2.memoizedState.isDehydrated && (finishedWork.flags & 256) === 0 : false;
    }
    function commitBeforeMutationEffects(root, firstChild) {
      prepareForCommit(root.containerInfo);
      for (nextEffect = firstChild;nextEffect !== null; )
        if (root = nextEffect, firstChild = root.child, (root.subtreeFlags & 1028) !== 0 && firstChild !== null)
          firstChild.return = root, nextEffect = firstChild;
        else
          for (;nextEffect !== null; ) {
            firstChild = root = nextEffect;
            var { alternate: current2, flags } = firstChild;
            switch (firstChild.tag) {
              case 0:
                if ((flags & 4) !== 0 && (firstChild = firstChild.updateQueue, firstChild = firstChild !== null ? firstChild.events : null, firstChild !== null))
                  for (current2 = 0;current2 < firstChild.length; current2++)
                    flags = firstChild[current2], flags.ref.impl = flags.nextImpl;
                break;
              case 11:
              case 15:
                break;
              case 1:
                (flags & 1024) !== 0 && current2 !== null && commitClassSnapshot(firstChild, current2);
                break;
              case 3:
                (flags & 1024) !== 0 && supportsMutation && clearContainer(firstChild.stateNode.containerInfo);
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if ((flags & 1024) !== 0)
                  throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
            firstChild = root.sibling;
            if (firstChild !== null) {
              firstChild.return = root.return;
              nextEffect = firstChild;
              break;
            }
            nextEffect = root.return;
          }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (finishedRoot = finishedWork.stateNode, current2 === null)
              finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);
            else {
              var prevProps = resolveClassComponentProps(finishedWork.type, current2.memoizedProps);
              current2 = current2.memoizedState;
              finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
              shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current2, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current2, finishedRoot.__reactInternalSnapshotBeforeUpdate);
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          current2 = pushNestedEffectDurations();
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 64 && (flags = finishedWork.updateQueue, flags !== null)) {
            prevProps = null;
            if (finishedWork.child !== null)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  prevProps = getPublicInstance(finishedWork.child.stateNode);
                  break;
                case 1:
                  prevProps = finishedWork.child.stateNode;
              }
            try {
              runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          finishedRoot.effectDuration += popNestedEffectDurations(current2);
          break;
        case 27:
          supportsSingletons && current2 === null && flags & 4 && commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (current2 === null) {
            if (flags & 4)
              commitHostMount(finishedWork);
            else if (flags & 64) {
              finishedRoot = finishedWork.type;
              current2 = finishedWork.memoizedProps;
              prevProps = finishedWork.stateNode;
              try {
                runWithFiberInDEV(finishedWork, commitHydratedInstance, prevProps, finishedRoot, current2, finishedWork);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
          }
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current2, commitStartTime, finishedRoot.effectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 31:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 && (finishedRoot = finishedWork.memoizedState, finishedRoot !== null && (finishedRoot = finishedRoot.dehydrated, finishedRoot !== null && (flags = retryDehydratedSuspenseBoundary.bind(null, finishedWork), registerSuspenseInstanceRetry(finishedRoot, flags))));
          break;
        case 22:
          flags = finishedWork.memoizedState !== null || offscreenSubtreeIsHidden;
          if (!flags) {
            current2 = current2 !== null && current2.memoizedState !== null || offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? (recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, (finishedWork.subtreeFlags & 8772) !== 0), (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(finishedWork, componentEffectStartTime, componentEffectEndTime)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        case 30:
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors), finishedWork.alternate === null && finishedWork.return !== null && finishedWork.return.alternate !== null && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(finishedWork.return.alternate, finishedWork.return) || logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Mount")));
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      alternate !== null && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      fiber.tag === 5 && (alternate = fiber.stateNode, alternate !== null && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber._debugOwner = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child;parent !== null; )
        commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function")
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {
          hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
        }
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (deletedFiber.tag) {
        case 26:
          if (supportsResources) {
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            deletedFiber.memoizedState ? releaseResource(deletedFiber.memoizedState) : deletedFiber.stateNode && unmountHoistable(deletedFiber.stateNode);
            break;
          }
        case 27:
          if (supportsSingletons) {
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            runWithFiberInDEV(deletedFiber, releaseSingletonInstance, deletedFiber.stateNode);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          }
        case 5:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          if (supportsMutation) {
            if (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, hostParent !== null)
              if (hostParentIsContainer)
                try {
                  runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
                }
              else
                try {
                  runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
                }
          } else
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 18:
          supportsMutation && hostParent !== null && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          supportsMutation ? (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = true, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer) : (supportsPersistence && commitHostPortalContainerChildren(deletedFiber.stateNode, deletedFiber, createContainerChildSet()), recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber));
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 1:
          offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, typeof prevHostParent.componentWillUnmount === "function" && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 21:
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 22:
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || deletedFiber.memoizedState !== null;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      }
      (deletedFiber.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(deletedFiber, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
      if (supportsHydration && finishedWork.memoizedState === null && (finishedRoot = finishedWork.alternate, finishedRoot !== null && (finishedRoot = finishedRoot.memoizedState, finishedRoot !== null))) {
        finishedRoot = finishedRoot.dehydrated;
        try {
          runWithFiberInDEV(finishedWork, commitHydratedActivityInstance, finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (supportsHydration && finishedWork.memoizedState === null && (finishedRoot = finishedWork.alternate, finishedRoot !== null && (finishedRoot = finishedRoot.memoizedState, finishedRoot !== null && (finishedRoot = finishedRoot.dehydrated, finishedRoot !== null))))
        try {
          runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 31:
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          retryCache === null && (retryCache = finishedWork.stateNode = new PossiblyWeakSet);
          return retryCache;
        case 22:
          return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, retryCache === null && (retryCache = finishedWork._retryCache = new PossiblyWeakSet), retryCache;
        default:
          throw Error("Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React.");
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function(wakeable) {
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          if (isDevToolsPresent)
            if (inProgressLanes !== null && inProgressRoot !== null)
              restorePendingUpdaters(inProgressRoot, inProgressLanes);
            else
              throw Error("Expected finished root and lanes to be set. This is a bug in React.");
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          wakeable.then(retry, retry);
        }
      });
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (deletions !== null)
        for (var i = 0;i < deletions.length; i++) {
          var root = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], prevEffectStart = pushComponentEffectStart();
          if (supportsMutation) {
            var parent = returnFiber;
            a:
              for (;parent !== null; ) {
                switch (parent.tag) {
                  case 27:
                    if (supportsSingletons) {
                      if (isSingletonScope(parent.type)) {
                        hostParent = parent.stateNode;
                        hostParentIsContainer = false;
                        break a;
                      }
                      break;
                    }
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
            if (hostParent === null)
              throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
            hostParent = null;
            hostParentIsContainer = false;
          } else
            commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
          (deletedFiber.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(deletedFiber, componentEffectStartTime, componentEffectEndTime, "Unmount");
          popComponentEffectStart(prevEffectStart);
          root = deletedFiber;
          returnFiber = root.alternate;
          returnFiber !== null && (returnFiber.return = null);
          root.return = null;
        }
      if (parentFiber.subtreeFlags & 13886)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    function commitMutationEffectsOnFiber(finishedWork, root) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), current2 = finishedWork.alternate, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachRef(current2, current2.return));
          flags & 64 && offscreenSubtreeIsHidden && (flags = finishedWork.updateQueue, flags !== null && (current2 = flags.callbacks, current2 !== null && (root = flags.shared.hiddenCallbacks, flags.shared.hiddenCallbacks = root === null ? current2 : root.concat(current2))));
          break;
        case 26:
          if (supportsResources) {
            var hoistableRoot = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachRef(current2, current2.return));
            flags & 4 && (flags = current2 !== null ? current2.memoizedState : null, root = finishedWork.memoizedState, current2 === null ? root === null ? finishedWork.stateNode === null ? finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork) : mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : finishedWork.stateNode = acquireResource(hoistableRoot, root, finishedWork.memoizedProps) : flags !== root ? (flags === null ? current2.stateNode !== null && unmountHoistable(current2.stateNode) : releaseResource(flags), root === null ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, root, finishedWork.memoizedProps)) : root === null && finishedWork.stateNode !== null && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current2.memoizedProps));
            break;
          }
        case 27:
          if (supportsSingletons) {
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachRef(current2, current2.return));
            current2 !== null && flags & 4 && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current2.memoizedProps);
            break;
          }
        case 5:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachRef(current2, current2.return));
          if (supportsMutation) {
            if (finishedWork.flags & 32) {
              root = finishedWork.stateNode;
              try {
                runWithFiberInDEV(finishedWork, resetTextContent, root);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            flags & 4 && finishedWork.stateNode != null && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, current2 !== null ? current2.memoizedProps : root));
            flags & 1024 && (needsFormReset = true, finishedWork.type !== "form" && console.error("Unexpected host component type. Expected a form. This is a bug in React."));
          } else
            supportsPersistence && finishedWork.alternate !== null && (finishedWork.alternate.stateNode = finishedWork.stateNode);
          break;
        case 6:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4 && supportsMutation) {
            if (finishedWork.stateNode === null)
              throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            flags = finishedWork.memoizedProps;
            current2 = current2 !== null ? current2.memoizedProps : flags;
            root = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, commitTextUpdate, root, current2, flags);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          hoistableRoot = pushNestedEffectDurations();
          if (supportsResources) {
            prepareToCommitHoistables();
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root.containerInfo);
            recursivelyTraverseMutationEffects(root, finishedWork);
            currentHoistableRoot = previousHoistableRoot;
          } else
            recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (supportsMutation && supportsHydration && current2 !== null && current2.memoizedState.isDehydrated)
              try {
                runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            if (supportsPersistence) {
              flags = root.containerInfo;
              current2 = root.pendingChildren;
              try {
                runWithFiberInDEV(finishedWork, replaceContainerChildren, flags, current2);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
          }
          needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
          root.effectDuration += popNestedEffectDurations(hoistableRoot);
          break;
        case 4:
          supportsResources ? (current2 = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), currentHoistableRoot = current2) : (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork));
          flags & 4 && supportsPersistence && commitHostPortalContainerChildren(finishedWork.stateNode, finishedWork, finishedWork.stateNode.pendingChildren);
          break;
        case 12:
          flags = pushNestedEffectDurations();
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
          break;
        case 31:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 13:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 && finishedWork.memoizedState !== null !== (current2 !== null && current2.memoizedState !== null) && (globalMostRecentFallbackTime = now$1());
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          hoistableRoot = finishedWork.memoizedState !== null;
          var wasHidden = current2 !== null && current2.memoizedState !== null, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          wasHidden && !hoistableRoot && !prevOffscreenSubtreeIsHidden && !prevOffscreenSubtreeWasHidden && (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(finishedWork, componentEffectStartTime, componentEffectEndTime);
          commitReconciliationEffects(finishedWork);
          if (flags & 8192 && (root = finishedWork.stateNode, root._visibility = hoistableRoot ? root._visibility & ~OffscreenVisible : root._visibility | OffscreenVisible, !hoistableRoot || current2 === null || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || (recursivelyTraverseDisappearLayoutEffects(finishedWork), (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Disconnect")), supportsMutation))
            a:
              if (current2 = null, supportsMutation)
                for (root = finishedWork;; ) {
                  if (root.tag === 5 || supportsResources && root.tag === 26) {
                    if (current2 === null) {
                      wasHidden = current2 = root;
                      try {
                        previousHoistableRoot = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, previousHoistableRoot) : runWithFiberInDEV(wasHidden, unhideInstance, wasHidden.stateNode, wasHidden.memoizedProps);
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (root.tag === 6) {
                    if (current2 === null) {
                      wasHidden = root;
                      try {
                        var instance = wasHidden.stateNode;
                        hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, instance) : runWithFiberInDEV(wasHidden, unhideTextInstance, instance, wasHidden.memoizedProps);
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (root.tag === 18) {
                    if (current2 === null) {
                      wasHidden = root;
                      try {
                        var instance$jscomp$0 = wasHidden.stateNode;
                        hoistableRoot ? runWithFiberInDEV(wasHidden, hideDehydratedBoundary, instance$jscomp$0) : runWithFiberInDEV(wasHidden, unhideDehydratedBoundary, wasHidden.stateNode);
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if ((root.tag !== 22 && root.tag !== 23 || root.memoizedState === null || root === finishedWork) && root.child !== null) {
                    root.child.return = root;
                    root = root.child;
                    continue;
                  }
                  if (root === finishedWork)
                    break a;
                  for (;root.sibling === null; ) {
                    if (root.return === null || root.return === finishedWork)
                      break a;
                    current2 === root && (current2 = null);
                    root = root.return;
                  }
                  current2 === root && (current2 = null);
                  root.sibling.return = root.return;
                  root = root.sibling;
                }
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (current2 = flags.retryQueue, current2 !== null && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors), finishedWork.alternate === null && finishedWork.return !== null && finishedWork.return.alternate !== null && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(finishedWork.return.alternate, finishedWork.return) || logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Mount")));
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child;parentFiber !== null; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          fiber.tag === 5 && fiber.flags & 1024 && resetFormInstance(fiber.stateNode);
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyTraverseLayoutEffects(root, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    function disappearLayoutEffects(finishedWork) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 1:
          safelyDetachRef(finishedWork, finishedWork.return);
          var instance = finishedWork.stateNode;
          typeof instance.componentWillUnmount === "function" && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 27:
          supportsSingletons && runWithFiberInDEV(finishedWork, releaseSingletonInstance, finishedWork.stateNode);
        case 26:
        case 5:
          safelyDetachRef(finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 22:
          finishedWork.memoizedState === null && recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 30:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        default:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child;parentFiber !== null; )
        disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
    }
    function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          commitHookLayoutEffects(finishedWork, Layout);
          break;
        case 1:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          current2 = finishedWork.stateNode;
          typeof current2.componentDidMount === "function" && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current2);
          current2 = finishedWork.updateQueue;
          if (current2 !== null) {
            finishedRoot = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current2, finishedRoot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 27:
          supportsSingletons && commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && current2 === null && flags & 4 && commitHostMount(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (includeWorkInProgressEffects && flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
            includeWorkInProgressEffects = finishedWork.stateNode;
            includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current2, commitStartTime, includeWorkInProgressEffects.effectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          break;
        case 31:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          finishedWork.memoizedState === null && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 30:
          break;
        default:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & 8772) !== 0;
      for (parentFiber = parentFiber.child;parentFiber !== null; )
        reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;
    }
    function commitOffscreenPassiveMountEffects(current2, finishedWork) {
      var previousCache = null;
      current2 !== null && current2.memoizedState !== null && current2.memoizedState.cachePool !== null && (previousCache = current2.memoizedState.cachePool.pool);
      current2 = null;
      finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null && (current2 = finishedWork.memoizedState.cachePool.pool);
      current2 !== previousCache && (current2 != null && retainCache(current2), previousCache != null && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current2, finishedWork) {
      current2 = null;
      finishedWork.alternate !== null && (current2 = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current2 && (retainCache(finishedWork), current2 != null && releaseCache(current2));
    }
    function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions, endTime) {
      if (parentFiber.subtreeFlags & 10256 || parentFiber.actualDuration !== 0 && (parentFiber.alternate === null || parentFiber.alternate.child !== parentFiber.child))
        for (parentFiber = parentFiber.child;parentFiber !== null; ) {
          var nextSibling = parentFiber.sibling;
          commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions, nextSibling !== null ? nextSibling.actualStartTime : endTime);
          parentFiber = nextSibling;
        }
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          (finishedWork.mode & 2) !== NoMode && 0 < finishedWork.actualStartTime && (finishedWork.flags & 1) !== 0 && logComponentRender(finishedWork, finishedWork.actualStartTime, endTime, inHydratedSubtree, committedLanes);
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
          break;
        case 1:
          (finishedWork.mode & 2) !== NoMode && 0 < finishedWork.actualStartTime && ((finishedWork.flags & 128) !== 0 ? logComponentErrored(finishedWork, finishedWork.actualStartTime, endTime, []) : (finishedWork.flags & 1) !== 0 && logComponentRender(finishedWork, finishedWork.actualStartTime, endTime, inHydratedSubtree, committedLanes));
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          break;
        case 3:
          var prevProfilerEffectDuration = pushNestedEffectDurations(), wasInHydratedSubtree = inHydratedSubtree;
          inHydratedSubtree = finishedWork.alternate !== null && finishedWork.alternate.memoizedState.isDehydrated && (finishedWork.flags & 256) === 0;
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          inHydratedSubtree = wasInHydratedSubtree;
          flags & 2048 && (committedLanes = null, finishedWork.alternate !== null && (committedLanes = finishedWork.alternate.memoizedState.cache), committedTransitions = finishedWork.memoizedState.cache, committedTransitions !== committedLanes && (retainCache(committedTransitions), committedLanes != null && releaseCache(committedLanes)));
          finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);
          break;
        case 12:
          if (flags & 2048) {
            flags = pushNestedEffectDurations();
            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          break;
        case 31:
          flags = inHydratedSubtree;
          prevProfilerEffectDuration = finishedWork.alternate !== null ? finishedWork.alternate.memoizedState : null;
          wasInHydratedSubtree = finishedWork.memoizedState;
          prevProfilerEffectDuration !== null && wasInHydratedSubtree === null ? (wasInHydratedSubtree = finishedWork.deletions, wasInHydratedSubtree !== null && 0 < wasInHydratedSubtree.length && wasInHydratedSubtree[0].tag === 18 ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, prevProfilerEffectDuration !== null && logComponentErrored(finishedWork, finishedWork.actualStartTime, endTime, prevProfilerEffectDuration)) : inHydratedSubtree = true) : inHydratedSubtree = false;
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          inHydratedSubtree = flags;
          break;
        case 13:
          flags = inHydratedSubtree;
          prevProfilerEffectDuration = finishedWork.alternate !== null ? finishedWork.alternate.memoizedState : null;
          wasInHydratedSubtree = finishedWork.memoizedState;
          prevProfilerEffectDuration === null || prevProfilerEffectDuration.dehydrated === null || wasInHydratedSubtree !== null && wasInHydratedSubtree.dehydrated !== null ? inHydratedSubtree = false : (wasInHydratedSubtree = finishedWork.deletions, wasInHydratedSubtree !== null && 0 < wasInHydratedSubtree.length && wasInHydratedSubtree[0].tag === 18 ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, prevProfilerEffectDuration !== null && logComponentErrored(finishedWork, finishedWork.actualStartTime, endTime, prevProfilerEffectDuration)) : inHydratedSubtree = true);
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          inHydratedSubtree = flags;
          break;
        case 23:
          break;
        case 22:
          wasInHydratedSubtree = finishedWork.stateNode;
          prevProfilerEffectDuration = finishedWork.alternate;
          finishedWork.memoizedState !== null ? wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : (wasInHydratedSubtree._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, (finishedWork.subtreeFlags & 10256) !== 0 || finishedWork.actualDuration !== 0 && (finishedWork.alternate === null || finishedWork.alternate.child !== finishedWork.child), endTime), (finishedWork.mode & 2) === NoMode || inHydratedSubtree || (finishedRoot = finishedWork.actualStartTime, 0 <= finishedRoot && 0.05 < endTime - finishedRoot && logComponentReappeared(finishedWork, finishedRoot, endTime), 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(finishedWork, componentEffectStartTime, componentEffectEndTime)));
          flags & 2048 && commitOffscreenPassiveMountEffects(prevProfilerEffectDuration, finishedWork);
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
      }
      if ((finishedWork.mode & 2) !== NoMode) {
        if (finishedRoot = !inHydratedSubtree && finishedWork.alternate === null && finishedWork.return !== null && finishedWork.return.alternate !== null)
          committedLanes = finishedWork.actualStartTime, 0 <= committedLanes && 0.05 < endTime - committedLanes && logComponentTrigger(finishedWork, committedLanes, endTime, "Mount");
        0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors), finishedRoot && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Mount"));
      }
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      alreadyWarnedForDeepEquality = prevDeepEquality;
    }
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && ((parentFiber.subtreeFlags & 10256) !== 0 || parentFiber.actualDuration !== 0 && (parentFiber.alternate === null || parentFiber.alternate.child !== parentFiber.child));
      for (parentFiber = parentFiber.child;parentFiber !== null; ) {
        var nextSibling = parentFiber.sibling;
        reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, nextSibling !== null ? nextSibling.actualStartTime : endTime);
        parentFiber = nextSibling;
      }
    }
    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality;
      includeWorkInProgressEffects && (finishedWork.mode & 2) !== NoMode && 0 < finishedWork.actualStartTime && (finishedWork.flags & 1) !== 0 && logComponentRender(finishedWork, finishedWork.actualStartTime, endTime, inHydratedSubtree, committedLanes);
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime);
          commitHookPassiveMountEffects(finishedWork, Passive);
          break;
        case 23:
          break;
        case 22:
          var _instance2 = finishedWork.stateNode;
          finishedWork.memoizedState !== null ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime));
          includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
          break;
        case 24:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime);
          includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      alreadyWarnedForDeepEquality = prevDeepEquality;
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, endTime$jscomp$0) {
      if (parentFiber.subtreeFlags & 10256 || parentFiber.actualDuration !== 0 && (parentFiber.alternate === null || parentFiber.alternate.child !== parentFiber.child))
        for (var child = parentFiber.child;child !== null; ) {
          parentFiber = child.sibling;
          var finishedRoot = finishedRoot$jscomp$0, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, endTime = parentFiber !== null ? parentFiber.actualStartTime : endTime$jscomp$0, prevDeepEquality = alreadyWarnedForDeepEquality;
          (child.mode & 2) !== NoMode && 0 < child.actualStartTime && (child.flags & 1) !== 0 && logComponentRender(child, child.actualStartTime, endTime, inHydratedSubtree, committedLanes);
          var flags = child.flags;
          switch (child.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, endTime);
              flags & 2048 && commitOffscreenPassiveMountEffects(child.alternate, child);
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, endTime);
              flags & 2048 && commitCachePassiveMountEffect(child.alternate, child);
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, endTime);
          }
          alreadyWarnedForDeepEquality = prevDeepEquality;
          child = parentFiber;
        }
    }
    function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          accumulateSuspenseyCommitOnFiber(parentFiber, committedLanes, suspendedState), parentFiber = parentFiber.sibling;
    }
    function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
          if (fiber.flags & suspenseyCommitFlag)
            if (fiber.memoizedState !== null)
              suspendResource(suspendedState, currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
            else {
              var { stateNode: instance, type } = fiber;
              fiber = fiber.memoizedProps;
              ((committedLanes & 335544128) === committedLanes || maySuspendCommitInSyncRender(type, fiber)) && suspendInstance(suspendedState, instance, type, fiber);
            }
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
          fiber.flags & suspenseyCommitFlag && (instance = fiber.stateNode, type = fiber.type, fiber = fiber.memoizedProps, ((committedLanes & 335544128) === committedLanes || maySuspendCommitInSyncRender(type, fiber)) && suspendInstance(suspendedState, instance, type, fiber));
          break;
        case 3:
        case 4:
          supportsResources ? (instance = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo), recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState), currentHoistableRoot = instance) : recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
          break;
        case 22:
          fiber.memoizedState === null && (instance = fiber.alternate, instance !== null && instance.memoizedState !== null ? (instance = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState), suspenseyCommitFlag = instance) : recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (previousFiber !== null && (parentFiber = previousFiber.child, parentFiber !== null)) {
        previousFiber.child = null;
        do
          previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
        while (parentFiber !== null);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if ((parentFiber.flags & 16) !== 0) {
        if (deletions !== null)
          for (var i = 0;i < deletions.length; i++) {
            var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
            (childToDelete.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(childToDelete, componentEffectStartTime, componentEffectEndTime, "Unmount");
            popComponentEffectStart(prevEffectStart);
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);
          break;
        case 3:
          var prevProfilerEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);
          break;
        case 12:
          prevProfilerEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevProfilerEffectDuration);
          break;
        case 22:
          prevProfilerEffectDuration = finishedWork.stateNode;
          finishedWork.memoizedState !== null && prevProfilerEffectDuration._visibility & OffscreenPassiveEffectsConnected && (finishedWork.return === null || finishedWork.return.tag !== 13) ? (prevProfilerEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork), (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Disconnect")) : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      componentEffectErrors = prevEffectErrors;
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if ((parentFiber.flags & 16) !== 0) {
        if (deletions !== null)
          for (var i = 0;i < deletions.length; i++) {
            var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
            (childToDelete.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(childToDelete, componentEffectStartTime, componentEffectEndTime, "Unmount");
            popComponentEffectStart(prevEffectStart);
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child;parentFiber !== null; )
        disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
    }
    function disconnectPassiveEffect(finishedWork) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
          break;
        default:
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
      }
      (finishedWork.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      componentEffectErrors = prevEffectErrors;
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor$jscomp$0) {
      for (;nextEffect !== null; ) {
        var fiber = nextEffect, current2 = fiber, nearestMountedAncestor = nearestMountedAncestor$jscomp$0, prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
        switch (current2.tag) {
          case 0:
          case 11:
          case 15:
            commitHookPassiveUnmountEffects(current2, nearestMountedAncestor, Passive);
            break;
          case 23:
          case 22:
            current2.memoizedState !== null && current2.memoizedState.cachePool !== null && (nearestMountedAncestor = current2.memoizedState.cachePool.pool, nearestMountedAncestor != null && retainCache(nearestMountedAncestor));
            break;
          case 24:
            releaseCache(current2.memoizedState.cache);
        }
        (current2.mode & 2) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(current2, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
        popComponentEffectStart(prevEffectStart);
        popComponentEffectDuration(prevEffectDuration);
        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        componentEffectErrors = prevEffectErrors;
        current2 = fiber.child;
        if (current2 !== null)
          current2.return = fiber, nextEffect = current2;
        else
          a:
            for (fiber = deletedSubtreeRoot;nextEffect !== null; ) {
              current2 = nextEffect;
              prevEffectStart = current2.sibling;
              prevEffectDuration = current2.return;
              detachFiberAfterEffects(current2);
              if (current2 === fiber) {
                nextEffect = null;
                break a;
              }
              if (prevEffectStart !== null) {
                prevEffectStart.return = prevEffectDuration;
                nextEffect = prevEffectStart;
                break a;
              }
              nextEffect = prevEffectDuration;
            }
      }
    }
    function findFiberRootForHostRoot(hostRoot) {
      var maybeFiber = getInstanceFromNode(hostRoot);
      if (maybeFiber != null) {
        if (typeof maybeFiber.memoizedProps["data-testname"] !== "string")
          throw Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
        return maybeFiber;
      }
      hostRoot = findFiberRoot(hostRoot);
      if (hostRoot === null)
        throw Error("Could not find React container within specified host subtree.");
      return hostRoot.stateNode.current;
    }
    function matchSelector(fiber$jscomp$0, selector) {
      var tag = fiber$jscomp$0.tag;
      switch (selector.$$typeof) {
        case COMPONENT_TYPE:
          if (fiber$jscomp$0.type === selector.value)
            return true;
          break;
        case HAS_PSEUDO_CLASS_TYPE:
          a: {
            selector = selector.value;
            fiber$jscomp$0 = [fiber$jscomp$0, 0];
            for (tag = 0;tag < fiber$jscomp$0.length; ) {
              var fiber = fiber$jscomp$0[tag++], tag$jscomp$0 = fiber.tag, selectorIndex = fiber$jscomp$0[tag++], selector$jscomp$0 = selector[selectorIndex];
              if (tag$jscomp$0 !== 5 && tag$jscomp$0 !== 26 && tag$jscomp$0 !== 27 || !isHiddenSubtree(fiber)) {
                for (;selector$jscomp$0 != null && matchSelector(fiber, selector$jscomp$0); )
                  selectorIndex++, selector$jscomp$0 = selector[selectorIndex];
                if (selectorIndex === selector.length) {
                  selector = true;
                  break a;
                } else
                  for (fiber = fiber.child;fiber !== null; )
                    fiber$jscomp$0.push(fiber, selectorIndex), fiber = fiber.sibling;
              }
            }
            selector = false;
          }
          return selector;
        case ROLE_TYPE:
          if ((tag === 5 || tag === 26 || tag === 27) && matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value))
            return true;
          break;
        case TEXT_TYPE:
          if (tag === 5 || tag === 6 || tag === 26 || tag === 27) {
            if (fiber$jscomp$0 = getTextContent(fiber$jscomp$0), fiber$jscomp$0 !== null && 0 <= fiber$jscomp$0.indexOf(selector.value))
              return true;
          }
          break;
        case TEST_NAME_TYPE:
          if (tag === 5 || tag === 26 || tag === 27) {
            if (fiber$jscomp$0 = fiber$jscomp$0.memoizedProps["data-testname"], typeof fiber$jscomp$0 === "string" && fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase())
              return true;
          }
          break;
        default:
          throw Error("Invalid selector type specified.");
      }
      return false;
    }
    function selectorToString(selector) {
      switch (selector.$$typeof) {
        case COMPONENT_TYPE:
          return "<" + (getComponentNameFromType(selector.value) || "Unknown") + ">";
        case HAS_PSEUDO_CLASS_TYPE:
          return ":has(" + (selectorToString(selector) || "") + ")";
        case ROLE_TYPE:
          return '[role="' + selector.value + '"]';
        case TEXT_TYPE:
          return '"' + selector.value + '"';
        case TEST_NAME_TYPE:
          return '[data-testname="' + selector.value + '"]';
        default:
          throw Error("Invalid selector type specified.");
      }
    }
    function findPaths(root, selectors) {
      var matchingFibers = [];
      root = [root, 0];
      for (var index = 0;index < root.length; ) {
        var fiber = root[index++], tag = fiber.tag, selectorIndex = root[index++], selector = selectors[selectorIndex];
        if (tag !== 5 && tag !== 26 && tag !== 27 || !isHiddenSubtree(fiber)) {
          for (;selector != null && matchSelector(fiber, selector); )
            selectorIndex++, selector = selectors[selectorIndex];
          if (selectorIndex === selectors.length)
            matchingFibers.push(fiber);
          else
            for (fiber = fiber.child;fiber !== null; )
              root.push(fiber, selectorIndex), fiber = fiber.sibling;
        }
      }
      return matchingFibers;
    }
    function findAllNodes(hostRoot, selectors) {
      if (!supportsTestSelectors)
        throw Error("Test selector API is not supported by this renderer.");
      hostRoot = findFiberRootForHostRoot(hostRoot);
      hostRoot = findPaths(hostRoot, selectors);
      selectors = [];
      hostRoot = Array.from(hostRoot);
      for (var index = 0;index < hostRoot.length; ) {
        var node = hostRoot[index++], tag = node.tag;
        if (tag === 5 || tag === 26 || tag === 27)
          isHiddenSubtree(node) || selectors.push(node.stateNode);
        else
          for (node = node.child;node !== null; )
            hostRoot.push(node), node = node.sibling;
      }
      return selectors;
    }
    function onCommitRoot() {
      supportsTestSelectors && commitHooks.forEach(function(commitHook) {
        return commitHook();
      });
    }
    function isConcurrentActEnvironment() {
      var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : undefined;
      isReactActEnvironmentGlobal || ReactSharedInternals.actQueue === null || console.error("The current testing environment is not configured to support act(...)");
      return isReactActEnvironmentGlobal;
    }
    function requestUpdateLane(fiber) {
      if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== 0)
        return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
      var transition = ReactSharedInternals.T;
      return transition !== null ? (transition._updatedFibers || (transition._updatedFibers = new Set), transition._updatedFibers.add(fiber), requestTransitionLane()) : resolveUpdatePriority();
    }
    function requestDeferredLane() {
      if (workInProgressDeferredLane === 0)
        if ((workInProgressRootRenderLanes & 536870912) === 0 || isHydrating) {
          var lane = nextTransitionDeferredLane;
          nextTransitionDeferredLane <<= 1;
          (nextTransitionDeferredLane & 3932160) === 0 && (nextTransitionDeferredLane = 262144);
          workInProgressDeferredLane = lane;
        } else
          workInProgressDeferredLane = 536870912;
      lane = suspenseHandlerStackCursor.current;
      lane !== null && (lane.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root, fiber, lane) {
      isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
      isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
      if (root === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || root.cancelPendingCommit !== null)
        prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
      markRootUpdated$1(root, lane);
      if ((executionContext & RenderContext) !== NoContext && root === workInProgressRoot) {
        if (isRendering)
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              root = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
              didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render", fiber, root, root));
              break;
            case 1:
              didWarnAboutUpdateInRender || (console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), didWarnAboutUpdateInRender = true);
          }
      } else
        isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, false)), ensureRootIsScheduled(root);
    }
    function performWorkOnRoot(root, lanes, forceSync) {
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw Error("Should not already be working.");
      if (workInProgressRootRenderLanes !== 0 && workInProgress !== null) {
        var yieldedFiber = workInProgress, yieldEndTime = now$1();
        switch (yieldReason) {
          case SuspendedOnImmediate:
          case SuspendedOnData:
            var startTime = yieldStartTime;
            supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(console.timeStamp.bind(console, "Suspended", startTime, yieldEndTime, "Components ", undefined, "primary-light")) : console.timeStamp("Suspended", startTime, yieldEndTime, "Components ", undefined, "primary-light"));
            break;
          case SuspendedOnAction:
            startTime = yieldStartTime;
            supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(console.timeStamp.bind(console, "Action", startTime, yieldEndTime, "Components ", undefined, "primary-light")) : console.timeStamp("Action", startTime, yieldEndTime, "Components ", undefined, "primary-light"));
            break;
          default:
            supportsUserTiming && (yieldedFiber = yieldEndTime - yieldStartTime, 3 > yieldedFiber || console.timeStamp("Blocked", yieldStartTime, yieldEndTime, "Components ", undefined, 5 > yieldedFiber ? "primary-light" : 10 > yieldedFiber ? "primary" : 100 > yieldedFiber ? "primary-dark" : "error"));
        }
      }
      startTime = (forceSync = !forceSync && (lanes & 127) === 0 && (lanes & root.expiredLanes) === 0 || checkIfRootIsPrerendering(root, lanes)) ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, true);
      var renderWasConcurrent = forceSync;
      do {
        if (startTime === RootInProgress) {
          workInProgressRootIsPrerendering && !forceSync && markRootSuspended(root, lanes, 0, false);
          lanes = workInProgressSuspendedReason;
          yieldStartTime = now();
          yieldReason = lanes;
          break;
        } else {
          yieldedFiber = now$1();
          yieldEndTime = root.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(yieldEndTime)) {
            setCurrentTrackFromLanes(lanes);
            yieldEndTime = renderStartTime;
            startTime = yieldedFiber;
            !supportsUserTiming || startTime <= yieldEndTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(console.timeStamp.bind(console, "Teared Render", yieldEndTime, startTime, currentTrack, "Scheduler ", "error")) : console.timeStamp("Teared Render", yieldEndTime, startTime, currentTrack, "Scheduler ", "error"));
            finalizeRender(lanes, yieldedFiber);
            startTime = renderRootSync(root, lanes, false);
            renderWasConcurrent = false;
            continue;
          }
          if (startTime === RootErrored) {
            renderWasConcurrent = lanes;
            if (root.errorRecoveryDisabledLanes & renderWasConcurrent)
              var errorRetryLanes = 0;
            else
              errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = errorRetryLanes !== 0 ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
            if (errorRetryLanes !== 0) {
              setCurrentTrackFromLanes(lanes);
              logErroredRenderPhase(renderStartTime, yieldedFiber, lanes, workInProgressUpdateTask);
              finalizeRender(lanes, yieldedFiber);
              lanes = errorRetryLanes;
              a: {
                yieldedFiber = root;
                startTime = renderWasConcurrent;
                renderWasConcurrent = workInProgressRootConcurrentErrors;
                var wasRootDehydrated = supportsHydration && yieldedFiber.current.memoizedState.isDehydrated;
                wasRootDehydrated && (prepareFreshStack(yieldedFiber, errorRetryLanes).flags |= 256);
                errorRetryLanes = renderRootSync(yieldedFiber, errorRetryLanes, false);
                if (errorRetryLanes !== RootErrored) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    yieldedFiber.errorRecoveryDisabledLanes |= startTime;
                    workInProgressRootInterleavedUpdatedLanes |= startTime;
                    startTime = RootSuspendedWithDelay;
                    break a;
                  }
                  yieldedFiber = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = renderWasConcurrent;
                  yieldedFiber !== null && (workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = yieldedFiber : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, yieldedFiber));
                }
                startTime = errorRetryLanes;
              }
              renderWasConcurrent = false;
              if (startTime !== RootErrored)
                continue;
              else
                yieldedFiber = now$1();
            }
          }
          if (startTime === RootFatalErrored) {
            setCurrentTrackFromLanes(lanes);
            logErroredRenderPhase(renderStartTime, yieldedFiber, lanes, workInProgressUpdateTask);
            finalizeRender(lanes, yieldedFiber);
            prepareFreshStack(root, 0);
            markRootSuspended(root, lanes, 0, true);
            break;
          }
          a: {
            forceSync = root;
            switch (startTime) {
              case RootInProgress:
              case RootFatalErrored:
                throw Error("Root did not complete. This is a bug in React.");
              case RootSuspendedWithDelay:
                if ((lanes & 4194048) !== lanes)
                  break;
              case RootSuspendedAtTheShell:
                setCurrentTrackFromLanes(lanes);
                logSuspendedRenderPhase(renderStartTime, yieldedFiber, lanes, workInProgressUpdateTask);
                finalizeRender(lanes, yieldedFiber);
                yieldEndTime = lanes;
                (yieldEndTime & 127) !== 0 ? blockingSuspendedTime = yieldedFiber : (yieldEndTime & 4194048) !== 0 && (transitionSuspendedTime = yieldedFiber);
                markRootSuspended(forceSync, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                break a;
              case RootErrored:
                workInProgressRootRecoverableErrors = null;
                break;
              case RootSuspended:
              case RootCompleted:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (ReactSharedInternals.actQueue !== null)
              commitRoot(forceSync, yieldEndTime, lanes, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, startTime, null, null, renderStartTime, yieldedFiber);
            else {
              if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                markRootSuspended(forceSync, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                if (getNextLanes(forceSync, 0, true) !== 0)
                  break a;
                pendingEffectsLanes = lanes;
                forceSync.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, forceSync, yieldEndTime, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, startTime, "Throttled", renderStartTime, yieldedFiber), renderWasConcurrent);
                break a;
              }
              commitRootWhenReady(forceSync, yieldEndTime, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, startTime, null, renderStartTime, yieldedFiber);
            }
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root);
    }
    function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root.timeoutHandle = noTimeout;
      var subtreeFlags = finishedWork.subtreeFlags, suspendedState = null;
      if (subtreeFlags & 8192 || (subtreeFlags & 16785408) === 16785408) {
        if (suspendedState = startSuspendingCommit(), accumulateSuspenseyCommitOnFiber(finishedWork, lanes, suspendedState), subtreeFlags = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now$1() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now$1() : 0, subtreeFlags = waitForCommitToBeReady(suspendedState, subtreeFlags), subtreeFlags !== null) {
          pendingEffectsLanes = lanes;
          root.cancelPendingCommit = subtreeFlags(commitRoot.bind(null, root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, getSuspendedCommitReason(suspendedState, root.containerInfo), completedRenderStartTime, completedRenderEndTime));
          markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
          return;
        }
      }
      commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node = finishedWork;; ) {
        var tag = node.tag;
        if ((tag === 0 || tag === 11 || tag === 15) && node.flags & 16384 && (tag = node.updateQueue, tag !== null && (tag = tag.stores, tag !== null)))
          for (var i = 0;i < tag.length; i++) {
            var check2 = tag[i], getSnapshot = check2.getSnapshot;
            check2 = check2.value;
            try {
              if (!objectIs(getSnapshot(), check2))
                return false;
            } catch (error) {
              return false;
            }
          }
        tag = node.child;
        if (node.subtreeFlags & 16384 && tag !== null)
          tag.return = node, node = tag;
        else {
          if (node === finishedWork)
            break;
          for (;node.sibling === null; ) {
            if (node.return === null || node.return === finishedWork)
              return true;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return true;
    }
    function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root.suspendedLanes |= suspendedLanes;
      root.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root.expirationTimes;
      for (var lanes = suspendedLanes;0 < lanes; ) {
        var index = 31 - clz32(lanes), lane = 1 << index;
        didAttemptEntireTree[index] = -1;
        lanes &= ~lane;
      }
      spawnedLane !== 0 && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
    }
    function flushSyncWork() {
      return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
    }
    function isAlreadyRendering() {
      return (executionContext & (RenderContext | CommitContext)) !== NoContext;
    }
    function resetWorkInProgressStack() {
      if (workInProgress !== null) {
        if (workInProgressSuspendedReason === NotSuspended)
          var interruptedWork = workInProgress.return;
        else
          interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
        for (;interruptedWork !== null; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
        workInProgress = null;
      }
    }
    function finalizeRender(lanes, finalizationTime) {
      (lanes & 127) !== 0 && (blockingClampTime = finalizationTime);
      (lanes & 4194048) !== 0 && (transitionClampTime = finalizationTime);
    }
    function prepareFreshStack(root, lanes) {
      supportsUserTiming && (console.timeStamp("Blocking Track", 0.003, 0.003, "Blocking", "Scheduler ", "primary-light"), console.timeStamp("Transition Track", 0.003, 0.003, "Transition", "Scheduler ", "primary-light"), console.timeStamp("Suspense Track", 0.003, 0.003, "Suspense", "Scheduler ", "primary-light"), console.timeStamp("Idle Track", 0.003, 0.003, "Idle", "Scheduler ", "primary-light"));
      var previousRenderStartTime = renderStartTime;
      renderStartTime = now();
      if (workInProgressRootRenderLanes !== 0 && 0 < previousRenderStartTime) {
        setCurrentTrackFromLanes(workInProgressRootRenderLanes);
        if (workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootSuspendedWithDelay)
          logSuspendedRenderPhase(previousRenderStartTime, renderStartTime, lanes, workInProgressUpdateTask);
        else {
          var endTime = renderStartTime, debugTask = workInProgressUpdateTask;
          if (supportsUserTiming && !(endTime <= previousRenderStartTime)) {
            var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", label = (lanes & 536870912) === lanes ? "Prewarm" : (lanes & 201326741) === lanes ? "Interrupted Hydration" : "Interrupted Render";
            debugTask ? debugTask.run(console.timeStamp.bind(console, label, previousRenderStartTime, endTime, currentTrack, "Scheduler ", color)) : console.timeStamp(label, previousRenderStartTime, endTime, currentTrack, "Scheduler ", color);
          }
        }
        finalizeRender(workInProgressRootRenderLanes, renderStartTime);
      }
      previousRenderStartTime = workInProgressUpdateTask;
      workInProgressUpdateTask = null;
      if ((lanes & 127) !== 0) {
        workInProgressUpdateTask = blockingUpdateTask;
        debugTask = 0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime ? blockingClampTime : blockingUpdateTime;
        endTime = 0 <= blockingEventTime && blockingEventTime < blockingClampTime ? blockingClampTime : blockingEventTime;
        color = 0 <= endTime ? endTime : 0 <= debugTask ? debugTask : renderStartTime;
        0 <= blockingSuspendedTime && (setCurrentTrackFromLanes(2), logSuspendedWithDelayPhase(blockingSuspendedTime, color, lanes, previousRenderStartTime));
        previousRenderStartTime = debugTask;
        var eventTime = endTime, eventType = blockingEventType, eventIsRepeat = 0 < blockingEventRepeatTime, isSpawnedUpdate = blockingUpdateType === 1, isPingedUpdate = blockingUpdateType === 2;
        debugTask = renderStartTime;
        endTime = blockingUpdateTask;
        color = blockingUpdateMethodName;
        label = blockingUpdateComponentName;
        if (supportsUserTiming) {
          currentTrack = "Blocking";
          0 < previousRenderStartTime ? previousRenderStartTime > debugTask && (previousRenderStartTime = debugTask) : previousRenderStartTime = debugTask;
          0 < eventTime ? eventTime > previousRenderStartTime && (eventTime = previousRenderStartTime) : eventTime = previousRenderStartTime;
          if (eventType !== null && previousRenderStartTime > eventTime) {
            var color$jscomp$0 = eventIsRepeat ? "secondary-light" : "warning";
            endTime ? endTime.run(console.timeStamp.bind(console, eventIsRepeat ? "Consecutive" : "Event: " + eventType, eventTime, previousRenderStartTime, currentTrack, "Scheduler ", color$jscomp$0)) : console.timeStamp(eventIsRepeat ? "Consecutive" : "Event: " + eventType, eventTime, previousRenderStartTime, currentTrack, "Scheduler ", color$jscomp$0);
          }
          debugTask > previousRenderStartTime && (eventTime = isSpawnedUpdate ? "error" : (lanes & 738197653) === lanes ? "tertiary-light" : "primary-light", isSpawnedUpdate = isPingedUpdate ? "Promise Resolved" : isSpawnedUpdate ? "Cascading Update" : 5 < debugTask - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], label != null && isPingedUpdate.push(["Component name", label]), color != null && isPingedUpdate.push(["Method name", color]), previousRenderStartTime = {
            start: previousRenderStartTime,
            end: debugTask,
            detail: {
              devtools: {
                properties: isPingedUpdate,
                track: currentTrack,
                trackGroup: "Scheduler ",
                color: eventTime
              }
            }
          }, endTime ? endTime.run(performance.measure.bind(performance, isSpawnedUpdate, previousRenderStartTime)) : performance.measure(isSpawnedUpdate, previousRenderStartTime));
        }
        blockingUpdateTime = -1.1;
        blockingUpdateType = 0;
        blockingUpdateComponentName = blockingUpdateMethodName = null;
        blockingSuspendedTime = -1.1;
        blockingEventRepeatTime = blockingEventTime;
        blockingEventTime = -1.1;
        blockingClampTime = now();
      }
      (lanes & 4194048) !== 0 && (workInProgressUpdateTask = transitionUpdateTask, debugTask = 0 <= transitionStartTime && transitionStartTime < transitionClampTime ? transitionClampTime : transitionStartTime, previousRenderStartTime = 0 <= transitionUpdateTime && transitionUpdateTime < transitionClampTime ? transitionClampTime : transitionUpdateTime, endTime = 0 <= transitionEventTime && transitionEventTime < transitionClampTime ? transitionClampTime : transitionEventTime, color = 0 <= endTime ? endTime : 0 <= previousRenderStartTime ? previousRenderStartTime : renderStartTime, 0 <= transitionSuspendedTime && (setCurrentTrackFromLanes(256), logSuspendedWithDelayPhase(transitionSuspendedTime, color, lanes, workInProgressUpdateTask)), isPingedUpdate = endTime, eventTime = transitionEventType, eventType = 0 < transitionEventRepeatTime, eventIsRepeat = transitionUpdateType === 2, color = renderStartTime, endTime = transitionUpdateTask, label = transitionUpdateMethodName, isSpawnedUpdate = transitionUpdateComponentName, supportsUserTiming && (currentTrack = "Transition", 0 < previousRenderStartTime ? previousRenderStartTime > color && (previousRenderStartTime = color) : previousRenderStartTime = color, 0 < debugTask ? debugTask > previousRenderStartTime && (debugTask = previousRenderStartTime) : debugTask = previousRenderStartTime, 0 < isPingedUpdate ? isPingedUpdate > debugTask && (isPingedUpdate = debugTask) : isPingedUpdate = debugTask, debugTask > isPingedUpdate && eventTime !== null && (color$jscomp$0 = eventType ? "secondary-light" : "warning", endTime ? endTime.run(console.timeStamp.bind(console, eventType ? "Consecutive" : "Event: " + eventTime, isPingedUpdate, debugTask, currentTrack, "Scheduler ", color$jscomp$0)) : console.timeStamp(eventType ? "Consecutive" : "Event: " + eventTime, isPingedUpdate, debugTask, currentTrack, "Scheduler ", color$jscomp$0)), previousRenderStartTime > debugTask && (endTime ? endTime.run(console.timeStamp.bind(console, "Action", debugTask, previousRenderStartTime, currentTrack, "Scheduler ", "primary-dark")) : console.timeStamp("Action", debugTask, previousRenderStartTime, currentTrack, "Scheduler ", "primary-dark")), color > previousRenderStartTime && (debugTask = eventIsRepeat ? "Promise Resolved" : 5 < color - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], isSpawnedUpdate != null && isPingedUpdate.push(["Component name", isSpawnedUpdate]), label != null && isPingedUpdate.push(["Method name", label]), previousRenderStartTime = {
        start: previousRenderStartTime,
        end: color,
        detail: {
          devtools: {
            properties: isPingedUpdate,
            track: currentTrack,
            trackGroup: "Scheduler ",
            color: "primary-light"
          }
        }
      }, endTime ? endTime.run(performance.measure.bind(performance, debugTask, previousRenderStartTime)) : performance.measure(debugTask, previousRenderStartTime))), transitionUpdateTime = transitionStartTime = -1.1, transitionUpdateType = 0, transitionSuspendedTime = -1.1, transitionEventRepeatTime = transitionEventTime, transitionEventTime = -1.1, transitionClampTime = now());
      previousRenderStartTime = root.timeoutHandle;
      previousRenderStartTime !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(previousRenderStartTime));
      previousRenderStartTime = root.cancelPendingCommit;
      previousRenderStartTime !== null && (root.cancelPendingCommit = null, previousRenderStartTime());
      pendingEffectsLanes = 0;
      resetWorkInProgressStack();
      workInProgressRoot = root;
      workInProgress = previousRenderStartTime = createWorkInProgress(root.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = NotSuspended;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = false;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
      workInProgressRootDidAttachPingListener = false;
      workInProgressRootExitStatus = RootInProgress;
      workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      (lanes & 8) !== 0 && (lanes |= lanes & 32);
      endTime = root.entangledLanes;
      if (endTime !== 0)
        for (root = root.entanglements, endTime &= lanes;0 < endTime; )
          debugTask = 31 - clz32(endTime), color = 1 << debugTask, lanes |= root[debugTask], endTime &= ~color;
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      root = getCurrentTime();
      1000 < root - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = root);
      ReactStrictModeWarnings.discardPendingWarnings();
      return previousRenderStartTime;
    }
    function handleThrow(root, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      ReactSharedInternals.getCurrentStack = null;
      isRendering = false;
      current = null;
      thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function" ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
      workInProgressThrownValue = thrownValue;
      var erroredWork = workInProgress;
      erroredWork === null ? (workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current))) : erroredWork.mode & 2 && stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
    }
    function shouldRemainOnPreviousScreen() {
      var handler = suspenseHandlerStackCursor.current;
      return handler === null ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? shellBoundary === null ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || (workInProgressRootRenderLanes & 536870912) !== 0 ? handler === shellBoundary : false;
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return prevDispatcher === null ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function markRenderDerivedCause(fiber) {
      workInProgressUpdateTask === null && (workInProgressUpdateTask = fiber._debugTask == null ? null : fiber._debugTask);
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = RootSuspendedWithDelay;
      workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && suspenseHandlerStackCursor.current !== null || (workInProgressRootIsPrerendering = true);
      (workInProgressRootSkippedLanes & 134217727) === 0 && (workInProgressRootInterleavedUpdatedLanes & 134217727) === 0 || workInProgressRoot === null || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
    }
    function renderRootSync(root, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        prepareFreshStack(root, lanes);
      }
      lanes = false;
      memoizedUpdaters = workInProgressRootExitStatus;
      a:
        do
          try {
            if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case SuspendedOnHydration:
                  resetWorkInProgressStack();
                  memoizedUpdaters = RootSuspendedAtTheShell;
                  break a;
                case SuspendedOnImmediate:
                case SuspendedOnData:
                case SuspendedOnAction:
                case SuspendedOnDeprecatedThrowPromise:
                  suspenseHandlerStackCursor.current === null && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    memoizedUpdaters = RootInProgress;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            memoizedUpdaters = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$4) {
            handleThrow(root, thrownValue$4);
          }
        while (1);
      lanes && root.shellSuspendCounter++;
      resetContextDependencies();
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      workInProgress === null && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
      return memoizedUpdaters;
    }
    function workLoopSync() {
      for (;workInProgress !== null; )
        performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
        prepareFreshStack(root, lanes);
      } else
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
      a:
        do
          try {
            if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null)
              b:
                switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                  case SuspendedOnError:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);
                    break;
                  case SuspendedOnData:
                  case SuspendedOnAction:
                    if (isThenableResolved(memoizedUpdaters)) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function() {
                      workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                      ensureRootIsScheduled(root);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                  case SuspendedOnImmediate:
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                  case SuspendedOnInstance:
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                  case SuspendedAndReadyToContinue:
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));
                    break;
                  case SuspendedOnInstanceAndReadyToContinue:
                    var resource = null;
                    switch (workInProgress.tag) {
                      case 26:
                        resource = workInProgress.memoizedState;
                      case 5:
                      case 27:
                        var hostFiber = workInProgress, type = hostFiber.type, props = hostFiber.pendingProps;
                        if (resource ? preloadResource(resource) : preloadInstance(hostFiber.stateNode, type, props)) {
                          workInProgressSuspendedReason = NotSuspended;
                          workInProgressThrownValue = null;
                          var sibling = hostFiber.sibling;
                          if (sibling !== null)
                            workInProgress = sibling;
                          else {
                            var returnFiber = hostFiber.return;
                            returnFiber !== null ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                          }
                          break b;
                        }
                        break;
                      default:
                        console.error("Unexpected type of fiber triggered a suspensey commit. This is a bug in React.");
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);
                    break;
                  case SuspendedOnDeprecatedThrowPromise:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);
                    break;
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootSuspendedAtTheShell;
                    break a;
                  default:
                    throw Error("Unexpected SuspendedReason. This is a bug in React.");
                }
            ReactSharedInternals.actQueue !== null ? workLoopSync() : workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$5) {
            handleThrow(root, thrownValue$5);
          }
        while (1);
      resetContextDependencies();
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (workInProgress !== null)
        return RootInProgress;
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrentByScheduler() {
      for (;workInProgress !== null && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var current2 = unitOfWork.alternate;
      (unitOfWork.mode & 2) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(unitOfWork, beginWork, current2, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(unitOfWork, beginWork, current2, unitOfWork, entangledRenderLanes);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      current2 === null ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      next === null ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    function replayBeginWork(unitOfWork) {
      var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & 2) !== NoMode;
      isProfilingMode && startProfilerTimer(unitOfWork);
      switch (unitOfWork.tag) {
        case 15:
        case 0:
          current2 = replayFunctionComponent(current2, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, undefined, workInProgressRootRenderLanes);
          break;
        case 11:
          current2 = replayFunctionComponent(current2, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);
          break;
        case 5:
          resetHooksOnUnwind(unitOfWork);
        default:
          unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
      }
      isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
      return current2;
    }
    function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
      resetContextDependencies();
      resetHooksOnUnwind(unitOfWork);
      thenableState$1 = null;
      thenableIndexCounter$1 = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
          workInProgressRootExitStatus = RootFatalErrored;
          logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (returnFiber !== null)
          throw workInProgress = returnFiber, error;
        workInProgressRootExitStatus = RootFatalErrored;
        logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || suspendedReason === SuspendedOnError)
          root = true;
        else if (workInProgressRootIsPrerendering || (workInProgressRootRenderLanes & 536870912) !== 0)
          root = false;
        else if (workInProgressRootDidSkipSuspendedSiblings = root = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
          suspendedReason = suspenseHandlerStackCursor.current, suspendedReason !== null && suspendedReason.tag === 13 && (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root);
      } else
        completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if ((completedWork.flags & 32768) !== 0) {
          unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
          return;
        }
        var current2 = completedWork.alternate;
        unitOfWork = completedWork.return;
        startProfilerTimer(completedWork);
        current2 = runWithFiberInDEV(completedWork, completeWork, current2, completedWork, entangledRenderLanes);
        (completedWork.mode & 2) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
        if (current2 !== null) {
          workInProgress = current2;
          return;
        }
        completedWork = completedWork.sibling;
        if (completedWork !== null) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (completedWork !== null);
      workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (next !== null) {
          next.flags &= 32767;
          workInProgress = next;
          return;
        }
        if ((unitOfWork.mode & 2) !== NoMode) {
          stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
          next = unitOfWork.actualDuration;
          for (var child = unitOfWork.child;child !== null; )
            next += child.actualDuration, child = child.sibling;
          unitOfWork.actualDuration = next;
        }
        next = unitOfWork.return;
        next !== null && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
        if (!skipSiblings && (unitOfWork = unitOfWork.sibling, unitOfWork !== null)) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (unitOfWork !== null);
      workInProgressRootExitStatus = RootSuspendedAtTheShell;
      workInProgress = null;
    }
    function commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root.cancelPendingCommit = null;
      do
        flushPendingEffects();
      while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
      ReactStrictModeWarnings.flushLegacyContextWarning();
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw Error("Should not already be working.");
      setCurrentTrackFromLanes(lanes);
      exitStatus === RootErrored ? logErroredRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes, workInProgressUpdateTask) : recoverableErrors !== null ? logRecoveredRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes, recoverableErrors, finishedWork !== null && finishedWork.alternate !== null && finishedWork.alternate.memoizedState.isDehydrated && (finishedWork.flags & 256) !== 0, workInProgressUpdateTask) : logRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes, workInProgressUpdateTask);
      if (finishedWork !== null) {
        lanes === 0 && console.error("finishedLanes should not be empty during a commit. This is a bug in React.");
        if (finishedWork === root.current)
          throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
        didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(root, lanes, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
        root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        pendingEffectsRenderEndTime = completedRenderEndTime;
        pendingSuspendedCommitReason = suspendedCommitReason;
        pendingDelayedCommitReason = IMMEDIATE_COMMIT;
        pendingSuspendedViewTransitionReason = null;
        finishedWork.actualDuration !== 0 || (finishedWork.subtreeFlags & 10256) !== 0 || (finishedWork.flags & 10256) !== 0 ? (root.callbackNode = null, root.callbackPriority = 0, scheduleCallback(NormalPriority$1, function() {
          trackSchedulerEvent();
          pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
          flushPassiveEffects();
          return null;
        })) : (root.callbackNode = null, root.callbackPriority = 0);
        commitErrors = null;
        commitStartTime = now();
        suspendedCommitReason !== null && logSuspendedCommitPhase(completedRenderEndTime, commitStartTime, suspendedCommitReason, workInProgressUpdateTask);
        recoverableErrors = (finishedWork.flags & 13878) !== 0;
        if ((finishedWork.subtreeFlags & 13878) !== 0 || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = getCurrentUpdatePriority();
          setCurrentUpdatePriority(2);
          spawnedLane = executionContext;
          executionContext |= CommitContext;
          try {
            commitBeforeMutationEffects(root, finishedWork, lanes);
          } finally {
            executionContext = spawnedLane, setCurrentUpdatePriority(transitions), ReactSharedInternals.T = recoverableErrors;
          }
        }
        pendingEffectsStatus = PENDING_MUTATION_PHASE;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    function flushMutationEffects() {
      if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = (finishedWork.flags & 13878) !== 0;
        if ((finishedWork.subtreeFlags & 13878) !== 0 || rootMutationHasEffect) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(2);
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            inProgressLanes = lanes, inProgressRoot = root, resetComponentEffectTimers(), commitMutationEffectsOnFiber(finishedWork, root), inProgressRoot = inProgressLanes = null, resetAfterCommit(root.containerInfo);
          } finally {
            executionContext = prevExecutionContext, setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = rootMutationHasEffect;
          }
        }
        root.current = finishedWork;
        pendingEffectsStatus = PENDING_LAYOUT_PHASE;
      }
    }
    function flushLayoutEffects() {
      if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        var suspendedViewTransitionReason = pendingSuspendedViewTransitionReason;
        if (suspendedViewTransitionReason !== null) {
          commitStartTime = now();
          var startTime = commitEndTime, endTime = commitStartTime;
          !supportsUserTiming || endTime <= startTime || (animatingTask ? animatingTask.run(console.timeStamp.bind(console, suspendedViewTransitionReason, startTime, endTime, currentTrack, "Scheduler ", "secondary-light")) : console.timeStamp(suspendedViewTransitionReason, startTime, endTime, currentTrack, "Scheduler ", "secondary-light"));
        }
        suspendedViewTransitionReason = pendingEffectsRoot;
        startTime = pendingFinishedWork;
        endTime = pendingEffectsLanes;
        var rootHasLayoutEffect = (startTime.flags & 8772) !== 0;
        if ((startTime.subtreeFlags & 8772) !== 0 || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var _previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(2);
          var _prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            inProgressLanes = endTime, inProgressRoot = suspendedViewTransitionReason, resetComponentEffectTimers(), commitLayoutEffectOnFiber(suspendedViewTransitionReason, startTime.alternate, startTime), inProgressRoot = inProgressLanes = null;
          } finally {
            executionContext = _prevExecutionContext, setCurrentUpdatePriority(_previousPriority), ReactSharedInternals.T = rootHasLayoutEffect;
          }
        }
        suspendedViewTransitionReason = pendingEffectsRenderEndTime;
        startTime = pendingSuspendedCommitReason;
        commitEndTime = now();
        suspendedViewTransitionReason = startTime === null ? suspendedViewTransitionReason : commitStartTime;
        startTime = commitEndTime;
        endTime = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
        rootHasLayoutEffect = workInProgressUpdateTask;
        commitErrors !== null ? logCommitErrored(suspendedViewTransitionReason, startTime, commitErrors, false, rootHasLayoutEffect) : !supportsUserTiming || startTime <= suspendedViewTransitionReason || (rootHasLayoutEffect ? rootHasLayoutEffect.run(console.timeStamp.bind(console, endTime ? "Commit Interrupted View Transition" : "Commit", suspendedViewTransitionReason, startTime, currentTrack, "Scheduler ", endTime ? "error" : "secondary-dark")) : console.timeStamp(endTime ? "Commit Interrupted View Transition" : "Commit", suspendedViewTransitionReason, startTime, currentTrack, "Scheduler ", endTime ? "error" : "secondary-dark"));
        pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
      }
    }
    function flushSpawnedWork() {
      if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
        if (pendingEffectsStatus === PENDING_SPAWNED_WORK) {
          var startViewTransitionStartTime = commitEndTime;
          commitEndTime = now();
          var endTime = commitEndTime, abortedViewTransition = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
          !supportsUserTiming || endTime <= startViewTransitionStartTime || (animatingTask ? animatingTask.run(console.timeStamp.bind(console, abortedViewTransition ? "Interrupted View Transition" : "Starting Animation", startViewTransitionStartTime, endTime, currentTrack, "Scheduler ", abortedViewTransition ? "error" : "secondary-light")) : console.timeStamp(abortedViewTransition ? "Interrupted View Transition" : "Starting Animation", startViewTransitionStartTime, endTime, currentTrack, "Scheduler ", abortedViewTransition ? " error" : "secondary-light"));
          pendingDelayedCommitReason !== ABORTED_VIEW_TRANSITION_COMMIT && (pendingDelayedCommitReason = ANIMATION_STARTED_COMMIT);
        }
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        requestPaint();
        startViewTransitionStartTime = pendingEffectsRoot;
        var finishedWork = pendingFinishedWork;
        endTime = pendingEffectsLanes;
        abortedViewTransition = pendingRecoverableErrors;
        var rootDidHavePassiveEffects = finishedWork.actualDuration !== 0 || (finishedWork.subtreeFlags & 10256) !== 0 || (finishedWork.flags & 10256) !== 0;
        rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(startViewTransitionStartTime, startViewTransitionStartTime.pendingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
        var remainingLanes = startViewTransitionStartTime.pendingLanes;
        remainingLanes === 0 && (legacyErrorBoundariesThatAlreadyFailed = null);
        rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(startViewTransitionStartTime);
        remainingLanes = lanesToEventPriority(endTime);
        finishedWork = finishedWork.stateNode;
        if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function")
          try {
            var didError = (finishedWork.current.flags & 128) === 128;
            switch (remainingLanes) {
              case 2:
                var schedulerPriority = ImmediatePriority;
                break;
              case 8:
                schedulerPriority = UserBlockingPriority;
                break;
              case 32:
                schedulerPriority = NormalPriority$1;
                break;
              case 268435456:
                schedulerPriority = IdlePriority;
                break;
              default:
                schedulerPriority = NormalPriority$1;
            }
            injectedHook.onCommitFiberRoot(rendererID, finishedWork, schedulerPriority, didError);
          } catch (err) {
            hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
          }
        isDevToolsPresent && startViewTransitionStartTime.memoizedUpdaters.clear();
        onCommitRoot();
        if (abortedViewTransition !== null) {
          didError = ReactSharedInternals.T;
          schedulerPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(2);
          ReactSharedInternals.T = null;
          try {
            var onRecoverableError = startViewTransitionStartTime.onRecoverableError;
            for (finishedWork = 0;finishedWork < abortedViewTransition.length; finishedWork++) {
              var recoverableError = abortedViewTransition[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
              runWithFiberInDEV(recoverableError.source, onRecoverableError, recoverableError.value, errorInfo);
            }
          } finally {
            ReactSharedInternals.T = didError, setCurrentUpdatePriority(schedulerPriority);
          }
        }
        (pendingEffectsLanes & 3) !== 0 && flushPendingEffects();
        ensureRootIsScheduled(startViewTransitionStartTime);
        remainingLanes = startViewTransitionStartTime.pendingLanes;
        (endTime & 261930) !== 0 && (remainingLanes & 42) !== 0 ? (nestedUpdateScheduled = true, startViewTransitionStartTime === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = startViewTransitionStartTime)) : nestedUpdateCount = 0;
        rootDidHavePassiveEffects || finalizeRender(endTime, commitEndTime);
        supportsHydration && flushHydrationEvents();
        flushSyncWorkAcrossRoots_impl(0, false);
      }
    }
    function makeErrorInfo(componentStack) {
      componentStack = { componentStack };
      Object.defineProperty(componentStack, "digest", {
        get: function() {
          console.error('You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');
        }
      });
      return componentStack;
    }
    function releaseRootPooledCache(root, remainingLanes) {
      (root.pooledCacheLanes &= remainingLanes) === 0 && (remainingLanes = root.pooledCache, remainingLanes != null && (root.pooledCache = null, releaseCache(remainingLanes)));
    }
    function flushPendingEffects() {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects();
    }
    function flushPassiveEffects() {
      if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
        return false;
      var root = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 32 > renderPriority ? 32 : renderPriority;
      renderPriority = ReactSharedInternals.T;
      var previousPriority = getCurrentUpdatePriority();
      try {
        setCurrentUpdatePriority(priority);
        ReactSharedInternals.T = null;
        var transitions = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        priority = pendingEffectsRoot;
        var lanes = pendingEffectsLanes;
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw Error("Cannot flush passive effects while already rendering.");
        setCurrentTrackFromLanes(lanes);
        isFlushingPassiveEffects = true;
        didScheduleUpdateDuringPassiveEffects = false;
        var passiveEffectStartTime = 0;
        commitErrors = null;
        passiveEffectStartTime = now$1();
        if (pendingDelayedCommitReason === ANIMATION_STARTED_COMMIT) {
          var startTime = commitEndTime, endTime = passiveEffectStartTime;
          !supportsUserTiming || endTime <= startTime || (animatingTask ? animatingTask.run(console.timeStamp.bind(console, "Animating", startTime, endTime, currentTrack, "Scheduler ", "secondary-dark")) : console.timeStamp("Animating", startTime, endTime, currentTrack, "Scheduler ", "secondary-dark"));
        } else {
          startTime = commitEndTime;
          endTime = passiveEffectStartTime;
          var delayedUntilPaint = pendingDelayedCommitReason === DELAYED_PASSIVE_COMMIT;
          !supportsUserTiming || endTime <= startTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(console.timeStamp.bind(console, delayedUntilPaint ? "Waiting for Paint" : "Waiting", startTime, endTime, currentTrack, "Scheduler ", "secondary-light")) : console.timeStamp(delayedUntilPaint ? "Waiting for Paint" : "Waiting", startTime, endTime, currentTrack, "Scheduler ", "secondary-light"));
        }
        startTime = executionContext;
        executionContext |= CommitContext;
        var finishedWork = priority.current;
        resetComponentEffectTimers();
        commitPassiveUnmountOnFiber(finishedWork);
        var finishedWork$jscomp$0 = priority.current;
        finishedWork = pendingEffectsRenderEndTime;
        resetComponentEffectTimers();
        commitPassiveMountOnFiber(priority, finishedWork$jscomp$0, lanes, transitions, finishedWork);
        commitDoubleInvokeEffectsInDEV(priority);
        executionContext = startTime;
        var passiveEffectsEndTime = now$1();
        finishedWork$jscomp$0 = passiveEffectStartTime;
        finishedWork = workInProgressUpdateTask;
        commitErrors !== null ? logCommitErrored(finishedWork$jscomp$0, passiveEffectsEndTime, commitErrors, true, finishedWork) : !supportsUserTiming || passiveEffectsEndTime <= finishedWork$jscomp$0 || (finishedWork ? finishedWork.run(console.timeStamp.bind(console, "Remaining Effects", finishedWork$jscomp$0, passiveEffectsEndTime, currentTrack, "Scheduler ", "secondary-dark")) : console.timeStamp("Remaining Effects", finishedWork$jscomp$0, passiveEffectsEndTime, currentTrack, "Scheduler ", "secondary-dark"));
        finalizeRender(lanes, passiveEffectsEndTime);
        flushSyncWorkAcrossRoots_impl(0, false);
        didScheduleUpdateDuringPassiveEffects ? priority === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = priority) : nestedPassiveUpdateCount = 0;
        didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
        if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function")
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, priority);
          } catch (err) {
            hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
          }
        var stateNode = priority.current.stateNode;
        stateNode.effectDuration = 0;
        stateNode.passiveEffectDuration = 0;
        return true;
      } finally {
        setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      recordEffectError(sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      rootFiber !== null && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      isRunningInsertionEffect = false;
      if (sourceFiber.tag === 3)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else {
        for (;nearestMountedAncestor !== null; ) {
          if (nearestMountedAncestor.tag === 3) {
            captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
            return;
          }
          if (nearestMountedAncestor.tag === 1) {
            var instance = nearestMountedAncestor.stateNode;
            if (typeof nearestMountedAncestor.type.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              recordEffectError(sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              instance !== null && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
              return;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
        console.error(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, error);
      }
    }
    function attachPingListener(root, wakeable, lanes) {
      var pingCache = root.pingCache;
      if (pingCache === null) {
        pingCache = root.pingCache = new PossiblyWeakMap;
        var threadIDs = new Set;
        pingCache.set(wakeable, threadIDs);
      } else
        threadIDs = pingCache.get(wakeable), threadIDs === undefined && (threadIDs = new Set, pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));
    }
    function pingSuspendedRoot(root, wakeable, pingedLanes) {
      var pingCache = root.pingCache;
      pingCache !== null && pingCache.delete(wakeable);
      root.pingedLanes |= root.suspendedLanes & pingedLanes;
      root.warmLanes &= ~pingedLanes;
      (pingedLanes & 127) !== 0 ? 0 > blockingUpdateTime && (blockingClampTime = blockingUpdateTime = now(), blockingUpdateTask = createTask("Promise Resolved"), blockingUpdateType = 2) : (pingedLanes & 4194048) !== 0 && 0 > transitionUpdateTime && (transitionClampTime = transitionUpdateTime = now(), transitionUpdateTask = createTask("Promise Resolved"), transitionUpdateType = 2);
      isConcurrentActEnvironment() && ReactSharedInternals.actQueue === null && console.error(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`);
      workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      retryLane === 0 && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      boundaryFiber !== null && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
      suspenseState !== null && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 31:
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          suspenseState !== null && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      retryCache !== null && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
      if ((parentFiber.subtreeFlags & 67117056) !== 0)
        for (parentFiber = parentFiber.child;parentFiber !== null; ) {
          var root = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
          isStrictModeFiber = isInStrictMode || isStrictModeFiber;
          fiber.tag !== 22 ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : fiber.memoizedState === null && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));
          parentFiber = parentFiber.sibling;
        }
    }
    function doubleInvokeEffectsOnFiber(root, fiber) {
      setIsStrictModeForDevtools(true);
      try {
        disappearLayoutEffects(fiber), disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, false), reconnectPassiveEffects(root, fiber, 0, null, false, 0);
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
    function commitDoubleInvokeEffectsInDEV(root) {
      var doubleInvokeEffects = true;
      root.current.mode & 24 || (doubleInvokeEffects = false);
      recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);
    }
    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
      if ((executionContext & RenderContext) === NoContext) {
        var tag = fiber.tag;
        if (tag === 3 || tag === 1 || tag === 0 || tag === 11 || tag === 14 || tag === 15) {
          tag = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (didWarnStateUpdateForNotYetMountedComponent !== null) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(tag))
              return;
            didWarnStateUpdateForNotYetMountedComponent.add(tag);
          } else
            didWarnStateUpdateForNotYetMountedComponent = new Set([tag]);
          runWithFiberInDEV(fiber, function() {
            console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead.");
          });
        }
      }
    }
    function restorePendingUpdaters(root, lanes) {
      isDevToolsPresent && root.memoizedUpdaters.forEach(function(schedulingFiber) {
        addFiberToLanesMap(root, schedulingFiber, lanes);
      });
    }
    function scheduleCallback(priorityLevel, callback) {
      var actQueue = ReactSharedInternals.actQueue;
      return actQueue !== null ? (actQueue.push(callback), fakeActCallbackNode) : scheduleCallback$3(priorityLevel, callback);
    }
    function warnIfUpdatesNotWrappedWithActDEV(fiber) {
      isConcurrentActEnvironment() && ReactSharedInternals.actQueue === null && runWithFiberInDEV(fiber, function() {
        console.error(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`, getComponentNameFromFiber(fiber));
      });
    }
    function resolveFunctionForHotReloading(type) {
      if (resolveFamily === null)
        return type;
      var family = resolveFamily(type);
      return family === undefined ? type : family.current;
    }
    function resolveForwardRefForHotReloading(type) {
      if (resolveFamily === null)
        return type;
      var family = resolveFamily(type);
      return family === undefined ? type !== null && type !== undefined && typeof type.render === "function" && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, type.displayName !== undefined && (family.displayName = type.displayName), family) : type : family.current;
    }
    function isCompatibleFamilyForHotReloading(fiber, element) {
      if (resolveFamily === null)
        return false;
      var prevType = fiber.elementType;
      element = element.type;
      var needsCompareFamilies = false, $$typeofNextType = typeof element === "object" && element !== null ? element.$$typeof : null;
      switch (fiber.tag) {
        case 1:
          typeof element === "function" && (needsCompareFamilies = true);
          break;
        case 0:
          typeof element === "function" ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
          break;
        case 11:
          $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
          break;
        case 14:
        case 15:
          $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
          break;
        default:
          return false;
      }
      return needsCompareFamilies && (fiber = resolveFamily(prevType), fiber !== undefined && fiber === resolveFamily(element)) ? true : false;
    }
    function markFailedErrorBoundaryForHotReloading(fiber) {
      resolveFamily !== null && typeof WeakSet === "function" && (failedBoundaries === null && (failedBoundaries = new WeakSet), failedBoundaries.add(fiber));
    }
    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
      do {
        var _fiber = fiber, alternate = _fiber.alternate, child = _fiber.child, sibling = _fiber.sibling, tag = _fiber.tag;
        _fiber = _fiber.type;
        var candidateType = null;
        switch (tag) {
          case 0:
          case 15:
          case 1:
            candidateType = _fiber;
            break;
          case 11:
            candidateType = _fiber.render;
        }
        if (resolveFamily === null)
          throw Error("Expected resolveFamily to be set during hot reload.");
        var needsRender = false;
        _fiber = false;
        candidateType !== null && (candidateType = resolveFamily(candidateType), candidateType !== undefined && (staleFamilies.has(candidateType) ? _fiber = true : updatedFamilies.has(candidateType) && (tag === 1 ? _fiber = true : needsRender = true)));
        failedBoundaries !== null && (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) && (_fiber = true);
        _fiber && (fiber._debugNeedsRemount = true);
        if (_fiber || needsRender)
          alternate = enqueueConcurrentRenderForLane(fiber, 2), alternate !== null && scheduleUpdateOnFiber(alternate, fiber, 2);
        child === null || _fiber || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
        if (sibling === null)
          break;
        fiber = sibling;
      } while (1);
    }
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
      this.actualDuration = -0;
      this.actualStartTime = -1.1;
      this.treeBaseDuration = this.selfBaseDuration = -0;
      this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
      this._debugNeedsRemount = false;
      this._debugHookTypes = null;
      hasBadMapPolyfill || typeof Object.preventExtensions !== "function" || Object.preventExtensions(this);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current2, pendingProps) {
      var workInProgress2 = current2.alternate;
      workInProgress2 === null ? (workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
      workInProgress2.flags = current2.flags & 65011712;
      workInProgress2.childLanes = current2.childLanes;
      workInProgress2.lanes = current2.lanes;
      workInProgress2.child = current2.child;
      workInProgress2.memoizedProps = current2.memoizedProps;
      workInProgress2.memoizedState = current2.memoizedState;
      workInProgress2.updateQueue = current2.updateQueue;
      pendingProps = current2.dependencies;
      workInProgress2.dependencies = pendingProps === null ? null : {
        lanes: pendingProps.lanes,
        firstContext: pendingProps.firstContext,
        _debugThenableState: pendingProps._debugThenableState
      };
      workInProgress2.sibling = current2.sibling;
      workInProgress2.index = current2.index;
      workInProgress2.ref = current2.ref;
      workInProgress2.refCleanup = current2.refCleanup;
      workInProgress2.selfBaseDuration = current2.selfBaseDuration;
      workInProgress2.treeBaseDuration = current2.treeBaseDuration;
      workInProgress2._debugInfo = current2._debugInfo;
      workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
      switch (workInProgress2.tag) {
        case 0:
        case 15:
          workInProgress2.type = resolveFunctionForHotReloading(current2.type);
          break;
        case 1:
          workInProgress2.type = resolveFunctionForHotReloading(current2.type);
          break;
        case 11:
          workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
      }
      return workInProgress2;
    }
    function resetWorkInProgress(workInProgress2, renderLanes2) {
      workInProgress2.flags &= 65011714;
      var current2 = workInProgress2.alternate;
      current2 === null ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = renderLanes2 === null ? null : {
        lanes: renderLanes2.lanes,
        firstContext: renderLanes2.firstContext,
        _debugThenableState: renderLanes2._debugThenableState
      }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
      return workInProgress2;
    }
    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
      var fiberTag = 0, resolvedType = type;
      if (typeof type === "function")
        shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
      else if (typeof type === "string")
        supportsResources && supportsSingletons ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : isHostSingletonType(type) ? 27 : 5) : supportsResources ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : 5) : fiberTag = supportsSingletons ? isHostSingletonType(type) ? 27 : 5 : 5;
      else
        a:
          switch (type) {
            case REACT_ACTIVITY_TYPE:
              return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return type = pendingProps, owner = mode, typeof type.id !== "string" && console.error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | 2), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
            case REACT_SUSPENSE_TYPE:
              return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
            case REACT_SUSPENSE_LIST_TYPE:
              return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
            default:
              if (typeof type === "object" && type !== null)
                switch (type.$$typeof) {
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    resolvedType = resolveForwardRefForHotReloading(resolvedType);
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    resolvedType = null;
                    break a;
                }
              resolvedType = "";
              if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0)
                resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              type === null ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
              fiberTag = owner ? typeof owner.tag === "number" ? getComponentNameFromFiber(owner) : typeof owner.name === "string" ? owner.name : null : null;
              fiberTag && (resolvedType += `

Check the render method of \`` + fiberTag + "`.");
              fiberTag = 29;
              pendingProps = Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType));
              resolvedType = null;
          }
      key = createFiber(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = resolvedType;
      key.lanes = lanes;
      key._debugOwner = owner;
      return key;
    }
    function createFiberFromElement(element, mode, lanes) {
      mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);
      mode._debugOwner = element._owner;
      mode._debugStack = element._debugStack;
      mode._debugTask = element._debugTask;
      return mode;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiber(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiber(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromDehydratedFragment(dehydratedNode) {
      var fiber = createFiber(18, null, null, NoMode);
      fiber.stateNode = dehydratedNode;
      return fiber;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiber(4, portal.children !== null ? portal.children : [], portal.key, mode);
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = noTimeout;
      this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = new Map;
      this.passiveEffectDuration = this.effectDuration = -0;
      this.memoizedUpdaters = new Set;
      containerInfo = this.pendingUpdatersLaneMap = [];
      for (tag = 0;31 > tag; tag++)
        containerInfo.push(new Set);
      this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
    }
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
      containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState);
      tag = 1;
      isStrictMode === true && (tag |= 24);
      isStrictMode = createFiber(3, null, null, tag | 2);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      retainCache(tag);
      containerInfo.pooledCache = tag;
      retainCache(tag);
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent)
        return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerSync(element, container, parentComponent, callback) {
      updateContainerImpl(container.current, 2, element, container, parentComponent, callback);
      return 2;
    }
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
      if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function")
        try {
          injectedHook.onScheduleFiberRoot(rendererID, container, element);
        } catch (err) {
          hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
        }
      parentComponent = getContextForSubtree(parentComponent);
      container.context === null ? container.context = parentComponent : container.pendingContext = parentComponent;
      isRendering && current !== null && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, getComponentNameFromFiber(current) || "Unknown"));
      container = createUpdate(lane);
      container.payload = { element };
      callback = callback === undefined ? null : callback;
      callback !== null && (typeof callback !== "function" && console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback), container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      element !== null && (startUpdateTimerByLane(lane, "root.render()", null), scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (fiber !== null && fiber.dehydrated !== null) {
        var a = fiber.retryLane;
        fiber.retryLane = a !== 0 && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function getCurrentFiberForDevTools() {
      return current;
    }
    var exports2 = {};
    var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.tracing_marker");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    Symbol.for("react.view_transition");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, rendererVersion = $$$config.rendererVersion, rendererPackageName = $$$config.rendererPackageName, extraDevToolsConfig = $$$config.extraDevToolsConfig, getPublicInstance = $$$config.getPublicInstance, getRootHostContext = $$$config.getRootHostContext, getChildHostContext = $$$config.getChildHostContext, prepareForCommit = $$$config.prepareForCommit, resetAfterCommit = $$$config.resetAfterCommit, createInstance = $$$config.createInstance;
    $$$config.cloneMutableInstance;
    var { appendInitialChild, finalizeInitialChildren, shouldSetTextContent, createTextInstance } = $$$config;
    $$$config.cloneMutableTextInstance;
    var { scheduleTimeout, cancelTimeout, noTimeout, isPrimaryRenderer } = $$$config;
    $$$config.warnsIfNotActing;
    var { supportsMutation, supportsPersistence, supportsHydration, getInstanceFromNode } = $$$config;
    $$$config.beforeActiveInstanceBlur;
    var preparePortalMount = $$$config.preparePortalMount;
    $$$config.prepareScopeUpdate;
    $$$config.getInstanceFromScope;
    var { setCurrentUpdatePriority, getCurrentUpdatePriority, resolveUpdatePriority, trackSchedulerEvent, resolveEventType, resolveEventTimeStamp, shouldAttemptEagerTransition, detachDeletedInstance } = $$$config;
    $$$config.requestPostPaintCallback;
    var { maySuspendCommit, maySuspendCommitOnUpdate, maySuspendCommitInSyncRender, preloadInstance, startSuspendingCommit, suspendInstance } = $$$config;
    $$$config.suspendOnActiveViewTransition;
    var { waitForCommitToBeReady, getSuspendedCommitReason, NotPendingTransition, HostTransitionContext, resetFormInstance, bindToConsole, supportsMicrotasks, scheduleMicrotask, supportsTestSelectors, findFiberRoot, getBoundingRect, getTextContent, isHiddenSubtree, matchAccessibilityRole, setFocusIfFocusable, setupIntersectionObserver, appendChild, appendChildToContainer, commitTextUpdate, commitMount, commitUpdate, insertBefore, insertInContainerBefore, removeChild, removeChildFromContainer, resetTextContent, hideInstance, hideTextInstance, unhideInstance, unhideTextInstance } = $$$config;
    $$$config.cancelViewTransitionName;
    $$$config.cancelRootViewTransitionName;
    $$$config.restoreRootViewTransitionName;
    $$$config.cloneRootViewTransitionContainer;
    $$$config.removeRootViewTransitionClone;
    $$$config.measureClonedInstance;
    $$$config.hasInstanceChanged;
    $$$config.hasInstanceAffectedParent;
    $$$config.startViewTransition;
    $$$config.startGestureTransition;
    $$$config.stopViewTransition;
    $$$config.getCurrentGestureOffset;
    $$$config.createViewTransitionInstance;
    var clearContainer = $$$config.clearContainer;
    $$$config.createFragmentInstance;
    $$$config.updateFragmentInstanceFiber;
    $$$config.commitNewChildToFragmentInstance;
    $$$config.deleteChildFromFragmentInstance;
    var { cloneInstance, createContainerChildSet, appendChildToContainerChildSet, finalizeContainerChildren, replaceContainerChildren, cloneHiddenInstance, cloneHiddenTextInstance, isSuspenseInstancePending, isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry, canHydrateFormStateMarker, isFormStateMarkerMatching, getNextHydratableSibling, getNextHydratableSiblingAfterSingleton, getFirstHydratableChild, getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinActivityInstance, getFirstHydratableChildWithinSuspenseInstance, getFirstHydratableChildWithinSingleton, canHydrateInstance, canHydrateTextInstance, canHydrateActivityInstance, canHydrateSuspenseInstance, hydrateInstance, hydrateTextInstance, hydrateActivityInstance, hydrateSuspenseInstance, getNextHydratableInstanceAfterActivityInstance, getNextHydratableInstanceAfterSuspenseInstance, commitHydratedInstance, commitHydratedContainer, commitHydratedActivityInstance, commitHydratedSuspenseInstance, finalizeHydratedChildren, flushHydrationEvents } = $$$config;
    $$$config.clearActivityBoundary;
    var clearSuspenseBoundary = $$$config.clearSuspenseBoundary;
    $$$config.clearActivityBoundaryFromContainer;
    var { clearSuspenseBoundaryFromContainer, hideDehydratedBoundary, unhideDehydratedBoundary, shouldDeleteUnhydratedTailInstances, diffHydratedPropsForDevWarnings, diffHydratedTextForDevWarnings, describeHydratableInstanceForDevWarnings, validateHydratableInstance, validateHydratableTextInstance, supportsResources, isHostHoistableType, getHoistableRoot, getResource, acquireResource, releaseResource, hydrateHoistable, mountHoistable, unmountHoistable, createHoistableInstance, prepareToCommitHoistables, mayResourceSuspendCommit, preloadResource, suspendResource, supportsSingletons, resolveSingletonInstance, acquireSingletonInstance, releaseSingletonInstance, isHostSingletonType, isSingletonScope } = $$$config, valueStack = [];
    var fiberStack = [];
    var index$jscomp$0 = -1, emptyContextObject = {};
    Object.freeze(emptyContextObject);
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log$1 = Math.log, LN2 = Math.LN2, nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, IdlePriority = Scheduler.unstable_IdlePriority, log2 = Scheduler.log, unstable_setDisableYieldValue2 = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, hasLoggedError = false, isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined", lastResetTime = 0;
    if (typeof performance === "object" && typeof performance.now === "function") {
      var localPerformance = performance;
      var getCurrentTime = function() {
        return localPerformance.now();
      };
    } else {
      var localDate = Date;
      getCurrentTime = function() {
        return localDate.now();
      };
    }
    var objectIs = typeof Object.is === "function" ? Object.is : is, reportGlobalError = typeof reportError === "function" ? reportError : function(error) {
      if (typeof window === "object" && typeof window.ErrorEvent === "function") {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event))
          return;
      } else if (typeof process === "object" && typeof process.emit === "function") {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, hasOwnProperty = Object.prototype.hasOwnProperty, supportsUserTiming = typeof console !== "undefined" && typeof console.timeStamp === "function" && typeof performance !== "undefined" && typeof performance.measure === "function", currentTrack = "Blocking", alreadyWarnedForDeepEquality = false, reusableComponentDevToolDetails = {
      color: "primary",
      properties: null,
      tooltipText: "",
      track: "Components "
    }, reusableComponentOptions = {
      start: -0,
      end: -0,
      detail: { devtools: reusableComponentDevToolDetails }
    }, resuableChangedPropsEntry = ["Changed Props", ""], reusableDeeplyEqualPropsEntry = [
      "Changed Props",
      "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner."
    ], disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    disabledLog.__reactDisabledLog = true;
    var prefix, suffix, reentry = false;
    var componentFrameCache = new (typeof WeakMap === "function" ? WeakMap : Map);
    var CapturedStacks = new WeakMap, forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), needsEscaping = /["'&<>\n\t]|^\s|\s$/, current = null, isRendering = false, hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error("Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), NoMode = 0, valueCursor = createCursor(null);
    var rendererCursorDEV = createCursor(null);
    var renderer2CursorDEV = createCursor(null);
    var rendererSigil = {};
    var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = typeof AbortController !== "undefined" ? AbortController : function() {
      var listeners = [], signal = this.signal = {
        aborted: false,
        addEventListener: function(type, listener) {
          listeners.push(listener);
        }
      };
      this.abort = function() {
        signal.aborted = true;
        listeners.forEach(function(listener) {
          return listener();
        });
      };
    }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
      _currentRenderer: null,
      _currentRenderer2: null
    }, now = Scheduler.unstable_now, createTask = console.createTask ? console.createTask : function() {
      return null;
    }, renderStartTime = -0, commitStartTime = -0, commitEndTime = -0, commitErrors = null, profilerStartTime = -1.1, profilerEffectDuration = -0, componentEffectDuration = -0, componentEffectStartTime = -1.1, componentEffectEndTime = -1.1, componentEffectErrors = null, componentEffectSpawnedUpdate = false, blockingClampTime = -0, blockingUpdateTime = -1.1, blockingUpdateTask = null, blockingUpdateType = 0, blockingUpdateMethodName = null, blockingUpdateComponentName = null, blockingEventTime = -1.1, blockingEventType = null, blockingEventRepeatTime = -1.1, blockingSuspendedTime = -1.1, transitionClampTime = -0, transitionStartTime = -1.1, transitionUpdateTime = -1.1, transitionUpdateType = 0, transitionUpdateTask = null, transitionUpdateMethodName = null, transitionUpdateComponentName = null, transitionEventTime = -1.1, transitionEventType = null, transitionEventRepeatTime = -1.1, transitionSuspendedTime = -1.1, animatingTask = null, yieldReason = 0, yieldStartTime = -1.1, currentUpdateIsNested = false, nestedUpdateScheduled = false, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode$1 = {}, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function(transition, returnValue) {
      globalMostRecentTransitionTime = now$1();
      if (typeof returnValue === "object" && returnValue !== null && typeof returnValue.then === "function") {
        if (0 > transitionStartTime && 0 > transitionUpdateTime) {
          transitionStartTime = now();
          var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
          if (newEventTime !== transitionEventRepeatTime || newEventType !== transitionEventType)
            transitionEventRepeatTime = -1.1;
          transitionEventTime = newEventTime;
          transitionEventType = newEventType;
        }
        entangleAsyncAction(transition, returnValue);
      }
      prevOnStartTransitionFinish !== null && prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null), ReactStrictModeWarnings = {
      recordUnsafeLifecycleWarnings: function() {},
      flushPendingUnsafeLifecycleWarnings: function() {},
      recordLegacyContextWarning: function() {},
      flushLegacyContextWarning: function() {},
      discardPendingWarnings: function() {}
    }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = new Set;
    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
      didWarnAboutUnsafeLifecycles.has(fiber.type) || (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true && pendingComponentWillMountWarnings.push(fiber), fiber.mode & 8 && typeof instance.UNSAFE_componentWillMount === "function" && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & 8 && typeof instance.UNSAFE_componentWillReceiveProps === "function" && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & 8 && typeof instance.UNSAFE_componentWillUpdate === "function" && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
    };
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
      var componentWillMountUniqueNames = new Set;
      0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillMountWarnings = []);
      var UNSAFE_componentWillMountUniqueNames = new Set;
      0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillMountWarnings = []);
      var componentWillReceivePropsUniqueNames = new Set;
      0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillReceivePropsWarnings = []);
      var UNSAFE_componentWillReceivePropsUniqueNames = new Set;
      0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
      var componentWillUpdateUniqueNames = new Set;
      0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillUpdateWarnings = []);
      var UNSAFE_componentWillUpdateUniqueNames = new Set;
      0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
      if (0 < UNSAFE_componentWillMountUniqueNames.size) {
        var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
        console.error(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, sortedNames);
      }
      0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state

Please update the following components: %s`, sortedNames));
      0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, sortedNames));
      0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(`componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, sortedNames));
      0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, sortedNames));
      0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(`componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, sortedNames));
    };
    var pendingLegacyContextWarning = new Map, didWarnAboutLegacyContext = new Set;
    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
      var strictRoot = null;
      for (var node = fiber;node !== null; )
        node.mode & 8 && (strictRoot = node), node = node.return;
      strictRoot === null ? console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") && (node === undefined && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
    };
    ReactStrictModeWarnings.flushLegacyContextWarning = function() {
      pendingLegacyContextWarning.forEach(function(fiberArray) {
        if (fiberArray.length !== 0) {
          var firstFiber = fiberArray[0], uniqueNames = new Set;
          fiberArray.forEach(function(fiber) {
            uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutLegacyContext.add(fiber.type);
          });
          var sortedNames = setToSortedString(uniqueNames);
          runWithFiberInDEV(firstFiber, function() {
            console.error(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://react.dev/link/legacy-context`, sortedNames);
          });
        }
      });
    };
    ReactStrictModeWarnings.discardPendingWarnings = function() {
      pendingComponentWillMountWarnings = [];
      pendingUNSAFE_ComponentWillMountWarnings = [];
      pendingComponentWillReceivePropsWarnings = [];
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
      pendingComponentWillUpdateWarnings = [];
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
      pendingLegacyContextWarning = new Map;
    };
    var callComponent = {
      react_stack_bottom_frame: function(Component, props, secondArg) {
        var wasRendering = isRendering;
        isRendering = true;
        try {
          return Component(props, secondArg);
        } finally {
          isRendering = wasRendering;
        }
      }
    }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
      react_stack_bottom_frame: function(instance) {
        var wasRendering = isRendering;
        isRendering = true;
        try {
          return instance.render();
        } finally {
          isRendering = wasRendering;
        }
      }
    }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callComponentDidMount = {
      react_stack_bottom_frame: function(finishedWork, instance) {
        try {
          instance.componentDidMount();
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }, callComponentDidMountInDEV = callComponentDidMount.react_stack_bottom_frame.bind(callComponentDidMount), callComponentDidUpdate = {
      react_stack_bottom_frame: function(finishedWork, instance, prevProps, prevState, snapshot) {
        try {
          instance.componentDidUpdate(prevProps, prevState, snapshot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }, callComponentDidUpdateInDEV = callComponentDidUpdate.react_stack_bottom_frame.bind(callComponentDidUpdate), callComponentDidCatch = {
      react_stack_bottom_frame: function(instance, errorInfo) {
        var stack = errorInfo.stack;
        instance.componentDidCatch(errorInfo.value, {
          componentStack: stack !== null ? stack : ""
        });
      }
    }, callComponentDidCatchInDEV = callComponentDidCatch.react_stack_bottom_frame.bind(callComponentDidCatch), callComponentWillUnmount = {
      react_stack_bottom_frame: function(current2, nearestMountedAncestor, instance) {
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error);
        }
      }
    }, callComponentWillUnmountInDEV = callComponentWillUnmount.react_stack_bottom_frame.bind(callComponentWillUnmount), callCreate = {
      react_stack_bottom_frame: function(effect) {
        var create = effect.create;
        effect = effect.inst;
        create = create();
        return effect.destroy = create;
      }
    }, callCreateInDEV = callCreate.react_stack_bottom_frame.bind(callCreate), callDestroy = {
      react_stack_bottom_frame: function(current2, nearestMountedAncestor, destroy) {
        try {
          destroy();
        } catch (error) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error);
        }
      }
    }, callDestroyInDEV = callDestroy.react_stack_bottom_frame.bind(callDestroy), callLazyInit = {
      react_stack_bottom_frame: function(lazy) {
        var init = lazy._init;
        return init(lazy._payload);
      }
    }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), SuspenseException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."), SuspenseyCommitException = Error("Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), SuspenseActionException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."), noopSuspenseyCommitThenable = {
      then: function() {
        console.error('Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.');
      }
    }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;
    var didWarnAboutGenerators = didWarnAboutMaps = false;
    var ownerHasKeyUseWarning = {};
    var ownerHasFunctionTypeWarning = {};
    var ownerHasSymbolTypeWarning = {};
    warnForMissingKey = function(returnFiber, workInProgress2, child) {
      if (child !== null && typeof child === "object" && child._store && (!child._store.validated && child.key == null || child._store.validated === 2)) {
        if (typeof child._store !== "object")
          throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        child._store.validated = 1;
        var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
        if (!ownerHasKeyUseWarning[componentKey]) {
          ownerHasKeyUseWarning[componentKey] = true;
          child = child._owner;
          returnFiber = returnFiber._debugOwner;
          var currentComponentErrorInfo = "";
          returnFiber && typeof returnFiber.tag === "number" && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = `

Check the render method of \`` + componentKey + "`.");
          currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = `

Check the top-level render call using <` + componentName2 + ">.");
          var childOwnerAppendix = "";
          child != null && returnFiber !== child && (componentName2 = null, typeof child.tag === "number" ? componentName2 = getComponentNameFromFiber(child) : typeof child.name === "string" && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
          runWithFiberInDEV(workInProgress2, function() {
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);
          });
        }
      }
    };
    var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
    var didWarnUpdateInsideUpdate = false;
    var currentlyProcessingQueue = null;
    var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;
    var didWarnAboutMismatchedHooksForComponent = new Set;
    var didWarnAboutUseWrappedInTryCatch = new Set;
    var didWarnAboutAsyncClientComponent = new Set;
    var didWarnAboutUseFormState = new Set;
    var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
      readContext,
      use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError,
      useHostTransitionStatus: throwInvalidHookError,
      useFormState: throwInvalidHookError,
      useActionState: throwInvalidHookError,
      useOptimistic: throwInvalidHookError,
      useMemoCache: throwInvalidHookError,
      useCacheRefresh: throwInvalidHookError
    };
    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
    var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
    HooksDispatcherOnMountInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountEffect(create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountLayoutEffect(create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function(initialValue) {
        currentHookNameInDev = "useRef";
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function(initialState) {
        currentHookNameInDev = "useState";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        mountHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        mountHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function(action, initialState) {
        currentHookNameInDev = "useFormState";
        mountHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useActionState: function(action, initialState) {
        currentHookNameInDev = "useActionState";
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        mountHookTypesDev();
        return mountEvent(callback);
      }
    };
    HooksDispatcherOnMountWithHookTypesInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        return mountEffect(create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function(initialValue) {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function(initialState) {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return mountId();
      },
      useActionState: function(action, initialState) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return mountActionState(action, initialState);
      },
      useFormState: function(action, initialState) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return mountRefresh();
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        updateHookTypesDev();
        return mountEvent(callback);
      }
    };
    HooksDispatcherOnUpdateInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return updateActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    HooksDispatcherOnRerenderInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return rerenderActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    InvalidNestedHooksDispatcherOnMountInDEV = {
      readContext: function(context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function(usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountEffect(create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function(initialValue) {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function(initialState) {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function(action, initialState) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useActionState: function(action, initialState) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useMemoCache: function(size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountEvent(callback);
      }
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV = {
      readContext: function(context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function(usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useMemoCache: function(size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV = {
      readContext: function(context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function(usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useMemoCache: function(size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    var fakeInternalInstance = {};
    var didWarnAboutStateAssignmentForComponent = new Set;
    var didWarnAboutUninitializedState = new Set;
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;
    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set;
    var didWarnAboutDirectlyAssigningPropsToState = new Set;
    var didWarnAboutUndefinedDerivedState = new Set;
    var didWarnAboutContextTypes$1 = new Set;
    var didWarnAboutChildContextTypes = new Set;
    var didWarnAboutInvalidateContextType = new Set;
    var didWarnOnInvalidCallback = new Set;
    Object.freeze(fakeInternalInstance);
    var classComponentUpdater = {
      enqueueSetState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(inst), update = createUpdate(lane);
        update.payload = payload;
        callback !== undefined && callback !== null && (warnOnInvalidCallback(callback), update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        payload !== null && (startUpdateTimerByLane(lane, "this.setState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(inst), update = createUpdate(lane);
        update.tag = ReplaceState;
        update.payload = payload;
        callback !== undefined && callback !== null && (warnOnInvalidCallback(callback), update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        payload !== null && (startUpdateTimerByLane(lane, "this.replaceState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueForceUpdate: function(inst, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(inst), update = createUpdate(lane);
        update.tag = ForceUpdate;
        callback !== undefined && callback !== null && (warnOnInvalidCallback(callback), update.callback = callback);
        callback = enqueueUpdate(inst, update, lane);
        callback !== null && (startUpdateTimerByLane(lane, "this.forceUpdate()", inst), scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
      }
    }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error("This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."), didReceiveUpdate = false;
    var didWarnAboutBadClass = {};
    var didWarnAboutContextTypeOnFunctionComponent = {};
    var didWarnAboutContextTypes = {};
    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
    var didWarnAboutReassigningProps = false;
    var didWarnAboutRevealOrder = {};
    var didWarnAboutTailOptions = {};
    var SUSPENDED_MARKER = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set;
    var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, inHydratedSubtree = false, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
      getCacheForType: function(resourceType) {
        var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
        cacheForType === undefined && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
        return cacheForType;
      },
      cacheSignal: function() {
        return readContext(CacheContext).controller.signal;
      },
      getOwner: function() {
        return current;
      }
    }, COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;
    if (typeof Symbol === "function" && Symbol.for) {
      var symbolFor = Symbol.for;
      COMPONENT_TYPE = symbolFor("selector.component");
      HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
      ROLE_TYPE = symbolFor("selector.role");
      TEST_NAME_TYPE = symbolFor("selector.test_id");
      TEXT_TYPE = symbolFor("selector.text");
    }
    var commitHooks = [], PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, workInProgressUpdateTask = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, ABORTED_VIEW_TRANSITION_COMMIT = 1, DELAYED_PASSIVE_COMMIT = 2, ANIMATION_STARTED_COMMIT = 3, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingEffectsRenderEndTime = -0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, pendingSuspendedCommitReason = null, pendingDelayedCommitReason = IMMEDIATE_COMMIT, pendingSuspendedViewTransitionReason = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
    var didWarnAboutUpdateInRenderForAnotherComponent = new Set;
    var fakeActCallbackNode = {}, resolveFamily = null, failedBoundaries = null;
    var hasBadMapPolyfill = false;
    try {
      var nonExtensibleObject = Object.preventExtensions({});
      new Map([[nonExtensibleObject, null]]);
      new Set([nonExtensibleObject]);
    } catch (e) {
      hasBadMapPolyfill = true;
    }
    var didWarnAboutNestedUpdates = false;
    var didWarnAboutFindNodeInStrictMode = {};
    var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, scheduleRetry = null, setErrorHandler = null, setSuspenseHandler = null;
    overrideHookState = function(fiber, id, path, value) {
      id = findHook(fiber, id);
      id !== null && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), path !== null && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateDeletePath = function(fiber, id, path) {
      id = findHook(fiber, id);
      id !== null && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), path !== null && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
      id = findHook(fiber, id);
      id !== null && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), oldPath !== null && scheduleUpdateOnFiber(oldPath, fiber, 2));
    };
    overrideProps = function(fiber, path, value) {
      fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      path !== null && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsDeletePath = function(fiber, path) {
      fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      path !== null && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsRenamePath = function(fiber, oldPath, newPath) {
      fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      oldPath = enqueueConcurrentRenderForLane(fiber, 2);
      oldPath !== null && scheduleUpdateOnFiber(oldPath, fiber, 2);
    };
    scheduleUpdate = function(fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      root !== null && scheduleUpdateOnFiber(root, fiber, 2);
    };
    scheduleRetry = function(fiber) {
      var lane = claimNextRetryLane(), root = enqueueConcurrentRenderForLane(fiber, lane);
      root !== null && scheduleUpdateOnFiber(root, fiber, lane);
    };
    setErrorHandler = function(newShouldErrorImpl) {
      shouldErrorImpl = newShouldErrorImpl;
    };
    setSuspenseHandler = function(newShouldSuspendImpl) {
      shouldSuspendImpl = newShouldSuspendImpl;
    };
    exports2.attemptContinuousHydration = function(fiber) {
      if (fiber.tag === 13 || fiber.tag === 31) {
        var root = enqueueConcurrentRenderForLane(fiber, 67108864);
        root !== null && scheduleUpdateOnFiber(root, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    };
    exports2.attemptHydrationAtCurrentPriority = function(fiber) {
      if (fiber.tag === 13 || fiber.tag === 31) {
        var lane = requestUpdateLane(fiber);
        lane = getBumpedLaneForHydrationByLane(lane);
        var root = enqueueConcurrentRenderForLane(fiber, lane);
        root !== null && scheduleUpdateOnFiber(root, fiber, lane);
        markRetryLaneIfNotHydrated(fiber, lane);
      }
    };
    exports2.attemptSynchronousHydration = function(fiber) {
      switch (fiber.tag) {
        case 3:
          fiber = fiber.stateNode;
          if (fiber.current.memoizedState.isDehydrated) {
            var lanes = getHighestPriorityLanes(fiber.pendingLanes);
            if (lanes !== 0) {
              fiber.pendingLanes |= 2;
              for (fiber.entangledLanes |= 2;lanes; ) {
                var lane = 1 << 31 - clz32(lanes);
                fiber.entanglements[1] |= lane;
                lanes &= ~lane;
              }
              ensureRootIsScheduled(fiber);
              (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
            }
          }
          break;
        case 31:
        case 13:
          lanes = enqueueConcurrentRenderForLane(fiber, 2), lanes !== null && scheduleUpdateOnFiber(lanes, fiber, 2), flushSyncWork(), markRetryLaneIfNotHydrated(fiber, 2);
      }
    };
    exports2.batchedUpdates = function(fn, a) {
      return fn(a);
    };
    exports2.createComponentSelector = function(component) {
      return { $$typeof: COMPONENT_TYPE, value: component };
    };
    exports2.createContainer = function(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
      return createFiberRoot(containerInfo, tag, false, null, hydrationCallbacks, isStrictMode, identifierPrefix, null, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator);
    };
    exports2.createHasPseudoClassSelector = function(selectors) {
      return { $$typeof: HAS_PSEUDO_CLASS_TYPE, value: selectors };
    };
    exports2.createHydrationContainer = function(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, transitionCallbacks, formState) {
      initialChildren = createFiberRoot(containerInfo, tag, true, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator);
      initialChildren.context = getContextForSubtree(null);
      containerInfo = initialChildren.current;
      tag = requestUpdateLane(containerInfo);
      tag = getBumpedLaneForHydrationByLane(tag);
      hydrationCallbacks = createUpdate(tag);
      hydrationCallbacks.callback = callback !== undefined && callback !== null ? callback : null;
      enqueueUpdate(containerInfo, hydrationCallbacks, tag);
      startUpdateTimerByLane(tag, "hydrateRoot()", null);
      callback = tag;
      initialChildren.current.lanes = callback;
      markRootUpdated$1(initialChildren, callback);
      ensureRootIsScheduled(initialChildren);
      return initialChildren;
    };
    exports2.createPortal = function(children, containerInfo, implementation) {
      var key = 3 < arguments.length && arguments[3] !== undefined ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = false;
      } catch (e$6) {
        JSCompiler_inline_result = true;
      }
      JSCompiler_inline_result && (console.error("The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", typeof Symbol === "function" && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"), testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: key == null ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    };
    exports2.createRoleSelector = function(role) {
      return { $$typeof: ROLE_TYPE, value: role };
    };
    exports2.createTestNameSelector = function(id) {
      return { $$typeof: TEST_NAME_TYPE, value: id };
    };
    exports2.createTextSelector = function(text) {
      return { $$typeof: TEXT_TYPE, value: text };
    };
    exports2.defaultOnCaughtError = function(error) {
      var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
      typeof error === "object" && error !== null && typeof error.environmentName === "string" ? bindToConsole("error", [`%o

%s

%s
`, error, componentNameMessage, recreateMessage], error.environmentName)() : console.error(`%o

%s

%s
`, error, componentNameMessage, recreateMessage);
    };
    exports2.defaultOnRecoverableError = function(error) {
      reportGlobalError(error);
    };
    exports2.defaultOnUncaughtError = function(error) {
      reportGlobalError(error);
      console.warn(`%s

%s
`, componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.", `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://react.dev/link/error-boundaries to learn more about error boundaries.`);
    };
    exports2.deferredUpdates = function(fn) {
      var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();
      try {
        return setCurrentUpdatePriority(32), ReactSharedInternals.T = null, fn();
      } finally {
        setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition;
      }
    };
    exports2.discreteUpdates = function(fn, a, b, c, d) {
      var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();
      try {
        return setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn(a, b, c, d);
      } finally {
        setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS);
      }
    };
    exports2.findAllNodes = findAllNodes;
    exports2.findBoundingRects = function(hostRoot, selectors) {
      if (!supportsTestSelectors)
        throw Error("Test selector API is not supported by this renderer.");
      selectors = findAllNodes(hostRoot, selectors);
      hostRoot = [];
      for (var i = 0;i < selectors.length; i++)
        hostRoot.push(getBoundingRect(selectors[i]));
      for (selectors = hostRoot.length - 1;0 < selectors; selectors--) {
        i = hostRoot[selectors];
        for (var targetLeft = i.x, targetRight = targetLeft + i.width, targetTop = i.y, targetBottom = targetTop + i.height, j = selectors - 1;0 <= j; j--)
          if (selectors !== j) {
            var otherRect = hostRoot[j], otherLeft = otherRect.x, otherRight = otherLeft + otherRect.width, otherTop = otherRect.y, otherBottom = otherTop + otherRect.height;
            if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {
              hostRoot.splice(selectors, 1);
              break;
            } else if (!(targetLeft !== otherLeft || i.width !== otherRect.width || otherBottom < targetTop || otherTop > targetBottom)) {
              otherTop > targetTop && (otherRect.height += otherTop - targetTop, otherRect.y = targetTop);
              otherBottom < targetBottom && (otherRect.height = targetBottom - otherTop);
              hostRoot.splice(selectors, 1);
              break;
            } else if (!(targetTop !== otherTop || i.height !== otherRect.height || otherRight < targetLeft || otherLeft > targetRight)) {
              otherLeft > targetLeft && (otherRect.width += otherLeft - targetLeft, otherRect.x = targetLeft);
              otherRight < targetRight && (otherRect.width = targetRight - otherLeft);
              hostRoot.splice(selectors, 1);
              break;
            }
          }
      }
      return hostRoot;
    };
    exports2.findHostInstance = function(component) {
      var fiber = component._reactInternals;
      if (fiber === undefined) {
        if (typeof component.render === "function")
          throw Error("Unable to find node on an unmounted component.");
        component = Object.keys(component).join(",");
        throw Error("Argument appears to not be a ReactComponent. Keys: " + component);
      }
      component = findCurrentHostFiber(fiber);
      return component === null ? null : getPublicInstance(component.stateNode);
    };
    exports2.findHostInstanceWithNoPortals = function(fiber) {
      fiber = findCurrentFiberUsingSlowPath(fiber);
      fiber = fiber !== null ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;
      return fiber === null ? null : getPublicInstance(fiber.stateNode);
    };
    exports2.findHostInstanceWithWarning = function(component, methodName) {
      var fiber = component._reactInternals;
      if (fiber === undefined) {
        if (typeof component.render === "function")
          throw Error("Unable to find node on an unmounted component.");
        component = Object.keys(component).join(",");
        throw Error("Argument appears to not be a ReactComponent. Keys: " + component);
      }
      component = findCurrentHostFiber(fiber);
      if (component === null)
        return null;
      if (component.mode & 8) {
        var componentName2 = getComponentNameFromFiber(fiber) || "Component";
        didWarnAboutFindNodeInStrictMode[componentName2] || (didWarnAboutFindNodeInStrictMode[componentName2] = true, runWithFiberInDEV(component, function() {
          fiber.mode & 8 ? console.error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node", methodName, methodName, componentName2) : console.error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node", methodName, methodName, componentName2);
        }));
      }
      return getPublicInstance(component.stateNode);
    };
    exports2.flushPassiveEffects = flushPendingEffects;
    exports2.flushSyncFromReconciler = function(fn) {
      var prevExecutionContext = executionContext;
      executionContext |= 1;
      var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();
      try {
        if (setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn)
          return fn();
      } finally {
        setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext = prevExecutionContext, (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncWorkAcrossRoots_impl(0, false);
      }
    };
    exports2.flushSyncWork = flushSyncWork;
    exports2.focusWithin = function(hostRoot, selectors) {
      if (!supportsTestSelectors)
        throw Error("Test selector API is not supported by this renderer.");
      hostRoot = findFiberRootForHostRoot(hostRoot);
      selectors = findPaths(hostRoot, selectors);
      selectors = Array.from(selectors);
      for (hostRoot = 0;hostRoot < selectors.length; ) {
        var fiber = selectors[hostRoot++], tag = fiber.tag;
        if (!isHiddenSubtree(fiber)) {
          if ((tag === 5 || tag === 26 || tag === 27) && setFocusIfFocusable(fiber.stateNode))
            return true;
          for (fiber = fiber.child;fiber !== null; )
            selectors.push(fiber), fiber = fiber.sibling;
        }
      }
      return false;
    };
    exports2.getFindAllNodesFailureDescription = function(hostRoot, selectors) {
      if (!supportsTestSelectors)
        throw Error("Test selector API is not supported by this renderer.");
      var maxSelectorIndex = 0, matchedNames = [];
      hostRoot = [findFiberRootForHostRoot(hostRoot), 0];
      for (var index = 0;index < hostRoot.length; ) {
        var fiber = hostRoot[index++], tag = fiber.tag, selectorIndex = hostRoot[index++], selector = selectors[selectorIndex];
        if (tag !== 5 && tag !== 26 && tag !== 27 || !isHiddenSubtree(fiber)) {
          if (matchSelector(fiber, selector) && (matchedNames.push(selectorToString(selector)), selectorIndex++, selectorIndex > maxSelectorIndex && (maxSelectorIndex = selectorIndex)), selectorIndex < selectors.length)
            for (fiber = fiber.child;fiber !== null; )
              hostRoot.push(fiber, selectorIndex), fiber = fiber.sibling;
        }
      }
      if (maxSelectorIndex < selectors.length) {
        for (hostRoot = [];maxSelectorIndex < selectors.length; maxSelectorIndex++)
          hostRoot.push(selectorToString(selectors[maxSelectorIndex]));
        return `findAllNodes was able to match part of the selector:
  ` + (matchedNames.join(" > ") + `

No matching component was found for:
  `) + hostRoot.join(" > ");
      }
      return null;
    };
    exports2.getPublicRootInstance = function(container) {
      container = container.current;
      if (!container.child)
        return null;
      switch (container.child.tag) {
        case 27:
        case 5:
          return getPublicInstance(container.child.stateNode);
        default:
          return container.child.stateNode;
      }
    };
    exports2.injectIntoDevTools = function() {
      var internals = {
        bundleType: 1,
        version: rendererVersion,
        rendererPackageName,
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.2.0"
      };
      extraDevToolsConfig !== null && (internals.rendererConfig = extraDevToolsConfig);
      internals.overrideHookState = overrideHookState;
      internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
      internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
      internals.overrideProps = overrideProps;
      internals.overridePropsDeletePath = overridePropsDeletePath;
      internals.overridePropsRenamePath = overridePropsRenamePath;
      internals.scheduleUpdate = scheduleUpdate;
      internals.scheduleRetry = scheduleRetry;
      internals.setErrorHandler = setErrorHandler;
      internals.setSuspenseHandler = setSuspenseHandler;
      internals.scheduleRefresh = scheduleRefresh;
      internals.scheduleRoot = scheduleRoot;
      internals.setRefreshHandler = setRefreshHandler;
      internals.getCurrentFiber = getCurrentFiberForDevTools;
      return injectInternals(internals);
    };
    exports2.isAlreadyRendering = isAlreadyRendering;
    exports2.observeVisibleRects = function(hostRoot, selectors, callback, options) {
      function commitHook() {
        var nextInstanceRoots = findAllNodes(hostRoot, selectors);
        instanceRoots.forEach(function(target) {
          0 > nextInstanceRoots.indexOf(target) && unobserve(target);
        });
        nextInstanceRoots.forEach(function(target) {
          0 > instanceRoots.indexOf(target) && observe(target);
        });
      }
      if (!supportsTestSelectors)
        throw Error("Test selector API is not supported by this renderer.");
      var instanceRoots = findAllNodes(hostRoot, selectors);
      callback = setupIntersectionObserver(instanceRoots, callback, options);
      var { disconnect, observe, unobserve } = callback;
      commitHooks.push(commitHook);
      return {
        disconnect: function() {
          var index = commitHooks.indexOf(commitHook);
          0 <= index && commitHooks.splice(index, 1);
          disconnect();
        }
      };
    };
    exports2.shouldError = function(fiber) {
      return shouldErrorImpl(fiber);
    };
    exports2.shouldSuspend = function(fiber) {
      return shouldSuspendImpl(fiber);
    };
    exports2.startHostTransition = function(formFiber, pendingState, action, formData) {
      if (formFiber.tag !== 5)
        throw Error("Expected the form instance to be a HostComponent. This is a bug in React.");
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startHostActionTimer(formFiber);
      startTransition(formFiber, queue, pendingState, NotPendingTransition, action === null ? noop : function() {
        ReactSharedInternals.T === null && console.error("requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.");
        var stateHook = ensureFormComponentIsStateful(formFiber);
        stateHook.next === null && (stateHook = formFiber.alternate.memoizedState);
        dispatchSetStateInternal(formFiber, stateHook.next.queue, {}, requestUpdateLane(formFiber));
        return action(formData);
      });
    };
    exports2.updateContainer = function(element, container, parentComponent, callback) {
      var current2 = container.current, lane = requestUpdateLane(current2);
      updateContainerImpl(current2, lane, element, container, parentComponent, callback);
      return lane;
    };
    exports2.updateContainerSync = updateContainerSync;
    return exports2;
  }, module.exports.default = module.exports, Object.defineProperty(module.exports, "__esModule", { value: true });
});

// node_modules/react-reconciler/index.js
var require_react_reconciler = __commonJS((exports, module) => {
  if (false) {} else {
    module.exports = require_react_reconciler_development();
  }
});

// node_modules/ws/lib/constants.js
var require_constants2 = __commonJS((exports, module) => {
  var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
  var hasBlob = typeof Blob !== "undefined";
  if (hasBlob)
    BINARY_TYPES.push("blob");
  module.exports = {
    BINARY_TYPES,
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    hasBlob,
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {}
  };
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var { EMPTY_BUFFER } = require_constants2();
  var FastBuffer = Buffer[Symbol.species];
  function concat(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  }
  function _mask(source, mask, output, offset, length) {
    for (let i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  function _unmask(buffer, mask) {
    for (let i = 0;i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }
  function toArrayBuffer(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  }
  function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = (()=>{throw new Error("Cannot require module "+"bufferutil");})();
      module.exports.mask = function(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bufferUtil.mask(source, mask, output, offset, length);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e) {}
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants2();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }
  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  }
  function inflateOnError(err) {
    this[kPerMessageDeflate]._inflate = null;
    if (this[kError]) {
      this[kCallback](this[kError]);
      return;
    }
    err[kStatusCode] = 1007;
    this[kCallback](err);
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var { isUtf8 } = __require("buffer");
  var { hasBlob } = require_constants2();
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  function isValidStatusCode(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  }
  function _isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  function isBlob(value) {
    return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
  }
  module.exports = {
    isBlob,
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = (()=>{throw new Error("Cannot require module "+"utf-8-validate");})();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {}
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants2();
  var { concat, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var FastBuffer = Buffer[Symbol.species];
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var DEFER_EVENT = 6;

  class Receiver extends Writable {
    constructor(options = {}) {
      super();
      this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;
      this._binaryType = options.binaryType || BINARY_TYPES[0];
      this._extensions = options.extensions || {};
      this._isServer = !!options.isServer;
      this._maxPayload = options.maxPayload | 0;
      this._skipUTF8Validation = !!options.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._errored = false;
      this._loop = false;
      this._state = GET_INFO;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            this.getInfo(cb);
            break;
          case GET_PAYLOAD_LENGTH_16:
            this.getPayloadLength16(cb);
            break;
          case GET_PAYLOAD_LENGTH_64:
            this.getPayloadLength64(cb);
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            this.getData(cb);
            break;
          case INFLATING:
          case DEFER_EVENT:
            this._loop = false;
            return;
        }
      } while (this._loop);
      if (!this._errored)
        cb();
    }
    getInfo(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        const error = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        cb(error);
        return;
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        cb(error);
        return;
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (!this._fragmented) {
          const error = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          const error = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          cb(error);
          return;
        }
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          cb(error);
          return;
        }
      } else {
        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        cb(error);
        return;
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          const error = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          cb(error);
          return;
        }
      } else if (this._masked) {
        const error = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        cb(error);
        return;
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        this.haveLength(cb);
    }
    getPayloadLength16(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      this.haveLength(cb);
    }
    getPayloadLength64(cb) {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        const error = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        cb(error);
        return;
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      this.haveLength(cb);
    }
    haveLength(cb) {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          cb(error);
          return;
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7) {
        this.controlMessage(data, cb);
        return;
      }
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      this.dataMessage(cb);
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
            cb(error);
            return;
          }
          this._fragments.push(buf);
        }
        this.dataMessage(cb);
        if (this._state === GET_INFO)
          this.startLoop(cb);
      });
    }
    dataMessage(cb) {
      if (!this._fin) {
        this._state = GET_INFO;
        return;
      }
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data;
        if (this._binaryType === "nodebuffer") {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else if (this._binaryType === "blob") {
          data = new Blob(fragments);
        } else {
          data = fragments;
        }
        if (this._allowSynchronousEvents) {
          this.emit("message", data, true);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", data, true);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      } else {
        const buf = concat(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          cb(error);
          return;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", buf, false);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", buf, false);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
    }
    controlMessage(data, cb) {
      if (this._opcode === 8) {
        if (data.length === 0) {
          this._loop = false;
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            cb(error);
            return;
          }
          const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            cb(error);
            return;
          }
          this._loop = false;
          this.emit("conclude", code, buf);
          this.end();
        }
        this._state = GET_INFO;
        return;
      }
      if (this._allowSynchronousEvents) {
        this.emit(this._opcode === 9 ? "ping" : "pong", data);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
    createError(ErrorCtor, message, prefix, statusCode, errorCode) {
      this._loop = false;
      this._errored = true;
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, this.createError);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
  module.exports = Receiver;
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants2();
  var { isBlob, isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);
  var RANDOM_POOL_SIZE = 8 * 1024;
  var randomPool;
  var randomPoolPointer = RANDOM_POOL_SIZE;
  var DEFAULT = 0;
  var DEFLATING = 1;
  var GET_BLOB_DATA = 2;

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._queue = [];
      this._state = DEFAULT;
      this.onerror = NOOP;
      this[kWebSocket] = undefined;
    }
    static frame(data, options) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options.mask) {
        mask = options.maskBuffer || maskBuffer;
        if (options.generateMask) {
          options.generateMask(mask);
        } else {
          if (randomPoolPointer === RANDOM_POOL_SIZE) {
            if (randomPool === undefined) {
              randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
            }
            randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
            randomPoolPointer = 0;
          }
          mask[0] = randomPool[randomPoolPointer++];
          mask[1] = randomPool[randomPoolPointer++];
          mask[2] = randomPool[randomPoolPointer++];
          mask[3] = randomPool[randomPoolPointer++];
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
          dataLength = options[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options.mask && options.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, buf, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options, cb]);
        } else {
          this.getBlobData(data, false, options, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options, cb]);
        } else {
          this.getBlobData(data, false, options, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    send(data, options, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options.binary ? 2 : 1;
      let rsv1 = options.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin)
        this._firstFragment = true;
      const opts = {
        [kByteLength]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
        } else {
          this.getBlobData(data, this._compress, opts, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    }
    getBlobData(blob, compress, options, cb) {
      this._bufferedBytes += options[kByteLength];
      this._state = GET_BLOB_DATA;
      blob.arrayBuffer().then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while the blob was being read");
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer(arrayBuffer);
        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      }).catch((err) => {
        process.nextTick(onError, this, err, cb);
      });
    }
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options[kByteLength];
      this._state = DEFLATING;
      perMessageDeflate.compress(data, options.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          callCallbacks(this, err, cb);
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        this._state = DEFAULT;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (this._state === DEFAULT && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
  function callCallbacks(sender, err, cb) {
    if (typeof cb === "function")
      cb(err);
    for (let i = 0;i < sender._queue.length; i++) {
      const params = sender._queue[i];
      const callback = params[params.length - 1];
      if (typeof callback === "function")
        callback(err);
    }
  }
  function onError(sender, err, cb) {
    callCallbacks(sender, err, cb);
    sender.onerror(err);
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var { kForOnEventAttribute, kListener } = require_constants2();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event.prototype, "target", { enumerable: true });
  Object.defineProperty(Event.prototype, "type", { enumerable: true });

  class CloseEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kCode] = options.code === undefined ? 0 : options.code;
      this[kReason] = options.reason === undefined ? "" : options.reason;
      this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kError] = options.error === undefined ? null : options.error;
      this[kMessage] = options.message === undefined ? "" : options.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kData] = options.data === undefined ? null : options.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget = {
    addEventListener(type, handler, options = {}) {
      for (const listener of this.listeners(type)) {
        if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
  };
  function callListener(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function push(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  }
  function parse(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  }
  function format(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  }
  module.exports = { format, parse };
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Duplex, Readable } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var { isBlob } = require_validation();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants2();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format, parse } = require_extension();
  var { toBuffer } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket extends EventEmitter {
    constructor(address, protocols, options) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._errorEmitted = false;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._autoPong = options.autoPong;
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options) {
      const receiver = new Receiver({
        allowSynchronousEvents: options.allowSynchronousEvents,
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      const sender = new Sender(socket, this._extensions, options.generateMask);
      this._receiver = receiver;
      this._sender = sender;
      this._socket = socket;
      receiver[kWebSocket] = this;
      sender[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      sender.onerror = senderOnError;
      if (socket.setTimeout)
        socket.setTimeout(0);
      if (socket.setNoDelay)
        socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      setCloseTimer(this);
    }
    pause() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener;
  WebSocket.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket;
  function initAsClient(websocket, address, protocols, options) {
    const opts = {
      allowSynchronousEvents: true,
      autoPong: true,
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    websocket._autoPong = opts.autoPong;
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL2) {
      parsedUrl = address;
    } else {
      try {
        parsedUrl = new URL2(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", ` + '"http:", "https:", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options && options.headers;
        options = { ...options, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options.headers.authorization) {
        options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket.CONNECTING)
        return;
      req = websocket._req = null;
      const upgrade = res.headers.upgrade;
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        allowSynchronousEvents: opts.allowSynchronousEvents,
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  }
  function emitErrorAndClose(websocket, err) {
    websocket._readyState = WebSocket.CLOSING;
    websocket._errorEmitted = true;
    websocket.emit("error", err);
    websocket.emitClose();
  }
  function netConnect(options) {
    options.path = options.socketPath;
    return net.connect(options);
  }
  function tlsConnect(options) {
    options.path = undefined;
    if (!options.servername && options.servername !== "") {
      options.servername = net.isIP(options.host) ? "" : options.host;
    }
    return tls.connect(options);
  }
  function abortHandshake(websocket, stream2, message) {
    websocket._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream2.setHeader) {
      stream2[kAborted] = true;
      stream2.abort();
      if (stream2.socket && !stream2.socket.destroyed) {
        stream2.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream2.destroy(err);
      stream2.once("error", websocket.emit.bind(websocket, "error"));
      stream2.once("close", websocket.emitClose.bind(websocket));
    }
  }
  function sendAfterClose(websocket, data, cb) {
    if (data) {
      const length = isBlob(data) ? data.size : toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length;
      else
        websocket._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      process.nextTick(cb, err);
    }
  }
  function receiverOnConclude(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  }
  function receiverOnDrain() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  }
  function receiverOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }
  function receiverOnMessage(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  }
  function receiverOnPing(data) {
    const websocket = this[kWebSocket];
    if (websocket._autoPong)
      websocket.pong(data, !this._isServer, NOOP);
    websocket.emit("ping", data);
  }
  function receiverOnPong(data) {
    this[kWebSocket].emit("pong", data);
  }
  function resume(stream2) {
    stream2.resume();
  }
  function senderOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket.readyState === WebSocket.CLOSED)
      return;
    if (websocket.readyState === WebSocket.OPEN) {
      websocket._readyState = WebSocket.CLOSING;
      setCloseTimer(websocket);
    }
    this._socket.end();
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function setCloseTimer(websocket) {
    websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);
  }
  function socketOnClose() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  }
  function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  }
  function socketOnEnd() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
  }
  function socketOnError() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var WebSocket = require_websocket();
  var { Duplex } = __require("stream");
  function emitClose(stream2) {
    stream2.emit("close");
  }
  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  function duplexOnError(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  }
  function createWebSocketStream(ws, options) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  }
  module.exports = createWebSocketStream;
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function parse(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  }
  module.exports = { parse };
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var http = __require("http");
  var { Duplex } = __require("stream");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket = require_websocket();
  var { GUID, kWebSocket } = require_constants2();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options, callback) {
      super();
      options = {
        allowSynchronousEvents: true,
        autoPong: true,
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket,
        ...options
      };
      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
      }
      if (options.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true)
        options.perMessageDeflate = {};
      if (options.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const upgrade = req.headers.upgrade;
      const version = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (key === undefined || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version !== 13 && version !== 8) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
          "Sec-WebSocket-Version": "13, 8"
        });
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null, undefined, this.options);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat(`\r
`).join(`\r
`));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        allowSynchronousEvents: this.options.allowSynchronousEvents,
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
  function addListeners(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  }
  function emitClose(server) {
    server._state = CLOSED;
    server.emit("close");
  }
  function socketOnError() {
    this.destroy();
  }
  function abortHandshake(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(`\r
`) + `\r
\r
` + message);
  }
  function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message, headers);
    }
  }
});

// node_modules/ws/wrapper.mjs
var import_stream, import_receiver, import_sender, import_websocket, import_websocket_server, wrapper_default;
var init_wrapper = __esm(() => {
  import_stream = __toESM(require_stream(), 1);
  import_receiver = __toESM(require_receiver(), 1);
  import_sender = __toESM(require_sender(), 1);
  import_websocket = __toESM(require_websocket(), 1);
  import_websocket_server = __toESM(require_websocket_server(), 1);
  wrapper_default = import_websocket.default;
});

// node_modules/ink/build/devtools-window-polyfill.js
var customGlobal;
var init_devtools_window_polyfill = __esm(() => {
  init_wrapper();
  customGlobal = global;
  customGlobal.WebSocket ||= wrapper_default;
  customGlobal.window ||= global;
  customGlobal.self ||= global;
  customGlobal.window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = [
    {
      type: 1,
      value: 7,
      isEnabled: true
    },
    {
      type: 2,
      value: "InternalApp",
      isEnabled: true,
      isValid: true
    },
    {
      type: 2,
      value: "InternalAppContext",
      isEnabled: true,
      isValid: true
    },
    {
      type: 2,
      value: "InternalStdoutContext",
      isEnabled: true,
      isValid: true
    },
    {
      type: 2,
      value: "InternalStderrContext",
      isEnabled: true,
      isValid: true
    },
    {
      type: 2,
      value: "InternalStdinContext",
      isEnabled: true,
      isValid: true
    },
    {
      type: 2,
      value: "InternalFocusContext",
      isEnabled: true,
      isValid: true
    }
  ];
});

// node_modules/react-devtools-core/dist/backend.js
var require_backend = __commonJS((exports, module) => {
  (function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === "object" && typeof module === "object")
      module.exports = factory();
    else if (typeof define === "function" && define.amd)
      define([], factory);
    else if (typeof exports === "object")
      exports["ReactDevToolsBackend"] = factory();
    else
      root["ReactDevToolsBackend"] = factory();
  })(self, () => {
    return (() => {
      var __webpack_modules__ = {
        786: (__unused_webpack_module, exports2, __webpack_require__2) => {
          var __webpack_unused_export__;
          function _typeof(o) {
            "@babel/helpers - typeof";
            return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
              return typeof o2;
            } : function(o2) {
              return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
            }, _typeof(o);
          }
          var ErrorStackParser = __webpack_require__2(206), React = __webpack_require__2(189), assign = Object.assign, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), hasOwnProperty = Object.prototype.hasOwnProperty, hookLog = [], primitiveStackCache = null;
          function getPrimitiveStackCache() {
            if (primitiveStackCache === null) {
              var cache3 = new Map;
              try {
                Dispatcher.useContext({
                  _currentValue: null
                });
                Dispatcher.useState(null);
                Dispatcher.useReducer(function(s) {
                  return s;
                }, null);
                Dispatcher.useRef(null);
                typeof Dispatcher.useCacheRefresh === "function" && Dispatcher.useCacheRefresh();
                Dispatcher.useLayoutEffect(function() {});
                Dispatcher.useInsertionEffect(function() {});
                Dispatcher.useEffect(function() {});
                Dispatcher.useImperativeHandle(undefined, function() {
                  return null;
                });
                Dispatcher.useDebugValue(null);
                Dispatcher.useCallback(function() {});
                Dispatcher.useTransition();
                Dispatcher.useSyncExternalStore(function() {
                  return function() {};
                }, function() {
                  return null;
                }, function() {
                  return null;
                });
                Dispatcher.useDeferredValue(null);
                Dispatcher.useMemo(function() {
                  return null;
                });
                Dispatcher.useOptimistic(null, function(s) {
                  return s;
                });
                Dispatcher.useFormState(function(s) {
                  return s;
                }, null);
                Dispatcher.useActionState(function(s) {
                  return s;
                }, null);
                Dispatcher.useHostTransitionStatus();
                typeof Dispatcher.useMemoCache === "function" && Dispatcher.useMemoCache(0);
                if (typeof Dispatcher.use === "function") {
                  Dispatcher.use({
                    $$typeof: REACT_CONTEXT_TYPE,
                    _currentValue: null
                  });
                  Dispatcher.use({
                    then: function then() {},
                    status: "fulfilled",
                    value: null
                  });
                  try {
                    Dispatcher.use({
                      then: function then() {}
                    });
                  } catch (x) {}
                }
                Dispatcher.useId();
                typeof Dispatcher.useEffectEvent === "function" && Dispatcher.useEffectEvent(function() {});
              } finally {
                var readHookLog = hookLog;
                hookLog = [];
              }
              for (var i = 0;i < readHookLog.length; i++) {
                var hook = readHookLog[i];
                cache3.set(hook.primitive, ErrorStackParser.parse(hook.stackError));
              }
              primitiveStackCache = cache3;
            }
            return primitiveStackCache;
          }
          var currentFiber = null, currentHook = null, currentContextDependency = null, currentThenableIndex = 0, currentThenableState = null;
          function nextHook() {
            var hook = currentHook;
            hook !== null && (currentHook = hook.next);
            return hook;
          }
          function readContext(context) {
            if (currentFiber === null)
              return context._currentValue;
            if (currentContextDependency === null)
              throw Error("Context reads do not line up with context dependencies. This is a bug in React Debug Tools.");
            hasOwnProperty.call(currentContextDependency, "memoizedValue") ? (context = currentContextDependency.memoizedValue, currentContextDependency = currentContextDependency.next) : context = context._currentValue;
            return context;
          }
          var SuspenseException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."), Dispatcher = {
            readContext,
            use: function use(usable) {
              if (usable !== null && _typeof(usable) === "object") {
                if (typeof usable.then === "function") {
                  usable = currentThenableState !== null && currentThenableIndex < currentThenableState.length ? currentThenableState[currentThenableIndex++] : usable;
                  switch (usable.status) {
                    case "fulfilled":
                      var fulfilledValue = usable.value;
                      hookLog.push({
                        displayName: null,
                        primitive: "Promise",
                        stackError: Error(),
                        value: fulfilledValue,
                        debugInfo: usable._debugInfo === undefined ? null : usable._debugInfo,
                        dispatcherHookName: "Use"
                      });
                      return fulfilledValue;
                    case "rejected":
                      throw usable.reason;
                  }
                  hookLog.push({
                    displayName: null,
                    primitive: "Unresolved",
                    stackError: Error(),
                    value: usable,
                    debugInfo: usable._debugInfo === undefined ? null : usable._debugInfo,
                    dispatcherHookName: "Use"
                  });
                  throw SuspenseException;
                }
                if (usable.$$typeof === REACT_CONTEXT_TYPE)
                  return fulfilledValue = readContext(usable), hookLog.push({
                    displayName: usable.displayName || "Context",
                    primitive: "Context (use)",
                    stackError: Error(),
                    value: fulfilledValue,
                    debugInfo: null,
                    dispatcherHookName: "Use"
                  }), fulfilledValue;
              }
              throw Error("An unsupported type was passed to use(): " + String(usable));
            },
            useCallback: function useCallback(callback) {
              var hook = nextHook();
              hookLog.push({
                displayName: null,
                primitive: "Callback",
                stackError: Error(),
                value: hook !== null ? hook.memoizedState[0] : callback,
                debugInfo: null,
                dispatcherHookName: "Callback"
              });
              return callback;
            },
            useContext: function useContext(context) {
              var value = readContext(context);
              hookLog.push({
                displayName: context.displayName || null,
                primitive: "Context",
                stackError: Error(),
                value,
                debugInfo: null,
                dispatcherHookName: "Context"
              });
              return value;
            },
            useEffect: function useEffect(create) {
              nextHook();
              hookLog.push({
                displayName: null,
                primitive: "Effect",
                stackError: Error(),
                value: create,
                debugInfo: null,
                dispatcherHookName: "Effect"
              });
            },
            useImperativeHandle: function useImperativeHandle(ref) {
              nextHook();
              var instance = undefined;
              ref !== null && _typeof(ref) === "object" && (instance = ref.current);
              hookLog.push({
                displayName: null,
                primitive: "ImperativeHandle",
                stackError: Error(),
                value: instance,
                debugInfo: null,
                dispatcherHookName: "ImperativeHandle"
              });
            },
            useLayoutEffect: function useLayoutEffect(create) {
              nextHook();
              hookLog.push({
                displayName: null,
                primitive: "LayoutEffect",
                stackError: Error(),
                value: create,
                debugInfo: null,
                dispatcherHookName: "LayoutEffect"
              });
            },
            useInsertionEffect: function useInsertionEffect(create) {
              nextHook();
              hookLog.push({
                displayName: null,
                primitive: "InsertionEffect",
                stackError: Error(),
                value: create,
                debugInfo: null,
                dispatcherHookName: "InsertionEffect"
              });
            },
            useMemo: function useMemo(nextCreate) {
              var hook = nextHook();
              nextCreate = hook !== null ? hook.memoizedState[0] : nextCreate();
              hookLog.push({
                displayName: null,
                primitive: "Memo",
                stackError: Error(),
                value: nextCreate,
                debugInfo: null,
                dispatcherHookName: "Memo"
              });
              return nextCreate;
            },
            useReducer: function useReducer(reducer, initialArg, init) {
              reducer = nextHook();
              initialArg = reducer !== null ? reducer.memoizedState : init !== undefined ? init(initialArg) : initialArg;
              hookLog.push({
                displayName: null,
                primitive: "Reducer",
                stackError: Error(),
                value: initialArg,
                debugInfo: null,
                dispatcherHookName: "Reducer"
              });
              return [initialArg, function() {}];
            },
            useRef: function useRef(initialValue) {
              var hook = nextHook();
              initialValue = hook !== null ? hook.memoizedState : {
                current: initialValue
              };
              hookLog.push({
                displayName: null,
                primitive: "Ref",
                stackError: Error(),
                value: initialValue.current,
                debugInfo: null,
                dispatcherHookName: "Ref"
              });
              return initialValue;
            },
            useState: function useState(initialState) {
              var hook = nextHook();
              initialState = hook !== null ? hook.memoizedState : typeof initialState === "function" ? initialState() : initialState;
              hookLog.push({
                displayName: null,
                primitive: "State",
                stackError: Error(),
                value: initialState,
                debugInfo: null,
                dispatcherHookName: "State"
              });
              return [initialState, function() {}];
            },
            useDebugValue: function useDebugValue(value, formatterFn) {
              hookLog.push({
                displayName: null,
                primitive: "DebugValue",
                stackError: Error(),
                value: typeof formatterFn === "function" ? formatterFn(value) : value,
                debugInfo: null,
                dispatcherHookName: "DebugValue"
              });
            },
            useDeferredValue: function useDeferredValue(value) {
              var hook = nextHook();
              value = hook !== null ? hook.memoizedState : value;
              hookLog.push({
                displayName: null,
                primitive: "DeferredValue",
                stackError: Error(),
                value,
                debugInfo: null,
                dispatcherHookName: "DeferredValue"
              });
              return value;
            },
            useTransition: function useTransition() {
              var stateHook = nextHook();
              nextHook();
              stateHook = stateHook !== null ? stateHook.memoizedState : false;
              hookLog.push({
                displayName: null,
                primitive: "Transition",
                stackError: Error(),
                value: stateHook,
                debugInfo: null,
                dispatcherHookName: "Transition"
              });
              return [stateHook, function() {}];
            },
            useSyncExternalStore: function useSyncExternalStore(subscribe, getSnapshot) {
              nextHook();
              nextHook();
              subscribe = getSnapshot();
              hookLog.push({
                displayName: null,
                primitive: "SyncExternalStore",
                stackError: Error(),
                value: subscribe,
                debugInfo: null,
                dispatcherHookName: "SyncExternalStore"
              });
              return subscribe;
            },
            useId: function useId() {
              var hook = nextHook();
              hook = hook !== null ? hook.memoizedState : "";
              hookLog.push({
                displayName: null,
                primitive: "Id",
                stackError: Error(),
                value: hook,
                debugInfo: null,
                dispatcherHookName: "Id"
              });
              return hook;
            },
            useHostTransitionStatus: function useHostTransitionStatus() {
              var status = readContext({
                _currentValue: null
              });
              hookLog.push({
                displayName: null,
                primitive: "HostTransitionStatus",
                stackError: Error(),
                value: status,
                debugInfo: null,
                dispatcherHookName: "HostTransitionStatus"
              });
              return status;
            },
            useFormState: function useFormState(action, initialState) {
              var hook = nextHook();
              nextHook();
              nextHook();
              action = Error();
              var debugInfo = null, error = null;
              if (hook !== null) {
                if (initialState = hook.memoizedState, _typeof(initialState) === "object" && initialState !== null && typeof initialState.then === "function")
                  switch (initialState.status) {
                    case "fulfilled":
                      var value = initialState.value;
                      debugInfo = initialState._debugInfo === undefined ? null : initialState._debugInfo;
                      break;
                    case "rejected":
                      error = initialState.reason;
                      break;
                    default:
                      error = SuspenseException, debugInfo = initialState._debugInfo === undefined ? null : initialState._debugInfo, value = initialState;
                  }
                else
                  value = initialState;
              } else
                value = initialState;
              hookLog.push({
                displayName: null,
                primitive: "FormState",
                stackError: action,
                value,
                debugInfo,
                dispatcherHookName: "FormState"
              });
              if (error !== null)
                throw error;
              return [value, function() {}, false];
            },
            useActionState: function useActionState(action, initialState) {
              var hook = nextHook();
              nextHook();
              nextHook();
              action = Error();
              var debugInfo = null, error = null;
              if (hook !== null) {
                if (initialState = hook.memoizedState, _typeof(initialState) === "object" && initialState !== null && typeof initialState.then === "function")
                  switch (initialState.status) {
                    case "fulfilled":
                      var value = initialState.value;
                      debugInfo = initialState._debugInfo === undefined ? null : initialState._debugInfo;
                      break;
                    case "rejected":
                      error = initialState.reason;
                      break;
                    default:
                      error = SuspenseException, debugInfo = initialState._debugInfo === undefined ? null : initialState._debugInfo, value = initialState;
                  }
                else
                  value = initialState;
              } else
                value = initialState;
              hookLog.push({
                displayName: null,
                primitive: "ActionState",
                stackError: action,
                value,
                debugInfo,
                dispatcherHookName: "ActionState"
              });
              if (error !== null)
                throw error;
              return [value, function() {}, false];
            },
            useOptimistic: function useOptimistic(passthrough) {
              var hook = nextHook();
              passthrough = hook !== null ? hook.memoizedState : passthrough;
              hookLog.push({
                displayName: null,
                primitive: "Optimistic",
                stackError: Error(),
                value: passthrough,
                debugInfo: null,
                dispatcherHookName: "Optimistic"
              });
              return [passthrough, function() {}];
            },
            useMemoCache: function useMemoCache(size) {
              var fiber = currentFiber;
              if (fiber == null)
                return [];
              fiber = fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;
              if (fiber == null)
                return [];
              var data = fiber.data[fiber.index];
              if (data === undefined) {
                data = fiber.data[fiber.index] = Array(size);
                for (var i = 0;i < size; i++)
                  data[i] = REACT_MEMO_CACHE_SENTINEL;
              }
              fiber.index++;
              return data;
            },
            useCacheRefresh: function useCacheRefresh() {
              var hook = nextHook();
              hookLog.push({
                displayName: null,
                primitive: "CacheRefresh",
                stackError: Error(),
                value: hook !== null ? hook.memoizedState : function() {},
                debugInfo: null,
                dispatcherHookName: "CacheRefresh"
              });
              return function() {};
            },
            useEffectEvent: function useEffectEvent(callback) {
              nextHook();
              hookLog.push({
                displayName: null,
                primitive: "EffectEvent",
                stackError: Error(),
                value: callback,
                debugInfo: null,
                dispatcherHookName: "EffectEvent"
              });
              return callback;
            }
          }, DispatcherProxyHandler = {
            get: function get(target, prop) {
              if (target.hasOwnProperty(prop))
                return target[prop];
              target = Error("Missing method in Dispatcher: " + prop);
              target.name = "ReactDebugToolsUnsupportedHookError";
              throw target;
            }
          }, DispatcherProxy = typeof Proxy === "undefined" ? Dispatcher : new Proxy(Dispatcher, DispatcherProxyHandler), mostLikelyAncestorIndex = 0;
          function findSharedIndex(hookStack, rootStack, rootIndex) {
            var source = rootStack[rootIndex].source, i = 0;
            a:
              for (;i < hookStack.length; i++)
                if (hookStack[i].source === source) {
                  for (var a = rootIndex + 1, b = i + 1;a < rootStack.length && b < hookStack.length; a++, b++)
                    if (hookStack[b].source !== rootStack[a].source)
                      continue a;
                  return i;
                }
            return -1;
          }
          function isReactWrapper(functionName, wrapperName) {
            functionName = parseHookName(functionName);
            return wrapperName === "HostTransitionStatus" ? functionName === wrapperName || functionName === "FormStatus" : functionName === wrapperName;
          }
          function parseHookName(functionName) {
            if (!functionName)
              return "";
            var startIndex = functionName.lastIndexOf("[as ");
            if (startIndex !== -1)
              return parseHookName(functionName.slice(startIndex + 4, -1));
            startIndex = functionName.lastIndexOf(".");
            startIndex = startIndex === -1 ? 0 : startIndex + 1;
            functionName.slice(startIndex).startsWith("unstable_") && (startIndex += 9);
            functionName.slice(startIndex).startsWith("experimental_") && (startIndex += 13);
            if (functionName.slice(startIndex, startIndex + 3) === "use") {
              if (functionName.length - startIndex === 3)
                return "Use";
              startIndex += 3;
            }
            return functionName.slice(startIndex);
          }
          function buildTree(rootStack$jscomp$0, readHookLog) {
            for (var rootChildren = [], prevStack = null, levelChildren = rootChildren, nativeHookID = 0, stackOfChildren = [], i = 0;i < readHookLog.length; i++) {
              var hook = readHookLog[i];
              var rootStack = rootStack$jscomp$0;
              var JSCompiler_inline_result = ErrorStackParser.parse(hook.stackError);
              b: {
                var hookStack = JSCompiler_inline_result, rootIndex = findSharedIndex(hookStack, rootStack, mostLikelyAncestorIndex);
                if (rootIndex !== -1)
                  rootStack = rootIndex;
                else {
                  for (var i$jscomp$0 = 0;i$jscomp$0 < rootStack.length && 5 > i$jscomp$0; i$jscomp$0++)
                    if (rootIndex = findSharedIndex(hookStack, rootStack, i$jscomp$0), rootIndex !== -1) {
                      mostLikelyAncestorIndex = i$jscomp$0;
                      rootStack = rootIndex;
                      break b;
                    }
                  rootStack = -1;
                }
              }
              b: {
                hookStack = JSCompiler_inline_result;
                rootIndex = getPrimitiveStackCache().get(hook.primitive);
                if (rootIndex !== undefined) {
                  for (i$jscomp$0 = 0;i$jscomp$0 < rootIndex.length && i$jscomp$0 < hookStack.length; i$jscomp$0++)
                    if (rootIndex[i$jscomp$0].source !== hookStack[i$jscomp$0].source) {
                      i$jscomp$0 < hookStack.length - 1 && isReactWrapper(hookStack[i$jscomp$0].functionName, hook.dispatcherHookName) && i$jscomp$0++;
                      i$jscomp$0 < hookStack.length - 1 && isReactWrapper(hookStack[i$jscomp$0].functionName, hook.dispatcherHookName) && i$jscomp$0++;
                      hookStack = i$jscomp$0;
                      break b;
                    }
                }
                hookStack = -1;
              }
              JSCompiler_inline_result = rootStack === -1 || hookStack === -1 || 2 > rootStack - hookStack ? hookStack === -1 ? [null, null] : [JSCompiler_inline_result[hookStack - 1], null] : [JSCompiler_inline_result[hookStack - 1], JSCompiler_inline_result.slice(hookStack, rootStack - 1)];
              hookStack = JSCompiler_inline_result[0];
              JSCompiler_inline_result = JSCompiler_inline_result[1];
              rootStack = hook.displayName;
              rootStack === null && hookStack !== null && (rootStack = parseHookName(hookStack.functionName) || parseHookName(hook.dispatcherHookName));
              if (JSCompiler_inline_result !== null) {
                hookStack = 0;
                if (prevStack !== null) {
                  for (;hookStack < JSCompiler_inline_result.length && hookStack < prevStack.length && JSCompiler_inline_result[JSCompiler_inline_result.length - hookStack - 1].source === prevStack[prevStack.length - hookStack - 1].source; )
                    hookStack++;
                  for (prevStack = prevStack.length - 1;prevStack > hookStack; prevStack--)
                    levelChildren = stackOfChildren.pop();
                }
                for (prevStack = JSCompiler_inline_result.length - hookStack - 1;1 <= prevStack; prevStack--)
                  hookStack = [], rootIndex = JSCompiler_inline_result[prevStack], rootIndex = {
                    id: null,
                    isStateEditable: false,
                    name: parseHookName(JSCompiler_inline_result[prevStack - 1].functionName),
                    value: undefined,
                    subHooks: hookStack,
                    debugInfo: null,
                    hookSource: {
                      lineNumber: rootIndex.lineNumber === undefined ? null : rootIndex.lineNumber,
                      columnNumber: rootIndex.columnNumber === undefined ? null : rootIndex.columnNumber,
                      functionName: rootIndex.functionName === undefined ? null : rootIndex.functionName,
                      fileName: rootIndex.fileName === undefined ? null : rootIndex.fileName
                    }
                  }, levelChildren.push(rootIndex), stackOfChildren.push(levelChildren), levelChildren = hookStack;
                prevStack = JSCompiler_inline_result;
              }
              hookStack = hook.primitive;
              rootIndex = hook.debugInfo;
              hook = {
                id: hookStack === "Context" || hookStack === "Context (use)" || hookStack === "DebugValue" || hookStack === "Promise" || hookStack === "Unresolved" || hookStack === "HostTransitionStatus" ? null : nativeHookID++,
                isStateEditable: hookStack === "Reducer" || hookStack === "State",
                name: rootStack || hookStack,
                value: hook.value,
                subHooks: [],
                debugInfo: rootIndex,
                hookSource: null
              };
              rootStack = {
                lineNumber: null,
                functionName: null,
                fileName: null,
                columnNumber: null
              };
              JSCompiler_inline_result && 1 <= JSCompiler_inline_result.length && (JSCompiler_inline_result = JSCompiler_inline_result[0], rootStack.lineNumber = JSCompiler_inline_result.lineNumber === undefined ? null : JSCompiler_inline_result.lineNumber, rootStack.functionName = JSCompiler_inline_result.functionName === undefined ? null : JSCompiler_inline_result.functionName, rootStack.fileName = JSCompiler_inline_result.fileName === undefined ? null : JSCompiler_inline_result.fileName, rootStack.columnNumber = JSCompiler_inline_result.columnNumber === undefined ? null : JSCompiler_inline_result.columnNumber);
              hook.hookSource = rootStack;
              levelChildren.push(hook);
            }
            processDebugValues(rootChildren, null);
            return rootChildren;
          }
          function processDebugValues(hooksTree, parentHooksNode) {
            for (var debugValueHooksNodes = [], i = 0;i < hooksTree.length; i++) {
              var hooksNode = hooksTree[i];
              hooksNode.name === "DebugValue" && hooksNode.subHooks.length === 0 ? (hooksTree.splice(i, 1), i--, debugValueHooksNodes.push(hooksNode)) : processDebugValues(hooksNode.subHooks, hooksNode);
            }
            parentHooksNode !== null && (debugValueHooksNodes.length === 1 ? parentHooksNode.value = debugValueHooksNodes[0].value : 1 < debugValueHooksNodes.length && (parentHooksNode.value = debugValueHooksNodes.map(function(_ref) {
              return _ref.value;
            })));
          }
          function handleRenderFunctionError(error) {
            if (error !== SuspenseException) {
              if (error instanceof Error && error.name === "ReactDebugToolsUnsupportedHookError")
                throw error;
              var wrapperError = Error("Error rendering inspected component", {
                cause: error
              });
              wrapperError.name = "ReactDebugToolsRenderError";
              wrapperError.cause = error;
              throw wrapperError;
            }
          }
          function inspectHooks(renderFunction, props, currentDispatcher) {
            currentDispatcher == null && (currentDispatcher = ReactSharedInternals);
            var previousDispatcher = currentDispatcher.H;
            currentDispatcher.H = DispatcherProxy;
            try {
              var ancestorStackError = Error();
              renderFunction(props);
            } catch (error) {
              handleRenderFunctionError(error);
            } finally {
              renderFunction = hookLog, hookLog = [], currentDispatcher.H = previousDispatcher;
            }
            currentDispatcher = ancestorStackError === undefined ? [] : ErrorStackParser.parse(ancestorStackError);
            return buildTree(currentDispatcher, renderFunction);
          }
          function restoreContexts(contextMap) {
            contextMap.forEach(function(value, context) {
              return context._currentValue = value;
            });
          }
          __webpack_unused_export__ = inspectHooks;
          exports2.inspectHooksOfFiber = function(fiber, currentDispatcher) {
            currentDispatcher == null && (currentDispatcher = ReactSharedInternals);
            if (fiber.tag !== 0 && fiber.tag !== 15 && fiber.tag !== 11)
              throw Error("Unknown Fiber. Needs to be a function component to inspect hooks.");
            getPrimitiveStackCache();
            currentHook = fiber.memoizedState;
            currentFiber = fiber;
            var thenableState = fiber.dependencies && fiber.dependencies._debugThenableState;
            thenableState = thenableState ? thenableState.thenables || thenableState : null;
            currentThenableState = Array.isArray(thenableState) ? thenableState : null;
            currentThenableIndex = 0;
            if (hasOwnProperty.call(currentFiber, "dependencies"))
              thenableState = currentFiber.dependencies, currentContextDependency = thenableState !== null ? thenableState.firstContext : null;
            else if (hasOwnProperty.call(currentFiber, "dependencies_old"))
              thenableState = currentFiber.dependencies_old, currentContextDependency = thenableState !== null ? thenableState.firstContext : null;
            else if (hasOwnProperty.call(currentFiber, "dependencies_new"))
              thenableState = currentFiber.dependencies_new, currentContextDependency = thenableState !== null ? thenableState.firstContext : null;
            else if (hasOwnProperty.call(currentFiber, "contextDependencies"))
              thenableState = currentFiber.contextDependencies, currentContextDependency = thenableState !== null ? thenableState.first : null;
            else
              throw Error("Unsupported React version. This is a bug in React Debug Tools.");
            thenableState = fiber.type;
            var props = fiber.memoizedProps;
            if (thenableState !== fiber.elementType && thenableState && thenableState.defaultProps) {
              props = assign({}, props);
              var defaultProps = thenableState.defaultProps;
              for (propName in defaultProps)
                props[propName] === undefined && (props[propName] = defaultProps[propName]);
            }
            var propName = new Map;
            try {
              if (currentContextDependency !== null && !hasOwnProperty.call(currentContextDependency, "memoizedValue"))
                for (defaultProps = fiber;defaultProps; ) {
                  if (defaultProps.tag === 10) {
                    var context = defaultProps.type;
                    context._context !== undefined && (context = context._context);
                    propName.has(context) || (propName.set(context, context._currentValue), context._currentValue = defaultProps.memoizedProps.value);
                  }
                  defaultProps = defaultProps.return;
                }
              if (fiber.tag === 11) {
                var renderFunction = thenableState.render;
                context = props;
                var ref = fiber.ref;
                fiber = currentDispatcher;
                var previousDispatcher = fiber.H;
                fiber.H = DispatcherProxy;
                try {
                  var ancestorStackError = Error();
                  renderFunction(context, ref);
                } catch (error) {
                  handleRenderFunctionError(error);
                } finally {
                  var readHookLog = hookLog;
                  hookLog = [];
                  fiber.H = previousDispatcher;
                }
                var rootStack = ancestorStackError === undefined ? [] : ErrorStackParser.parse(ancestorStackError);
                return buildTree(rootStack, readHookLog);
              }
              return inspectHooks(thenableState, props, currentDispatcher);
            } finally {
              currentThenableState = currentContextDependency = currentHook = currentFiber = null, currentThenableIndex = 0, restoreContexts(propName);
            }
          };
        },
        987: (module2, __unused_webpack_exports, __webpack_require__2) => {
          if (true) {
            module2.exports = __webpack_require__2(786);
          } else {}
        },
        126: (__unused_webpack_module, exports2, __webpack_require__2) => {
          var process3 = __webpack_require__2(169);
          function _typeof(o) {
            "@babel/helpers - typeof";
            return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
              return typeof o2;
            } : function(o2) {
              return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
            }, _typeof(o);
          }
          var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_POSTPONE_TYPE = Symbol.for("react.postpone"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || _typeof(maybeIterable) !== "object")
              return null;
            maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
            return typeof maybeIterable === "function" ? maybeIterable : null;
          }
          var ReactNoopUpdateQueue = {
            isMounted: function isMounted() {
              return false;
            },
            enqueueForceUpdate: function enqueueForceUpdate() {},
            enqueueReplaceState: function enqueueReplaceState() {},
            enqueueSetState: function enqueueSetState() {}
          }, assign = Object.assign, emptyObject = {};
          function Component(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component.prototype.isReactComponent = {};
          Component.prototype.setState = function(partialState, callback) {
            if (_typeof(partialState) !== "object" && typeof partialState !== "function" && partialState != null)
              throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          function ComponentDummy() {}
          ComponentDummy.prototype = Component.prototype;
          function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent.prototype = new ComponentDummy;
          pureComponentPrototype.constructor = PureComponent;
          assign(pureComponentPrototype, Component.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          var isArrayImpl = Array.isArray;
          function noop() {}
          var ReactSharedInternals = {
            H: null,
            A: null,
            T: null,
            S: null,
            G: null
          }, hasOwnProperty = Object.prototype.hasOwnProperty;
          function ReactElement(type, key, props) {
            var refProp = props.ref;
            return {
              $$typeof: REACT_ELEMENT_TYPE,
              type,
              key,
              ref: refProp !== undefined ? refProp : null,
              props
            };
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            return ReactElement(oldElement.type, newKey, oldElement.props);
          }
          function isValidElement(object) {
            return _typeof(object) === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function escape(key) {
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            return "$" + key.replace(/[=:]/g, function(match) {
              return escaperLookup[match];
            });
          }
          var userProvidedKeyEscapeRegex = /\/+/g;
          function getElementKey(element, index) {
            return _typeof(element) === "object" && element !== null && element.key != null ? escape("" + element.key) : index.toString(36);
          }
          function resolveThenable(thenable) {
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
              default:
                switch (typeof thenable.status === "string" ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
                  thenable.status === "pending" && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                }, function(error) {
                  thenable.status === "pending" && (thenable.status = "rejected", thenable.reason = error);
                })), thenable.status) {
                  case "fulfilled":
                    return thenable.value;
                  case "rejected":
                    throw thenable.reason;
                }
            }
            throw thenable;
          }
          function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = _typeof(children);
            if (type === "undefined" || type === "boolean")
              children = null;
            var invokeCallback = false;
            if (children === null)
              invokeCallback = true;
            else
              switch (type) {
                case "bigint":
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                      break;
                    case REACT_LAZY_TYPE:
                      return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
                  }
              }
            if (invokeCallback)
              return callback = callback(children), invokeCallback = nameSoFar === "" ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", invokeCallback != null && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
                return c;
              })) : callback != null && (isValidElement(callback) && (callback = cloneAndReplaceKey(callback, escapedPrefix + (callback.key == null || children && children.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + invokeCallback)), array.push(callback)), 1;
            invokeCallback = 0;
            var nextNamePrefix = nameSoFar === "" ? "." : nameSoFar + ":";
            if (isArrayImpl(children))
              for (var i = 0;i < children.length; i++)
                nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
            else if (i = getIteratorFn(children), typeof i === "function")
              for (children = i.call(children), i = 0;!(nameSoFar = children.next()).done; )
                nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
            else if (type === "object") {
              if (typeof children.then === "function")
                return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
              array = String(children);
              throw Error("Objects are not valid as a React child (found: " + (array === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
            }
            return invokeCallback;
          }
          function mapChildren(children, func, context) {
            if (children == null)
              return children;
            var result = [], count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context, child, count++);
            });
            return result;
          }
          function lazyInitializer(payload) {
            if (payload._status === -1) {
              var ctor = payload._result;
              ctor = ctor();
              ctor.then(function(moduleObject) {
                if (payload._status === 0 || payload._status === -1)
                  payload._status = 1, payload._result = moduleObject;
              }, function(error) {
                if (payload._status === 0 || payload._status === -1)
                  payload._status = 2, payload._result = error;
              });
              payload._status === -1 && (payload._status = 0, payload._result = ctor);
            }
            if (payload._status === 1)
              return payload._result.default;
            throw payload._result;
          }
          function useOptimistic(passthrough, reducer) {
            return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
          }
          var reportGlobalError = typeof reportError === "function" ? reportError : function(error) {
            if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && typeof window.ErrorEvent === "function") {
              var event = new window.ErrorEvent("error", {
                bubbles: true,
                cancelable: true,
                message: _typeof(error) === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error),
                error
              });
              if (!window.dispatchEvent(event))
                return;
            } else if ((typeof process3 === "undefined" ? "undefined" : _typeof(process3)) === "object" && typeof process3.emit === "function") {
              process3.emit("uncaughtException", error);
              return;
            }
            console.error(error);
          };
          function startTransition(scope) {
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            currentTransition.types = prevTransition !== null ? prevTransition.types : null;
            currentTransition.gesture = null;
            ReactSharedInternals.T = currentTransition;
            try {
              var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
              onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
              _typeof(returnValue) === "object" && returnValue !== null && typeof returnValue.then === "function" && returnValue.then(noop, reportGlobalError);
            } catch (error) {
              reportGlobalError(error);
            } finally {
              prevTransition !== null && currentTransition.types !== null && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
            }
          }
          function addTransitionType(type) {
            var transition = ReactSharedInternals.T;
            if (transition !== null) {
              var transitionTypes = transition.types;
              transitionTypes === null ? transition.types = [type] : transitionTypes.indexOf(type) === -1 && transitionTypes.push(type);
            } else
              startTransition(addTransitionType.bind(null, type));
          }
          var Children = {
            map: mapChildren,
            forEach: function forEach(children, forEachFunc, forEachContext) {
              mapChildren(children, function() {
                forEachFunc.apply(this, arguments);
              }, forEachContext);
            },
            count: function count(children) {
              var n = 0;
              mapChildren(children, function() {
                n++;
              });
              return n;
            },
            toArray: function toArray(children) {
              return mapChildren(children, function(child) {
                return child;
              }) || [];
            },
            only: function only(children) {
              if (!isValidElement(children))
                throw Error("React.Children.only expected to receive a single React element child.");
              return children;
            }
          };
          exports2.Activity = REACT_ACTIVITY_TYPE;
          exports2.Children = Children;
          exports2.Component = Component;
          exports2.Fragment = REACT_FRAGMENT_TYPE;
          exports2.Profiler = REACT_PROFILER_TYPE;
          exports2.PureComponent = PureComponent;
          exports2.StrictMode = REACT_STRICT_MODE_TYPE;
          exports2.Suspense = REACT_SUSPENSE_TYPE;
          exports2.ViewTransition = REACT_VIEW_TRANSITION_TYPE;
          exports2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
          exports2.__COMPILER_RUNTIME = {
            __proto__: null,
            c: function c(size) {
              return ReactSharedInternals.H.useMemoCache(size);
            }
          };
          exports2.addTransitionType = addTransitionType;
          exports2.cache = function(fn) {
            return function() {
              return fn.apply(null, arguments);
            };
          };
          exports2.cacheSignal = function() {
            return null;
          };
          exports2.cloneElement = function(element, config, children) {
            if (element === null || element === undefined)
              throw Error("The argument must be a React element, but you passed " + element + ".");
            var props = assign({}, element.props), key = element.key;
            if (config != null)
              for (propName in config.key !== undefined && (key = "" + config.key), config)
                !hasOwnProperty.call(config, propName) || propName === "key" || propName === "__self" || propName === "__source" || propName === "ref" && config.ref === undefined || (props[propName] = config[propName]);
            var propName = arguments.length - 2;
            if (propName === 1)
              props.children = children;
            else if (1 < propName) {
              for (var childArray = Array(propName), i = 0;i < propName; i++)
                childArray[i] = arguments[i + 2];
              props.children = childArray;
            }
            return ReactElement(element.type, key, props);
          };
          exports2.createContext = function(defaultValue) {
            defaultValue = {
              $$typeof: REACT_CONTEXT_TYPE,
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              _threadCount: 0,
              Provider: null,
              Consumer: null
            };
            defaultValue.Provider = defaultValue;
            defaultValue.Consumer = {
              $$typeof: REACT_CONSUMER_TYPE,
              _context: defaultValue
            };
            return defaultValue;
          };
          exports2.createElement = function(type, config, children) {
            var propName, props = {}, key = null;
            if (config != null)
              for (propName in config.key !== undefined && (key = "" + config.key), config)
                hasOwnProperty.call(config, propName) && propName !== "key" && propName !== "__self" && propName !== "__source" && (props[propName] = config[propName]);
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1)
              props.children = children;
            else if (1 < childrenLength) {
              for (var childArray = Array(childrenLength), i = 0;i < childrenLength; i++)
                childArray[i] = arguments[i + 2];
              props.children = childArray;
            }
            if (type && type.defaultProps)
              for (propName in childrenLength = type.defaultProps, childrenLength)
                props[propName] === undefined && (props[propName] = childrenLength[propName]);
            return ReactElement(type, key, props);
          };
          exports2.createRef = function() {
            return {
              current: null
            };
          };
          exports2.experimental_useOptimistic = function(passthrough, reducer) {
            return useOptimistic(passthrough, reducer);
          };
          exports2.forwardRef = function(render) {
            return {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
          };
          exports2.isValidElement = isValidElement;
          exports2.lazy = function(ctor) {
            return {
              $$typeof: REACT_LAZY_TYPE,
              _payload: {
                _status: -1,
                _result: ctor
              },
              _init: lazyInitializer
            };
          };
          exports2.memo = function(type, compare) {
            return {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare === undefined ? null : compare
            };
          };
          exports2.startTransition = startTransition;
          exports2.unstable_Activity = REACT_ACTIVITY_TYPE;
          exports2.unstable_SuspenseList = REACT_SUSPENSE_LIST_TYPE;
          exports2.unstable_getCacheForType = function(resourceType) {
            var dispatcher = ReactSharedInternals.A;
            return dispatcher ? dispatcher.getCacheForType(resourceType) : resourceType();
          };
          exports2.unstable_postpone = function(reason) {
            reason = Error(reason);
            reason.$$typeof = REACT_POSTPONE_TYPE;
            throw reason;
          };
          exports2.unstable_startGestureTransition = function(provider, scope, options) {
            if (provider == null)
              throw Error("A Timeline is required as the first argument to startGestureTransition.");
            var prevTransition = ReactSharedInternals.T, currentTransition = {
              types: null
            };
            currentTransition.gesture = provider;
            ReactSharedInternals.T = currentTransition;
            try {
              scope();
              var onStartGestureTransitionFinish = ReactSharedInternals.G;
              if (onStartGestureTransitionFinish !== null)
                return onStartGestureTransitionFinish(currentTransition, provider, options);
            } catch (error) {
              reportGlobalError(error);
            } finally {
              ReactSharedInternals.T = prevTransition;
            }
            return noop;
          };
          exports2.unstable_useCacheRefresh = function() {
            return ReactSharedInternals.H.useCacheRefresh();
          };
          exports2.use = function(usable) {
            return ReactSharedInternals.H.use(usable);
          };
          exports2.useActionState = function(action, initialState, permalink) {
            return ReactSharedInternals.H.useActionState(action, initialState, permalink);
          };
          exports2.useCallback = function(callback, deps) {
            return ReactSharedInternals.H.useCallback(callback, deps);
          };
          exports2.useContext = function(Context) {
            return ReactSharedInternals.H.useContext(Context);
          };
          exports2.useDebugValue = function() {};
          exports2.useDeferredValue = function(value, initialValue) {
            return ReactSharedInternals.H.useDeferredValue(value, initialValue);
          };
          exports2.useEffect = function(create, deps) {
            return ReactSharedInternals.H.useEffect(create, deps);
          };
          exports2.useEffectEvent = function(callback) {
            return ReactSharedInternals.H.useEffectEvent(callback);
          };
          exports2.useId = function() {
            return ReactSharedInternals.H.useId();
          };
          exports2.useImperativeHandle = function(ref, create, deps) {
            return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
          };
          exports2.useInsertionEffect = function(create, deps) {
            return ReactSharedInternals.H.useInsertionEffect(create, deps);
          };
          exports2.useLayoutEffect = function(create, deps) {
            return ReactSharedInternals.H.useLayoutEffect(create, deps);
          };
          exports2.useMemo = function(create, deps) {
            return ReactSharedInternals.H.useMemo(create, deps);
          };
          exports2.useOptimistic = useOptimistic;
          exports2.useReducer = function(reducer, initialArg, init) {
            return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
          };
          exports2.useRef = function(initialValue) {
            return ReactSharedInternals.H.useRef(initialValue);
          };
          exports2.useState = function(initialState) {
            return ReactSharedInternals.H.useState(initialState);
          };
          exports2.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
            return ReactSharedInternals.H.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          };
          exports2.useTransition = function() {
            return ReactSharedInternals.H.useTransition();
          };
          exports2.version = "19.3.0-experimental-3cde211b-20251020";
        },
        189: (module2, __unused_webpack_exports, __webpack_require__2) => {
          if (true) {
            module2.exports = __webpack_require__2(126);
          } else {}
        },
        206: function(module2, exports2, __webpack_require__2) {
          var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
          function _typeof(o) {
            "@babel/helpers - typeof";
            return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
              return typeof o2;
            } : function(o2) {
              return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
            }, _typeof(o);
          }
          (function(root, factory) {
            if (true) {
              __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__2(430)], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__);
            } else {}
          })(this, function ErrorStackParser(StackFrame) {
            var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
            var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
            var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
            return {
              parse: function ErrorStackParser$$parse(error) {
                if (typeof error.stacktrace !== "undefined" || typeof error["opera#sourceloc"] !== "undefined") {
                  return this.parseOpera(error);
                } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                  return this.parseV8OrIE(error);
                } else if (error.stack) {
                  return this.parseFFOrSafari(error);
                } else {
                  throw new Error("Cannot parse given Error object");
                }
              },
              extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
                if (urlLike.indexOf(":") === -1) {
                  return [urlLike];
                }
                var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
                var parts = regExp.exec(urlLike.replace(/[()]/g, ""));
                return [parts[1], parts[2] || undefined, parts[3] || undefined];
              },
              parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
                var filtered = error.stack.split(`
`).filter(function(line) {
                  return !!line.match(CHROME_IE_STACK_REGEXP);
                }, this);
                return filtered.map(function(line) {
                  if (line.indexOf("(eval ") > -1) {
                    line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(\),.*$)/g, "");
                  }
                  var sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(");
                  var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);
                  sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
                  var tokens = sanitizedLine.split(/\s+/).slice(1);
                  var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
                  var functionName = tokens.join(" ") || undefined;
                  var fileName = ["eval", "<anonymous>"].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];
                  return new StackFrame({
                    functionName,
                    fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                  });
                }, this);
              },
              parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
                var filtered = error.stack.split(`
`).filter(function(line) {
                  return !line.match(SAFARI_NATIVE_CODE_REGEXP);
                }, this);
                return filtered.map(function(line) {
                  if (line.indexOf(" > eval") > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
                  }
                  if (line.indexOf("@") === -1 && line.indexOf(":") === -1) {
                    return new StackFrame({
                      functionName: line
                    });
                  } else {
                    var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                    var matches = line.match(functionNameRegex);
                    var functionName = matches && matches[1] ? matches[1] : undefined;
                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ""));
                    return new StackFrame({
                      functionName,
                      fileName: locationParts[0],
                      lineNumber: locationParts[1],
                      columnNumber: locationParts[2],
                      source: line
                    });
                  }
                }, this);
              },
              parseOpera: function ErrorStackParser$$parseOpera(e) {
                if (!e.stacktrace || e.message.indexOf(`
`) > -1 && e.message.split(`
`).length > e.stacktrace.split(`
`).length) {
                  return this.parseOpera9(e);
                } else if (!e.stack) {
                  return this.parseOpera10(e);
                } else {
                  return this.parseOpera11(e);
                }
              },
              parseOpera9: function ErrorStackParser$$parseOpera9(e) {
                var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
                var lines = e.message.split(`
`);
                var result = [];
                for (var i = 2, len = lines.length;i < len; i += 2) {
                  var match = lineRE.exec(lines[i]);
                  if (match) {
                    result.push(new StackFrame({
                      fileName: match[2],
                      lineNumber: match[1],
                      source: lines[i]
                    }));
                  }
                }
                return result;
              },
              parseOpera10: function ErrorStackParser$$parseOpera10(e) {
                var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
                var lines = e.stacktrace.split(`
`);
                var result = [];
                for (var i = 0, len = lines.length;i < len; i += 2) {
                  var match = lineRE.exec(lines[i]);
                  if (match) {
                    result.push(new StackFrame({
                      functionName: match[3] || undefined,
                      fileName: match[2],
                      lineNumber: match[1],
                      source: lines[i]
                    }));
                  }
                }
                return result;
              },
              parseOpera11: function ErrorStackParser$$parseOpera11(error) {
                var filtered = error.stack.split(`
`).filter(function(line) {
                  return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
                }, this);
                return filtered.map(function(line) {
                  var tokens = line.split("@");
                  var locationParts = this.extractLocation(tokens.pop());
                  var functionCall = tokens.shift() || "";
                  var functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || undefined;
                  var argsRaw;
                  if (functionCall.match(/\(([^)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1");
                  }
                  var args = argsRaw === undefined || argsRaw === "[arguments not available]" ? undefined : argsRaw.split(",");
                  return new StackFrame({
                    functionName,
                    args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                  });
                }, this);
              }
            };
          });
        },
        730: (module2, __unused_webpack_exports, __webpack_require__2) => {
          function _typeof(o) {
            "@babel/helpers - typeof";
            return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
              return typeof o2;
            } : function(o2) {
              return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
            }, _typeof(o);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0;i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            Object.defineProperty(Constructor, "prototype", { writable: false });
            return Constructor;
          }
          function _toPropertyKey(t) {
            var i = _toPrimitive(t, "string");
            return _typeof(i) == "symbol" ? i : i + "";
          }
          function _toPrimitive(t, r) {
            if (_typeof(t) != "object" || !t)
              return t;
            var e = t[Symbol.toPrimitive];
            if (e !== undefined) {
              var i = e.call(t, r || "default");
              if (_typeof(i) != "object")
                return i;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (r === "string" ? String : Number)(t);
          }
          var Yallist = __webpack_require__2(695);
          var MAX = Symbol("max");
          var LENGTH = Symbol("length");
          var LENGTH_CALCULATOR = Symbol("lengthCalculator");
          var ALLOW_STALE = Symbol("allowStale");
          var MAX_AGE = Symbol("maxAge");
          var DISPOSE = Symbol("dispose");
          var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
          var LRU_LIST = Symbol("lruList");
          var CACHE = Symbol("cache");
          var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
          var naiveLength = function naiveLength() {
            return 1;
          };
          var LRUCache = /* @__PURE__ */ function() {
            function LRUCache2(options) {
              _classCallCheck(this, LRUCache2);
              if (typeof options === "number")
                options = {
                  max: options
                };
              if (!options)
                options = {};
              if (options.max && (typeof options.max !== "number" || options.max < 0))
                throw new TypeError("max must be a non-negative number");
              var max = this[MAX] = options.max || Infinity;
              var lc = options.length || naiveLength;
              this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
              this[ALLOW_STALE] = options.stale || false;
              if (options.maxAge && typeof options.maxAge !== "number")
                throw new TypeError("maxAge must be a number");
              this[MAX_AGE] = options.maxAge || 0;
              this[DISPOSE] = options.dispose;
              this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
              this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
              this.reset();
            }
            return _createClass(LRUCache2, [{
              key: "max",
              get: function get() {
                return this[MAX];
              },
              set: function set(mL) {
                if (typeof mL !== "number" || mL < 0)
                  throw new TypeError("max must be a non-negative number");
                this[MAX] = mL || Infinity;
                trim(this);
              }
            }, {
              key: "allowStale",
              get: function get() {
                return this[ALLOW_STALE];
              },
              set: function set(allowStale) {
                this[ALLOW_STALE] = !!allowStale;
              }
            }, {
              key: "maxAge",
              get: function get() {
                return this[MAX_AGE];
              },
              set: function set(mA) {
                if (typeof mA !== "number")
                  throw new TypeError("maxAge must be a non-negative number");
                this[MAX_AGE] = mA;
                trim(this);
              }
            }, {
              key: "lengthCalculator",
              get: function get() {
                return this[LENGTH_CALCULATOR];
              },
              set: function set(lC) {
                var _this = this;
                if (typeof lC !== "function")
                  lC = naiveLength;
                if (lC !== this[LENGTH_CALCULATOR]) {
                  this[LENGTH_CALCULATOR] = lC;
                  this[LENGTH] = 0;
                  this[LRU_LIST].forEach(function(hit) {
                    hit.length = _this[LENGTH_CALCULATOR](hit.value, hit.key);
                    _this[LENGTH] += hit.length;
                  });
                }
                trim(this);
              }
            }, {
              key: "length",
              get: function get() {
                return this[LENGTH];
              }
            }, {
              key: "itemCount",
              get: function get() {
                return this[LRU_LIST].length;
              }
            }, {
              key: "rforEach",
              value: function rforEach(fn, thisp) {
                thisp = thisp || this;
                for (var walker = this[LRU_LIST].tail;walker !== null; ) {
                  var prev = walker.prev;
                  forEachStep(this, fn, walker, thisp);
                  walker = prev;
                }
              }
            }, {
              key: "forEach",
              value: function forEach(fn, thisp) {
                thisp = thisp || this;
                for (var walker = this[LRU_LIST].head;walker !== null; ) {
                  var next = walker.next;
                  forEachStep(this, fn, walker, thisp);
                  walker = next;
                }
              }
            }, {
              key: "keys",
              value: function keys() {
                return this[LRU_LIST].toArray().map(function(k) {
                  return k.key;
                });
              }
            }, {
              key: "values",
              value: function values() {
                return this[LRU_LIST].toArray().map(function(k) {
                  return k.value;
                });
              }
            }, {
              key: "reset",
              value: function reset() {
                var _this2 = this;
                if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
                  this[LRU_LIST].forEach(function(hit) {
                    return _this2[DISPOSE](hit.key, hit.value);
                  });
                }
                this[CACHE] = new Map;
                this[LRU_LIST] = new Yallist;
                this[LENGTH] = 0;
              }
            }, {
              key: "dump",
              value: function dump() {
                var _this3 = this;
                return this[LRU_LIST].map(function(hit) {
                  return isStale(_this3, hit) ? false : {
                    k: hit.key,
                    v: hit.value,
                    e: hit.now + (hit.maxAge || 0)
                  };
                }).toArray().filter(function(h) {
                  return h;
                });
              }
            }, {
              key: "dumpLru",
              value: function dumpLru() {
                return this[LRU_LIST];
              }
            }, {
              key: "set",
              value: function set(key, value, maxAge) {
                maxAge = maxAge || this[MAX_AGE];
                if (maxAge && typeof maxAge !== "number")
                  throw new TypeError("maxAge must be a number");
                var now = maxAge ? Date.now() : 0;
                var len = this[LENGTH_CALCULATOR](value, key);
                if (this[CACHE].has(key)) {
                  if (len > this[MAX]) {
                    _del(this, this[CACHE].get(key));
                    return false;
                  }
                  var node = this[CACHE].get(key);
                  var item = node.value;
                  if (this[DISPOSE]) {
                    if (!this[NO_DISPOSE_ON_SET])
                      this[DISPOSE](key, item.value);
                  }
                  item.now = now;
                  item.maxAge = maxAge;
                  item.value = value;
                  this[LENGTH] += len - item.length;
                  item.length = len;
                  this.get(key);
                  trim(this);
                  return true;
                }
                var hit = new Entry(key, value, len, now, maxAge);
                if (hit.length > this[MAX]) {
                  if (this[DISPOSE])
                    this[DISPOSE](key, value);
                  return false;
                }
                this[LENGTH] += hit.length;
                this[LRU_LIST].unshift(hit);
                this[CACHE].set(key, this[LRU_LIST].head);
                trim(this);
                return true;
              }
            }, {
              key: "has",
              value: function has(key) {
                if (!this[CACHE].has(key))
                  return false;
                var hit = this[CACHE].get(key).value;
                return !isStale(this, hit);
              }
            }, {
              key: "get",
              value: function get(key) {
                return _get(this, key, true);
              }
            }, {
              key: "peek",
              value: function peek(key) {
                return _get(this, key, false);
              }
            }, {
              key: "pop",
              value: function pop() {
                var node = this[LRU_LIST].tail;
                if (!node)
                  return null;
                _del(this, node);
                return node.value;
              }
            }, {
              key: "del",
              value: function del(key) {
                _del(this, this[CACHE].get(key));
              }
            }, {
              key: "load",
              value: function load(arr) {
                this.reset();
                var now = Date.now();
                for (var l = arr.length - 1;l >= 0; l--) {
                  var hit = arr[l];
                  var expiresAt = hit.e || 0;
                  if (expiresAt === 0)
                    this.set(hit.k, hit.v);
                  else {
                    var maxAge = expiresAt - now;
                    if (maxAge > 0) {
                      this.set(hit.k, hit.v, maxAge);
                    }
                  }
                }
              }
            }, {
              key: "prune",
              value: function prune() {
                var _this4 = this;
                this[CACHE].forEach(function(value, key) {
                  return _get(_this4, key, false);
                });
              }
            }]);
          }();
          var _get = function _get(self2, key, doUse) {
            var node = self2[CACHE].get(key);
            if (node) {
              var hit = node.value;
              if (isStale(self2, hit)) {
                _del(self2, node);
                if (!self2[ALLOW_STALE])
                  return;
              } else {
                if (doUse) {
                  if (self2[UPDATE_AGE_ON_GET])
                    node.value.now = Date.now();
                  self2[LRU_LIST].unshiftNode(node);
                }
              }
              return hit.value;
            }
          };
          var isStale = function isStale(self2, hit) {
            if (!hit || !hit.maxAge && !self2[MAX_AGE])
              return false;
            var diff = Date.now() - hit.now;
            return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
          };
          var trim = function trim(self2) {
            if (self2[LENGTH] > self2[MAX]) {
              for (var walker = self2[LRU_LIST].tail;self2[LENGTH] > self2[MAX] && walker !== null; ) {
                var prev = walker.prev;
                _del(self2, walker);
                walker = prev;
              }
            }
          };
          var _del = function _del(self2, node) {
            if (node) {
              var hit = node.value;
              if (self2[DISPOSE])
                self2[DISPOSE](hit.key, hit.value);
              self2[LENGTH] -= hit.length;
              self2[CACHE].delete(hit.key);
              self2[LRU_LIST].removeNode(node);
            }
          };
          var Entry = /* @__PURE__ */ _createClass(function Entry(key, value, length, now, maxAge) {
            _classCallCheck(this, Entry);
            this.key = key;
            this.value = value;
            this.length = length;
            this.now = now;
            this.maxAge = maxAge || 0;
          });
          var forEachStep = function forEachStep(self2, fn, node, thisp) {
            var hit = node.value;
            if (isStale(self2, hit)) {
              _del(self2, node);
              if (!self2[ALLOW_STALE])
                hit = undefined;
            }
            if (hit)
              fn.call(thisp, hit.value, hit.key, self2);
          };
          module2.exports = LRUCache;
        },
        169: (module2) => {
          var process3 = module2.exports = {};
          var cachedSetTimeout;
          var cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }
          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }
          (function() {
            try {
              if (typeof setTimeout === "function") {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === "function") {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e2) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e2) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process3.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i = 1;i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function() {
            this.fun.apply(null, this.array);
          };
          process3.title = "browser";
          process3.browser = true;
          process3.env = {};
          process3.argv = [];
          process3.version = "";
          process3.versions = {};
          function noop() {}
          process3.on = noop;
          process3.addListener = noop;
          process3.once = noop;
          process3.off = noop;
          process3.removeListener = noop;
          process3.removeAllListeners = noop;
          process3.emit = noop;
          process3.prependListener = noop;
          process3.prependOnceListener = noop;
          process3.listeners = function(name) {
            return [];
          };
          process3.binding = function(name) {
            throw new Error("process.binding is not supported");
          };
          process3.cwd = function() {
            return "/";
          };
          process3.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
          };
          process3.umask = function() {
            return 0;
          };
        },
        430: function(module2, exports2) {
          var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
          function _typeof(o) {
            "@babel/helpers - typeof";
            return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
              return typeof o2;
            } : function(o2) {
              return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
            }, _typeof(o);
          }
          (function(root, factory) {
            if (true) {
              __WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__);
            } else {}
          })(this, function() {
            function _isNumber(n) {
              return !isNaN(parseFloat(n)) && isFinite(n);
            }
            function _capitalize(str) {
              return str.charAt(0).toUpperCase() + str.substring(1);
            }
            function _getter(p) {
              return function() {
                return this[p];
              };
            }
            var booleanProps = ["isConstructor", "isEval", "isNative", "isToplevel"];
            var numericProps = ["columnNumber", "lineNumber"];
            var stringProps = ["fileName", "functionName", "source"];
            var arrayProps = ["args"];
            var props = booleanProps.concat(numericProps, stringProps, arrayProps);
            function StackFrame(obj) {
              if (!obj)
                return;
              for (var i2 = 0;i2 < props.length; i2++) {
                if (obj[props[i2]] !== undefined) {
                  this["set" + _capitalize(props[i2])](obj[props[i2]]);
                }
              }
            }
            StackFrame.prototype = {
              getArgs: function getArgs() {
                return this.args;
              },
              setArgs: function setArgs(v) {
                if (Object.prototype.toString.call(v) !== "[object Array]") {
                  throw new TypeError("Args must be an Array");
                }
                this.args = v;
              },
              getEvalOrigin: function getEvalOrigin() {
                return this.evalOrigin;
              },
              setEvalOrigin: function setEvalOrigin(v) {
                if (v instanceof StackFrame) {
                  this.evalOrigin = v;
                } else if (v instanceof Object) {
                  this.evalOrigin = new StackFrame(v);
                } else {
                  throw new TypeError("Eval Origin must be an Object or StackFrame");
                }
              },
              toString: function toString() {
                var fileName = this.getFileName() || "";
                var lineNumber = this.getLineNumber() || "";
                var columnNumber = this.getColumnNumber() || "";
                var functionName = this.getFunctionName() || "";
                if (this.getIsEval()) {
                  if (fileName) {
                    return "[eval] (" + fileName + ":" + lineNumber + ":" + columnNumber + ")";
                  }
                  return "[eval]:" + lineNumber + ":" + columnNumber;
                }
                if (functionName) {
                  return functionName + " (" + fileName + ":" + lineNumber + ":" + columnNumber + ")";
                }
                return fileName + ":" + lineNumber + ":" + columnNumber;
              }
            };
            StackFrame.fromString = function StackFrame$$fromString(str) {
              var argsStartIndex = str.indexOf("(");
              var argsEndIndex = str.lastIndexOf(")");
              var functionName = str.substring(0, argsStartIndex);
              var args = str.substring(argsStartIndex + 1, argsEndIndex).split(",");
              var locationString = str.substring(argsEndIndex + 1);
              if (locationString.indexOf("@") === 0) {
                var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, "");
                var fileName = parts[1];
                var lineNumber = parts[2];
                var columnNumber = parts[3];
              }
              return new StackFrame({
                functionName,
                args: args || undefined,
                fileName,
                lineNumber: lineNumber || undefined,
                columnNumber: columnNumber || undefined
              });
            };
            for (var i = 0;i < booleanProps.length; i++) {
              StackFrame.prototype["get" + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
              StackFrame.prototype["set" + _capitalize(booleanProps[i])] = function(p) {
                return function(v) {
                  this[p] = Boolean(v);
                };
              }(booleanProps[i]);
            }
            for (var j = 0;j < numericProps.length; j++) {
              StackFrame.prototype["get" + _capitalize(numericProps[j])] = _getter(numericProps[j]);
              StackFrame.prototype["set" + _capitalize(numericProps[j])] = function(p) {
                return function(v) {
                  if (!_isNumber(v)) {
                    throw new TypeError(p + " must be a Number");
                  }
                  this[p] = Number(v);
                };
              }(numericProps[j]);
            }
            for (var k = 0;k < stringProps.length; k++) {
              StackFrame.prototype["get" + _capitalize(stringProps[k])] = _getter(stringProps[k]);
              StackFrame.prototype["set" + _capitalize(stringProps[k])] = function(p) {
                return function(v) {
                  this[p] = String(v);
                };
              }(stringProps[k]);
            }
            return StackFrame;
          });
        },
        476: (module2) => {
          function _typeof(o) {
            "@babel/helpers - typeof";
            return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
              return typeof o2;
            } : function(o2) {
              return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
            }, _typeof(o);
          }
          function _regeneratorRuntime() {
            /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
            _regeneratorRuntime = function _regeneratorRuntime() {
              return e;
            };
            var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
              t2[e2] = r2.value;
            }, i = typeof Symbol == "function" ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
            function define2(t2, e2, r2) {
              return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
            }
            try {
              define2({}, "");
            } catch (t2) {
              define2 = function define(t3, e2, r2) {
                return t3[e2] = r2;
              };
            }
            function wrap(t2, e2, r2, n2) {
              var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
              return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
            }
            function tryCatch(t2, e2, r2) {
              try {
                return { type: "normal", arg: t2.call(e2, r2) };
              } catch (t3) {
                return { type: "throw", arg: t3 };
              }
            }
            e.wrap = wrap;
            var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
            function Generator() {}
            function GeneratorFunction() {}
            function GeneratorFunctionPrototype() {}
            var p = {};
            define2(p, a, function() {
              return this;
            });
            var d = Object.getPrototypeOf, v = d && d(d(values([])));
            v && v !== r && n.call(v, a) && (p = v);
            var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
            function defineIteratorMethods(t2) {
              ["next", "throw", "return"].forEach(function(e2) {
                define2(t2, e2, function(t3) {
                  return this._invoke(e2, t3);
                });
              });
            }
            function AsyncIterator(t2, e2) {
              function invoke(r3, o2, i2, a2) {
                var c2 = tryCatch(t2[r3], t2, o2);
                if (c2.type !== "throw") {
                  var u2 = c2.arg, h2 = u2.value;
                  return h2 && _typeof(h2) == "object" && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
                    invoke("next", t3, i2, a2);
                  }, function(t3) {
                    invoke("throw", t3, i2, a2);
                  }) : e2.resolve(h2).then(function(t3) {
                    u2.value = t3, i2(u2);
                  }, function(t3) {
                    return invoke("throw", t3, i2, a2);
                  });
                }
                a2(c2.arg);
              }
              var r2;
              o(this, "_invoke", { value: function value(t3, n2) {
                function callInvokeWithMethodAndArg() {
                  return new e2(function(e3, r3) {
                    invoke(t3, n2, e3, r3);
                  });
                }
                return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
              } });
            }
            function makeInvokeMethod(e2, r2, n2) {
              var o2 = h;
              return function(i2, a2) {
                if (o2 === f)
                  throw Error("Generator is already running");
                if (o2 === s) {
                  if (i2 === "throw")
                    throw a2;
                  return { value: t, done: true };
                }
                for (n2.method = i2, n2.arg = a2;; ) {
                  var c2 = n2.delegate;
                  if (c2) {
                    var u2 = maybeInvokeDelegate(c2, n2);
                    if (u2) {
                      if (u2 === y)
                        continue;
                      return u2;
                    }
                  }
                  if (n2.method === "next")
                    n2.sent = n2._sent = n2.arg;
                  else if (n2.method === "throw") {
                    if (o2 === h)
                      throw o2 = s, n2.arg;
                    n2.dispatchException(n2.arg);
                  } else
                    n2.method === "return" && n2.abrupt("return", n2.arg);
                  o2 = f;
                  var p2 = tryCatch(e2, r2, n2);
                  if (p2.type === "normal") {
                    if (o2 = n2.done ? s : l, p2.arg === y)
                      continue;
                    return { value: p2.arg, done: n2.done };
                  }
                  p2.type === "throw" && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
                }
              };
            }
            function maybeInvokeDelegate(e2, r2) {
              var n2 = r2.method, o2 = e2.iterator[n2];
              if (o2 === t)
                return r2.delegate = null, n2 === "throw" && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), r2.method === "throw") || n2 !== "return" && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
              var i2 = tryCatch(o2, e2.iterator, r2.arg);
              if (i2.type === "throw")
                return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
              var a2 = i2.arg;
              return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, r2.method !== "return" && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
            }
            function pushTryEntry(t2) {
              var e2 = { tryLoc: t2[0] };
              1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
            }
            function resetTryEntry(t2) {
              var e2 = t2.completion || {};
              e2.type = "normal", delete e2.arg, t2.completion = e2;
            }
            function Context(t2) {
              this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
            }
            function values(e2) {
              if (e2 || e2 === "") {
                var r2 = e2[a];
                if (r2)
                  return r2.call(e2);
                if (typeof e2.next == "function")
                  return e2;
                if (!isNaN(e2.length)) {
                  var o2 = -1, i2 = function next() {
                    for (;++o2 < e2.length; )
                      if (n.call(e2, o2))
                        return next.value = e2[o2], next.done = false, next;
                    return next.value = t, next.done = true, next;
                  };
                  return i2.next = i2;
                }
              }
              throw new TypeError(_typeof(e2) + " is not iterable");
            }
            return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
              var e2 = typeof t2 == "function" && t2.constructor;
              return !!e2 && (e2 === GeneratorFunction || (e2.displayName || e2.name) === "GeneratorFunction");
            }, e.mark = function(t2) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
            }, e.awrap = function(t2) {
              return { __await: t2 };
            }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
              return this;
            }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
              i2 === undefined && (i2 = Promise);
              var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
              return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
                return t3.done ? t3.value : a2.next();
              });
            }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
              return this;
            }), define2(g, "toString", function() {
              return "[object Generator]";
            }), e.keys = function(t2) {
              var e2 = Object(t2), r2 = [];
              for (var n2 in e2)
                r2.push(n2);
              return r2.reverse(), function next() {
                for (;r2.length; ) {
                  var t3 = r2.pop();
                  if (t3 in e2)
                    return next.value = t3, next.done = false, next;
                }
                return next.done = true, next;
              };
            }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2)
                for (var r2 in this)
                  r2.charAt(0) === "t" && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
            }, stop: function stop() {
              this.done = true;
              var t2 = this.tryEntries[0].completion;
              if (t2.type === "throw")
                throw t2.arg;
              return this.rval;
            }, dispatchException: function dispatchException(e2) {
              if (this.done)
                throw e2;
              var r2 = this;
              function handle(n2, o3) {
                return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
              }
              for (var o2 = this.tryEntries.length - 1;o2 >= 0; --o2) {
                var i2 = this.tryEntries[o2], a2 = i2.completion;
                if (i2.tryLoc === "root")
                  return handle("end");
                if (i2.tryLoc <= this.prev) {
                  var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
                  if (c2 && u2) {
                    if (this.prev < i2.catchLoc)
                      return handle(i2.catchLoc, true);
                    if (this.prev < i2.finallyLoc)
                      return handle(i2.finallyLoc);
                  } else if (c2) {
                    if (this.prev < i2.catchLoc)
                      return handle(i2.catchLoc, true);
                  } else {
                    if (!u2)
                      throw Error("try statement without catch or finally");
                    if (this.prev < i2.finallyLoc)
                      return handle(i2.finallyLoc);
                  }
                }
              }
            }, abrupt: function abrupt(t2, e2) {
              for (var r2 = this.tryEntries.length - 1;r2 >= 0; --r2) {
                var o2 = this.tryEntries[r2];
                if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
                  var i2 = o2;
                  break;
                }
              }
              i2 && (t2 === "break" || t2 === "continue") && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
              var a2 = i2 ? i2.completion : {};
              return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
            }, complete: function complete(t2, e2) {
              if (t2.type === "throw")
                throw t2.arg;
              return t2.type === "break" || t2.type === "continue" ? this.next = t2.arg : t2.type === "return" ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : t2.type === "normal" && e2 && (this.next = e2), y;
            }, finish: function finish(t2) {
              for (var e2 = this.tryEntries.length - 1;e2 >= 0; --e2) {
                var r2 = this.tryEntries[e2];
                if (r2.finallyLoc === t2)
                  return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
              }
            }, catch: function _catch(t2) {
              for (var e2 = this.tryEntries.length - 1;e2 >= 0; --e2) {
                var r2 = this.tryEntries[e2];
                if (r2.tryLoc === t2) {
                  var n2 = r2.completion;
                  if (n2.type === "throw") {
                    var o2 = n2.arg;
                    resetTryEntry(r2);
                  }
                  return o2;
                }
              }
              throw Error("illegal catch attempt");
            }, delegateYield: function delegateYield(e2, r2, n2) {
              return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, this.method === "next" && (this.arg = t), y;
            } }, e;
          }
          module2.exports = function(Yallist) {
            Yallist.prototype[Symbol.iterator] = /* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
              var walker;
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (true)
                  switch (_context.prev = _context.next) {
                    case 0:
                      walker = this.head;
                    case 1:
                      if (!walker) {
                        _context.next = 7;
                        break;
                      }
                      _context.next = 4;
                      return walker.value;
                    case 4:
                      walker = walker.next;
                      _context.next = 1;
                      break;
                    case 7:
                    case "end":
                      return _context.stop();
                  }
              }, _callee, this);
            });
          };
        },
        695: (module2, __unused_webpack_exports, __webpack_require__2) => {
          module2.exports = Yallist;
          Yallist.Node = Node2;
          Yallist.create = Yallist;
          function Yallist(list) {
            var self2 = this;
            if (!(self2 instanceof Yallist)) {
              self2 = new Yallist;
            }
            self2.tail = null;
            self2.head = null;
            self2.length = 0;
            if (list && typeof list.forEach === "function") {
              list.forEach(function(item) {
                self2.push(item);
              });
            } else if (arguments.length > 0) {
              for (var i = 0, l = arguments.length;i < l; i++) {
                self2.push(arguments[i]);
              }
            }
            return self2;
          }
          Yallist.prototype.removeNode = function(node) {
            if (node.list !== this) {
              throw new Error("removing node which does not belong to this list");
            }
            var next = node.next;
            var prev = node.prev;
            if (next) {
              next.prev = prev;
            }
            if (prev) {
              prev.next = next;
            }
            if (node === this.head) {
              this.head = next;
            }
            if (node === this.tail) {
              this.tail = prev;
            }
            node.list.length--;
            node.next = null;
            node.prev = null;
            node.list = null;
            return next;
          };
          Yallist.prototype.unshiftNode = function(node) {
            if (node === this.head) {
              return;
            }
            if (node.list) {
              node.list.removeNode(node);
            }
            var head = this.head;
            node.list = this;
            node.next = head;
            if (head) {
              head.prev = node;
            }
            this.head = node;
            if (!this.tail) {
              this.tail = node;
            }
            this.length++;
          };
          Yallist.prototype.pushNode = function(node) {
            if (node === this.tail) {
              return;
            }
            if (node.list) {
              node.list.removeNode(node);
            }
            var tail = this.tail;
            node.list = this;
            node.prev = tail;
            if (tail) {
              tail.next = node;
            }
            this.tail = node;
            if (!this.head) {
              this.head = node;
            }
            this.length++;
          };
          Yallist.prototype.push = function() {
            for (var i = 0, l = arguments.length;i < l; i++) {
              push(this, arguments[i]);
            }
            return this.length;
          };
          Yallist.prototype.unshift = function() {
            for (var i = 0, l = arguments.length;i < l; i++) {
              unshift(this, arguments[i]);
            }
            return this.length;
          };
          Yallist.prototype.pop = function() {
            if (!this.tail) {
              return;
            }
            var res = this.tail.value;
            this.tail = this.tail.prev;
            if (this.tail) {
              this.tail.next = null;
            } else {
              this.head = null;
            }
            this.length--;
            return res;
          };
          Yallist.prototype.shift = function() {
            if (!this.head) {
              return;
            }
            var res = this.head.value;
            this.head = this.head.next;
            if (this.head) {
              this.head.prev = null;
            } else {
              this.tail = null;
            }
            this.length--;
            return res;
          };
          Yallist.prototype.forEach = function(fn, thisp) {
            thisp = thisp || this;
            for (var walker = this.head, i = 0;walker !== null; i++) {
              fn.call(thisp, walker.value, i, this);
              walker = walker.next;
            }
          };
          Yallist.prototype.forEachReverse = function(fn, thisp) {
            thisp = thisp || this;
            for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
              fn.call(thisp, walker.value, i, this);
              walker = walker.prev;
            }
          };
          Yallist.prototype.get = function(n) {
            for (var i = 0, walker = this.head;walker !== null && i < n; i++) {
              walker = walker.next;
            }
            if (i === n && walker !== null) {
              return walker.value;
            }
          };
          Yallist.prototype.getReverse = function(n) {
            for (var i = 0, walker = this.tail;walker !== null && i < n; i++) {
              walker = walker.prev;
            }
            if (i === n && walker !== null) {
              return walker.value;
            }
          };
          Yallist.prototype.map = function(fn, thisp) {
            thisp = thisp || this;
            var res = new Yallist;
            for (var walker = this.head;walker !== null; ) {
              res.push(fn.call(thisp, walker.value, this));
              walker = walker.next;
            }
            return res;
          };
          Yallist.prototype.mapReverse = function(fn, thisp) {
            thisp = thisp || this;
            var res = new Yallist;
            for (var walker = this.tail;walker !== null; ) {
              res.push(fn.call(thisp, walker.value, this));
              walker = walker.prev;
            }
            return res;
          };
          Yallist.prototype.reduce = function(fn, initial) {
            var acc;
            var walker = this.head;
            if (arguments.length > 1) {
              acc = initial;
            } else if (this.head) {
              walker = this.head.next;
              acc = this.head.value;
            } else {
              throw new TypeError("Reduce of empty list with no initial value");
            }
            for (var i = 0;walker !== null; i++) {
              acc = fn(acc, walker.value, i);
              walker = walker.next;
            }
            return acc;
          };
          Yallist.prototype.reduceReverse = function(fn, initial) {
            var acc;
            var walker = this.tail;
            if (arguments.length > 1) {
              acc = initial;
            } else if (this.tail) {
              walker = this.tail.prev;
              acc = this.tail.value;
            } else {
              throw new TypeError("Reduce of empty list with no initial value");
            }
            for (var i = this.length - 1;walker !== null; i--) {
              acc = fn(acc, walker.value, i);
              walker = walker.prev;
            }
            return acc;
          };
          Yallist.prototype.toArray = function() {
            var arr = new Array(this.length);
            for (var i = 0, walker = this.head;walker !== null; i++) {
              arr[i] = walker.value;
              walker = walker.next;
            }
            return arr;
          };
          Yallist.prototype.toArrayReverse = function() {
            var arr = new Array(this.length);
            for (var i = 0, walker = this.tail;walker !== null; i++) {
              arr[i] = walker.value;
              walker = walker.prev;
            }
            return arr;
          };
          Yallist.prototype.slice = function(from, to) {
            to = to || this.length;
            if (to < 0) {
              to += this.length;
            }
            from = from || 0;
            if (from < 0) {
              from += this.length;
            }
            var ret = new Yallist;
            if (to < from || to < 0) {
              return ret;
            }
            if (from < 0) {
              from = 0;
            }
            if (to > this.length) {
              to = this.length;
            }
            for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
              walker = walker.next;
            }
            for (;walker !== null && i < to; i++, walker = walker.next) {
              ret.push(walker.value);
            }
            return ret;
          };
          Yallist.prototype.sliceReverse = function(from, to) {
            to = to || this.length;
            if (to < 0) {
              to += this.length;
            }
            from = from || 0;
            if (from < 0) {
              from += this.length;
            }
            var ret = new Yallist;
            if (to < from || to < 0) {
              return ret;
            }
            if (from < 0) {
              from = 0;
            }
            if (to > this.length) {
              to = this.length;
            }
            for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
              walker = walker.prev;
            }
            for (;walker !== null && i > from; i--, walker = walker.prev) {
              ret.push(walker.value);
            }
            return ret;
          };
          Yallist.prototype.splice = function(start, deleteCount) {
            if (start > this.length) {
              start = this.length - 1;
            }
            if (start < 0) {
              start = this.length + start;
            }
            for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
              walker = walker.next;
            }
            var ret = [];
            for (var i = 0;walker && i < deleteCount; i++) {
              ret.push(walker.value);
              walker = this.removeNode(walker);
            }
            if (walker === null) {
              walker = this.tail;
            }
            if (walker !== this.head && walker !== this.tail) {
              walker = walker.prev;
            }
            for (var i = 2;i < arguments.length; i++) {
              walker = insert(this, walker, arguments[i]);
            }
            return ret;
          };
          Yallist.prototype.reverse = function() {
            var head = this.head;
            var tail = this.tail;
            for (var walker = head;walker !== null; walker = walker.prev) {
              var p = walker.prev;
              walker.prev = walker.next;
              walker.next = p;
            }
            this.head = tail;
            this.tail = head;
            return this;
          };
          function insert(self2, node, value) {
            var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
            if (inserted.next === null) {
              self2.tail = inserted;
            }
            if (inserted.prev === null) {
              self2.head = inserted;
            }
            self2.length++;
            return inserted;
          }
          function push(self2, item) {
            self2.tail = new Node2(item, self2.tail, null, self2);
            if (!self2.head) {
              self2.head = self2.tail;
            }
            self2.length++;
          }
          function unshift(self2, item) {
            self2.head = new Node2(item, null, self2.head, self2);
            if (!self2.tail) {
              self2.tail = self2.head;
            }
            self2.length++;
          }
          function Node2(value, prev, next, list) {
            if (!(this instanceof Node2)) {
              return new Node2(value, prev, next, list);
            }
            this.list = list;
            this.value = value;
            if (prev) {
              prev.next = this;
              this.prev = prev;
            } else {
              this.prev = null;
            }
            if (next) {
              next.prev = this;
              this.next = next;
            } else {
              this.next = null;
            }
          }
          try {
            __webpack_require__2(476)(Yallist);
          } catch (er) {}
        }
      };
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== undefined) {
          return cachedModule.exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          exports: {}
        };
        __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        return module2.exports;
      }
      (() => {
        __webpack_require__.n = (module2) => {
          var getter = module2 && module2.__esModule ? () => module2["default"] : () => module2;
          __webpack_require__.d(getter, { a: getter });
          return getter;
        };
      })();
      (() => {
        __webpack_require__.d = (exports2, definition) => {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      })();
      (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
      })();
      (() => {
        __webpack_require__.r = (exports2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
      })();
      var __webpack_exports__ = {};
      (() => {
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
          connectToDevTools: () => connectToDevTools,
          connectWithCustomMessagingProtocol: () => connectWithCustomMessagingProtocol,
          initialize: () => backend_initialize
        });
        function _typeof(o) {
          "@babel/helpers - typeof";
          return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, _typeof(o);
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0;i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", { writable: false });
          return Constructor;
        }
        function _defineProperty(obj, key, value) {
          key = _toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _toPropertyKey(t) {
          var i = _toPrimitive(t, "string");
          return _typeof(i) == "symbol" ? i : i + "";
        }
        function _toPrimitive(t, r) {
          if (_typeof(t) != "object" || !t)
            return t;
          var e = t[Symbol.toPrimitive];
          if (e !== undefined) {
            var i = e.call(t, r || "default");
            if (_typeof(i) != "object")
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (r === "string" ? String : Number)(t);
        }
        var EventEmitter = /* @__PURE__ */ function() {
          function EventEmitter2() {
            _classCallCheck(this, EventEmitter2);
            _defineProperty(this, "listenersMap", new Map);
          }
          return _createClass(EventEmitter2, [{
            key: "addListener",
            value: function addListener(event, listener) {
              var listeners = this.listenersMap.get(event);
              if (listeners === undefined) {
                this.listenersMap.set(event, [listener]);
              } else {
                var index = listeners.indexOf(listener);
                if (index < 0) {
                  listeners.push(listener);
                }
              }
            }
          }, {
            key: "emit",
            value: function emit(event) {
              var listeners = this.listenersMap.get(event);
              if (listeners !== undefined) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                if (listeners.length === 1) {
                  var listener = listeners[0];
                  listener.apply(null, args);
                } else {
                  var didThrow = false;
                  var caughtError = null;
                  var clonedListeners = Array.from(listeners);
                  for (var i = 0;i < clonedListeners.length; i++) {
                    var _listener = clonedListeners[i];
                    try {
                      _listener.apply(null, args);
                    } catch (error) {
                      if (caughtError === null) {
                        didThrow = true;
                        caughtError = error;
                      }
                    }
                  }
                  if (didThrow) {
                    throw caughtError;
                  }
                }
              }
            }
          }, {
            key: "removeAllListeners",
            value: function removeAllListeners() {
              this.listenersMap.clear();
            }
          }, {
            key: "removeListener",
            value: function removeListener(event, listener) {
              var listeners = this.listenersMap.get(event);
              if (listeners !== undefined) {
                var index = listeners.indexOf(listener);
                if (index >= 0) {
                  listeners.splice(index, 1);
                }
              }
            }
          }]);
        }();
        var CHROME_WEBSTORE_EXTENSION_ID = "fmkadmapgofadopljbjfkapdkoienihi";
        var INTERNAL_EXTENSION_ID = "dnjnjgbfilfphmojnmhliehogmojhclc";
        var LOCAL_EXTENSION_ID = "ikiahnapldjmdmpkmfhjdjilojjhgcbf";
        var __DEBUG__ = false;
        var __PERFORMANCE_PROFILE__ = false;
        var TREE_OPERATION_ADD = 1;
        var TREE_OPERATION_REMOVE = 2;
        var TREE_OPERATION_REORDER_CHILDREN = 3;
        var TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4;
        var TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS = 5;
        var TREE_OPERATION_REMOVE_ROOT = 6;
        var TREE_OPERATION_SET_SUBTREE_MODE = 7;
        var SUSPENSE_TREE_OPERATION_ADD = 8;
        var SUSPENSE_TREE_OPERATION_REMOVE = 9;
        var SUSPENSE_TREE_OPERATION_REORDER_CHILDREN = 10;
        var SUSPENSE_TREE_OPERATION_RESIZE = 11;
        var SUSPENSE_TREE_OPERATION_SUSPENDERS = 12;
        var PROFILING_FLAG_BASIC_SUPPORT = 1;
        var PROFILING_FLAG_TIMELINE_SUPPORT = 2;
        var PROFILING_FLAG_PERFORMANCE_TRACKS_SUPPORT = 4;
        var UNKNOWN_SUSPENDERS_NONE = 0;
        var UNKNOWN_SUSPENDERS_REASON_PRODUCTION = 1;
        var UNKNOWN_SUSPENDERS_REASON_OLD_VERSION = 2;
        var UNKNOWN_SUSPENDERS_REASON_THROWN_PROMISE = 3;
        var LOCAL_STORAGE_DEFAULT_TAB_KEY = "React::DevTools::defaultTab";
        var constants_LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY = "React::DevTools::componentFilters";
        var SESSION_STORAGE_LAST_SELECTION_KEY = "React::DevTools::lastSelection";
        var constants_LOCAL_STORAGE_OPEN_IN_EDITOR_URL = "React::DevTools::openInEditorUrl";
        var constants_LOCAL_STORAGE_OPEN_IN_EDITOR_URL_PRESET = "React::DevTools::openInEditorUrlPreset";
        var constants_LOCAL_STORAGE_ALWAYS_OPEN_IN_EDITOR = "React::DevTools::alwaysOpenInEditor";
        var LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY = "React::DevTools::parseHookNames";
        var constants_SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = "React::DevTools::recordChangeDescriptions";
        var constants_SESSION_STORAGE_RECORD_TIMELINE_KEY = "React::DevTools::recordTimeline";
        var constants_SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = "React::DevTools::reloadAndProfile";
        var LOCAL_STORAGE_BROWSER_THEME = "React::DevTools::theme";
        var LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = "React::DevTools::traceUpdatesEnabled";
        var LOCAL_STORAGE_SUPPORTS_PROFILING_KEY = "React::DevTools::supportsProfiling";
        var PROFILER_EXPORT_VERSION = 5;
        var FIREFOX_CONSOLE_DIMMING_COLOR = "color: rgba(124, 124, 124, 0.75)";
        var ANSI_STYLE_DIMMING_TEMPLATE = "\x1B[2;38;2;124;124;124m%s\x1B[0m";
        var ANSI_STYLE_DIMMING_TEMPLATE_WITH_COMPONENT_STACK = "\x1B[2;38;2;124;124;124m%s %o\x1B[0m";
        function esm_typeof(o) {
          "@babel/helpers - typeof";
          return esm_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, esm_typeof(o);
        }
        function _slicedToArray(arr, i) {
          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _nonIterableRest() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len);i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        function _iterableToArrayLimit(r, l) {
          var t = r == null ? null : typeof Symbol != "undefined" && r[Symbol.iterator] || r["@@iterator"];
          if (t != null) {
            var e, n, i, u, a = [], f = true, o = false;
            try {
              if (i = (t = t.call(r)).next, l === 0) {
                if (Object(t) !== t)
                  return;
                f = false;
              } else
                for (;!(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
                  ;
            } catch (r2) {
              o = true, n = r2;
            } finally {
              try {
                if (!f && t.return != null && (u = t.return(), Object(u) !== u))
                  return;
              } finally {
                if (o)
                  throw n;
              }
            }
            return a;
          }
        }
        function _arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        var compareVersions = function compareVersions(v1, v2) {
          var n1 = validateAndParse(v1);
          var n2 = validateAndParse(v2);
          var p1 = n1.pop();
          var p2 = n2.pop();
          var r = compareSegments(n1, n2);
          if (r !== 0)
            return r;
          if (p1 && p2) {
            return compareSegments(p1.split("."), p2.split("."));
          } else if (p1 || p2) {
            return p1 ? -1 : 1;
          }
          return 0;
        };
        var validate2 = function validate(version) {
          return typeof version === "string" && /^[v\d]/.test(version) && semver.test(version);
        };
        var compare = function compare(v1, v2, operator) {
          assertValidOperator(operator);
          var res = compareVersions(v1, v2);
          return operatorResMap[operator].includes(res);
        };
        var satisfies = function satisfies(version, range) {
          var m = range.match(/^([<>=~^]+)/);
          var op = m ? m[1] : "=";
          if (op !== "^" && op !== "~")
            return compare(version, range, op);
          var _validateAndParse = validateAndParse(version), _validateAndParse2 = _slicedToArray(_validateAndParse, 5), v1 = _validateAndParse2[0], v2 = _validateAndParse2[1], v3 = _validateAndParse2[2], vp = _validateAndParse2[4];
          var _validateAndParse3 = validateAndParse(range), _validateAndParse4 = _slicedToArray(_validateAndParse3, 5), r1 = _validateAndParse4[0], r2 = _validateAndParse4[1], r3 = _validateAndParse4[2], rp = _validateAndParse4[4];
          var v = [v1, v2, v3];
          var r = [r1, r2 !== null && r2 !== undefined ? r2 : "x", r3 !== null && r3 !== undefined ? r3 : "x"];
          if (rp) {
            if (!vp)
              return false;
            if (compareSegments(v, r) !== 0)
              return false;
            if (compareSegments(vp.split("."), rp.split(".")) === -1)
              return false;
          }
          var nonZero = r.findIndex(function(v4) {
            return v4 !== "0";
          }) + 1;
          var i = op === "~" ? 2 : nonZero > 1 ? nonZero : 1;
          if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0)
            return false;
          if (compareSegments(v.slice(i), r.slice(i)) === -1)
            return false;
          return true;
        };
        var semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
        var validateAndParse = function validateAndParse(version) {
          if (typeof version !== "string") {
            throw new TypeError("Invalid argument expected string");
          }
          var match = version.match(semver);
          if (!match) {
            throw new Error("Invalid argument not valid semver ('".concat(version, "' received)"));
          }
          match.shift();
          return match;
        };
        var isWildcard = function isWildcard(s) {
          return s === "*" || s === "x" || s === "X";
        };
        var tryParse = function tryParse(v) {
          var n = parseInt(v, 10);
          return isNaN(n) ? v : n;
        };
        var forceType = function forceType(a, b) {
          return esm_typeof(a) !== esm_typeof(b) ? [String(a), String(b)] : [a, b];
        };
        var compareStrings = function compareStrings(a, b) {
          if (isWildcard(a) || isWildcard(b))
            return 0;
          var _forceType = forceType(tryParse(a), tryParse(b)), _forceType2 = _slicedToArray(_forceType, 2), ap = _forceType2[0], bp = _forceType2[1];
          if (ap > bp)
            return 1;
          if (ap < bp)
            return -1;
          return 0;
        };
        var compareSegments = function compareSegments(a, b) {
          for (var i = 0;i < Math.max(a.length, b.length); i++) {
            var r = compareStrings(a[i] || "0", b[i] || "0");
            if (r !== 0)
              return r;
          }
          return 0;
        };
        var operatorResMap = {
          ">": [1],
          ">=": [0, 1],
          "=": [0],
          "<=": [-1, 0],
          "<": [-1]
        };
        var allowedOperators = Object.keys(operatorResMap);
        var assertValidOperator = function assertValidOperator(op) {
          if (typeof op !== "string") {
            throw new TypeError("Invalid operator type, expected string but got ".concat(esm_typeof(op)));
          }
          if (allowedOperators.indexOf(op) === -1) {
            throw new Error("Invalid operator, expected one of ".concat(allowedOperators.join("|")));
          }
        };
        var lru_cache = __webpack_require__(730);
        var lru_cache_default = /* @__PURE__ */ __webpack_require__.n(lru_cache);
        var enableHydrationLaneScheduling = true;
        var disableSchedulerTimeoutInWorkLoop = false;
        var enableSuspenseCallback = false;
        var enableScopeAPI = false;
        var enableCreateEventHandleAPI = false;
        var enableLegacyFBSupport = false;
        var enableYieldingBeforePassive = false;
        var enableThrottledScheduling = false;
        var enableLegacyCache = null;
        var enableAsyncIterableChildren = null;
        var enableTaint = null;
        var enablePostpone = null;
        var enableHalt = true;
        var enableViewTransition = true;
        var enableGestureTransition = null;
        var enableScrollEndPolyfill = null;
        var enableSuspenseyImages = false;
        var enableFizzBlockingRender = null;
        var enableSrcObject = null;
        var enableHydrationChangeEvent = null;
        var enableDefaultTransitionIndicator = null;
        var enableObjectFiber = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableSuspenseAvoidThisFallback = false;
        var enableCPUSuspense = null;
        var enableNoCloningMemoCache = false;
        var enableUseEffectEventHook = true;
        var enableFizzExternalRuntime = null;
        var alwaysThrottleRetries = true;
        var passChildrenWhenCloningPersistedNodes = false;
        var enableEagerAlternateStateNodeCleanup = true;
        var enableRetryLaneExpiration = false;
        var retryLaneExpirationMs = 5000;
        var syncLaneExpirationMs = 250;
        var transitionLaneExpirationMs = 5000;
        var enableInfiniteRenderLoopDetection = false;
        var enableFragmentRefs = true;
        var enableFragmentRefsScrollIntoView = true;
        var renameElementSymbol = true;
        var enableHiddenSubtreeInsertionEffectCleanup = true;
        var disableLegacyContext = true;
        var disableLegacyContextForFunctionComponents = true;
        var enableMoveBefore = false;
        var disableClientCache = true;
        var enableReactTestRendererWarning = true;
        var disableLegacyMode = true;
        var disableCommentsAsDOMContainers = true;
        var enableTrustedTypesIntegration = false;
        var disableInputAttributeSyncing = false;
        var disableTextareaChildren = false;
        var enableProfilerTimer = null;
        var enableComponentPerformanceTrack = true;
        var enableSchedulingProfiler = !enableComponentPerformanceTrack && false;
        var enableProfilerCommitHooks = null;
        var enableProfilerNestedUpdatePhase = null;
        var enableAsyncDebugInfo = true;
        var enableUpdaterTracking = null;
        var ownerStackLimit = 1e4;
        function ReactSymbols_typeof(o) {
          "@babel/helpers - typeof";
          return ReactSymbols_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, ReactSymbols_typeof(o);
        }
        var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_ELEMENT_TYPE = renameElementSymbol ? Symbol.for("react.transitional.element") : REACT_LEGACY_ELEMENT_TYPE;
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
        var REACT_POSTPONE_TYPE = Symbol.for("react.postpone");
        var REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || ReactSymbols_typeof(maybeIterable) !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ASYNC_ITERATOR = Symbol.asyncIterator;
        var types_ElementTypeClass = 1;
        var ElementTypeContext = 2;
        var types_ElementTypeFunction = 5;
        var types_ElementTypeForwardRef = 6;
        var ElementTypeHostComponent = 7;
        var types_ElementTypeMemo = 8;
        var ElementTypeOtherOrUnknown = 9;
        var ElementTypeProfiler = 10;
        var ElementTypeRoot = 11;
        var ElementTypeSuspense = 12;
        var ElementTypeSuspenseList = 13;
        var ElementTypeTracingMarker = 14;
        var types_ElementTypeVirtual = 15;
        var ElementTypeViewTransition = 16;
        var ElementTypeActivity = 17;
        var ComponentFilterElementType = 1;
        var ComponentFilterDisplayName = 2;
        var ComponentFilterLocation = 3;
        var ComponentFilterHOC = 4;
        var ComponentFilterEnvironmentName = 5;
        var StrictMode = 1;
        var isArray = Array.isArray;
        const src_isArray = isArray;
        var process3 = __webpack_require__(169);
        function ownKeys(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function(r2) {
              return Object.getOwnPropertyDescriptor(e, r2).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread(e) {
          for (var r = 1;r < arguments.length; r++) {
            var t = arguments[r] != null ? arguments[r] : {};
            r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
              utils_defineProperty(e, r2, t[r2]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
              Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
            });
          }
          return e;
        }
        function utils_defineProperty(obj, key, value) {
          key = utils_toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function utils_toPropertyKey(t) {
          var i = utils_toPrimitive(t, "string");
          return utils_typeof(i) == "symbol" ? i : i + "";
        }
        function utils_toPrimitive(t, r) {
          if (utils_typeof(t) != "object" || !t)
            return t;
          var e = t[Symbol.toPrimitive];
          if (e !== undefined) {
            var i = e.call(t, r || "default");
            if (utils_typeof(i) != "object")
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (r === "string" ? String : Number)(t);
        }
        function utils_typeof(o) {
          "@babel/helpers - typeof";
          return utils_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, utils_typeof(o);
        }
        function _toConsumableArray(arr) {
          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || utils_unsupportedIterableToArray(arr) || _nonIterableSpread();
        }
        function _nonIterableSpread() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function utils_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return utils_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return utils_arrayLikeToArray(o, minLen);
        }
        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
            return Array.from(iter);
        }
        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return utils_arrayLikeToArray(arr);
        }
        function utils_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len);i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        var utils_hasOwnProperty = Object.prototype.hasOwnProperty;
        var cachedDisplayNames = new WeakMap;
        var encodedStringCache = new (lru_cache_default())({
          max: 1000
        });
        var LEGACY_REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        function alphaSortKeys(a, b) {
          if (a.toString() > b.toString()) {
            return 1;
          } else if (b.toString() > a.toString()) {
            return -1;
          } else {
            return 0;
          }
        }
        function getAllEnumerableKeys(obj) {
          var keys = new Set;
          var current = obj;
          var _loop = function _loop() {
            var currentKeys = [].concat(_toConsumableArray(Object.keys(current)), _toConsumableArray(Object.getOwnPropertySymbols(current)));
            var descriptors = Object.getOwnPropertyDescriptors(current);
            currentKeys.forEach(function(key) {
              if (descriptors[key].enumerable) {
                keys.add(key);
              }
            });
            current = Object.getPrototypeOf(current);
          };
          while (current != null) {
            _loop();
          }
          return keys;
        }
        function getWrappedDisplayName(outerType, innerType, wrapperName, fallbackName) {
          var displayName = outerType === null || outerType === undefined ? undefined : outerType.displayName;
          return displayName || "".concat(wrapperName, "(").concat(getDisplayName(innerType, fallbackName), ")");
        }
        function getDisplayName(type) {
          var fallbackName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Anonymous";
          var nameFromCache = cachedDisplayNames.get(type);
          if (nameFromCache != null) {
            return nameFromCache;
          }
          var displayName = fallbackName;
          if (typeof type.displayName === "string") {
            displayName = type.displayName;
          } else if (typeof type.name === "string" && type.name !== "") {
            displayName = type.name;
          }
          cachedDisplayNames.set(type, displayName);
          return displayName;
        }
        var uidCounter = 0;
        function getUID() {
          return ++uidCounter;
        }
        function utfDecodeStringWithRanges(array, left, right) {
          var string = "";
          for (var i = left;i <= right; i++) {
            string += String.fromCodePoint(array[i]);
          }
          return string;
        }
        function surrogatePairToCodePoint(charCode1, charCode2) {
          return ((charCode1 & 1023) << 10) + (charCode2 & 1023) + 65536;
        }
        function utfEncodeString(string) {
          var cached = encodedStringCache.get(string);
          if (cached !== undefined) {
            return cached;
          }
          var encoded = [];
          var i = 0;
          var charCode;
          while (i < string.length) {
            charCode = string.charCodeAt(i);
            if ((charCode & 63488) === 55296) {
              encoded.push(surrogatePairToCodePoint(charCode, string.charCodeAt(++i)));
            } else {
              encoded.push(charCode);
            }
            ++i;
          }
          encodedStringCache.set(string, encoded);
          return encoded;
        }
        function printOperationsArray(operations) {
          var rendererID = operations[0];
          var rootID = operations[1];
          var logs = ["operations for renderer:".concat(rendererID, " and root:").concat(rootID)];
          var i = 2;
          var stringTable = [null];
          var stringTableSize = operations[i++];
          var stringTableEnd = i + stringTableSize;
          while (i < stringTableEnd) {
            var nextLength = operations[i++];
            var nextString = utfDecodeStringWithRanges(operations, i, i + nextLength - 1);
            stringTable.push(nextString);
            i += nextLength;
          }
          while (i < operations.length) {
            var operation = operations[i];
            switch (operation) {
              case TREE_OPERATION_ADD: {
                var id = operations[i + 1];
                var type = operations[i + 2];
                i += 3;
                if (type === ElementTypeRoot) {
                  logs.push("Add new root node ".concat(id));
                  i++;
                  i++;
                  i++;
                  i++;
                } else {
                  var parentID = operations[i];
                  i++;
                  i++;
                  var displayNameStringID = operations[i];
                  var displayName = stringTable[displayNameStringID];
                  i++;
                  i++;
                  i++;
                  logs.push("Add node ".concat(id, " (").concat(displayName || "null", ") as child of ").concat(parentID));
                }
                break;
              }
              case TREE_OPERATION_REMOVE: {
                var removeLength = operations[i + 1];
                i += 2;
                for (var removeIndex = 0;removeIndex < removeLength; removeIndex++) {
                  var _id = operations[i];
                  i += 1;
                  logs.push("Remove node ".concat(_id));
                }
                break;
              }
              case TREE_OPERATION_REMOVE_ROOT: {
                i += 1;
                logs.push("Remove root ".concat(rootID));
                break;
              }
              case TREE_OPERATION_SET_SUBTREE_MODE: {
                var _id2 = operations[i + 1];
                var mode = operations[i + 2];
                i += 3;
                logs.push("Mode ".concat(mode, " set for subtree with root ").concat(_id2));
                break;
              }
              case TREE_OPERATION_REORDER_CHILDREN: {
                var _id3 = operations[i + 1];
                var numChildren = operations[i + 2];
                i += 3;
                var children = operations.slice(i, i + numChildren);
                i += numChildren;
                logs.push("Re-order node ".concat(_id3, " children ").concat(children.join(",")));
                break;
              }
              case TREE_OPERATION_UPDATE_TREE_BASE_DURATION:
                i += 3;
                break;
              case TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS: {
                var _id4 = operations[i + 1];
                var numErrors = operations[i + 2];
                var numWarnings = operations[i + 3];
                i += 4;
                logs.push("Node ".concat(_id4, " has ").concat(numErrors, " errors and ").concat(numWarnings, " warnings"));
                break;
              }
              case SUSPENSE_TREE_OPERATION_ADD: {
                var fiberID = operations[i + 1];
                var _parentID = operations[i + 2];
                var nameStringID = operations[i + 3];
                var isSuspended = operations[i + 4];
                var numRects = operations[i + 5];
                i += 6;
                var name = stringTable[nameStringID];
                var rects = undefined;
                if (numRects === -1) {
                  rects = "null";
                } else {
                  rects = "[";
                  for (var rectIndex = 0;rectIndex < numRects; rectIndex++) {
                    var offset = i + rectIndex * 4;
                    var x = operations[offset + 0];
                    var y = operations[offset + 1];
                    var width = operations[offset + 2];
                    var height = operations[offset + 3];
                    if (rectIndex > 0) {
                      rects += ", ";
                    }
                    rects += "(".concat(x, ", ").concat(y, ", ").concat(width, ", ").concat(height, ")");
                    i += 4;
                  }
                  rects += "]";
                }
                logs.push("Add suspense node ".concat(fiberID, " (").concat(String(name), ",rects={").concat(rects, "}) under ").concat(_parentID, " suspended ").concat(isSuspended));
                break;
              }
              case SUSPENSE_TREE_OPERATION_REMOVE: {
                var _removeLength = operations[i + 1];
                i += 2;
                for (var _removeIndex = 0;_removeIndex < _removeLength; _removeIndex++) {
                  var _id5 = operations[i];
                  i += 1;
                  logs.push("Remove suspense node ".concat(_id5));
                }
                break;
              }
              case SUSPENSE_TREE_OPERATION_REORDER_CHILDREN: {
                var _id6 = operations[i + 1];
                var _numChildren = operations[i + 2];
                i += 3;
                var _children = operations.slice(i, i + _numChildren);
                i += _numChildren;
                logs.push("Re-order suspense node ".concat(_id6, " children ").concat(_children.join(",")));
                break;
              }
              case SUSPENSE_TREE_OPERATION_RESIZE: {
                var _id7 = operations[i + 1];
                var _numRects = operations[i + 2];
                i += 3;
                if (_numRects === -1) {
                  logs.push("Resize suspense node ".concat(_id7, " to null"));
                } else {
                  var line = "Resize suspense node ".concat(_id7, " to [");
                  for (var _rectIndex = 0;_rectIndex < _numRects; _rectIndex++) {
                    var _x = operations[i + 0];
                    var _y = operations[i + 1];
                    var _width = operations[i + 2];
                    var _height = operations[i + 3];
                    if (_rectIndex > 0) {
                      line += ", ";
                    }
                    line += "(".concat(_x, ", ").concat(_y, ", ").concat(_width, ", ").concat(_height, ")");
                    i += 4;
                  }
                  logs.push(line + "]");
                }
                break;
              }
              case SUSPENSE_TREE_OPERATION_SUSPENDERS: {
                i++;
                var changeLength = operations[i++];
                for (var changeIndex = 0;changeIndex < changeLength; changeIndex++) {
                  var _id8 = operations[i++];
                  var hasUniqueSuspenders = operations[i++] === 1;
                  var _isSuspended = operations[i++] === 1;
                  var environmentNamesLength = operations[i++];
                  i += environmentNamesLength;
                  logs.push("Suspense node ".concat(_id8, " unique suspenders set to ").concat(String(hasUniqueSuspenders), " is suspended set to ").concat(String(_isSuspended), " with ").concat(String(environmentNamesLength), " environments"));
                }
                break;
              }
              default:
                throw Error('Unsupported Bridge operation "'.concat(operation, '"'));
            }
          }
          console.log(logs.join(`
  `));
        }
        function getDefaultComponentFilters() {
          return [{
            type: ComponentFilterElementType,
            value: ElementTypeHostComponent,
            isEnabled: true
          }];
        }
        function getSavedComponentFilters() {
          try {
            var raw = localStorageGetItem(LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY);
            if (raw != null) {
              var parsedFilters = JSON.parse(raw);
              return filterOutLocationComponentFilters(parsedFilters);
            }
          } catch (error) {}
          return getDefaultComponentFilters();
        }
        function setSavedComponentFilters(componentFilters) {
          localStorageSetItem(LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY, JSON.stringify(filterOutLocationComponentFilters(componentFilters)));
        }
        function filterOutLocationComponentFilters(componentFilters) {
          if (!Array.isArray(componentFilters)) {
            return componentFilters;
          }
          return componentFilters.filter(function(f) {
            return f.type !== ComponentFilterLocation;
          });
        }
        var vscodeFilepath = "vscode://file/{path}:{line}:{column}";
        function getDefaultPreset() {
          return typeof process3.env.EDITOR_URL === "string" ? "custom" : "vscode";
        }
        function getDefaultOpenInEditorURL() {
          return typeof process3.env.EDITOR_URL === "string" ? process3.env.EDITOR_URL : vscodeFilepath;
        }
        function getOpenInEditorURL() {
          try {
            var rawPreset = localStorageGetItem(LOCAL_STORAGE_OPEN_IN_EDITOR_URL_PRESET);
            switch (rawPreset) {
              case '"vscode"':
                return vscodeFilepath;
            }
            var raw = localStorageGetItem(LOCAL_STORAGE_OPEN_IN_EDITOR_URL);
            if (raw != null) {
              return JSON.parse(raw);
            }
          } catch (error) {}
          return getDefaultOpenInEditorURL();
        }
        function getAlwaysOpenInEditor() {
          try {
            var raw = localStorageGetItem(LOCAL_STORAGE_ALWAYS_OPEN_IN_EDITOR);
            return raw === "true";
          } catch (error) {}
          return false;
        }
        function parseElementDisplayNameFromBackend(displayName, type) {
          if (displayName === null) {
            return {
              formattedDisplayName: null,
              hocDisplayNames: null,
              compiledWithForget: false
            };
          }
          if (displayName.startsWith("Forget(")) {
            var displayNameWithoutForgetWrapper = displayName.slice(7, displayName.length - 1);
            var _parseElementDisplayN = parseElementDisplayNameFromBackend(displayNameWithoutForgetWrapper, type), formattedDisplayName = _parseElementDisplayN.formattedDisplayName, _hocDisplayNames = _parseElementDisplayN.hocDisplayNames;
            return {
              formattedDisplayName,
              hocDisplayNames: _hocDisplayNames,
              compiledWithForget: true
            };
          }
          var hocDisplayNames = null;
          switch (type) {
            case ElementTypeClass:
            case ElementTypeForwardRef:
            case ElementTypeFunction:
            case ElementTypeMemo:
            case ElementTypeVirtual:
              if (displayName.indexOf("(") >= 0) {
                var matches = displayName.match(/[^()]+/g);
                if (matches != null) {
                  displayName = matches.pop();
                  hocDisplayNames = matches;
                }
              }
              break;
            default:
              break;
          }
          return {
            formattedDisplayName: displayName,
            hocDisplayNames,
            compiledWithForget: false
          };
        }
        function shallowDiffers(prev, next) {
          for (var attribute in prev) {
            if (!(attribute in next)) {
              return true;
            }
          }
          for (var _attribute in next) {
            if (prev[_attribute] !== next[_attribute]) {
              return true;
            }
          }
          return false;
        }
        function utils_getInObject(object, path) {
          return path.reduce(function(reduced, attr) {
            if (reduced) {
              if (utils_hasOwnProperty.call(reduced, attr)) {
                return reduced[attr];
              }
              if (typeof reduced[Symbol.iterator] === "function") {
                return Array.from(reduced)[attr];
              }
            }
            return null;
          }, object);
        }
        function deletePathInObject(object, path) {
          var length = path.length;
          var last = path[length - 1];
          if (object != null) {
            var parent = utils_getInObject(object, path.slice(0, length - 1));
            if (parent) {
              if (src_isArray(parent)) {
                parent.splice(last, 1);
              } else {
                delete parent[last];
              }
            }
          }
        }
        function renamePathInObject(object, oldPath, newPath) {
          var length = oldPath.length;
          if (object != null) {
            var parent = utils_getInObject(object, oldPath.slice(0, length - 1));
            if (parent) {
              var lastOld = oldPath[length - 1];
              var lastNew = newPath[length - 1];
              parent[lastNew] = parent[lastOld];
              if (src_isArray(parent)) {
                parent.splice(lastOld, 1);
              } else {
                delete parent[lastOld];
              }
            }
          }
        }
        function utils_setInObject(object, path, value) {
          var length = path.length;
          var last = path[length - 1];
          if (object != null) {
            var parent = utils_getInObject(object, path.slice(0, length - 1));
            if (parent) {
              parent[last] = value;
            }
          }
        }
        function isError(data) {
          if ("name" in data && "message" in data) {
            while (data) {
              if (Object.prototype.toString.call(data) === "[object Error]") {
                return true;
              }
              data = Object.getPrototypeOf(data);
            }
          }
          return false;
        }
        function getDataType(data) {
          if (data === null) {
            return "null";
          } else if (data === undefined) {
            return "undefined";
          }
          if (typeof HTMLElement !== "undefined" && data instanceof HTMLElement) {
            return "html_element";
          }
          var type = utils_typeof(data);
          switch (type) {
            case "bigint":
              return "bigint";
            case "boolean":
              return "boolean";
            case "function":
              return "function";
            case "number":
              if (Number.isNaN(data)) {
                return "nan";
              } else if (!Number.isFinite(data)) {
                return "infinity";
              } else {
                return "number";
              }
            case "object":
              switch (data.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_LEGACY_ELEMENT_TYPE:
                  return "react_element";
                case REACT_LAZY_TYPE:
                  return "react_lazy";
              }
              if (src_isArray(data)) {
                return "array";
              } else if (ArrayBuffer.isView(data)) {
                return utils_hasOwnProperty.call(data.constructor, "BYTES_PER_ELEMENT") ? "typed_array" : "data_view";
              } else if (data.constructor && data.constructor.name === "ArrayBuffer") {
                return "array_buffer";
              } else if (typeof data[Symbol.iterator] === "function") {
                var iterator = data[Symbol.iterator]();
                if (!iterator) {} else {
                  return iterator === data ? "opaque_iterator" : "iterator";
                }
              } else if (data.constructor && data.constructor.name === "RegExp") {
                return "regexp";
              } else if (typeof data.then === "function") {
                return "thenable";
              } else if (isError(data)) {
                return "error";
              } else {
                var toStringValue = Object.prototype.toString.call(data);
                if (toStringValue === "[object Date]") {
                  return "date";
                } else if (toStringValue === "[object HTMLAllCollection]") {
                  return "html_all_collection";
                }
              }
              if (!isPlainObject(data)) {
                return "class_instance";
              }
              return "object";
            case "string":
              return "string";
            case "symbol":
              return "symbol";
            case "undefined":
              if (Object.prototype.toString.call(data) === "[object HTMLAllCollection]") {
                return "html_all_collection";
              }
              return "undefined";
            default:
              return "unknown";
          }
        }
        function typeOfWithLegacyElementSymbol(object) {
          if (utils_typeof(object) === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_LEGACY_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                  case REACT_VIEW_TRANSITION_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                        return $$typeofType;
                      case REACT_CONSUMER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return;
        }
        function getDisplayNameForReactElement(element) {
          var elementType = typeOfWithLegacyElementSymbol(element);
          switch (elementType) {
            case REACT_CONSUMER_TYPE:
              return "ContextConsumer";
            case LEGACY_REACT_PROVIDER_TYPE:
              return "ContextProvider";
            case REACT_CONTEXT_TYPE:
              return "Context";
            case REACT_FORWARD_REF_TYPE:
              return "ForwardRef";
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_LAZY_TYPE:
              return "Lazy";
            case REACT_MEMO_TYPE:
              return "Memo";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_VIEW_TRANSITION_TYPE:
              return "ViewTransition";
            case REACT_TRACING_MARKER_TYPE:
              return "TracingMarker";
            default:
              var type = element.type;
              if (typeof type === "string") {
                return type;
              } else if (typeof type === "function") {
                return getDisplayName(type, "Anonymous");
              } else if (type != null) {
                return "NotImplementedInDevtools";
              } else {
                return "Element";
              }
          }
        }
        var MAX_PREVIEW_STRING_LENGTH = 50;
        function truncateForDisplay(string) {
          var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_PREVIEW_STRING_LENGTH;
          if (string.length > length) {
            return string.slice(0, length) + "";
          } else {
            return string;
          }
        }
        function formatDataForPreview(data, showFormattedValue) {
          if (data != null && utils_hasOwnProperty.call(data, meta.type)) {
            return showFormattedValue ? data[meta.preview_long] : data[meta.preview_short];
          }
          var type = getDataType(data);
          switch (type) {
            case "html_element":
              return "<".concat(truncateForDisplay(data.tagName.toLowerCase()), " />");
            case "function":
              if (typeof data.name === "function" || data.name === "") {
                return "() => {}";
              }
              return "".concat(truncateForDisplay(data.name), "() {}");
            case "string":
              return '"'.concat(data, '"');
            case "bigint":
              return truncateForDisplay(data.toString() + "n");
            case "regexp":
              return truncateForDisplay(data.toString());
            case "symbol":
              return truncateForDisplay(data.toString());
            case "react_element":
              return "<".concat(truncateForDisplay(getDisplayNameForReactElement(data) || "Unknown"), " />");
            case "react_lazy":
              var payload = data._payload;
              if (payload !== null && utils_typeof(payload) === "object") {
                if (payload._status === 0) {
                  return "pending lazy()";
                }
                if (payload._status === 1 && payload._result != null) {
                  if (showFormattedValue) {
                    var formatted = formatDataForPreview(payload._result.default, false);
                    return "fulfilled lazy() {".concat(truncateForDisplay(formatted), "}");
                  } else {
                    return "fulfilled lazy() {}";
                  }
                }
                if (payload._status === 2) {
                  if (showFormattedValue) {
                    var _formatted = formatDataForPreview(payload._result, false);
                    return "rejected lazy() {".concat(truncateForDisplay(_formatted), "}");
                  } else {
                    return "rejected lazy() {}";
                  }
                }
                if (payload.status === "pending" || payload.status === "blocked") {
                  return "pending lazy()";
                }
                if (payload.status === "fulfilled") {
                  if (showFormattedValue) {
                    var _formatted2 = formatDataForPreview(payload.value, false);
                    return "fulfilled lazy() {".concat(truncateForDisplay(_formatted2), "}");
                  } else {
                    return "fulfilled lazy() {}";
                  }
                }
                if (payload.status === "rejected") {
                  if (showFormattedValue) {
                    var _formatted3 = formatDataForPreview(payload.reason, false);
                    return "rejected lazy() {".concat(truncateForDisplay(_formatted3), "}");
                  } else {
                    return "rejected lazy() {}";
                  }
                }
              }
              return "lazy()";
            case "array_buffer":
              return "ArrayBuffer(".concat(data.byteLength, ")");
            case "data_view":
              return "DataView(".concat(data.buffer.byteLength, ")");
            case "array":
              if (showFormattedValue) {
                var _formatted4 = "";
                for (var i = 0;i < data.length; i++) {
                  if (i > 0) {
                    _formatted4 += ", ";
                  }
                  _formatted4 += formatDataForPreview(data[i], false);
                  if (_formatted4.length > MAX_PREVIEW_STRING_LENGTH) {
                    break;
                  }
                }
                return "[".concat(truncateForDisplay(_formatted4), "]");
              } else {
                var length = utils_hasOwnProperty.call(data, meta.size) ? data[meta.size] : data.length;
                return "Array(".concat(length, ")");
              }
            case "typed_array":
              var shortName = "".concat(data.constructor.name, "(").concat(data.length, ")");
              if (showFormattedValue) {
                var _formatted5 = "";
                for (var _i = 0;_i < data.length; _i++) {
                  if (_i > 0) {
                    _formatted5 += ", ";
                  }
                  _formatted5 += data[_i];
                  if (_formatted5.length > MAX_PREVIEW_STRING_LENGTH) {
                    break;
                  }
                }
                return "".concat(shortName, " [").concat(truncateForDisplay(_formatted5), "]");
              } else {
                return shortName;
              }
            case "iterator":
              var name = data.constructor.name;
              if (showFormattedValue) {
                var array = Array.from(data);
                var _formatted6 = "";
                for (var _i2 = 0;_i2 < array.length; _i2++) {
                  var entryOrEntries = array[_i2];
                  if (_i2 > 0) {
                    _formatted6 += ", ";
                  }
                  if (src_isArray(entryOrEntries)) {
                    var key = formatDataForPreview(entryOrEntries[0], true);
                    var value = formatDataForPreview(entryOrEntries[1], false);
                    _formatted6 += "".concat(key, " => ").concat(value);
                  } else {
                    _formatted6 += formatDataForPreview(entryOrEntries, false);
                  }
                  if (_formatted6.length > MAX_PREVIEW_STRING_LENGTH) {
                    break;
                  }
                }
                return "".concat(name, "(").concat(data.size, ") {").concat(truncateForDisplay(_formatted6), "}");
              } else {
                return "".concat(name, "(").concat(data.size, ")");
              }
            case "opaque_iterator": {
              return data[Symbol.toStringTag];
            }
            case "date":
              return data.toString();
            case "class_instance":
              try {
                var resolvedConstructorName = data.constructor.name;
                if (typeof resolvedConstructorName === "string") {
                  return resolvedConstructorName;
                }
                resolvedConstructorName = Object.getPrototypeOf(data).constructor.name;
                if (typeof resolvedConstructorName === "string") {
                  return resolvedConstructorName;
                }
                try {
                  return truncateForDisplay(String(data));
                } catch (error) {
                  return "unserializable";
                }
              } catch (error) {
                return "unserializable";
              }
            case "thenable":
              var displayName;
              if (isPlainObject(data)) {
                displayName = "Thenable";
              } else {
                var _resolvedConstructorName = data.constructor.name;
                if (typeof _resolvedConstructorName !== "string") {
                  _resolvedConstructorName = Object.getPrototypeOf(data).constructor.name;
                }
                if (typeof _resolvedConstructorName === "string") {
                  displayName = _resolvedConstructorName;
                } else {
                  displayName = "Thenable";
                }
              }
              switch (data.status) {
                case "pending":
                  return "pending ".concat(displayName);
                case "fulfilled":
                  if (showFormattedValue) {
                    var _formatted7 = formatDataForPreview(data.value, false);
                    return "fulfilled ".concat(displayName, " {").concat(truncateForDisplay(_formatted7), "}");
                  } else {
                    return "fulfilled ".concat(displayName, " {}");
                  }
                case "rejected":
                  if (showFormattedValue) {
                    var _formatted8 = formatDataForPreview(data.reason, false);
                    return "rejected ".concat(displayName, " {").concat(truncateForDisplay(_formatted8), "}");
                  } else {
                    return "rejected ".concat(displayName, " {}");
                  }
                default:
                  return displayName;
              }
            case "object":
              if (showFormattedValue) {
                var keys = Array.from(getAllEnumerableKeys(data)).sort(alphaSortKeys);
                var _formatted9 = "";
                for (var _i3 = 0;_i3 < keys.length; _i3++) {
                  var _key = keys[_i3];
                  if (_i3 > 0) {
                    _formatted9 += ", ";
                  }
                  _formatted9 += "".concat(_key.toString(), ": ").concat(formatDataForPreview(data[_key], false));
                  if (_formatted9.length > MAX_PREVIEW_STRING_LENGTH) {
                    break;
                  }
                }
                return "{".concat(truncateForDisplay(_formatted9), "}");
              } else {
                return "{}";
              }
            case "error":
              return truncateForDisplay(String(data));
            case "boolean":
            case "number":
            case "infinity":
            case "nan":
            case "null":
            case "undefined":
              return String(data);
            default:
              try {
                return truncateForDisplay(String(data));
              } catch (error) {
                return "unserializable";
              }
          }
        }
        var isPlainObject = function isPlainObject(object) {
          var objectPrototype = Object.getPrototypeOf(object);
          if (!objectPrototype)
            return true;
          var objectParentPrototype = Object.getPrototypeOf(objectPrototype);
          return !objectParentPrototype;
        };
        function backendToFrontendSerializedElementMapper(element) {
          var _parseElementDisplayN2 = parseElementDisplayNameFromBackend(element.displayName, element.type), formattedDisplayName = _parseElementDisplayN2.formattedDisplayName, hocDisplayNames = _parseElementDisplayN2.hocDisplayNames, compiledWithForget = _parseElementDisplayN2.compiledWithForget;
          return _objectSpread(_objectSpread({}, element), {}, {
            displayName: formattedDisplayName,
            hocDisplayNames,
            compiledWithForget
          });
        }
        function normalizeUrlIfValid(url) {
          try {
            return new URL(url).toString();
          } catch (_unused) {
            return url;
          }
        }
        function getIsReloadAndProfileSupported() {
          var isBackendStorageAPISupported = false;
          try {
            localStorage.getItem("test");
            isBackendStorageAPISupported = true;
          } catch (error) {}
          return isBackendStorageAPISupported && isSynchronousXHRSupported();
        }
        function getIfReloadedAndProfiling() {
          return sessionStorageGetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY) === "true";
        }
        function getProfilingSettings() {
          return {
            recordChangeDescriptions: sessionStorageGetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY) === "true",
            recordTimeline: sessionStorageGetItem(SESSION_STORAGE_RECORD_TIMELINE_KEY) === "true"
          };
        }
        function onReloadAndProfile(recordChangeDescriptions, recordTimeline) {
          sessionStorageSetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY, "true");
          sessionStorageSetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY, recordChangeDescriptions ? "true" : "false");
          sessionStorageSetItem(SESSION_STORAGE_RECORD_TIMELINE_KEY, recordTimeline ? "true" : "false");
        }
        function onReloadAndProfileFlagsReset() {
          sessionStorageRemoveItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY);
          sessionStorageRemoveItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY);
          sessionStorageRemoveItem(SESSION_STORAGE_RECORD_TIMELINE_KEY);
        }
        function unionOfTwoArrays(a, b) {
          var result = a;
          for (var i = 0;i < b.length; i++) {
            var value = b[i];
            if (a.indexOf(value) === -1) {
              if (result === a) {
                result = a.slice(0);
              }
              result.push(value);
            }
          }
          return result;
        }
        function noop() {}
        function hydration_ownKeys(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function(r2) {
              return Object.getOwnPropertyDescriptor(e, r2).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function hydration_objectSpread(e) {
          for (var r = 1;r < arguments.length; r++) {
            var t = arguments[r] != null ? arguments[r] : {};
            r % 2 ? hydration_ownKeys(Object(t), true).forEach(function(r2) {
              hydration_defineProperty(e, r2, t[r2]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : hydration_ownKeys(Object(t)).forEach(function(r2) {
              Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
            });
          }
          return e;
        }
        function hydration_defineProperty(obj, key, value) {
          key = hydration_toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function hydration_toPropertyKey(t) {
          var i = hydration_toPrimitive(t, "string");
          return hydration_typeof(i) == "symbol" ? i : i + "";
        }
        function hydration_toPrimitive(t, r) {
          if (hydration_typeof(t) != "object" || !t)
            return t;
          var e = t[Symbol.toPrimitive];
          if (e !== undefined) {
            var i = e.call(t, r || "default");
            if (hydration_typeof(i) != "object")
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (r === "string" ? String : Number)(t);
        }
        function hydration_typeof(o) {
          "@babel/helpers - typeof";
          return hydration_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, hydration_typeof(o);
        }
        var meta = {
          inspectable: Symbol("inspectable"),
          inspected: Symbol("inspected"),
          name: Symbol("name"),
          preview_long: Symbol("preview_long"),
          preview_short: Symbol("preview_short"),
          readonly: Symbol("readonly"),
          size: Symbol("size"),
          type: Symbol("type"),
          unserializable: Symbol("unserializable")
        };
        var LEVEL_THRESHOLD = 2;
        function createDehydrated(type, inspectable, data, cleaned, path) {
          cleaned.push(path);
          var dehydrated = {
            inspectable,
            type,
            preview_long: formatDataForPreview(data, true),
            preview_short: formatDataForPreview(data, false),
            name: typeof data.constructor !== "function" || typeof data.constructor.name !== "string" || data.constructor.name === "Object" ? "" : data.constructor.name
          };
          if (type === "array" || type === "typed_array") {
            dehydrated.size = data.length;
          } else if (type === "object") {
            dehydrated.size = Object.keys(data).length;
          }
          if (type === "iterator" || type === "typed_array") {
            dehydrated.readonly = true;
          }
          return dehydrated;
        }
        function dehydrate(data, cleaned, unserializable, path, isPathAllowed) {
          var level = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
          var type = getDataType(data);
          var isPathAllowedCheck;
          switch (type) {
            case "html_element":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data.tagName,
                type
              };
            case "function":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: typeof data.name === "function" || !data.name ? "function" : data.name,
                type
              };
            case "string":
              isPathAllowedCheck = isPathAllowed(path);
              if (isPathAllowedCheck) {
                return data;
              } else {
                return data.length <= 500 ? data : data.slice(0, 500) + "...";
              }
            case "bigint":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data.toString(),
                type
              };
            case "symbol":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data.toString(),
                type
              };
            case "react_element": {
              isPathAllowedCheck = isPathAllowed(path);
              if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
                cleaned.push(path);
                return {
                  inspectable: true,
                  preview_short: formatDataForPreview(data, false),
                  preview_long: formatDataForPreview(data, true),
                  name: getDisplayNameForReactElement(data) || "Unknown",
                  type
                };
              }
              var unserializableValue = {
                unserializable: true,
                type,
                readonly: true,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: getDisplayNameForReactElement(data) || "Unknown"
              };
              unserializableValue.key = dehydrate(data.key, cleaned, unserializable, path.concat(["key"]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
              if (data.$$typeof === REACT_LEGACY_ELEMENT_TYPE) {
                unserializableValue.ref = dehydrate(data.ref, cleaned, unserializable, path.concat(["ref"]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
              }
              unserializableValue.props = dehydrate(data.props, cleaned, unserializable, path.concat(["props"]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
              unserializable.push(path);
              return unserializableValue;
            }
            case "react_lazy": {
              isPathAllowedCheck = isPathAllowed(path);
              var payload = data._payload;
              if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
                cleaned.push(path);
                var inspectable = payload !== null && hydration_typeof(payload) === "object" && (payload._status === 1 || payload._status === 2 || payload.status === "fulfilled" || payload.status === "rejected");
                return {
                  inspectable,
                  preview_short: formatDataForPreview(data, false),
                  preview_long: formatDataForPreview(data, true),
                  name: "lazy()",
                  type
                };
              }
              var _unserializableValue = {
                unserializable: true,
                type,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: "lazy()"
              };
              _unserializableValue._payload = dehydrate(payload, cleaned, unserializable, path.concat(["_payload"]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
              unserializable.push(path);
              return _unserializableValue;
            }
            case "array_buffer":
            case "data_view":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: type === "data_view" ? "DataView" : "ArrayBuffer",
                size: data.byteLength,
                type
              };
            case "array":
              isPathAllowedCheck = isPathAllowed(path);
              if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
                return createDehydrated(type, true, data, cleaned, path);
              }
              var arr = [];
              for (var i = 0;i < data.length; i++) {
                arr[i] = dehydrateKey(data, i, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
              }
              return arr;
            case "html_all_collection":
            case "typed_array":
            case "iterator":
              isPathAllowedCheck = isPathAllowed(path);
              if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
                return createDehydrated(type, true, data, cleaned, path);
              } else {
                var _unserializableValue2 = {
                  unserializable: true,
                  type,
                  readonly: true,
                  size: type === "typed_array" ? data.length : undefined,
                  preview_short: formatDataForPreview(data, false),
                  preview_long: formatDataForPreview(data, true),
                  name: typeof data.constructor !== "function" || typeof data.constructor.name !== "string" || data.constructor.name === "Object" ? "" : data.constructor.name
                };
                Array.from(data).forEach(function(item, i2) {
                  return _unserializableValue2[i2] = dehydrate(item, cleaned, unserializable, path.concat([i2]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
                });
                unserializable.push(path);
                return _unserializableValue2;
              }
            case "opaque_iterator":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data[Symbol.toStringTag],
                type
              };
            case "date":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data.toString(),
                type
              };
            case "regexp":
              cleaned.push(path);
              return {
                inspectable: false,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data.toString(),
                type
              };
            case "thenable":
              isPathAllowedCheck = isPathAllowed(path);
              if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
                cleaned.push(path);
                return {
                  inspectable: data.status === "fulfilled" || data.status === "rejected",
                  preview_short: formatDataForPreview(data, false),
                  preview_long: formatDataForPreview(data, true),
                  name: data.toString(),
                  type
                };
              }
              if (data.status === "resolved_model" || data.status === "resolve_module") {
                data.then(noop);
              }
              switch (data.status) {
                case "fulfilled": {
                  var _unserializableValue3 = {
                    unserializable: true,
                    type,
                    preview_short: formatDataForPreview(data, false),
                    preview_long: formatDataForPreview(data, true),
                    name: "fulfilled Thenable"
                  };
                  _unserializableValue3.value = dehydrate(data.value, cleaned, unserializable, path.concat(["value"]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
                  unserializable.push(path);
                  return _unserializableValue3;
                }
                case "rejected": {
                  var _unserializableValue4 = {
                    unserializable: true,
                    type,
                    preview_short: formatDataForPreview(data, false),
                    preview_long: formatDataForPreview(data, true),
                    name: "rejected Thenable"
                  };
                  _unserializableValue4.reason = dehydrate(data.reason, cleaned, unserializable, path.concat(["reason"]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
                  unserializable.push(path);
                  return _unserializableValue4;
                }
                default:
                  cleaned.push(path);
                  return {
                    inspectable: false,
                    preview_short: formatDataForPreview(data, false),
                    preview_long: formatDataForPreview(data, true),
                    name: data.toString(),
                    type
                  };
              }
            case "object":
              isPathAllowedCheck = isPathAllowed(path);
              if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
                return createDehydrated(type, true, data, cleaned, path);
              } else {
                var object = {};
                getAllEnumerableKeys(data).forEach(function(key) {
                  var name = key.toString();
                  object[name] = dehydrateKey(data, key, cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
                });
                return object;
              }
            case "class_instance": {
              isPathAllowedCheck = isPathAllowed(path);
              if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
                return createDehydrated(type, true, data, cleaned, path);
              }
              var value = {
                unserializable: true,
                type,
                readonly: true,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: typeof data.constructor !== "function" || typeof data.constructor.name !== "string" ? "" : data.constructor.name
              };
              getAllEnumerableKeys(data).forEach(function(key) {
                var keyAsString = key.toString();
                value[keyAsString] = dehydrate(data[key], cleaned, unserializable, path.concat([keyAsString]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
              });
              unserializable.push(path);
              return value;
            }
            case "error": {
              isPathAllowedCheck = isPathAllowed(path);
              if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
                return createDehydrated(type, true, data, cleaned, path);
              }
              var _value = {
                unserializable: true,
                type,
                readonly: true,
                preview_short: formatDataForPreview(data, false),
                preview_long: formatDataForPreview(data, true),
                name: data.name
              };
              _value.message = dehydrate(data.message, cleaned, unserializable, path.concat(["message"]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
              _value.stack = dehydrate(data.stack, cleaned, unserializable, path.concat(["stack"]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
              if ("cause" in data) {
                _value.cause = dehydrate(data.cause, cleaned, unserializable, path.concat(["cause"]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
              }
              getAllEnumerableKeys(data).forEach(function(key) {
                var keyAsString = key.toString();
                _value[keyAsString] = dehydrate(data[key], cleaned, unserializable, path.concat([keyAsString]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
              });
              unserializable.push(path);
              return _value;
            }
            case "infinity":
            case "nan":
            case "undefined":
              cleaned.push(path);
              return {
                type
              };
            default:
              return data;
          }
        }
        function dehydrateKey(parent, key, cleaned, unserializable, path, isPathAllowed) {
          var level = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
          try {
            return dehydrate(parent[key], cleaned, unserializable, path, isPathAllowed, level);
          } catch (error) {
            var preview = "";
            if (hydration_typeof(error) === "object" && error !== null && typeof error.stack === "string") {
              preview = error.stack;
            } else if (typeof error === "string") {
              preview = error;
            }
            cleaned.push(path);
            return {
              inspectable: false,
              preview_short: "[Exception]",
              preview_long: preview ? "[Exception: " + preview + "]" : "[Exception]",
              name: preview,
              type: "unknown"
            };
          }
        }
        function fillInPath(object, data, path, value) {
          var target = getInObject(object, path);
          if (target != null) {
            if (!target[meta.unserializable]) {
              delete target[meta.inspectable];
              delete target[meta.inspected];
              delete target[meta.name];
              delete target[meta.preview_long];
              delete target[meta.preview_short];
              delete target[meta.readonly];
              delete target[meta.size];
              delete target[meta.type];
            }
          }
          if (value !== null && data.unserializable.length > 0) {
            var unserializablePath = data.unserializable[0];
            var isMatch = unserializablePath.length === path.length;
            for (var i = 0;i < path.length; i++) {
              if (path[i] !== unserializablePath[i]) {
                isMatch = false;
                break;
              }
            }
            if (isMatch) {
              upgradeUnserializable(value, value);
            }
          }
          setInObject(object, path, value);
        }
        function hydrate(object, cleaned, unserializable) {
          cleaned.forEach(function(path) {
            var length = path.length;
            var last = path[length - 1];
            var parent = getInObject(object, path.slice(0, length - 1));
            if (!parent || !parent.hasOwnProperty(last)) {
              return;
            }
            var value = parent[last];
            if (!value) {
              return;
            } else if (value.type === "infinity") {
              parent[last] = Infinity;
            } else if (value.type === "nan") {
              parent[last] = NaN;
            } else if (value.type === "undefined") {
              parent[last] = undefined;
            } else {
              var replaced = {};
              replaced[meta.inspectable] = !!value.inspectable;
              replaced[meta.inspected] = false;
              replaced[meta.name] = value.name;
              replaced[meta.preview_long] = value.preview_long;
              replaced[meta.preview_short] = value.preview_short;
              replaced[meta.size] = value.size;
              replaced[meta.readonly] = !!value.readonly;
              replaced[meta.type] = value.type;
              parent[last] = replaced;
            }
          });
          unserializable.forEach(function(path) {
            var length = path.length;
            var last = path[length - 1];
            var parent = getInObject(object, path.slice(0, length - 1));
            if (!parent || !parent.hasOwnProperty(last)) {
              return;
            }
            var node = parent[last];
            var replacement = hydration_objectSpread({}, node);
            upgradeUnserializable(replacement, node);
            parent[last] = replacement;
          });
          return object;
        }
        function upgradeUnserializable(destination, source) {
          Object.defineProperties(destination, hydration_defineProperty(hydration_defineProperty(hydration_defineProperty(hydration_defineProperty(hydration_defineProperty(hydration_defineProperty(hydration_defineProperty(hydration_defineProperty({}, meta.inspected, {
            configurable: true,
            enumerable: false,
            value: !!source.inspected
          }), meta.name, {
            configurable: true,
            enumerable: false,
            value: source.name
          }), meta.preview_long, {
            configurable: true,
            enumerable: false,
            value: source.preview_long
          }), meta.preview_short, {
            configurable: true,
            enumerable: false,
            value: source.preview_short
          }), meta.size, {
            configurable: true,
            enumerable: false,
            value: source.size
          }), meta.readonly, {
            configurable: true,
            enumerable: false,
            value: !!source.readonly
          }), meta.type, {
            configurable: true,
            enumerable: false,
            value: source.type
          }), meta.unserializable, {
            configurable: true,
            enumerable: false,
            value: !!source.unserializable
          }));
          delete destination.inspected;
          delete destination.name;
          delete destination.preview_long;
          delete destination.preview_short;
          delete destination.size;
          delete destination.readonly;
          delete destination.type;
          delete destination.unserializable;
        }
        var isArrayImpl = Array.isArray;
        function isArray_isArray(a) {
          return isArrayImpl(a);
        }
        const shared_isArray = isArray_isArray;
        function backend_utils_typeof(o) {
          "@babel/helpers - typeof";
          return backend_utils_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, backend_utils_typeof(o);
        }
        function utils_ownKeys(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function(r2) {
              return Object.getOwnPropertyDescriptor(e, r2).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function utils_objectSpread(e) {
          for (var r = 1;r < arguments.length; r++) {
            var t = arguments[r] != null ? arguments[r] : {};
            r % 2 ? utils_ownKeys(Object(t), true).forEach(function(r2) {
              backend_utils_defineProperty(e, r2, t[r2]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : utils_ownKeys(Object(t)).forEach(function(r2) {
              Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
            });
          }
          return e;
        }
        function backend_utils_defineProperty(obj, key, value) {
          key = backend_utils_toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function backend_utils_toPropertyKey(t) {
          var i = backend_utils_toPrimitive(t, "string");
          return backend_utils_typeof(i) == "symbol" ? i : i + "";
        }
        function backend_utils_toPrimitive(t, r) {
          if (backend_utils_typeof(t) != "object" || !t)
            return t;
          var e = t[Symbol.toPrimitive];
          if (e !== undefined) {
            var i = e.call(t, r || "default");
            if (backend_utils_typeof(i) != "object")
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (r === "string" ? String : Number)(t);
        }
        var FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER = "999.9.9";
        function hasAssignedBackend(version) {
          if (version == null || version === "") {
            return false;
          }
          return gte(version, FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER);
        }
        function cleanForBridge(data, isPathAllowed) {
          var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          if (data !== null) {
            var cleanedPaths = [];
            var unserializablePaths = [];
            var cleanedData = dehydrate(data, cleanedPaths, unserializablePaths, path, isPathAllowed);
            return {
              data: cleanedData,
              cleaned: cleanedPaths,
              unserializable: unserializablePaths
            };
          } else {
            return null;
          }
        }
        function copyWithDelete(obj, path) {
          var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          var key = path[index];
          var updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj);
          if (index + 1 === path.length) {
            if (shared_isArray(updated)) {
              updated.splice(key, 1);
            } else {
              delete updated[key];
            }
          } else {
            updated[key] = copyWithDelete(obj[key], path, index + 1);
          }
          return updated;
        }
        function copyWithRename(obj, oldPath, newPath) {
          var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
          var oldKey = oldPath[index];
          var updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj);
          if (index + 1 === oldPath.length) {
            var newKey = newPath[index];
            updated[newKey] = updated[oldKey];
            if (shared_isArray(updated)) {
              updated.splice(oldKey, 1);
            } else {
              delete updated[oldKey];
            }
          } else {
            updated[oldKey] = copyWithRename(obj[oldKey], oldPath, newPath, index + 1);
          }
          return updated;
        }
        function copyWithSet(obj, path, value) {
          var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
          if (index >= path.length) {
            return value;
          }
          var key = path[index];
          var updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj);
          updated[key] = copyWithSet(obj[key], path, value, index + 1);
          return updated;
        }
        function getEffectDurations(root) {
          var effectDuration = null;
          var passiveEffectDuration = null;
          var hostRoot = root.current;
          if (hostRoot != null) {
            var stateNode = hostRoot.stateNode;
            if (stateNode != null) {
              effectDuration = stateNode.effectDuration != null ? stateNode.effectDuration : null;
              passiveEffectDuration = stateNode.passiveEffectDuration != null ? stateNode.passiveEffectDuration : null;
            }
          }
          return {
            effectDuration,
            passiveEffectDuration
          };
        }
        function serializeToString(data) {
          if (data === undefined) {
            return "undefined";
          }
          if (typeof data === "function") {
            return data.toString();
          }
          var cache3 = new Set;
          return JSON.stringify(data, function(key, value) {
            if (backend_utils_typeof(value) === "object" && value !== null) {
              if (cache3.has(value)) {
                return;
              }
              cache3.add(value);
            }
            if (typeof value === "bigint") {
              return value.toString() + "n";
            }
            return value;
          }, 2);
        }
        function safeToString(val) {
          try {
            return String(val);
          } catch (err) {
            if (backend_utils_typeof(val) === "object") {
              return "[object Object]";
            }
            throw err;
          }
        }
        function formatConsoleArgumentsToSingleString(maybeMessage) {
          for (var _len = arguments.length, inputArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
            inputArgs[_key - 1] = arguments[_key];
          }
          var args = inputArgs.slice();
          var formatted = safeToString(maybeMessage);
          if (typeof maybeMessage === "string") {
            if (args.length) {
              var REGEXP = /(%?)(%([jds]))/g;
              formatted = formatted.replace(REGEXP, function(match, escaped, ptn, flag) {
                var arg = args.shift();
                switch (flag) {
                  case "s":
                    arg += "";
                    break;
                  case "d":
                  case "i":
                    arg = parseInt(arg, 10).toString();
                    break;
                  case "f":
                    arg = parseFloat(arg).toString();
                    break;
                }
                if (!escaped) {
                  return arg;
                }
                args.unshift(arg);
                return match;
              });
            }
          }
          if (args.length) {
            for (var i = 0;i < args.length; i++) {
              formatted += " " + safeToString(args[i]);
            }
          }
          formatted = formatted.replace(/%{2,2}/g, "%");
          return String(formatted);
        }
        function isSynchronousXHRSupported() {
          return !!(window.document && window.document.featurePolicy && window.document.featurePolicy.allowsFeature("sync-xhr"));
        }
        function gt() {
          var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
          var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          return compareVersions(a, b) === 1;
        }
        function gte() {
          var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
          var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          return compareVersions(a, b) > -1;
        }
        var isReactNativeEnvironment = function isReactNativeEnvironment() {
          return window.document == null;
        };
        function formatDurationToMicrosecondsGranularity(duration) {
          return Math.round(duration * 1000) / 1000;
        }
        function utils_slicedToArray(arr, i) {
          return utils_arrayWithHoles(arr) || utils_iterableToArrayLimit(arr, i) || views_utils_unsupportedIterableToArray(arr, i) || utils_nonIterableRest();
        }
        function utils_nonIterableRest() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function views_utils_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return views_utils_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return views_utils_arrayLikeToArray(o, minLen);
        }
        function views_utils_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len);i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        function utils_iterableToArrayLimit(r, l) {
          var t = r == null ? null : typeof Symbol != "undefined" && r[Symbol.iterator] || r["@@iterator"];
          if (t != null) {
            var e, n, i, u, a = [], f = true, o = false;
            try {
              if (i = (t = t.call(r)).next, l === 0) {
                if (Object(t) !== t)
                  return;
                f = false;
              } else
                for (;!(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
                  ;
            } catch (r2) {
              o = true, n = r2;
            } finally {
              try {
                if (!f && t.return != null && (u = t.return(), Object(u) !== u))
                  return;
              } finally {
                if (o)
                  throw n;
              }
            }
            return a;
          }
        }
        function utils_arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        function getOwnerWindow(node) {
          if (!node.ownerDocument) {
            return null;
          }
          return node.ownerDocument.defaultView;
        }
        function getOwnerIframe(node) {
          var nodeWindow = getOwnerWindow(node);
          if (nodeWindow) {
            return nodeWindow.frameElement;
          }
          return null;
        }
        function getBoundingClientRectWithBorderOffset(node) {
          var dimensions = getElementDimensions(node);
          return mergeRectOffsets([node.getBoundingClientRect(), {
            top: dimensions.borderTop,
            left: dimensions.borderLeft,
            bottom: dimensions.borderBottom,
            right: dimensions.borderRight,
            width: 0,
            height: 0
          }]);
        }
        function mergeRectOffsets(rects) {
          return rects.reduce(function(previousRect, rect) {
            if (previousRect == null) {
              return rect;
            }
            return {
              top: previousRect.top + rect.top,
              left: previousRect.left + rect.left,
              width: previousRect.width,
              height: previousRect.height,
              bottom: previousRect.bottom + rect.bottom,
              right: previousRect.right + rect.right
            };
          });
        }
        function getNestedBoundingClientRect(node, boundaryWindow) {
          var ownerIframe = getOwnerIframe(node);
          if (ownerIframe && ownerIframe !== boundaryWindow) {
            var rects = [node.getBoundingClientRect()];
            var currentIframe = ownerIframe;
            var onlyOneMore = false;
            while (currentIframe) {
              var rect = getBoundingClientRectWithBorderOffset(currentIframe);
              rects.push(rect);
              currentIframe = getOwnerIframe(currentIframe);
              if (onlyOneMore) {
                break;
              }
              if (currentIframe && getOwnerWindow(currentIframe) === boundaryWindow) {
                onlyOneMore = true;
              }
            }
            return mergeRectOffsets(rects);
          } else {
            return node.getBoundingClientRect();
          }
        }
        function getElementDimensions(domElement) {
          var calculatedStyle = window.getComputedStyle(domElement);
          return {
            borderLeft: parseInt(calculatedStyle.borderLeftWidth, 10),
            borderRight: parseInt(calculatedStyle.borderRightWidth, 10),
            borderTop: parseInt(calculatedStyle.borderTopWidth, 10),
            borderBottom: parseInt(calculatedStyle.borderBottomWidth, 10),
            marginLeft: parseInt(calculatedStyle.marginLeft, 10),
            marginRight: parseInt(calculatedStyle.marginRight, 10),
            marginTop: parseInt(calculatedStyle.marginTop, 10),
            marginBottom: parseInt(calculatedStyle.marginBottom, 10),
            paddingLeft: parseInt(calculatedStyle.paddingLeft, 10),
            paddingRight: parseInt(calculatedStyle.paddingRight, 10),
            paddingTop: parseInt(calculatedStyle.paddingTop, 10),
            paddingBottom: parseInt(calculatedStyle.paddingBottom, 10)
          };
        }
        function extractHOCNames(displayName) {
          if (!displayName)
            return {
              baseComponentName: "",
              hocNames: []
            };
          var hocRegex = /([A-Z][a-zA-Z0-9]*?)\((.*)\)/g;
          var hocNames = [];
          var baseComponentName = displayName;
          var match;
          while ((match = hocRegex.exec(baseComponentName)) != null) {
            if (Array.isArray(match)) {
              var _match = match, _match2 = utils_slicedToArray(_match, 3), hocName = _match2[1], inner = _match2[2];
              hocNames.push(hocName);
              baseComponentName = inner;
            }
          }
          return {
            baseComponentName,
            hocNames
          };
        }
        function Overlay_typeof(o) {
          "@babel/helpers - typeof";
          return Overlay_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, Overlay_typeof(o);
        }
        function Overlay_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function Overlay_defineProperties(target, props) {
          for (var i = 0;i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, Overlay_toPropertyKey(descriptor.key), descriptor);
          }
        }
        function Overlay_createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            Overlay_defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            Overlay_defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", { writable: false });
          return Constructor;
        }
        function Overlay_toPropertyKey(t) {
          var i = Overlay_toPrimitive(t, "string");
          return Overlay_typeof(i) == "symbol" ? i : i + "";
        }
        function Overlay_toPrimitive(t, r) {
          if (Overlay_typeof(t) != "object" || !t)
            return t;
          var e = t[Symbol.toPrimitive];
          if (e !== undefined) {
            var i = e.call(t, r || "default");
            if (Overlay_typeof(i) != "object")
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (r === "string" ? String : Number)(t);
        }
        var Overlay_assign = Object.assign;
        var OverlayRect = /* @__PURE__ */ function() {
          function OverlayRect2(doc, container) {
            Overlay_classCallCheck(this, OverlayRect2);
            this.node = doc.createElement("div");
            this.border = doc.createElement("div");
            this.padding = doc.createElement("div");
            this.content = doc.createElement("div");
            this.border.style.borderColor = overlayStyles.border;
            this.padding.style.borderColor = overlayStyles.padding;
            this.content.style.backgroundColor = overlayStyles.background;
            Overlay_assign(this.node.style, {
              borderColor: overlayStyles.margin,
              pointerEvents: "none",
              position: "fixed"
            });
            this.node.style.zIndex = "10000000";
            this.node.appendChild(this.border);
            this.border.appendChild(this.padding);
            this.padding.appendChild(this.content);
            container.appendChild(this.node);
          }
          return Overlay_createClass(OverlayRect2, [{
            key: "remove",
            value: function remove() {
              if (this.node.parentNode) {
                this.node.parentNode.removeChild(this.node);
              }
            }
          }, {
            key: "update",
            value: function update(box, dims) {
              boxWrap(dims, "margin", this.node);
              boxWrap(dims, "border", this.border);
              boxWrap(dims, "padding", this.padding);
              Overlay_assign(this.content.style, {
                height: box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom + "px",
                width: box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight + "px"
              });
              Overlay_assign(this.node.style, {
                top: box.top - dims.marginTop + "px",
                left: box.left - dims.marginLeft + "px"
              });
            }
          }]);
        }();
        var OverlayTip = /* @__PURE__ */ function() {
          function OverlayTip2(doc, container) {
            Overlay_classCallCheck(this, OverlayTip2);
            this.tip = doc.createElement("div");
            Overlay_assign(this.tip.style, {
              display: "flex",
              flexFlow: "row nowrap",
              backgroundColor: "#333740",
              borderRadius: "2px",
              fontFamily: '"SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace',
              fontWeight: "bold",
              padding: "3px 5px",
              pointerEvents: "none",
              position: "fixed",
              fontSize: "12px",
              whiteSpace: "nowrap"
            });
            this.nameSpan = doc.createElement("span");
            this.tip.appendChild(this.nameSpan);
            Overlay_assign(this.nameSpan.style, {
              color: "#ee78e6",
              borderRight: "1px solid #aaaaaa",
              paddingRight: "0.5rem",
              marginRight: "0.5rem"
            });
            this.dimSpan = doc.createElement("span");
            this.tip.appendChild(this.dimSpan);
            Overlay_assign(this.dimSpan.style, {
              color: "#d7d7d7"
            });
            this.tip.style.zIndex = "10000000";
            container.appendChild(this.tip);
          }
          return Overlay_createClass(OverlayTip2, [{
            key: "remove",
            value: function remove() {
              if (this.tip.parentNode) {
                this.tip.parentNode.removeChild(this.tip);
              }
            }
          }, {
            key: "updateText",
            value: function updateText(name, width, height) {
              this.nameSpan.textContent = name;
              this.dimSpan.textContent = Math.round(width) + "px  " + Math.round(height) + "px";
            }
          }, {
            key: "updatePosition",
            value: function updatePosition(dims, bounds) {
              var tipRect = this.tip.getBoundingClientRect();
              var tipPos = findTipPos(dims, bounds, {
                width: tipRect.width,
                height: tipRect.height
              });
              Overlay_assign(this.tip.style, tipPos.style);
            }
          }]);
        }();
        var Overlay = /* @__PURE__ */ function() {
          function Overlay2(agent2) {
            Overlay_classCallCheck(this, Overlay2);
            var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
            this.window = currentWindow;
            var tipBoundsWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
            this.tipBoundsWindow = tipBoundsWindow;
            var doc = currentWindow.document;
            this.container = doc.createElement("div");
            this.container.style.zIndex = "10000000";
            this.tip = new OverlayTip(doc, this.container);
            this.rects = [];
            this.agent = agent2;
            doc.body.appendChild(this.container);
          }
          return Overlay_createClass(Overlay2, [{
            key: "remove",
            value: function remove() {
              this.tip.remove();
              this.rects.forEach(function(rect) {
                rect.remove();
              });
              this.rects.length = 0;
              if (this.container.parentNode) {
                this.container.parentNode.removeChild(this.container);
              }
            }
          }, {
            key: "inspect",
            value: function inspect(nodes, name) {
              var _this = this;
              var elements = nodes.filter(function(node2) {
                return node2.nodeType === Node.ELEMENT_NODE;
              });
              while (this.rects.length > elements.length) {
                var rect = this.rects.pop();
                rect.remove();
              }
              if (elements.length === 0) {
                return;
              }
              while (this.rects.length < elements.length) {
                this.rects.push(new OverlayRect(this.window.document, this.container));
              }
              var outerBox = {
                top: Number.POSITIVE_INFINITY,
                right: Number.NEGATIVE_INFINITY,
                bottom: Number.NEGATIVE_INFINITY,
                left: Number.POSITIVE_INFINITY
              };
              elements.forEach(function(element, index) {
                var box = getNestedBoundingClientRect(element, _this.window);
                var dims = getElementDimensions(element);
                outerBox.top = Math.min(outerBox.top, box.top - dims.marginTop);
                outerBox.right = Math.max(outerBox.right, box.left + box.width + dims.marginRight);
                outerBox.bottom = Math.max(outerBox.bottom, box.top + box.height + dims.marginBottom);
                outerBox.left = Math.min(outerBox.left, box.left - dims.marginLeft);
                var rect2 = _this.rects[index];
                rect2.update(box, dims);
              });
              if (!name) {
                name = elements[0].nodeName.toLowerCase();
                var node = elements[0];
                var ownerName = this.agent.getComponentNameForHostInstance(node);
                if (ownerName) {
                  name += " (in " + ownerName + ")";
                }
              }
              this.tip.updateText(name, outerBox.right - outerBox.left, outerBox.bottom - outerBox.top);
              var tipBounds = getNestedBoundingClientRect(this.tipBoundsWindow.document.documentElement, this.window);
              this.tip.updatePosition({
                top: outerBox.top,
                left: outerBox.left,
                height: outerBox.bottom - outerBox.top,
                width: outerBox.right - outerBox.left
              }, {
                top: tipBounds.top + this.tipBoundsWindow.scrollY,
                left: tipBounds.left + this.tipBoundsWindow.scrollX,
                height: this.tipBoundsWindow.innerHeight,
                width: this.tipBoundsWindow.innerWidth
              });
            }
          }]);
        }();
        function findTipPos(dims, bounds, tipSize) {
          var tipHeight = Math.max(tipSize.height, 20);
          var tipWidth = Math.max(tipSize.width, 60);
          var margin = 5;
          var top;
          if (dims.top + dims.height + tipHeight <= bounds.top + bounds.height) {
            if (dims.top + dims.height < bounds.top + 0) {
              top = bounds.top + margin;
            } else {
              top = dims.top + dims.height + margin;
            }
          } else if (dims.top - tipHeight <= bounds.top + bounds.height) {
            if (dims.top - tipHeight - margin < bounds.top + margin) {
              top = bounds.top + margin;
            } else {
              top = dims.top - tipHeight - margin;
            }
          } else {
            top = bounds.top + bounds.height - tipHeight - margin;
          }
          var left = dims.left + margin;
          if (dims.left < bounds.left) {
            left = bounds.left + margin;
          }
          if (dims.left + tipWidth > bounds.left + bounds.width) {
            left = bounds.left + bounds.width - tipWidth - margin;
          }
          top += "px";
          left += "px";
          return {
            style: {
              top,
              left
            }
          };
        }
        function boxWrap(dims, what, node) {
          Overlay_assign(node.style, {
            borderTopWidth: dims[what + "Top"] + "px",
            borderLeftWidth: dims[what + "Left"] + "px",
            borderRightWidth: dims[what + "Right"] + "px",
            borderBottomWidth: dims[what + "Bottom"] + "px",
            borderStyle: "solid"
          });
        }
        var overlayStyles = {
          background: "rgba(120, 170, 210, 0.7)",
          padding: "rgba(77, 200, 0, 0.3)",
          margin: "rgba(255, 155, 0, 0.3)",
          border: "rgba(255, 200, 50, 0.3)"
        };
        var SHOW_DURATION = 2000;
        var timeoutID = null;
        var overlay = null;
        function hideOverlayNative(agent2) {
          agent2.emit("hideNativeHighlight");
        }
        function hideOverlayWeb() {
          timeoutID = null;
          if (overlay !== null) {
            overlay.remove();
            overlay = null;
          }
        }
        function hideOverlay(agent2) {
          return isReactNativeEnvironment() ? hideOverlayNative(agent2) : hideOverlayWeb();
        }
        function showOverlayNative(elements, agent2) {
          agent2.emit("showNativeHighlight", elements);
        }
        function showOverlayWeb(elements, componentName, agent2, hideAfterTimeout) {
          if (timeoutID !== null) {
            clearTimeout(timeoutID);
          }
          if (overlay === null) {
            overlay = new Overlay(agent2);
          }
          overlay.inspect(elements, componentName);
          if (hideAfterTimeout) {
            timeoutID = setTimeout(function() {
              return hideOverlay(agent2);
            }, SHOW_DURATION);
          }
        }
        function showOverlay(elements, componentName, agent2, hideAfterTimeout) {
          return isReactNativeEnvironment() ? showOverlayNative(elements, agent2) : showOverlayWeb(elements, componentName, agent2, hideAfterTimeout);
        }
        var iframesListeningTo = new Set;
        var inspectOnlySuspenseNodes = false;
        function setupHighlighter(bridge, agent2) {
          bridge.addListener("clearHostInstanceHighlight", clearHostInstanceHighlight);
          bridge.addListener("highlightHostInstance", highlightHostInstance);
          bridge.addListener("highlightHostInstances", highlightHostInstances);
          bridge.addListener("scrollToHostInstance", scrollToHostInstance);
          bridge.addListener("shutdown", stopInspectingHost);
          bridge.addListener("startInspectingHost", startInspectingHost);
          bridge.addListener("stopInspectingHost", stopInspectingHost);
          function startInspectingHost(onlySuspenseNodes) {
            inspectOnlySuspenseNodes = onlySuspenseNodes;
            registerListenersOnWindow(window);
          }
          function registerListenersOnWindow(window2) {
            if (window2 && typeof window2.addEventListener === "function") {
              window2.addEventListener("click", onClick, true);
              window2.addEventListener("mousedown", onMouseEvent, true);
              window2.addEventListener("mouseover", onMouseEvent, true);
              window2.addEventListener("mouseup", onMouseEvent, true);
              window2.addEventListener("pointerdown", onPointerDown, true);
              window2.addEventListener("pointermove", onPointerMove, true);
              window2.addEventListener("pointerup", onPointerUp, true);
            } else {
              agent2.emit("startInspectingNative");
            }
          }
          function stopInspectingHost() {
            hideOverlay(agent2);
            removeListenersOnWindow(window);
            iframesListeningTo.forEach(function(frame) {
              try {
                removeListenersOnWindow(frame.contentWindow);
              } catch (error) {}
            });
            iframesListeningTo = new Set;
          }
          function removeListenersOnWindow(window2) {
            if (window2 && typeof window2.removeEventListener === "function") {
              window2.removeEventListener("click", onClick, true);
              window2.removeEventListener("mousedown", onMouseEvent, true);
              window2.removeEventListener("mouseover", onMouseEvent, true);
              window2.removeEventListener("mouseup", onMouseEvent, true);
              window2.removeEventListener("pointerdown", onPointerDown, true);
              window2.removeEventListener("pointermove", onPointerMove, true);
              window2.removeEventListener("pointerup", onPointerUp, true);
            } else {
              agent2.emit("stopInspectingNative");
            }
          }
          function clearHostInstanceHighlight() {
            hideOverlay(agent2);
          }
          function highlightHostInstance(_ref) {
            var { displayName, hideAfterTimeout, id, openBuiltinElementsPanel, rendererID, scrollIntoView } = _ref;
            var renderer = agent2.rendererInterfaces[rendererID];
            if (renderer == null) {
              console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              hideOverlay(agent2);
              return;
            }
            if (!renderer.hasElementWithId(id)) {
              hideOverlay(agent2);
              return;
            }
            var nodes = renderer.findHostInstancesForElementID(id);
            if (nodes != null) {
              for (var i = 0;i < nodes.length; i++) {
                var node = nodes[i];
                if (node === null) {
                  continue;
                }
                var nodeRects = typeof node.getClientRects === "function" ? node.getClientRects() : [];
                if (nodeRects.length > 0 && (nodeRects.length > 2 || nodeRects[0].width > 0 || nodeRects[0].height > 0)) {
                  if (scrollIntoView && typeof node.scrollIntoView === "function") {
                    if (scrollDelayTimer) {
                      clearTimeout(scrollDelayTimer);
                      scrollDelayTimer = null;
                    }
                    node.scrollIntoView({
                      block: "nearest",
                      inline: "nearest"
                    });
                  }
                  showOverlay(nodes, displayName, agent2, hideAfterTimeout);
                  if (openBuiltinElementsPanel) {
                    window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0 = node;
                    bridge.send("syncSelectionToBuiltinElementsPanel");
                  }
                  return;
                }
              }
            }
            hideOverlay(agent2);
          }
          function highlightHostInstances(_ref2) {
            var { displayName, hideAfterTimeout, elements, scrollIntoView } = _ref2;
            var nodes = [];
            for (var i = 0;i < elements.length; i++) {
              var _elements$i = elements[i], id = _elements$i.id, rendererID = _elements$i.rendererID;
              var renderer = agent2.rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
                continue;
              }
              if (!renderer.hasElementWithId(id)) {
                continue;
              }
              var hostInstances = renderer.findHostInstancesForElementID(id);
              if (hostInstances !== null) {
                for (var j = 0;j < hostInstances.length; j++) {
                  nodes.push(hostInstances[j]);
                }
              }
            }
            if (nodes.length > 0) {
              var node = nodes[0];
              if (scrollIntoView && typeof node.scrollIntoView === "function") {
                node.scrollIntoView({
                  block: "nearest",
                  inline: "nearest"
                });
              }
            }
            showOverlay(nodes, displayName, agent2, hideAfterTimeout);
          }
          function attemptScrollToHostInstance(renderer, id) {
            var nodes = renderer.findHostInstancesForElementID(id);
            if (nodes != null) {
              for (var i = 0;i < nodes.length; i++) {
                var node = nodes[i];
                if (node === null) {
                  continue;
                }
                var nodeRects = typeof node.getClientRects === "function" ? node.getClientRects() : [];
                if (nodeRects.length > 0 && (nodeRects.length > 2 || nodeRects[0].width > 0 || nodeRects[0].height > 0)) {
                  if (typeof node.scrollIntoView === "function") {
                    node.scrollIntoView({
                      block: "nearest",
                      inline: "nearest",
                      behavior: "smooth"
                    });
                    return true;
                  }
                }
              }
            }
            return false;
          }
          var scrollDelayTimer = null;
          function scrollToHostInstance(_ref3) {
            var { id, rendererID } = _ref3;
            hideOverlay(agent2);
            if (scrollDelayTimer) {
              clearTimeout(scrollDelayTimer);
              scrollDelayTimer = null;
            }
            var renderer = agent2.rendererInterfaces[rendererID];
            if (renderer == null) {
              console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              return;
            }
            if (!renderer.hasElementWithId(id)) {
              return;
            }
            if (attemptScrollToHostInstance(renderer, id)) {
              return;
            }
            var rects = renderer.findLastKnownRectsForID(id);
            if (rects !== null && rects.length > 0) {
              var x = Infinity;
              var y = Infinity;
              for (var i = 0;i < rects.length; i++) {
                var rect = rects[i];
                if (rect.x < x) {
                  x = rect.x;
                }
                if (rect.y < y) {
                  y = rect.y;
                }
              }
              var element = document.documentElement;
              if (!element) {
                return;
              }
              if (x < window.scrollX || y < window.scrollY || x > window.scrollX + element.clientWidth || y > window.scrollY + element.clientHeight) {
                window.scrollTo({
                  top: y,
                  left: x,
                  behavior: "smooth"
                });
              }
              scrollDelayTimer = setTimeout(function() {
                attemptScrollToHostInstance(renderer, id);
              }, 100);
            }
          }
          function onClick(event) {
            event.preventDefault();
            event.stopPropagation();
            stopInspectingHost();
            bridge.send("stopInspectingHost", true);
          }
          function onMouseEvent(event) {
            event.preventDefault();
            event.stopPropagation();
          }
          function onPointerDown(event) {
            event.preventDefault();
            event.stopPropagation();
            selectElementForNode(getEventTarget(event));
          }
          var lastHoveredNode = null;
          function onPointerMove(event) {
            event.preventDefault();
            event.stopPropagation();
            var target = getEventTarget(event);
            if (lastHoveredNode === target)
              return;
            lastHoveredNode = target;
            if (target.tagName === "IFRAME") {
              var iframe = target;
              try {
                if (!iframesListeningTo.has(iframe)) {
                  var _window = iframe.contentWindow;
                  registerListenersOnWindow(_window);
                  iframesListeningTo.add(iframe);
                }
              } catch (error) {}
            }
            if (inspectOnlySuspenseNodes) {
              var match = agent2.getIDForHostInstance(target, inspectOnlySuspenseNodes);
              if (match !== null) {
                var renderer = agent2.rendererInterfaces[match.rendererID];
                if (renderer == null) {
                  console.warn('Invalid renderer id "'.concat(match.rendererID, '" for element "').concat(match.id, '"'));
                  return;
                }
                highlightHostInstance({
                  displayName: renderer.getDisplayNameForElementID(match.id),
                  hideAfterTimeout: false,
                  id: match.id,
                  openBuiltinElementsPanel: false,
                  rendererID: match.rendererID,
                  scrollIntoView: false
                });
              }
            } else {
              showOverlay([target], null, agent2, false);
            }
          }
          function onPointerUp(event) {
            event.preventDefault();
            event.stopPropagation();
          }
          var selectElementForNode = function selectElementForNode(node) {
            var match = agent2.getIDForHostInstance(node, inspectOnlySuspenseNodes);
            if (match !== null) {
              bridge.send("selectElement", match.id);
            }
          };
          function getEventTarget(event) {
            if (event.composed) {
              return event.composedPath()[0];
            }
            return event.target;
          }
        }
        function canvas_toConsumableArray(arr) {
          return canvas_arrayWithoutHoles(arr) || canvas_iterableToArray(arr) || canvas_unsupportedIterableToArray(arr) || canvas_nonIterableSpread();
        }
        function canvas_nonIterableSpread() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function canvas_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return canvas_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return canvas_arrayLikeToArray(o, minLen);
        }
        function canvas_iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
            return Array.from(iter);
        }
        function canvas_arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return canvas_arrayLikeToArray(arr);
        }
        function canvas_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len);i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        var COLORS = ["#37afa9", "#63b19e", "#80b393", "#97b488", "#abb67d", "#beb771", "#cfb965", "#dfba57", "#efbb49", "#febc38"];
        var canvas = null;
        function drawNative(nodeToData2, agent2) {
          var nodesToDraw = [];
          iterateNodes(nodeToData2, function(_ref) {
            var { color, node } = _ref;
            nodesToDraw.push({
              node,
              color
            });
          });
          agent2.emit("drawTraceUpdates", nodesToDraw);
          var mergedNodes = groupAndSortNodes(nodeToData2);
          agent2.emit("drawGroupedTraceUpdatesWithNames", mergedNodes);
        }
        function drawWeb(nodeToData2) {
          if (canvas === null) {
            initialize();
          }
          var dpr = window.devicePixelRatio || 1;
          var canvasFlow = canvas;
          canvasFlow.width = window.innerWidth * dpr;
          canvasFlow.height = window.innerHeight * dpr;
          canvasFlow.style.width = "".concat(window.innerWidth, "px");
          canvasFlow.style.height = "".concat(window.innerHeight, "px");
          var context = canvasFlow.getContext("2d");
          context.scale(dpr, dpr);
          context.clearRect(0, 0, canvasFlow.width / dpr, canvasFlow.height / dpr);
          var mergedNodes = groupAndSortNodes(nodeToData2);
          mergedNodes.forEach(function(group) {
            drawGroupBorders(context, group);
            drawGroupLabel(context, group);
          });
          if (canvas !== null) {
            if (nodeToData2.size === 0 && canvas.matches(":popover-open")) {
              canvas.hidePopover();
              return;
            }
            if (canvas.matches(":popover-open")) {
              canvas.hidePopover();
            }
            canvas.showPopover();
          }
        }
        function groupAndSortNodes(nodeToData2) {
          var positionGroups = new Map;
          iterateNodes(nodeToData2, function(_ref2) {
            var _positionGroups$get;
            var { rect, color, displayName, count } = _ref2;
            if (!rect)
              return;
            var key = "".concat(rect.left, ",").concat(rect.top);
            if (!positionGroups.has(key))
              positionGroups.set(key, []);
            (_positionGroups$get = positionGroups.get(key)) === null || _positionGroups$get === undefined || _positionGroups$get.push({
              rect,
              color,
              displayName,
              count
            });
          });
          return Array.from(positionGroups.values()).sort(function(groupA, groupB) {
            var maxCountA = Math.max.apply(Math, canvas_toConsumableArray(groupA.map(function(item) {
              return item.count;
            })));
            var maxCountB = Math.max.apply(Math, canvas_toConsumableArray(groupB.map(function(item) {
              return item.count;
            })));
            return maxCountA - maxCountB;
          });
        }
        function drawGroupBorders(context, group) {
          group.forEach(function(_ref3) {
            var { color, rect } = _ref3;
            context.beginPath();
            context.strokeStyle = color;
            context.rect(rect.left, rect.top, rect.width - 1, rect.height - 1);
            context.stroke();
          });
        }
        function drawGroupLabel(context, group) {
          var mergedName = group.map(function(_ref4) {
            var { displayName, count } = _ref4;
            return displayName ? "".concat(displayName).concat(count > 1 ? " x".concat(count) : "") : "";
          }).filter(Boolean).join(", ");
          if (mergedName) {
            drawLabel(context, group[0].rect, mergedName, group[0].color);
          }
        }
        function draw(nodeToData2, agent2) {
          return isReactNativeEnvironment() ? drawNative(nodeToData2, agent2) : drawWeb(nodeToData2);
        }
        function iterateNodes(nodeToData2, execute) {
          nodeToData2.forEach(function(data, node) {
            var colorIndex = Math.min(COLORS.length - 1, data.count - 1);
            var color = COLORS[colorIndex];
            execute({
              color,
              node,
              count: data.count,
              displayName: data.displayName,
              expirationTime: data.expirationTime,
              lastMeasuredAt: data.lastMeasuredAt,
              rect: data.rect
            });
          });
        }
        function drawLabel(context, rect, text, color) {
          var { left, top } = rect;
          context.font = "10px monospace";
          context.textBaseline = "middle";
          context.textAlign = "center";
          var padding = 2;
          var textHeight = 14;
          var metrics = context.measureText(text);
          var backgroundWidth = metrics.width + padding * 2;
          var backgroundHeight = textHeight;
          var labelX = left;
          var labelY = top - backgroundHeight;
          context.fillStyle = color;
          context.fillRect(labelX, labelY, backgroundWidth, backgroundHeight);
          context.fillStyle = "#000000";
          context.fillText(text, labelX + backgroundWidth / 2, labelY + backgroundHeight / 2);
        }
        function destroyNative(agent2) {
          agent2.emit("disableTraceUpdates");
        }
        function destroyWeb() {
          if (canvas !== null) {
            if (canvas.matches(":popover-open")) {
              canvas.hidePopover();
            }
            if (canvas.parentNode != null) {
              canvas.parentNode.removeChild(canvas);
            }
            canvas = null;
          }
        }
        function destroy(agent2) {
          return isReactNativeEnvironment() ? destroyNative(agent2) : destroyWeb();
        }
        function initialize() {
          canvas = window.document.createElement("canvas");
          canvas.setAttribute("popover", "manual");
          canvas.style.cssText = `
    xx-background-color: red;
    xx-opacity: 0.5;
    bottom: 0;
    left: 0;
    pointer-events: none;
    position: fixed;
    right: 0;
    top: 0;
    background-color: transparent;
    outline: none;
    box-shadow: none;
    border: none;
  `;
          var root = window.document.documentElement;
          root.insertBefore(canvas, root.firstChild);
        }
        function TraceUpdates_typeof(o) {
          "@babel/helpers - typeof";
          return TraceUpdates_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, TraceUpdates_typeof(o);
        }
        var DISPLAY_DURATION = 250;
        var MAX_DISPLAY_DURATION = 3000;
        var REMEASUREMENT_AFTER_DURATION = 250;
        var HOC_MARKERS = new Map([["Forget", ""], ["Memo", "\uD83E\uDDE0"]]);
        var getCurrentTime = (typeof performance === "undefined" ? "undefined" : TraceUpdates_typeof(performance)) === "object" && typeof performance.now === "function" ? function() {
          return performance.now();
        } : function() {
          return Date.now();
        };
        var nodeToData = new Map;
        var agent = null;
        var drawAnimationFrameID = null;
        var isEnabled = false;
        var redrawTimeoutID = null;
        function TraceUpdates_initialize(injectedAgent) {
          agent = injectedAgent;
          agent.addListener("traceUpdates", traceUpdates);
        }
        function toggleEnabled(value) {
          isEnabled = value;
          if (!isEnabled) {
            nodeToData.clear();
            if (drawAnimationFrameID !== null) {
              cancelAnimationFrame(drawAnimationFrameID);
              drawAnimationFrameID = null;
            }
            if (redrawTimeoutID !== null) {
              clearTimeout(redrawTimeoutID);
              redrawTimeoutID = null;
            }
            destroy(agent);
          }
        }
        function traceUpdates(nodes) {
          if (!isEnabled)
            return;
          nodes.forEach(function(node) {
            var data = nodeToData.get(node);
            var now = getCurrentTime();
            var lastMeasuredAt = data != null ? data.lastMeasuredAt : 0;
            var rect = data != null ? data.rect : null;
            if (rect === null || lastMeasuredAt + REMEASUREMENT_AFTER_DURATION < now) {
              lastMeasuredAt = now;
              rect = measureNode(node);
            }
            var displayName = agent.getComponentNameForHostInstance(node);
            if (displayName) {
              var _extractHOCNames = extractHOCNames(displayName), baseComponentName = _extractHOCNames.baseComponentName, hocNames = _extractHOCNames.hocNames;
              var markers = hocNames.map(function(hoc) {
                return HOC_MARKERS.get(hoc) || "";
              }).join("");
              var enhancedDisplayName = markers ? "".concat(markers).concat(baseComponentName) : baseComponentName;
              displayName = enhancedDisplayName;
            }
            nodeToData.set(node, {
              count: data != null ? data.count + 1 : 1,
              expirationTime: data != null ? Math.min(now + MAX_DISPLAY_DURATION, data.expirationTime + DISPLAY_DURATION) : now + DISPLAY_DURATION,
              lastMeasuredAt,
              rect,
              displayName
            });
          });
          if (redrawTimeoutID !== null) {
            clearTimeout(redrawTimeoutID);
            redrawTimeoutID = null;
          }
          if (drawAnimationFrameID === null) {
            drawAnimationFrameID = requestAnimationFrame(prepareToDraw);
          }
        }
        function prepareToDraw() {
          drawAnimationFrameID = null;
          redrawTimeoutID = null;
          var now = getCurrentTime();
          var earliestExpiration = Number.MAX_VALUE;
          nodeToData.forEach(function(data, node) {
            if (data.expirationTime < now) {
              nodeToData.delete(node);
            } else {
              earliestExpiration = Math.min(earliestExpiration, data.expirationTime);
            }
          });
          draw(nodeToData, agent);
          if (earliestExpiration !== Number.MAX_VALUE) {
            redrawTimeoutID = setTimeout(prepareToDraw, earliestExpiration - now);
          }
        }
        function measureNode(node) {
          if (!node || typeof node.getBoundingClientRect !== "function") {
            return null;
          }
          var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
          return getNestedBoundingClientRect(node, currentWindow);
        }
        function bridge_typeof(o) {
          "@babel/helpers - typeof";
          return bridge_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, bridge_typeof(o);
        }
        function bridge_toConsumableArray(arr) {
          return bridge_arrayWithoutHoles(arr) || bridge_iterableToArray(arr) || bridge_unsupportedIterableToArray(arr) || bridge_nonIterableSpread();
        }
        function bridge_nonIterableSpread() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function bridge_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return bridge_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return bridge_arrayLikeToArray(o, minLen);
        }
        function bridge_iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
            return Array.from(iter);
        }
        function bridge_arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return bridge_arrayLikeToArray(arr);
        }
        function bridge_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len);i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        function bridge_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function bridge_defineProperties(target, props) {
          for (var i = 0;i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, bridge_toPropertyKey(descriptor.key), descriptor);
          }
        }
        function bridge_createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            bridge_defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            bridge_defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", { writable: false });
          return Constructor;
        }
        function _callSuper(t, o, e) {
          return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
        }
        function _possibleConstructorReturn(self2, call) {
          if (call && (bridge_typeof(call) === "object" || typeof call === "function")) {
            return call;
          } else if (call !== undefined) {
            throw new TypeError("Derived constructors may only return object or undefined");
          }
          return _assertThisInitialized(self2);
        }
        function _assertThisInitialized(self2) {
          if (self2 === undefined) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self2;
        }
        function _isNativeReflectConstruct() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
          } catch (t2) {}
          return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        function _getPrototypeOf(o) {
          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o2) {
            return o2.__proto__ || Object.getPrototypeOf(o2);
          };
          return _getPrototypeOf(o);
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
          Object.defineProperty(subClass, "prototype", { writable: false });
          if (superClass)
            _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        function bridge_defineProperty(obj, key, value) {
          key = bridge_toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function bridge_toPropertyKey(t) {
          var i = bridge_toPrimitive(t, "string");
          return bridge_typeof(i) == "symbol" ? i : i + "";
        }
        function bridge_toPrimitive(t, r) {
          if (bridge_typeof(t) != "object" || !t)
            return t;
          var e = t[Symbol.toPrimitive];
          if (e !== undefined) {
            var i = e.call(t, r || "default");
            if (bridge_typeof(i) != "object")
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (r === "string" ? String : Number)(t);
        }
        var BRIDGE_PROTOCOL = [{
          version: 0,
          minNpmVersion: '"<4.11.0"',
          maxNpmVersion: '"<4.11.0"'
        }, {
          version: 1,
          minNpmVersion: "4.13.0",
          maxNpmVersion: "4.21.0"
        }, {
          version: 2,
          minNpmVersion: "4.22.0",
          maxNpmVersion: null
        }];
        var currentBridgeProtocol = BRIDGE_PROTOCOL[BRIDGE_PROTOCOL.length - 1];
        var Bridge = /* @__PURE__ */ function(_EventEmitter) {
          function Bridge2(wall) {
            var _this;
            bridge_classCallCheck(this, Bridge2);
            _this = _callSuper(this, Bridge2);
            bridge_defineProperty(_this, "_isShutdown", false);
            bridge_defineProperty(_this, "_messageQueue", []);
            bridge_defineProperty(_this, "_scheduledFlush", false);
            bridge_defineProperty(_this, "_wallUnlisten", null);
            bridge_defineProperty(_this, "_flush", function() {
              try {
                if (_this._messageQueue.length) {
                  for (var i = 0;i < _this._messageQueue.length; i += 2) {
                    var _this$_wall;
                    (_this$_wall = _this._wall).send.apply(_this$_wall, [_this._messageQueue[i]].concat(bridge_toConsumableArray(_this._messageQueue[i + 1])));
                  }
                  _this._messageQueue.length = 0;
                }
              } finally {
                _this._scheduledFlush = false;
              }
            });
            bridge_defineProperty(_this, "overrideValueAtPath", function(_ref) {
              var { id, path, rendererID, type, value } = _ref;
              switch (type) {
                case "context":
                  _this.send("overrideContext", {
                    id,
                    path,
                    rendererID,
                    wasForwarded: true,
                    value
                  });
                  break;
                case "hooks":
                  _this.send("overrideHookState", {
                    id,
                    path,
                    rendererID,
                    wasForwarded: true,
                    value
                  });
                  break;
                case "props":
                  _this.send("overrideProps", {
                    id,
                    path,
                    rendererID,
                    wasForwarded: true,
                    value
                  });
                  break;
                case "state":
                  _this.send("overrideState", {
                    id,
                    path,
                    rendererID,
                    wasForwarded: true,
                    value
                  });
                  break;
              }
            });
            _this._wall = wall;
            _this._wallUnlisten = wall.listen(function(message) {
              if (message && message.event) {
                _this.emit(message.event, message.payload);
              }
            }) || null;
            _this.addListener("overrideValueAtPath", _this.overrideValueAtPath);
            return _this;
          }
          _inherits(Bridge2, _EventEmitter);
          return bridge_createClass(Bridge2, [{
            key: "wall",
            get: function get() {
              return this._wall;
            }
          }, {
            key: "send",
            value: function send(event) {
              if (this._isShutdown) {
                console.warn('Cannot send message "'.concat(event, '" through a Bridge that has been shutdown.'));
                return;
              }
              for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
                payload[_key - 1] = arguments[_key];
              }
              this._messageQueue.push(event, payload);
              if (!this._scheduledFlush) {
                this._scheduledFlush = true;
                if (typeof devtoolsJestTestScheduler === "function") {
                  devtoolsJestTestScheduler(this._flush);
                } else {
                  queueMicrotask(this._flush);
                }
              }
            }
          }, {
            key: "shutdown",
            value: function shutdown() {
              if (this._isShutdown) {
                console.warn("Bridge was already shutdown.");
                return;
              }
              this.emit("shutdown");
              this.send("shutdown");
              this._isShutdown = true;
              this.addListener = function() {};
              this.emit = function() {};
              this.removeAllListeners();
              var wallUnlisten = this._wallUnlisten;
              if (wallUnlisten) {
                wallUnlisten();
              }
              do {
                this._flush();
              } while (this._messageQueue.length);
            }
          }]);
        }(EventEmitter);
        const src_bridge = Bridge;
        function storage_localStorageGetItem(key) {
          try {
            return localStorage.getItem(key);
          } catch (error) {
            return null;
          }
        }
        function localStorageRemoveItem(key) {
          try {
            localStorage.removeItem(key);
          } catch (error) {}
        }
        function storage_localStorageSetItem(key, value) {
          try {
            return localStorage.setItem(key, value);
          } catch (error) {}
        }
        function storage_sessionStorageGetItem(key) {
          try {
            return sessionStorage.getItem(key);
          } catch (error) {
            return null;
          }
        }
        function storage_sessionStorageRemoveItem(key) {
          try {
            sessionStorage.removeItem(key);
          } catch (error) {}
        }
        function storage_sessionStorageSetItem(key, value) {
          try {
            return sessionStorage.setItem(key, value);
          } catch (error) {}
        }
        function agent_typeof(o) {
          "@babel/helpers - typeof";
          return agent_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, agent_typeof(o);
        }
        function agent_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function agent_defineProperties(target, props) {
          for (var i = 0;i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, agent_toPropertyKey(descriptor.key), descriptor);
          }
        }
        function agent_createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            agent_defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            agent_defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", { writable: false });
          return Constructor;
        }
        function agent_callSuper(t, o, e) {
          return o = agent_getPrototypeOf(o), agent_possibleConstructorReturn(t, agent_isNativeReflectConstruct() ? Reflect.construct(o, e || [], agent_getPrototypeOf(t).constructor) : o.apply(t, e));
        }
        function agent_possibleConstructorReturn(self2, call) {
          if (call && (agent_typeof(call) === "object" || typeof call === "function")) {
            return call;
          } else if (call !== undefined) {
            throw new TypeError("Derived constructors may only return object or undefined");
          }
          return agent_assertThisInitialized(self2);
        }
        function agent_assertThisInitialized(self2) {
          if (self2 === undefined) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self2;
        }
        function agent_isNativeReflectConstruct() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
          } catch (t2) {}
          return (agent_isNativeReflectConstruct = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        function agent_getPrototypeOf(o) {
          agent_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o2) {
            return o2.__proto__ || Object.getPrototypeOf(o2);
          };
          return agent_getPrototypeOf(o);
        }
        function agent_inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
          Object.defineProperty(subClass, "prototype", { writable: false });
          if (superClass)
            agent_setPrototypeOf(subClass, superClass);
        }
        function agent_setPrototypeOf(o, p) {
          agent_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return agent_setPrototypeOf(o, p);
        }
        function agent_defineProperty(obj, key, value) {
          key = agent_toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function agent_toPropertyKey(t) {
          var i = agent_toPrimitive(t, "string");
          return agent_typeof(i) == "symbol" ? i : i + "";
        }
        function agent_toPrimitive(t, r) {
          if (agent_typeof(t) != "object" || !t)
            return t;
          var e = t[Symbol.toPrimitive];
          if (e !== undefined) {
            var i = e.call(t, r || "default");
            if (agent_typeof(i) != "object")
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (r === "string" ? String : Number)(t);
        }
        var debug = function debug(methodName) {
          if (__DEBUG__) {
            var _console;
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            (_console = console).log.apply(_console, ["%cAgent %c".concat(methodName), "color: purple; font-weight: bold;", "font-weight: bold;"].concat(args));
          }
        };
        function createEmptyInspectedScreen(arbitraryRootID, type) {
          var suspendedBy = {
            cleaned: [],
            data: [],
            unserializable: []
          };
          return {
            id: arbitraryRootID,
            type,
            isErrored: false,
            errors: [],
            warnings: [],
            suspendedBy,
            suspendedByRange: null,
            unknownSuspenders: UNKNOWN_SUSPENDERS_NONE,
            rootType: null,
            plugins: {
              stylex: null
            },
            nativeTag: null,
            env: null,
            source: null,
            stack: null,
            rendererPackageName: null,
            rendererVersion: null,
            key: null,
            canEditFunctionProps: false,
            canEditHooks: false,
            canEditFunctionPropsDeletePaths: false,
            canEditFunctionPropsRenamePaths: false,
            canEditHooksAndDeletePaths: false,
            canEditHooksAndRenamePaths: false,
            canToggleError: false,
            canToggleSuspense: false,
            isSuspended: false,
            hasLegacyContext: false,
            context: null,
            hooks: null,
            props: null,
            state: null,
            owners: null
          };
        }
        function mergeRoots(left, right, suspendedByOffset) {
          var leftSuspendedByRange = left.suspendedByRange;
          var rightSuspendedByRange = right.suspendedByRange;
          if (right.isErrored) {
            left.isErrored = true;
          }
          for (var i = 0;i < right.errors.length; i++) {
            left.errors.push(right.errors[i]);
          }
          for (var _i = 0;_i < right.warnings.length; _i++) {
            left.warnings.push(right.warnings[_i]);
          }
          var leftSuspendedBy = left.suspendedBy;
          var _ref = right.suspendedBy, data = _ref.data, cleaned = _ref.cleaned, unserializable = _ref.unserializable;
          var leftSuspendedByData = leftSuspendedBy.data;
          var rightSuspendedByData = data;
          for (var _i2 = 0;_i2 < rightSuspendedByData.length; _i2++) {
            leftSuspendedByData.push(rightSuspendedByData[_i2]);
          }
          for (var _i3 = 0;_i3 < cleaned.length; _i3++) {
            leftSuspendedBy.cleaned.push([suspendedByOffset + cleaned[_i3][0]].concat(cleaned[_i3].slice(1)));
          }
          for (var _i4 = 0;_i4 < unserializable.length; _i4++) {
            leftSuspendedBy.unserializable.push([suspendedByOffset + unserializable[_i4][0]].concat(unserializable[_i4].slice(1)));
          }
          if (rightSuspendedByRange !== null) {
            if (leftSuspendedByRange === null) {
              left.suspendedByRange = [rightSuspendedByRange[0], rightSuspendedByRange[1]];
            } else {
              if (rightSuspendedByRange[0] < leftSuspendedByRange[0]) {
                leftSuspendedByRange[0] = rightSuspendedByRange[0];
              }
              if (rightSuspendedByRange[1] > leftSuspendedByRange[1]) {
                leftSuspendedByRange[1] = rightSuspendedByRange[1];
              }
            }
          }
        }
        var Agent = /* @__PURE__ */ function(_EventEmitter) {
          function Agent2(bridge) {
            var _this;
            var isProfiling = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var onReloadAndProfile2 = arguments.length > 2 ? arguments[2] : undefined;
            agent_classCallCheck(this, Agent2);
            _this = agent_callSuper(this, Agent2);
            agent_defineProperty(_this, "_isProfiling", false);
            agent_defineProperty(_this, "_rendererInterfaces", {});
            agent_defineProperty(_this, "_persistedSelection", null);
            agent_defineProperty(_this, "_persistedSelectionMatch", null);
            agent_defineProperty(_this, "_traceUpdatesEnabled", false);
            agent_defineProperty(_this, "clearErrorsAndWarnings", function(_ref2) {
              var rendererID = _ref2.rendererID;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '"'));
              } else {
                renderer.clearErrorsAndWarnings();
              }
            });
            agent_defineProperty(_this, "clearErrorsForElementID", function(_ref3) {
              var { id, rendererID } = _ref3;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '"'));
              } else {
                renderer.clearErrorsForElementID(id);
              }
            });
            agent_defineProperty(_this, "clearWarningsForElementID", function(_ref4) {
              var { id, rendererID } = _ref4;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '"'));
              } else {
                renderer.clearWarningsForElementID(id);
              }
            });
            agent_defineProperty(_this, "copyElementPath", function(_ref5) {
              var { id, path, rendererID } = _ref5;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                var value = renderer.getSerializedElementValueByPath(id, path);
                if (value != null) {
                  _this._bridge.send("saveToClipboard", value);
                } else {
                  console.warn('Unable to obtain serialized value for element "'.concat(id, '"'));
                }
              }
            });
            agent_defineProperty(_this, "deletePath", function(_ref6) {
              var { hookID, id, path, rendererID, type } = _ref6;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.deletePath(type, id, hookID, path);
              }
            });
            agent_defineProperty(_this, "getBackendVersion", function() {
              var version = "7.0.1-3cde211b0c";
              if (version) {
                _this._bridge.send("backendVersion", version);
              }
            });
            agent_defineProperty(_this, "getBridgeProtocol", function() {
              _this._bridge.send("bridgeProtocol", currentBridgeProtocol);
            });
            agent_defineProperty(_this, "getProfilingData", function(_ref7) {
              var rendererID = _ref7.rendererID;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '"'));
              }
              _this._bridge.send("profilingData", renderer.getProfilingData());
            });
            agent_defineProperty(_this, "getProfilingStatus", function() {
              _this._bridge.send("profilingStatus", _this._isProfiling);
            });
            agent_defineProperty(_this, "getOwnersList", function(_ref8) {
              var { id, rendererID } = _ref8;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                var owners = renderer.getOwnersList(id);
                _this._bridge.send("ownersList", {
                  id,
                  owners
                });
              }
            });
            agent_defineProperty(_this, "inspectElement", function(_ref9) {
              var { forceFullData, id, path, rendererID, requestID } = _ref9;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                _this._bridge.send("inspectedElement", renderer.inspectElement(requestID, id, path, forceFullData));
                if (_this._persistedSelectionMatch === null || _this._persistedSelectionMatch.id !== id) {
                  _this._persistedSelection = null;
                  _this._persistedSelectionMatch = null;
                  renderer.setTrackedPath(null);
                  _this._lastSelectedElementID = id;
                  _this._lastSelectedRendererID = rendererID;
                  if (!_this._persistSelectionTimerScheduled) {
                    _this._persistSelectionTimerScheduled = true;
                    setTimeout(_this._persistSelection, 1000);
                  }
                }
              }
            });
            agent_defineProperty(_this, "inspectScreen", function(_ref10) {
              var { requestID, id, forceFullData, path: screenPath } = _ref10;
              var inspectedScreen = null;
              var found = false;
              var suspendedByOffset = 0;
              var suspendedByPathIndex = null;
              var rendererPath = null;
              if (screenPath !== null && screenPath.length > 1) {
                var secondaryCategory = screenPath[0];
                if (secondaryCategory !== "suspendedBy") {
                  throw new Error("Only hydrating suspendedBy paths is supported. This is a bug.");
                }
                if (typeof screenPath[1] !== "number") {
                  throw new Error("Expected suspendedBy index to be a number. Received '".concat(screenPath[1], "' instead. This is a bug."));
                }
                suspendedByPathIndex = screenPath[1];
                rendererPath = screenPath.slice(2);
              }
              for (var rendererID in _this._rendererInterfaces) {
                var renderer = _this._rendererInterfaces[rendererID];
                var path = null;
                if (suspendedByPathIndex !== null && rendererPath !== null) {
                  var suspendedByPathRendererIndex = suspendedByPathIndex - suspendedByOffset;
                  var rendererHasRequestedSuspendedByPath = renderer.getElementAttributeByPath(id, ["suspendedBy", suspendedByPathRendererIndex]) !== undefined;
                  if (rendererHasRequestedSuspendedByPath) {
                    path = ["suspendedBy", suspendedByPathRendererIndex].concat(rendererPath);
                  }
                }
                var inspectedRootsPayload = renderer.inspectElement(requestID, id, path, forceFullData);
                switch (inspectedRootsPayload.type) {
                  case "hydrated-path":
                    inspectedRootsPayload.path[1] += suspendedByOffset;
                    if (inspectedRootsPayload.value !== null) {
                      for (var i = 0;i < inspectedRootsPayload.value.cleaned.length; i++) {
                        inspectedRootsPayload.value.cleaned[i][1] += suspendedByOffset;
                      }
                    }
                    _this._bridge.send("inspectedScreen", inspectedRootsPayload);
                    return;
                  case "full-data":
                    var inspectedRoots = inspectedRootsPayload.value;
                    if (inspectedScreen === null) {
                      inspectedScreen = createEmptyInspectedScreen(inspectedRoots.id, inspectedRoots.type);
                    }
                    mergeRoots(inspectedScreen, inspectedRoots, suspendedByOffset);
                    var dehydratedSuspendedBy = inspectedRoots.suspendedBy;
                    var suspendedBy = dehydratedSuspendedBy.data;
                    suspendedByOffset += suspendedBy.length;
                    found = true;
                    break;
                  case "no-change":
                    found = true;
                    var rootsSuspendedBy = renderer.getElementAttributeByPath(id, ["suspendedBy"]);
                    suspendedByOffset += rootsSuspendedBy.length;
                    break;
                  case "not-found":
                    break;
                  case "error":
                    _this._bridge.send("inspectedScreen", inspectedRootsPayload);
                    return;
                }
              }
              if (inspectedScreen === null) {
                if (found) {
                  _this._bridge.send("inspectedScreen", {
                    type: "no-change",
                    responseID: requestID,
                    id
                  });
                } else {
                  _this._bridge.send("inspectedScreen", {
                    type: "not-found",
                    responseID: requestID,
                    id
                  });
                }
              } else {
                _this._bridge.send("inspectedScreen", {
                  type: "full-data",
                  responseID: requestID,
                  id,
                  value: inspectedScreen
                });
              }
            });
            agent_defineProperty(_this, "logElementToConsole", function(_ref11) {
              var { id, rendererID } = _ref11;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.logElementToConsole(id);
              }
            });
            agent_defineProperty(_this, "overrideError", function(_ref12) {
              var { id, rendererID, forceError } = _ref12;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.overrideError(id, forceError);
              }
            });
            agent_defineProperty(_this, "overrideSuspense", function(_ref13) {
              var { id, rendererID, forceFallback } = _ref13;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.overrideSuspense(id, forceFallback);
              }
            });
            agent_defineProperty(_this, "overrideSuspenseMilestone", function(_ref14) {
              var suspendedSet = _ref14.suspendedSet;
              for (var rendererID in _this._rendererInterfaces) {
                var renderer = _this._rendererInterfaces[rendererID];
                if (renderer.supportsTogglingSuspense) {
                  renderer.overrideSuspenseMilestone(suspendedSet);
                }
              }
            });
            agent_defineProperty(_this, "overrideValueAtPath", function(_ref15) {
              var { hookID, id, path, rendererID, type, value } = _ref15;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.overrideValueAtPath(type, id, hookID, path, value);
              }
            });
            agent_defineProperty(_this, "overrideContext", function(_ref16) {
              var { id, path, rendererID, wasForwarded, value } = _ref16;
              if (!wasForwarded) {
                _this.overrideValueAtPath({
                  id,
                  path,
                  rendererID,
                  type: "context",
                  value
                });
              }
            });
            agent_defineProperty(_this, "overrideHookState", function(_ref17) {
              var { id, hookID, path, rendererID, wasForwarded, value } = _ref17;
              if (!wasForwarded) {
                _this.overrideValueAtPath({
                  id,
                  path,
                  rendererID,
                  type: "hooks",
                  value
                });
              }
            });
            agent_defineProperty(_this, "overrideProps", function(_ref18) {
              var { id, path, rendererID, wasForwarded, value } = _ref18;
              if (!wasForwarded) {
                _this.overrideValueAtPath({
                  id,
                  path,
                  rendererID,
                  type: "props",
                  value
                });
              }
            });
            agent_defineProperty(_this, "overrideState", function(_ref19) {
              var { id, path, rendererID, wasForwarded, value } = _ref19;
              if (!wasForwarded) {
                _this.overrideValueAtPath({
                  id,
                  path,
                  rendererID,
                  type: "state",
                  value
                });
              }
            });
            agent_defineProperty(_this, "onReloadAndProfileSupportedByHost", function() {
              _this._bridge.send("isReloadAndProfileSupportedByBackend", true);
            });
            agent_defineProperty(_this, "reloadAndProfile", function(_ref20) {
              var { recordChangeDescriptions, recordTimeline } = _ref20;
              if (typeof _this._onReloadAndProfile === "function") {
                _this._onReloadAndProfile(recordChangeDescriptions, recordTimeline);
              }
              _this._bridge.send("reloadAppForProfiling");
            });
            agent_defineProperty(_this, "renamePath", function(_ref21) {
              var { hookID, id, newPath, oldPath, rendererID, type } = _ref21;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.renamePath(type, id, hookID, oldPath, newPath);
              }
            });
            agent_defineProperty(_this, "setTraceUpdatesEnabled", function(traceUpdatesEnabled) {
              _this._traceUpdatesEnabled = traceUpdatesEnabled;
              toggleEnabled(traceUpdatesEnabled);
              for (var rendererID in _this._rendererInterfaces) {
                var renderer = _this._rendererInterfaces[rendererID];
                renderer.setTraceUpdatesEnabled(traceUpdatesEnabled);
              }
            });
            agent_defineProperty(_this, "syncSelectionFromBuiltinElementsPanel", function() {
              var target = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;
              if (target == null) {
                return;
              }
              _this.selectNode(target);
            });
            agent_defineProperty(_this, "shutdown", function() {
              _this.emit("shutdown");
              _this._bridge.removeAllListeners();
              _this.removeAllListeners();
            });
            agent_defineProperty(_this, "startProfiling", function(_ref22) {
              var { recordChangeDescriptions, recordTimeline } = _ref22;
              _this._isProfiling = true;
              for (var rendererID in _this._rendererInterfaces) {
                var renderer = _this._rendererInterfaces[rendererID];
                renderer.startProfiling(recordChangeDescriptions, recordTimeline);
              }
              _this._bridge.send("profilingStatus", _this._isProfiling);
            });
            agent_defineProperty(_this, "stopProfiling", function() {
              _this._isProfiling = false;
              for (var rendererID in _this._rendererInterfaces) {
                var renderer = _this._rendererInterfaces[rendererID];
                renderer.stopProfiling();
              }
              _this._bridge.send("profilingStatus", _this._isProfiling);
            });
            agent_defineProperty(_this, "stopInspectingNative", function(selected) {
              _this._bridge.send("stopInspectingHost", selected);
            });
            agent_defineProperty(_this, "storeAsGlobal", function(_ref23) {
              var { count, id, path, rendererID } = _ref23;
              var renderer = _this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '" for element "').concat(id, '"'));
              } else {
                renderer.storeAsGlobal(id, path, count);
              }
            });
            agent_defineProperty(_this, "updateHookSettings", function(settings) {
              _this.emit("updateHookSettings", settings);
            });
            agent_defineProperty(_this, "getHookSettings", function() {
              _this.emit("getHookSettings");
            });
            agent_defineProperty(_this, "onHookSettings", function(settings) {
              _this._bridge.send("hookSettings", settings);
            });
            agent_defineProperty(_this, "updateComponentFilters", function(componentFilters) {
              for (var rendererIDString in _this._rendererInterfaces) {
                var rendererID = +rendererIDString;
                var renderer = _this._rendererInterfaces[rendererID];
                if (_this._lastSelectedRendererID === rendererID) {
                  var path = renderer.getPathForElement(_this._lastSelectedElementID);
                  if (path !== null) {
                    renderer.setTrackedPath(path);
                    _this._persistedSelection = {
                      rendererID,
                      path
                    };
                  }
                }
                renderer.updateComponentFilters(componentFilters);
              }
            });
            agent_defineProperty(_this, "getEnvironmentNames", function() {
              var accumulatedNames = null;
              for (var rendererID in _this._rendererInterfaces) {
                var renderer = _this._rendererInterfaces[+rendererID];
                var names = renderer.getEnvironmentNames();
                if (accumulatedNames === null) {
                  accumulatedNames = names;
                } else {
                  for (var i = 0;i < names.length; i++) {
                    if (accumulatedNames.indexOf(names[i]) === -1) {
                      accumulatedNames.push(names[i]);
                    }
                  }
                }
              }
              _this._bridge.send("environmentNames", accumulatedNames || []);
            });
            agent_defineProperty(_this, "onTraceUpdates", function(nodes) {
              _this.emit("traceUpdates", nodes);
            });
            agent_defineProperty(_this, "onFastRefreshScheduled", function() {
              if (__DEBUG__) {
                debug("onFastRefreshScheduled");
              }
              _this._bridge.send("fastRefreshScheduled");
            });
            agent_defineProperty(_this, "onHookOperations", function(operations) {
              if (__DEBUG__) {
                debug("onHookOperations", "(".concat(operations.length, ") [").concat(operations.join(", "), "]"));
              }
              _this._bridge.send("operations", operations);
              if (_this._persistedSelection !== null) {
                var rendererID = operations[0];
                if (_this._persistedSelection.rendererID === rendererID) {
                  var renderer = _this._rendererInterfaces[rendererID];
                  if (renderer == null) {
                    console.warn('Invalid renderer id "'.concat(rendererID, '"'));
                  } else {
                    var prevMatch = _this._persistedSelectionMatch;
                    var nextMatch = renderer.getBestMatchForTrackedPath();
                    _this._persistedSelectionMatch = nextMatch;
                    var prevMatchID = prevMatch !== null ? prevMatch.id : null;
                    var nextMatchID = nextMatch !== null ? nextMatch.id : null;
                    if (prevMatchID !== nextMatchID) {
                      if (nextMatchID !== null) {
                        _this._bridge.send("selectElement", nextMatchID);
                      }
                    }
                    if (nextMatch !== null && nextMatch.isFullMatch) {
                      _this._persistedSelection = null;
                      _this._persistedSelectionMatch = null;
                      renderer.setTrackedPath(null);
                    }
                  }
                }
              }
            });
            agent_defineProperty(_this, "getIfHasUnsupportedRendererVersion", function() {
              _this.emit("getIfHasUnsupportedRendererVersion");
            });
            agent_defineProperty(_this, "_persistSelectionTimerScheduled", false);
            agent_defineProperty(_this, "_lastSelectedRendererID", -1);
            agent_defineProperty(_this, "_lastSelectedElementID", -1);
            agent_defineProperty(_this, "_persistSelection", function() {
              _this._persistSelectionTimerScheduled = false;
              var rendererID = _this._lastSelectedRendererID;
              var id = _this._lastSelectedElementID;
              var renderer = _this._rendererInterfaces[rendererID];
              var path = renderer != null ? renderer.getPathForElement(id) : null;
              if (path !== null) {
                storage_sessionStorageSetItem(SESSION_STORAGE_LAST_SELECTION_KEY, JSON.stringify({
                  rendererID,
                  path
                }));
              } else {
                storage_sessionStorageRemoveItem(SESSION_STORAGE_LAST_SELECTION_KEY);
              }
            });
            _this._isProfiling = isProfiling;
            _this._onReloadAndProfile = onReloadAndProfile2;
            var persistedSelectionString = storage_sessionStorageGetItem(SESSION_STORAGE_LAST_SELECTION_KEY);
            if (persistedSelectionString != null) {
              _this._persistedSelection = JSON.parse(persistedSelectionString);
            }
            _this._bridge = bridge;
            bridge.addListener("clearErrorsAndWarnings", _this.clearErrorsAndWarnings);
            bridge.addListener("clearErrorsForElementID", _this.clearErrorsForElementID);
            bridge.addListener("clearWarningsForElementID", _this.clearWarningsForElementID);
            bridge.addListener("copyElementPath", _this.copyElementPath);
            bridge.addListener("deletePath", _this.deletePath);
            bridge.addListener("getBackendVersion", _this.getBackendVersion);
            bridge.addListener("getBridgeProtocol", _this.getBridgeProtocol);
            bridge.addListener("getProfilingData", _this.getProfilingData);
            bridge.addListener("getProfilingStatus", _this.getProfilingStatus);
            bridge.addListener("getOwnersList", _this.getOwnersList);
            bridge.addListener("inspectElement", _this.inspectElement);
            bridge.addListener("inspectScreen", _this.inspectScreen);
            bridge.addListener("logElementToConsole", _this.logElementToConsole);
            bridge.addListener("overrideError", _this.overrideError);
            bridge.addListener("overrideSuspense", _this.overrideSuspense);
            bridge.addListener("overrideSuspenseMilestone", _this.overrideSuspenseMilestone);
            bridge.addListener("overrideValueAtPath", _this.overrideValueAtPath);
            bridge.addListener("reloadAndProfile", _this.reloadAndProfile);
            bridge.addListener("renamePath", _this.renamePath);
            bridge.addListener("setTraceUpdatesEnabled", _this.setTraceUpdatesEnabled);
            bridge.addListener("startProfiling", _this.startProfiling);
            bridge.addListener("stopProfiling", _this.stopProfiling);
            bridge.addListener("storeAsGlobal", _this.storeAsGlobal);
            bridge.addListener("syncSelectionFromBuiltinElementsPanel", _this.syncSelectionFromBuiltinElementsPanel);
            bridge.addListener("shutdown", _this.shutdown);
            bridge.addListener("updateHookSettings", _this.updateHookSettings);
            bridge.addListener("getHookSettings", _this.getHookSettings);
            bridge.addListener("updateComponentFilters", _this.updateComponentFilters);
            bridge.addListener("getEnvironmentNames", _this.getEnvironmentNames);
            bridge.addListener("getIfHasUnsupportedRendererVersion", _this.getIfHasUnsupportedRendererVersion);
            bridge.addListener("overrideContext", _this.overrideContext);
            bridge.addListener("overrideHookState", _this.overrideHookState);
            bridge.addListener("overrideProps", _this.overrideProps);
            bridge.addListener("overrideState", _this.overrideState);
            setupHighlighter(bridge, _this);
            TraceUpdates_initialize(_this);
            bridge.send("backendInitialized");
            if (_this._isProfiling) {
              bridge.send("profilingStatus", true);
            }
            return _this;
          }
          agent_inherits(Agent2, _EventEmitter);
          return agent_createClass(Agent2, [{
            key: "rendererInterfaces",
            get: function get() {
              return this._rendererInterfaces;
            }
          }, {
            key: "getInstanceAndStyle",
            value: function getInstanceAndStyle(_ref24) {
              var { id, rendererID } = _ref24;
              var renderer = this._rendererInterfaces[rendererID];
              if (renderer == null) {
                console.warn('Invalid renderer id "'.concat(rendererID, '"'));
                return null;
              }
              return renderer.getInstanceAndStyle(id);
            }
          }, {
            key: "getIDForHostInstance",
            value: function getIDForHostInstance(target, onlySuspenseNodes) {
              if (isReactNativeEnvironment() || typeof target.nodeType !== "number") {
                for (var rendererID in this._rendererInterfaces) {
                  var renderer = this._rendererInterfaces[rendererID];
                  try {
                    var id = onlySuspenseNodes ? renderer.getSuspenseNodeIDForHostInstance(target) : renderer.getElementIDForHostInstance(target);
                    if (id !== null) {
                      return {
                        id,
                        rendererID: +rendererID
                      };
                    }
                  } catch (error) {}
                }
                return null;
              } else {
                var bestMatch = null;
                var bestRenderer = null;
                var bestRendererID = 0;
                for (var _rendererID in this._rendererInterfaces) {
                  var _renderer = this._rendererInterfaces[_rendererID];
                  var nearestNode = _renderer.getNearestMountedDOMNode(target);
                  if (nearestNode !== null) {
                    if (nearestNode === target) {
                      bestMatch = nearestNode;
                      bestRenderer = _renderer;
                      bestRendererID = +_rendererID;
                      break;
                    }
                    if (bestMatch === null || bestMatch.contains(nearestNode)) {
                      bestMatch = nearestNode;
                      bestRenderer = _renderer;
                      bestRendererID = +_rendererID;
                    }
                  }
                }
                if (bestRenderer != null && bestMatch != null) {
                  try {
                    var _id = onlySuspenseNodes ? bestRenderer.getSuspenseNodeIDForHostInstance(bestMatch) : bestRenderer.getElementIDForHostInstance(bestMatch);
                    if (_id !== null) {
                      return {
                        id: _id,
                        rendererID: bestRendererID
                      };
                    }
                  } catch (error) {}
                }
                return null;
              }
            }
          }, {
            key: "getComponentNameForHostInstance",
            value: function getComponentNameForHostInstance(target) {
              var match = this.getIDForHostInstance(target);
              if (match !== null) {
                var renderer = this._rendererInterfaces[match.rendererID];
                return renderer.getDisplayNameForElementID(match.id);
              }
              return null;
            }
          }, {
            key: "selectNode",
            value: function selectNode(target) {
              var match = this.getIDForHostInstance(target);
              if (match !== null) {
                this._bridge.send("selectElement", match.id);
              }
            }
          }, {
            key: "registerRendererInterface",
            value: function registerRendererInterface(rendererID, rendererInterface) {
              this._rendererInterfaces[rendererID] = rendererInterface;
              rendererInterface.setTraceUpdatesEnabled(this._traceUpdatesEnabled);
              var renderer = rendererInterface.renderer;
              if (renderer !== null) {
                var devRenderer = renderer.bundleType === 1;
                var enableSuspenseTab = devRenderer && gte(renderer.version, "19.3.0-canary");
                if (enableSuspenseTab) {
                  this._bridge.send("enableSuspenseTab");
                }
              }
              var selection = this._persistedSelection;
              if (selection !== null && selection.rendererID === rendererID) {
                rendererInterface.setTrackedPath(selection.path);
              }
            }
          }, {
            key: "onUnsupportedRenderer",
            value: function onUnsupportedRenderer() {
              this._bridge.send("unsupportedRendererVersion");
            }
          }]);
        }(EventEmitter);
        function DevToolsConsolePatching_typeof(o) {
          "@babel/helpers - typeof";
          return DevToolsConsolePatching_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, DevToolsConsolePatching_typeof(o);
        }
        function DevToolsConsolePatching_ownKeys(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function(r2) {
              return Object.getOwnPropertyDescriptor(e, r2).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function DevToolsConsolePatching_objectSpread(e) {
          for (var r = 1;r < arguments.length; r++) {
            var t = arguments[r] != null ? arguments[r] : {};
            r % 2 ? DevToolsConsolePatching_ownKeys(Object(t), true).forEach(function(r2) {
              DevToolsConsolePatching_defineProperty(e, r2, t[r2]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : DevToolsConsolePatching_ownKeys(Object(t)).forEach(function(r2) {
              Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
            });
          }
          return e;
        }
        function DevToolsConsolePatching_defineProperty(obj, key, value) {
          key = DevToolsConsolePatching_toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function DevToolsConsolePatching_toPropertyKey(t) {
          var i = DevToolsConsolePatching_toPrimitive(t, "string");
          return DevToolsConsolePatching_typeof(i) == "symbol" ? i : i + "";
        }
        function DevToolsConsolePatching_toPrimitive(t, r) {
          if (DevToolsConsolePatching_typeof(t) != "object" || !t)
            return t;
          var e = t[Symbol.toPrimitive];
          if (e !== undefined) {
            var i = e.call(t, r || "default");
            if (DevToolsConsolePatching_typeof(i) != "object")
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (r === "string" ? String : Number)(t);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {}
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevLog
              }),
              info: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevInfo
              }),
              warn: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevWarn
              }),
              error: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevError
              }),
              group: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevGroup
              }),
              groupCollapsed: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevGroupCollapsed
              }),
              groupEnd: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            console.error("disabledDepth fell below zero. " + "This is a bug in React. Please file an issue.");
          }
        }
        function DevToolsComponentStackFrame_slicedToArray(arr, i) {
          return DevToolsComponentStackFrame_arrayWithHoles(arr) || DevToolsComponentStackFrame_iterableToArrayLimit(arr, i) || DevToolsComponentStackFrame_unsupportedIterableToArray(arr, i) || DevToolsComponentStackFrame_nonIterableRest();
        }
        function DevToolsComponentStackFrame_nonIterableRest() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function DevToolsComponentStackFrame_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return DevToolsComponentStackFrame_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return DevToolsComponentStackFrame_arrayLikeToArray(o, minLen);
        }
        function DevToolsComponentStackFrame_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len);i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        function DevToolsComponentStackFrame_iterableToArrayLimit(r, l) {
          var t = r == null ? null : typeof Symbol != "undefined" && r[Symbol.iterator] || r["@@iterator"];
          if (t != null) {
            var e, n, i, u, a = [], f = true, o = false;
            try {
              if (i = (t = t.call(r)).next, l === 0) {
                if (Object(t) !== t)
                  return;
                f = false;
              } else
                for (;!(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
                  ;
            } catch (r2) {
              o = true, n = r2;
            } finally {
              try {
                if (!f && t.return != null && (u = t.return(), Object(u) !== u))
                  return;
              } finally {
                if (o)
                  throw n;
              }
            }
            return a;
          }
        }
        function DevToolsComponentStackFrame_arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        function DevToolsComponentStackFrame_typeof(o) {
          "@babel/helpers - typeof";
          return DevToolsComponentStackFrame_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, DevToolsComponentStackFrame_typeof(o);
        }
        var prefix;
        function describeBuiltInComponentFrame(name) {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          var suffix = "";
          if (true) {
            suffix = " (<anonymous>)";
          } else {}
          return `
` + prefix + name + suffix;
        }
        function describeDebugInfoFrame(name, env2) {
          return describeBuiltInComponentFrame(name + (env2 ? " [" + env2 + "]" : ""));
        }
        var reentry = false;
        var componentFrameCache;
        if (false) {
          var PossiblyWeakMap;
        }
        function describeNativeComponentFrame(fn, construct, currentDispatcherRef) {
          if (!fn || reentry) {
            return "";
          }
          if (false) {
            var frame;
          }
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = undefined;
          reentry = true;
          var previousDispatcher = currentDispatcherRef.H;
          currentDispatcherRef.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function DetermineComponentFrameRoot() {
                var control;
                try {
                  if (construct) {
                    var Fake = function Fake() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function set() {
                        throw Error();
                      }
                    });
                    if ((typeof Reflect === "undefined" ? "undefined" : DevToolsComponentStackFrame_typeof(Reflect)) === "object" && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x) {
                        control = x;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x) {
                        control = x;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x) {
                      control = x;
                    }
                    var maybePromise = fn();
                    if (maybePromise && typeof maybePromise.catch === "function") {
                      maybePromise.catch(function() {});
                    }
                  }
                } catch (sample) {
                  if (sample && control && typeof sample.stack === "string") {
                    return [sample.stack, control.stack];
                  }
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
            if (namePropDescriptor && namePropDescriptor.configurable) {
              Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
              });
            }
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), _RunInRootFrame$Deter2 = DevToolsComponentStackFrame_slicedToArray(_RunInRootFrame$Deter, 2), sampleStack = _RunInRootFrame$Deter2[0], controlStack = _RunInRootFrame$Deter2[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split(`
`);
              var controlLines = controlStack.split(`
`);
              var s = 0;
              var c = 0;
              while (s < sampleLines.length && !sampleLines[s].includes("DetermineComponentFrameRoot")) {
                s++;
              }
              while (c < controlLines.length && !controlLines[c].includes("DetermineComponentFrameRoot")) {
                c++;
              }
              if (s === sampleLines.length || c === controlLines.length) {
                s = sampleLines.length - 1;
                c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
              }
              for (;s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        if (false) {}
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            Error.prepareStackTrace = previousPrepareStackTrace;
            currentDispatcherRef.H = previousDispatcher;
            reenableLogs();
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          if (false) {}
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, currentDispatcherRef) {
          return describeNativeComponentFrame(ctor, true, currentDispatcherRef);
        }
        function describeFunctionComponentFrame(fn, currentDispatcherRef) {
          return describeNativeComponentFrame(fn, false, currentDispatcherRef);
        }
        function formatOwnerStack(error) {
          var prevPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = undefined;
          var stack = error.stack;
          Error.prepareStackTrace = prevPrepareStackTrace;
          if (stack.startsWith(`Error: react-stack-top-frame
`)) {
            stack = stack.slice(29);
          }
          var idx = stack.indexOf(`
`);
          if (idx !== -1) {
            stack = stack.slice(idx + 1);
          }
          idx = stack.indexOf("react_stack_bottom_frame");
          if (idx === -1) {
            idx = stack.indexOf("react-stack-bottom-frame");
          }
          if (idx !== -1) {
            idx = stack.lastIndexOf(`
`, idx);
          }
          if (idx !== -1) {
            stack = stack.slice(0, idx);
          } else {
            return "";
          }
          return stack;
        }
        function getOwnerStackByComponentInfoInDev(componentInfo) {
          try {
            var info = "";
            if (!componentInfo.owner && typeof componentInfo.name === "string") {
              return describeBuiltInComponentFrame(componentInfo.name);
            }
            var owner = componentInfo;
            while (owner) {
              var ownerStack = owner.debugStack;
              if (ownerStack != null) {
                owner = owner.owner;
                if (owner) {
                  info += `
` + formatOwnerStack(ownerStack);
                }
              } else {
                break;
              }
            }
            return info;
          } catch (x) {
            return `
Error generating stack: ` + x.message + `
` + x.stack;
          }
        }
        var componentInfoToComponentLogsMap = new WeakMap;
        function renderer_toConsumableArray(arr) {
          return renderer_arrayWithoutHoles(arr) || renderer_iterableToArray(arr) || renderer_unsupportedIterableToArray(arr) || renderer_nonIterableSpread();
        }
        function renderer_nonIterableSpread() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function renderer_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return renderer_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return renderer_arrayLikeToArray(o, minLen);
        }
        function renderer_iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
            return Array.from(iter);
        }
        function renderer_arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return renderer_arrayLikeToArray(arr);
        }
        function renderer_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len);i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        function supportsConsoleTasks(componentInfo) {
          return !!componentInfo.debugTask;
        }
        function attach(hook, rendererID, renderer, global2) {
          var getCurrentComponentInfo = renderer.getCurrentComponentInfo;
          function getComponentStack(topFrame) {
            if (getCurrentComponentInfo === undefined) {
              return null;
            }
            var current = getCurrentComponentInfo();
            if (current === null) {
              return null;
            }
            if (supportsConsoleTasks(current)) {
              return null;
            }
            var enableOwnerStacks = current.debugStack != null;
            var componentStack = "";
            if (enableOwnerStacks) {
              var topStackFrames = formatOwnerStack(topFrame);
              if (topStackFrames) {
                componentStack += `
` + topStackFrames;
              }
              componentStack += getOwnerStackByComponentInfoInDev(current);
            }
            return {
              enableOwnerStacks,
              componentStack
            };
          }
          function onErrorOrWarning(type, args) {
            if (getCurrentComponentInfo === undefined) {
              return;
            }
            var componentInfo = getCurrentComponentInfo();
            if (componentInfo === null) {
              return;
            }
            if (args.length > 3 && typeof args[0] === "string" && args[0].startsWith("%c%s%c ") && typeof args[1] === "string" && typeof args[2] === "string" && typeof args[3] === "string") {
              var format = args[0].slice(7);
              var env2 = args[2].trim();
              args = args.slice(4);
              if (env2 !== componentInfo.env) {
                args.unshift("[" + env2 + "] " + format);
              } else {
                args.unshift(format);
              }
            }
            var message = formatConsoleArgumentsToSingleString.apply(undefined, renderer_toConsumableArray(args));
            var componentLogsEntry = componentInfoToComponentLogsMap.get(componentInfo);
            if (componentLogsEntry === undefined) {
              componentLogsEntry = {
                errors: new Map,
                errorsCount: 0,
                warnings: new Map,
                warningsCount: 0
              };
              componentInfoToComponentLogsMap.set(componentInfo, componentLogsEntry);
            }
            var messageMap = type === "error" ? componentLogsEntry.errors : componentLogsEntry.warnings;
            var count = messageMap.get(message) || 0;
            messageMap.set(message, count + 1);
            if (type === "error") {
              componentLogsEntry.errorsCount++;
            } else {
              componentLogsEntry.warningsCount++;
            }
          }
          var supportsTogglingSuspense = false;
          return {
            cleanup: function cleanup() {},
            clearErrorsAndWarnings: function clearErrorsAndWarnings() {},
            clearErrorsForElementID: function clearErrorsForElementID() {},
            clearWarningsForElementID: function clearWarningsForElementID() {},
            getSerializedElementValueByPath: function getSerializedElementValueByPath() {},
            deletePath: function deletePath() {},
            findHostInstancesForElementID: function findHostInstancesForElementID() {
              return null;
            },
            findLastKnownRectsForID: function findLastKnownRectsForID() {
              return null;
            },
            flushInitialOperations: function flushInitialOperations() {},
            getBestMatchForTrackedPath: function getBestMatchForTrackedPath() {
              return null;
            },
            getComponentStack,
            getDisplayNameForElementID: function getDisplayNameForElementID() {
              return null;
            },
            getNearestMountedDOMNode: function getNearestMountedDOMNode() {
              return null;
            },
            getElementIDForHostInstance: function getElementIDForHostInstance() {
              return null;
            },
            getSuspenseNodeIDForHostInstance: function getSuspenseNodeIDForHostInstance() {
              return null;
            },
            getInstanceAndStyle: function getInstanceAndStyle() {
              return {
                instance: null,
                style: null
              };
            },
            getOwnersList: function getOwnersList() {
              return null;
            },
            getPathForElement: function getPathForElement() {
              return null;
            },
            getProfilingData: function getProfilingData() {
              throw new Error("getProfilingData not supported by this renderer");
            },
            handleCommitFiberRoot: function handleCommitFiberRoot() {},
            handleCommitFiberUnmount: function handleCommitFiberUnmount() {},
            handlePostCommitFiberRoot: function handlePostCommitFiberRoot() {},
            hasElementWithId: function hasElementWithId() {
              return false;
            },
            inspectElement: function inspectElement(requestID, id, path) {
              return {
                id,
                responseID: requestID,
                type: "not-found"
              };
            },
            logElementToConsole: function logElementToConsole() {},
            getElementAttributeByPath: function getElementAttributeByPath() {},
            getElementSourceFunctionById: function getElementSourceFunctionById() {},
            onErrorOrWarning,
            overrideError: function overrideError() {},
            overrideSuspense: function overrideSuspense() {},
            overrideSuspenseMilestone: function overrideSuspenseMilestone() {},
            overrideValueAtPath: function overrideValueAtPath() {},
            renamePath: function renamePath() {},
            renderer,
            setTraceUpdatesEnabled: function setTraceUpdatesEnabled() {},
            setTrackedPath: function setTrackedPath() {},
            startProfiling: function startProfiling() {},
            stopProfiling: function stopProfiling() {},
            storeAsGlobal: function storeAsGlobal() {},
            supportsTogglingSuspense,
            updateComponentFilters: function updateComponentFilters() {},
            getEnvironmentNames: function getEnvironmentNames() {
              return [];
            }
          };
        }
        function parseStackTrace_slicedToArray(arr, i) {
          return parseStackTrace_arrayWithHoles(arr) || parseStackTrace_iterableToArrayLimit(arr, i) || parseStackTrace_unsupportedIterableToArray(arr, i) || parseStackTrace_nonIterableRest();
        }
        function parseStackTrace_nonIterableRest() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function parseStackTrace_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return parseStackTrace_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return parseStackTrace_arrayLikeToArray(o, minLen);
        }
        function parseStackTrace_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len);i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        function parseStackTrace_iterableToArrayLimit(r, l) {
          var t = r == null ? null : typeof Symbol != "undefined" && r[Symbol.iterator] || r["@@iterator"];
          if (t != null) {
            var e, n, i, u, a = [], f = true, o = false;
            try {
              if (i = (t = t.call(r)).next, l === 0) {
                if (Object(t) !== t)
                  return;
                f = false;
              } else
                for (;!(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
                  ;
            } catch (r2) {
              o = true, n = r2;
            } finally {
              try {
                if (!f && t.return != null && (u = t.return(), Object(u) !== u))
                  return;
              } finally {
                if (o)
                  throw n;
              }
            }
            return a;
          }
        }
        function parseStackTrace_arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        function parseStackTraceFromChromeStack(stack, skipFrames) {
          if (stack.startsWith(`Error: react-stack-top-frame
`)) {
            stack = stack.slice(29);
          }
          var idx = stack.indexOf("react_stack_bottom_frame");
          if (idx === -1) {
            idx = stack.indexOf("react-stack-bottom-frame");
          }
          if (idx !== -1) {
            idx = stack.lastIndexOf(`
`, idx);
          }
          if (idx !== -1) {
            stack = stack.slice(0, idx);
          }
          var frames = stack.split(`
`);
          var parsedFrames = [];
          for (var i = skipFrames;i < frames.length; i++) {
            var parsed = chromeFrameRegExp.exec(frames[i]);
            if (!parsed) {
              continue;
            }
            var name = parsed[1] || "";
            var isAsync = parsed[8] === "async ";
            if (name === "<anonymous>") {
              name = "";
            } else if (name.startsWith("async ")) {
              name = name.slice(5);
              isAsync = true;
            }
            var filename = parsed[2] || parsed[5] || "";
            if (filename === "<anonymous>") {
              filename = "";
            }
            var line = +(parsed[3] || parsed[6] || 0);
            var col = +(parsed[4] || parsed[7] || 0);
            parsedFrames.push([name, filename, line, col, 0, 0, isAsync]);
          }
          return parsedFrames;
        }
        var firefoxFrameRegExp = /^((?:.*".+")?[^@]*)@(.+):(\d+):(\d+)$/;
        function parseStackTraceFromFirefoxStack(stack, skipFrames) {
          var idx = stack.indexOf("react_stack_bottom_frame");
          if (idx === -1) {
            idx = stack.indexOf("react-stack-bottom-frame");
          }
          if (idx !== -1) {
            idx = stack.lastIndexOf(`
`, idx);
          }
          if (idx !== -1) {
            stack = stack.slice(0, idx);
          }
          var frames = stack.split(`
`);
          var parsedFrames = [];
          for (var i = skipFrames;i < frames.length; i++) {
            var parsed = firefoxFrameRegExp.exec(frames[i]);
            if (!parsed) {
              continue;
            }
            var name = parsed[1] || "";
            var filename = parsed[2] || "";
            var line = +parsed[3];
            var col = +parsed[4];
            parsedFrames.push([name, filename, line, col, 0, 0, false]);
          }
          return parsedFrames;
        }
        var CHROME_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
        function parseStackTraceFromString(stack, skipFrames) {
          if (stack.match(CHROME_STACK_REGEXP)) {
            return parseStackTraceFromChromeStack(stack, skipFrames);
          }
          return parseStackTraceFromFirefoxStack(stack, skipFrames);
        }
        var framesToSkip = 0;
        var collectedStackTrace = null;
        var identifierRegExp = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
        function getMethodCallName(callSite) {
          var typeName = callSite.getTypeName();
          var methodName = callSite.getMethodName();
          var functionName = callSite.getFunctionName();
          var result = "";
          if (functionName) {
            if (typeName && identifierRegExp.test(functionName) && functionName !== typeName) {
              result += typeName + ".";
            }
            result += functionName;
            if (methodName && functionName !== methodName && !functionName.endsWith("." + methodName) && !functionName.endsWith(" " + methodName)) {
              result += " [as " + methodName + "]";
            }
          } else {
            if (typeName) {
              result += typeName + ".";
            }
            if (methodName) {
              result += methodName;
            } else {
              result += "<anonymous>";
            }
          }
          return result;
        }
        function collectStackTrace(error, structuredStackTrace) {
          var result = [];
          for (var i = framesToSkip;i < structuredStackTrace.length; i++) {
            var callSite = structuredStackTrace[i];
            var _name = callSite.getFunctionName() || "<anonymous>";
            if (_name.includes("react_stack_bottom_frame") || _name.includes("react-stack-bottom-frame")) {
              break;
            } else if (callSite.isNative()) {
              var isAsync = callSite.isAsync();
              result.push([_name, "", 0, 0, 0, 0, isAsync]);
            } else {
              if (callSite.isConstructor()) {
                _name = "new " + _name;
              } else if (!callSite.isToplevel()) {
                _name = getMethodCallName(callSite);
              }
              if (_name === "<anonymous>") {
                _name = "";
              }
              var filename = callSite.getScriptNameOrSourceURL() || "<anonymous>";
              if (filename === "<anonymous>") {
                filename = "";
                if (callSite.isEval()) {
                  var origin = callSite.getEvalOrigin();
                  if (origin) {
                    filename = origin.toString() + ", <anonymous>";
                  }
                }
              }
              var line = callSite.getLineNumber() || 0;
              var col = callSite.getColumnNumber() || 0;
              var enclosingLine = typeof callSite.getEnclosingLineNumber === "function" ? callSite.getEnclosingLineNumber() || 0 : 0;
              var enclosingCol = typeof callSite.getEnclosingColumnNumber === "function" ? callSite.getEnclosingColumnNumber() || 0 : 0;
              var _isAsync = callSite.isAsync();
              result.push([_name, filename, line, col, enclosingLine, enclosingCol, _isAsync]);
            }
          }
          collectedStackTrace = result;
          var name = error.name || "Error";
          var message = error.message || "";
          var stack = name + ": " + message;
          for (var _i = 0;_i < structuredStackTrace.length; _i++) {
            stack += `
    at ` + structuredStackTrace[_i].toString();
          }
          return stack;
        }
        var chromeFrameRegExp = /^ *at (?:(.+) \((?:(.+):(\d+):(\d+)|\<anonymous\>)\)|(?:async )?(.+):(\d+):(\d+)|\<anonymous\>)$/;
        var stackTraceCache = new WeakMap;
        function parseStackTrace(error, skipFrames) {
          var existing = stackTraceCache.get(error);
          if (existing !== undefined) {
            return existing;
          }
          collectedStackTrace = null;
          framesToSkip = skipFrames;
          var previousPrepare = Error.prepareStackTrace;
          Error.prepareStackTrace = collectStackTrace;
          var stack;
          try {
            stack = String(error.stack);
          } finally {
            Error.prepareStackTrace = previousPrepare;
          }
          if (collectedStackTrace !== null) {
            var result = collectedStackTrace;
            collectedStackTrace = null;
            stackTraceCache.set(error, result);
            return result;
          }
          var parsedFrames = parseStackTraceFromString(stack, skipFrames);
          stackTraceCache.set(error, parsedFrames);
          return parsedFrames;
        }
        function extractLocationFromOwnerStack(error) {
          var stackTrace = parseStackTrace(error, 1);
          var stack = error.stack;
          if (!stack.includes("react_stack_bottom_frame") && !stack.includes("react-stack-bottom-frame")) {
            return null;
          }
          for (var i = stackTrace.length - 1;i >= 0; i--) {
            var _stackTrace$i = parseStackTrace_slicedToArray(stackTrace[i], 6), functionName = _stackTrace$i[0], fileName = _stackTrace$i[1], line = _stackTrace$i[2], col = _stackTrace$i[3], encLine = _stackTrace$i[4], encCol = _stackTrace$i[5];
            if (fileName.indexOf(":") !== -1) {
              return [functionName, fileName, encLine || line, encCol || col];
            }
          }
          return null;
        }
        function extractLocationFromComponentStack(stack) {
          var stackTrace = parseStackTraceFromString(stack, 0);
          for (var i = 0;i < stackTrace.length; i++) {
            var _stackTrace$i2 = parseStackTrace_slicedToArray(stackTrace[i], 6), functionName = _stackTrace$i2[0], fileName = _stackTrace$i2[1], line = _stackTrace$i2[2], col = _stackTrace$i2[3], encLine = _stackTrace$i2[4], encCol = _stackTrace$i2[5];
            if (fileName.indexOf(":") !== -1) {
              return [functionName, fileName, encLine || line, encCol || col];
            }
          }
          return null;
        }
        var react_debug_tools = __webpack_require__(987);
        var CONCURRENT_MODE_NUMBER = 60111;
        var CONCURRENT_MODE_SYMBOL_STRING = "Symbol(react.concurrent_mode)";
        var CONTEXT_NUMBER = 60110;
        var CONTEXT_SYMBOL_STRING = "Symbol(react.context)";
        var SERVER_CONTEXT_SYMBOL_STRING = "Symbol(react.server_context)";
        var DEPRECATED_ASYNC_MODE_SYMBOL_STRING = "Symbol(react.async_mode)";
        var ELEMENT_SYMBOL_STRING = "Symbol(react.transitional.element)";
        var LEGACY_ELEMENT_NUMBER = 60103;
        var LEGACY_ELEMENT_SYMBOL_STRING = "Symbol(react.element)";
        var DEBUG_TRACING_MODE_NUMBER = 60129;
        var DEBUG_TRACING_MODE_SYMBOL_STRING = "Symbol(react.debug_trace_mode)";
        var FORWARD_REF_NUMBER = 60112;
        var FORWARD_REF_SYMBOL_STRING = "Symbol(react.forward_ref)";
        var FRAGMENT_NUMBER = 60107;
        var FRAGMENT_SYMBOL_STRING = "Symbol(react.fragment)";
        var LAZY_NUMBER = 60116;
        var LAZY_SYMBOL_STRING = "Symbol(react.lazy)";
        var MEMO_NUMBER = 60115;
        var MEMO_SYMBOL_STRING = "Symbol(react.memo)";
        var PORTAL_NUMBER = 60106;
        var PORTAL_SYMBOL_STRING = "Symbol(react.portal)";
        var PROFILER_NUMBER = 60114;
        var PROFILER_SYMBOL_STRING = "Symbol(react.profiler)";
        var PROVIDER_NUMBER = 60109;
        var PROVIDER_SYMBOL_STRING = "Symbol(react.provider)";
        var CONSUMER_SYMBOL_STRING = "Symbol(react.consumer)";
        var SCOPE_NUMBER = 60119;
        var SCOPE_SYMBOL_STRING = "Symbol(react.scope)";
        var STRICT_MODE_NUMBER = 60108;
        var STRICT_MODE_SYMBOL_STRING = "Symbol(react.strict_mode)";
        var SUSPENSE_NUMBER = 60113;
        var SUSPENSE_SYMBOL_STRING = "Symbol(react.suspense)";
        var SUSPENSE_LIST_NUMBER = 60120;
        var SUSPENSE_LIST_SYMBOL_STRING = "Symbol(react.suspense_list)";
        var SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED_SYMBOL_STRING = "Symbol(react.server_context.defaultValue)";
        var ReactSymbols_REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
        var enableLogger = false;
        var enableStyleXFeatures = false;
        var isInternalFacebookBuild = false;
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        const shared_objectIs = objectIs;
        var hasOwnProperty_hasOwnProperty = Object.prototype.hasOwnProperty;
        const shared_hasOwnProperty = hasOwnProperty_hasOwnProperty;
        function ReactIODescription_typeof(o) {
          "@babel/helpers - typeof";
          return ReactIODescription_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, ReactIODescription_typeof(o);
        }
        function getIODescription(value) {
          if (true) {
            return "";
          }
          try {
            switch (ReactIODescription_typeof(value)) {
              case "function":
                return value.name || "";
              case "object":
                if (value === null) {
                  return "";
                } else if (value instanceof Error) {
                  return String(value.message);
                } else if (typeof value.url === "string") {
                  return value.url;
                } else if (typeof value.href === "string") {
                  return value.href;
                } else if (typeof value.src === "string") {
                  return value.src;
                } else if (typeof value.currentSrc === "string") {
                  return value.currentSrc;
                } else if (typeof value.command === "string") {
                  return value.command;
                } else if (ReactIODescription_typeof(value.request) === "object" && value.request !== null && typeof value.request.url === "string") {
                  return value.request.url;
                } else if (ReactIODescription_typeof(value.response) === "object" && value.response !== null && typeof value.response.url === "string") {
                  return value.response.url;
                } else if (typeof value.id === "string" || typeof value.id === "number" || typeof value.id === "bigint") {
                  return String(value.id);
                } else if (typeof value.name === "string") {
                  return value.name;
                } else {
                  var str = value.toString();
                  if (str.startsWith("[object ") || str.length < 5 || str.length > 500) {
                    return "";
                  }
                  return str;
                }
              case "string":
                if (value.length < 5 || value.length > 500) {
                  return "";
                }
                return value;
              case "number":
              case "bigint":
                return String(value);
              default:
                return "";
            }
          } catch (x) {
            return "";
          }
        }
        function describeFiber(workTagMap, workInProgress, currentDispatcherRef) {
          var { HostHoistable, HostSingleton, HostComponent, LazyComponent, SuspenseComponent, SuspenseListComponent, FunctionComponent, IndeterminateComponent, SimpleMemoComponent, ForwardRef, ClassComponent, ViewTransitionComponent, ActivityComponent } = workTagMap;
          switch (workInProgress.tag) {
            case HostHoistable:
            case HostSingleton:
            case HostComponent:
              return describeBuiltInComponentFrame(workInProgress.type);
            case LazyComponent:
              return describeBuiltInComponentFrame("Lazy");
            case SuspenseComponent:
              return describeBuiltInComponentFrame("Suspense");
            case SuspenseListComponent:
              return describeBuiltInComponentFrame("SuspenseList");
            case ViewTransitionComponent:
              return describeBuiltInComponentFrame("ViewTransition");
            case ActivityComponent:
              return describeBuiltInComponentFrame("Activity");
            case FunctionComponent:
            case IndeterminateComponent:
            case SimpleMemoComponent:
              return describeFunctionComponentFrame(workInProgress.type, currentDispatcherRef);
            case ForwardRef:
              return describeFunctionComponentFrame(workInProgress.type.render, currentDispatcherRef);
            case ClassComponent:
              return describeClassComponentFrame(workInProgress.type, currentDispatcherRef);
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workTagMap, workInProgress, currentDispatcherRef) {
          try {
            var info = "";
            var node = workInProgress;
            do {
              info += describeFiber(workTagMap, node, currentDispatcherRef);
              var debugInfo = node._debugInfo;
              if (debugInfo) {
                for (var i = debugInfo.length - 1;i >= 0; i--) {
                  var entry = debugInfo[i];
                  if (typeof entry.name === "string") {
                    info += describeDebugInfoFrame(entry.name, entry.env);
                  }
                }
              }
              node = node.return;
            } while (node);
            return info;
          } catch (x) {
            return `
Error generating stack: ` + x.message + `
` + x.stack;
          }
        }
        function getSourceLocationByFiber(workTagMap, fiber, currentDispatcherRef) {
          try {
            var info = describeFiber(workTagMap, fiber, currentDispatcherRef);
            if (info !== "") {
              return info.slice(1);
            }
          } catch (x) {
            console.error(x);
          }
          return null;
        }
        function DevToolsFiberComponentStack_supportsConsoleTasks(fiber) {
          return !!fiber._debugTask;
        }
        function supportsOwnerStacks(fiber) {
          return fiber._debugStack !== undefined;
        }
        function getOwnerStackByFiberInDev(workTagMap, workInProgress, currentDispatcherRef) {
          var { HostHoistable, HostSingleton, HostText, HostComponent, SuspenseComponent, SuspenseListComponent, ViewTransitionComponent, ActivityComponent } = workTagMap;
          try {
            var info = "";
            if (workInProgress.tag === HostText) {
              workInProgress = workInProgress.return;
            }
            switch (workInProgress.tag) {
              case HostHoistable:
              case HostSingleton:
              case HostComponent:
                info += describeBuiltInComponentFrame(workInProgress.type);
                break;
              case SuspenseComponent:
                info += describeBuiltInComponentFrame("Suspense");
                break;
              case SuspenseListComponent:
                info += describeBuiltInComponentFrame("SuspenseList");
                break;
              case ViewTransitionComponent:
                info += describeBuiltInComponentFrame("ViewTransition");
                break;
              case ActivityComponent:
                info += describeBuiltInComponentFrame("Activity");
                break;
            }
            var owner = workInProgress;
            while (owner) {
              if (typeof owner.tag === "number") {
                var fiber = owner;
                owner = fiber._debugOwner;
                var debugStack = fiber._debugStack;
                if (owner && debugStack) {
                  if (typeof debugStack !== "string") {
                    debugStack = formatOwnerStack(debugStack);
                  }
                  if (debugStack !== "") {
                    info += `
` + debugStack;
                  }
                }
              } else if (owner.debugStack != null) {
                var ownerStack = owner.debugStack;
                owner = owner.owner;
                if (owner && ownerStack) {
                  info += `
` + formatOwnerStack(ownerStack);
                }
              } else {
                break;
              }
            }
            return info;
          } catch (x) {
            return `
Error generating stack: ` + x.message + `
` + x.stack;
          }
        }
        var cachedStyleNameToValueMap = new Map;
        function getStyleXData(data) {
          var sources = new Set;
          var resolvedStyles = {};
          crawlData(data, sources, resolvedStyles);
          return {
            sources: Array.from(sources).sort(),
            resolvedStyles
          };
        }
        function crawlData(data, sources, resolvedStyles) {
          if (data == null) {
            return;
          }
          if (src_isArray(data)) {
            data.forEach(function(entry) {
              if (entry == null) {
                return;
              }
              if (src_isArray(entry)) {
                crawlData(entry, sources, resolvedStyles);
              } else {
                crawlObjectProperties(entry, sources, resolvedStyles);
              }
            });
          } else {
            crawlObjectProperties(data, sources, resolvedStyles);
          }
          resolvedStyles = Object.fromEntries(Object.entries(resolvedStyles).sort());
        }
        function crawlObjectProperties(entry, sources, resolvedStyles) {
          var keys = Object.keys(entry);
          keys.forEach(function(key) {
            var value = entry[key];
            if (typeof value === "string") {
              if (key === value) {
                sources.add(key);
              } else {
                var propertyValue = getPropertyValueForStyleName(value);
                if (propertyValue != null) {
                  resolvedStyles[key] = propertyValue;
                }
              }
            } else {
              var nestedStyle = {};
              resolvedStyles[key] = nestedStyle;
              crawlData([value], sources, nestedStyle);
            }
          });
        }
        function getPropertyValueForStyleName(styleName) {
          if (cachedStyleNameToValueMap.has(styleName)) {
            return cachedStyleNameToValueMap.get(styleName);
          }
          for (var styleSheetIndex = 0;styleSheetIndex < document.styleSheets.length; styleSheetIndex++) {
            var styleSheet = document.styleSheets[styleSheetIndex];
            var rules = null;
            try {
              rules = styleSheet.cssRules;
            } catch (_e) {
              continue;
            }
            for (var ruleIndex = 0;ruleIndex < rules.length; ruleIndex++) {
              if (!(rules[ruleIndex] instanceof CSSStyleRule)) {
                continue;
              }
              var rule = rules[ruleIndex];
              var { cssText, selectorText, style } = rule;
              if (selectorText != null) {
                if (selectorText.startsWith(".".concat(styleName))) {
                  var match = cssText.match(/{ *([a-z\-]+):/);
                  if (match !== null) {
                    var property = match[1];
                    var value = style.getPropertyValue(property);
                    cachedStyleNameToValueMap.set(styleName, value);
                    return value;
                  } else {
                    return null;
                  }
                }
              }
            }
          }
          return null;
        }
        var CHANGE_LOG_URL = "https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md";
        var UNSUPPORTED_VERSION_URL = "https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back";
        var REACT_DEVTOOLS_WORKPLACE_URL = "https://fburl.com/react-devtools-workplace-group";
        var THEME_STYLES = {
          light: {
            "--color-attribute-name": "#ef6632",
            "--color-attribute-name-not-editable": "#23272f",
            "--color-attribute-name-inverted": "rgba(255, 255, 255, 0.7)",
            "--color-attribute-value": "#1a1aa6",
            "--color-attribute-value-inverted": "#ffffff",
            "--color-attribute-editable-value": "#1a1aa6",
            "--color-background": "#ffffff",
            "--color-background-hover": "rgba(0, 136, 250, 0.1)",
            "--color-background-inactive": "#e5e5e5",
            "--color-background-invalid": "#fff0f0",
            "--color-background-selected": "#0088fa",
            "--color-button-background": "#ffffff",
            "--color-button-background-focus": "#ededed",
            "--color-button-background-hover": "rgba(0, 0, 0, 0.2)",
            "--color-button": "#5f6673",
            "--color-button-disabled": "#cfd1d5",
            "--color-button-active": "#0088fa",
            "--color-button-focus": "#23272f",
            "--color-button-hover": "#23272f",
            "--color-border": "#eeeeee",
            "--color-commit-did-not-render-fill": "#cfd1d5",
            "--color-commit-did-not-render-fill-text": "#000000",
            "--color-commit-did-not-render-pattern": "#cfd1d5",
            "--color-commit-did-not-render-pattern-text": "#333333",
            "--color-commit-gradient-0": "#37afa9",
            "--color-commit-gradient-1": "#63b19e",
            "--color-commit-gradient-2": "#80b393",
            "--color-commit-gradient-3": "#97b488",
            "--color-commit-gradient-4": "#abb67d",
            "--color-commit-gradient-5": "#beb771",
            "--color-commit-gradient-6": "#cfb965",
            "--color-commit-gradient-7": "#dfba57",
            "--color-commit-gradient-8": "#efbb49",
            "--color-commit-gradient-9": "#febc38",
            "--color-commit-gradient-text": "#000000",
            "--color-component-name": "#6a51b2",
            "--color-component-name-inverted": "#ffffff",
            "--color-component-badge-background": "#e6e6e6",
            "--color-component-badge-background-inverted": "rgba(255, 255, 255, 0.25)",
            "--color-component-badge-count": "#777d88",
            "--color-component-badge-count-inverted": "rgba(255, 255, 255, 0.7)",
            "--color-console-error-badge-text": "#ffffff",
            "--color-console-error-background": "#fff0f0",
            "--color-console-error-border": "#ffd6d6",
            "--color-console-error-icon": "#eb3941",
            "--color-console-error-text": "#fe2e31",
            "--color-console-warning-badge-text": "#000000",
            "--color-console-warning-background": "#fffbe5",
            "--color-console-warning-border": "#fff5c1",
            "--color-console-warning-icon": "#f4bd00",
            "--color-console-warning-text": "#64460c",
            "--color-context-background": "rgba(0,0,0,.9)",
            "--color-context-background-hover": "rgba(255, 255, 255, 0.1)",
            "--color-context-background-selected": "#178fb9",
            "--color-context-border": "#3d424a",
            "--color-context-text": "#ffffff",
            "--color-context-text-selected": "#ffffff",
            "--color-dim": "#777d88",
            "--color-dimmer": "#cfd1d5",
            "--color-dimmest": "#eff0f1",
            "--color-error-background": "hsl(0, 100%, 97%)",
            "--color-error-border": "hsl(0, 100%, 92%)",
            "--color-error-text": "#ff0000",
            "--color-expand-collapse-toggle": "#777d88",
            "--color-forget-badge-background": "#2683e2",
            "--color-forget-badge-background-inverted": "#1a6bbc",
            "--color-forget-text": "#fff",
            "--color-link": "#0000ff",
            "--color-modal-background": "rgba(255, 255, 255, 0.75)",
            "--color-bridge-version-npm-background": "#eff0f1",
            "--color-bridge-version-npm-text": "#000000",
            "--color-bridge-version-number": "#0088fa",
            "--color-primitive-hook-badge-background": "#e5e5e5",
            "--color-primitive-hook-badge-text": "#5f6673",
            "--color-record-active": "#fc3a4b",
            "--color-record-hover": "#3578e5",
            "--color-record-inactive": "#0088fa",
            "--color-resize-bar": "#eeeeee",
            "--color-resize-bar-active": "#dcdcdc",
            "--color-resize-bar-border": "#d1d1d1",
            "--color-resize-bar-dot": "#333333",
            "--color-timeline-internal-module": "#d1d1d1",
            "--color-timeline-internal-module-hover": "#c9c9c9",
            "--color-timeline-internal-module-text": "#444",
            "--color-timeline-native-event": "#ccc",
            "--color-timeline-native-event-hover": "#aaa",
            "--color-timeline-network-primary": "#fcf3dc",
            "--color-timeline-network-primary-hover": "#f0e7d1",
            "--color-timeline-network-secondary": "#efc457",
            "--color-timeline-network-secondary-hover": "#e3ba52",
            "--color-timeline-priority-background": "#f6f6f6",
            "--color-timeline-priority-border": "#eeeeee",
            "--color-timeline-user-timing": "#c9cacd",
            "--color-timeline-user-timing-hover": "#93959a",
            "--color-timeline-react-idle": "#d3e5f6",
            "--color-timeline-react-idle-hover": "#c3d9ef",
            "--color-timeline-react-render": "#9fc3f3",
            "--color-timeline-react-render-hover": "#83afe9",
            "--color-timeline-react-render-text": "#11365e",
            "--color-timeline-react-commit": "#c88ff0",
            "--color-timeline-react-commit-hover": "#b281d6",
            "--color-timeline-react-commit-text": "#3e2c4a",
            "--color-timeline-react-layout-effects": "#b281d6",
            "--color-timeline-react-layout-effects-hover": "#9d71bd",
            "--color-timeline-react-layout-effects-text": "#3e2c4a",
            "--color-timeline-react-passive-effects": "#b281d6",
            "--color-timeline-react-passive-effects-hover": "#9d71bd",
            "--color-timeline-react-passive-effects-text": "#3e2c4a",
            "--color-timeline-react-schedule": "#9fc3f3",
            "--color-timeline-react-schedule-hover": "#2683E2",
            "--color-timeline-react-suspense-rejected": "#f1cc14",
            "--color-timeline-react-suspense-rejected-hover": "#ffdf37",
            "--color-timeline-react-suspense-resolved": "#a6e59f",
            "--color-timeline-react-suspense-resolved-hover": "#89d281",
            "--color-timeline-react-suspense-unresolved": "#c9cacd",
            "--color-timeline-react-suspense-unresolved-hover": "#93959a",
            "--color-timeline-thrown-error": "#ee1638",
            "--color-timeline-thrown-error-hover": "#da1030",
            "--color-timeline-text-color": "#000000",
            "--color-timeline-text-dim-color": "#ccc",
            "--color-timeline-react-work-border": "#eeeeee",
            "--color-timebar-background": "#f6f6f6",
            "--color-search-match": "yellow",
            "--color-search-match-current": "#f7923b",
            "--color-selected-tree-highlight-active": "rgba(0, 136, 250, 0.1)",
            "--color-selected-tree-highlight-inactive": "rgba(0, 0, 0, 0.05)",
            "--color-scroll-caret": "rgba(150, 150, 150, 0.5)",
            "--color-tab-selected-border": "#0088fa",
            "--color-text": "#000000",
            "--color-text-invalid": "#ff0000",
            "--color-text-selected": "#ffffff",
            "--color-toggle-background-invalid": "#fc3a4b",
            "--color-toggle-background-on": "#0088fa",
            "--color-toggle-background-off": "#cfd1d5",
            "--color-toggle-text": "#ffffff",
            "--color-warning-background": "#fb3655",
            "--color-warning-background-hover": "#f82042",
            "--color-warning-text-color": "#ffffff",
            "--color-warning-text-color-inverted": "#fd4d69",
            "--color-suspense-default": "#0088fa",
            "--color-transition-default": "#6a51b2",
            "--color-suspense-server": "#62bc6a",
            "--color-transition-server": "#3f7844",
            "--color-suspense-other": "#f3ce49",
            "--color-transition-other": "#917b2c",
            "--color-suspense-errored": "#d57066",
            "--color-scroll-thumb": "#c2c2c2",
            "--color-scroll-track": "#fafafa",
            "--color-tooltip-background": "rgba(0, 0, 0, 0.9)",
            "--color-tooltip-text": "#ffffff",
            "--elevation-4": "0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)"
          },
          dark: {
            "--color-attribute-name": "#9d87d2",
            "--color-attribute-name-not-editable": "#ededed",
            "--color-attribute-name-inverted": "#282828",
            "--color-attribute-value": "#cedae0",
            "--color-attribute-value-inverted": "#ffffff",
            "--color-attribute-editable-value": "yellow",
            "--color-background": "#282c34",
            "--color-background-hover": "rgba(255, 255, 255, 0.1)",
            "--color-background-inactive": "#3d424a",
            "--color-background-invalid": "#5c0000",
            "--color-background-selected": "#178fb9",
            "--color-button-background": "#282c34",
            "--color-button-background-focus": "#3d424a",
            "--color-button-background-hover": "rgba(255, 255, 255, 0.2)",
            "--color-button": "#afb3b9",
            "--color-button-active": "#61dafb",
            "--color-button-disabled": "#4f5766",
            "--color-button-focus": "#a2e9fc",
            "--color-button-hover": "#ededed",
            "--color-border": "#3d424a",
            "--color-commit-did-not-render-fill": "#777d88",
            "--color-commit-did-not-render-fill-text": "#000000",
            "--color-commit-did-not-render-pattern": "#666c77",
            "--color-commit-did-not-render-pattern-text": "#ffffff",
            "--color-commit-gradient-0": "#37afa9",
            "--color-commit-gradient-1": "#63b19e",
            "--color-commit-gradient-2": "#80b393",
            "--color-commit-gradient-3": "#97b488",
            "--color-commit-gradient-4": "#abb67d",
            "--color-commit-gradient-5": "#beb771",
            "--color-commit-gradient-6": "#cfb965",
            "--color-commit-gradient-7": "#dfba57",
            "--color-commit-gradient-8": "#efbb49",
            "--color-commit-gradient-9": "#febc38",
            "--color-commit-gradient-text": "#000000",
            "--color-component-name": "#61dafb",
            "--color-component-name-inverted": "#282828",
            "--color-component-badge-background": "#5e6167",
            "--color-component-badge-background-inverted": "#46494e",
            "--color-component-badge-count": "#8f949d",
            "--color-component-badge-count-inverted": "rgba(255, 255, 255, 0.85)",
            "--color-console-error-badge-text": "#000000",
            "--color-console-error-background": "#290000",
            "--color-console-error-border": "#5c0000",
            "--color-console-error-icon": "#eb3941",
            "--color-console-error-text": "#fc7f7f",
            "--color-console-warning-badge-text": "#000000",
            "--color-console-warning-background": "#332b00",
            "--color-console-warning-border": "#665500",
            "--color-console-warning-icon": "#f4bd00",
            "--color-console-warning-text": "#f5f2ed",
            "--color-context-background": "rgba(255,255,255,.95)",
            "--color-context-background-hover": "rgba(0, 136, 250, 0.1)",
            "--color-context-background-selected": "#0088fa",
            "--color-context-border": "#eeeeee",
            "--color-context-text": "#000000",
            "--color-context-text-selected": "#ffffff",
            "--color-dim": "#8f949d",
            "--color-dimmer": "#777d88",
            "--color-dimmest": "#4f5766",
            "--color-error-background": "#200",
            "--color-error-border": "#900",
            "--color-error-text": "#f55",
            "--color-expand-collapse-toggle": "#8f949d",
            "--color-forget-badge-background": "#2683e2",
            "--color-forget-badge-background-inverted": "#1a6bbc",
            "--color-forget-text": "#fff",
            "--color-link": "#61dafb",
            "--color-modal-background": "rgba(0, 0, 0, 0.75)",
            "--color-bridge-version-npm-background": "rgba(0, 0, 0, 0.25)",
            "--color-bridge-version-npm-text": "#ffffff",
            "--color-bridge-version-number": "yellow",
            "--color-primitive-hook-badge-background": "rgba(0, 0, 0, 0.25)",
            "--color-primitive-hook-badge-text": "rgba(255, 255, 255, 0.7)",
            "--color-record-active": "#fc3a4b",
            "--color-record-hover": "#a2e9fc",
            "--color-record-inactive": "#61dafb",
            "--color-resize-bar": "#282c34",
            "--color-resize-bar-active": "#31363f",
            "--color-resize-bar-border": "#3d424a",
            "--color-resize-bar-dot": "#cfd1d5",
            "--color-timeline-internal-module": "#303542",
            "--color-timeline-internal-module-hover": "#363b4a",
            "--color-timeline-internal-module-text": "#7f8899",
            "--color-timeline-native-event": "#b2b2b2",
            "--color-timeline-native-event-hover": "#949494",
            "--color-timeline-network-primary": "#fcf3dc",
            "--color-timeline-network-primary-hover": "#e3dbc5",
            "--color-timeline-network-secondary": "#efc457",
            "--color-timeline-network-secondary-hover": "#d6af4d",
            "--color-timeline-priority-background": "#1d2129",
            "--color-timeline-priority-border": "#282c34",
            "--color-timeline-user-timing": "#c9cacd",
            "--color-timeline-user-timing-hover": "#93959a",
            "--color-timeline-react-idle": "#3d485b",
            "--color-timeline-react-idle-hover": "#465269",
            "--color-timeline-react-render": "#2683E2",
            "--color-timeline-react-render-hover": "#1a76d4",
            "--color-timeline-react-render-text": "#11365e",
            "--color-timeline-react-commit": "#731fad",
            "--color-timeline-react-commit-hover": "#611b94",
            "--color-timeline-react-commit-text": "#e5c1ff",
            "--color-timeline-react-layout-effects": "#611b94",
            "--color-timeline-react-layout-effects-hover": "#51167a",
            "--color-timeline-react-layout-effects-text": "#e5c1ff",
            "--color-timeline-react-passive-effects": "#611b94",
            "--color-timeline-react-passive-effects-hover": "#51167a",
            "--color-timeline-react-passive-effects-text": "#e5c1ff",
            "--color-timeline-react-schedule": "#2683E2",
            "--color-timeline-react-schedule-hover": "#1a76d4",
            "--color-timeline-react-suspense-rejected": "#f1cc14",
            "--color-timeline-react-suspense-rejected-hover": "#e4c00f",
            "--color-timeline-react-suspense-resolved": "#a6e59f",
            "--color-timeline-react-suspense-resolved-hover": "#89d281",
            "--color-timeline-react-suspense-unresolved": "#c9cacd",
            "--color-timeline-react-suspense-unresolved-hover": "#93959a",
            "--color-timeline-thrown-error": "#fb3655",
            "--color-timeline-thrown-error-hover": "#f82042",
            "--color-timeline-text-color": "#282c34",
            "--color-timeline-text-dim-color": "#555b66",
            "--color-timeline-react-work-border": "#3d424a",
            "--color-timebar-background": "#1d2129",
            "--color-search-match": "yellow",
            "--color-search-match-current": "#f7923b",
            "--color-selected-tree-highlight-active": "rgba(23, 143, 185, 0.15)",
            "--color-selected-tree-highlight-inactive": "rgba(255, 255, 255, 0.05)",
            "--color-scroll-caret": "#4f5766",
            "--color-shadow": "rgba(0, 0, 0, 0.5)",
            "--color-tab-selected-border": "#178fb9",
            "--color-text": "#ffffff",
            "--color-text-invalid": "#ff8080",
            "--color-text-selected": "#ffffff",
            "--color-toggle-background-invalid": "#fc3a4b",
            "--color-toggle-background-on": "#178fb9",
            "--color-toggle-background-off": "#777d88",
            "--color-toggle-text": "#ffffff",
            "--color-warning-background": "#ee1638",
            "--color-warning-background-hover": "#da1030",
            "--color-warning-text-color": "#ffffff",
            "--color-warning-text-color-inverted": "#ee1638",
            "--color-suspense-default": "#61dafb",
            "--color-transition-default": "#6a51b2",
            "--color-suspense-server": "#62bc6a",
            "--color-transition-server": "#3f7844",
            "--color-suspense-other": "#f3ce49",
            "--color-transition-other": "#917b2c",
            "--color-suspense-errored": "#d57066",
            "--color-scroll-thumb": "#afb3b9",
            "--color-scroll-track": "#313640",
            "--color-tooltip-background": "rgba(255, 255, 255, 0.95)",
            "--color-tooltip-text": "#000000",
            "--elevation-4": "0 2px 8px 0 rgba(0,0,0,0.32),0 4px 12px 0 rgba(0,0,0,0.24),0 1px 10px 0 rgba(0,0,0,0.18)"
          },
          compact: {
            "--font-size-monospace-small": "9px",
            "--font-size-monospace-normal": "11px",
            "--font-size-monospace-large": "15px",
            "--font-size-sans-small": "10px",
            "--font-size-sans-normal": "12px",
            "--font-size-sans-large": "14px",
            "--line-height-data": "18px"
          },
          comfortable: {
            "--font-size-monospace-small": "10px",
            "--font-size-monospace-normal": "13px",
            "--font-size-monospace-large": "17px",
            "--font-size-sans-small": "12px",
            "--font-size-sans-normal": "14px",
            "--font-size-sans-large": "16px",
            "--line-height-data": "22px"
          }
        };
        var COMFORTABLE_LINE_HEIGHT = parseInt(THEME_STYLES.comfortable["--line-height-data"], 10);
        var COMPACT_LINE_HEIGHT = parseInt(THEME_STYLES.compact["--line-height-data"], 10);
        var REACT_TOTAL_NUM_LANES = 31;
        var SCHEDULING_PROFILER_VERSION = 1;
        var SNAPSHOT_MAX_HEIGHT = 60;
        function profilingHooks_slicedToArray(arr, i) {
          return profilingHooks_arrayWithHoles(arr) || profilingHooks_iterableToArrayLimit(arr, i) || profilingHooks_unsupportedIterableToArray(arr, i) || profilingHooks_nonIterableRest();
        }
        function profilingHooks_nonIterableRest() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function profilingHooks_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return profilingHooks_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return profilingHooks_arrayLikeToArray(o, minLen);
        }
        function profilingHooks_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len);i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        function profilingHooks_iterableToArrayLimit(r, l) {
          var t = r == null ? null : typeof Symbol != "undefined" && r[Symbol.iterator] || r["@@iterator"];
          if (t != null) {
            var e, n, i, u, a = [], f = true, o = false;
            try {
              if (i = (t = t.call(r)).next, l === 0) {
                if (Object(t) !== t)
                  return;
                f = false;
              } else
                for (;!(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
                  ;
            } catch (r2) {
              o = true, n = r2;
            } finally {
              try {
                if (!f && t.return != null && (u = t.return(), Object(u) !== u))
                  return;
              } finally {
                if (o)
                  throw n;
              }
            }
            return a;
          }
        }
        function profilingHooks_arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        function profilingHooks_typeof(o) {
          "@babel/helpers - typeof";
          return profilingHooks_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, profilingHooks_typeof(o);
        }
        var TIME_OFFSET = 10;
        var performanceTarget = null;
        var supportsUserTiming = typeof performance !== "undefined" && typeof performance.mark === "function" && typeof performance.clearMarks === "function";
        var supportsUserTimingV3 = false;
        if (supportsUserTiming) {
          var CHECK_V3_MARK = "__v3";
          var markOptions = {};
          Object.defineProperty(markOptions, "startTime", {
            get: function get() {
              supportsUserTimingV3 = true;
              return 0;
            },
            set: function set() {}
          });
          try {
            performance.mark(CHECK_V3_MARK, markOptions);
          } catch (error) {} finally {
            performance.clearMarks(CHECK_V3_MARK);
          }
        }
        if (supportsUserTimingV3) {
          performanceTarget = performance;
        }
        var profilingHooks_getCurrentTime = (typeof performance === "undefined" ? "undefined" : profilingHooks_typeof(performance)) === "object" && typeof performance.now === "function" ? function() {
          return performance.now();
        } : function() {
          return Date.now();
        };
        function setPerformanceMock_ONLY_FOR_TESTING(performanceMock) {
          performanceTarget = performanceMock;
          supportsUserTiming = performanceMock !== null;
          supportsUserTimingV3 = performanceMock !== null;
        }
        function createProfilingHooks(_ref) {
          var { getDisplayNameForFiber, getIsProfiling, getLaneLabelMap, workTagMap, currentDispatcherRef, reactVersion } = _ref;
          var currentBatchUID = 0;
          var currentReactComponentMeasure = null;
          var currentReactMeasuresStack = [];
          var currentTimelineData = null;
          var currentFiberStacks = new Map;
          var isProfiling = false;
          var nextRenderShouldStartNewBatch = false;
          function getRelativeTime() {
            var currentTime = profilingHooks_getCurrentTime();
            if (currentTimelineData) {
              if (currentTimelineData.startTime === 0) {
                currentTimelineData.startTime = currentTime - TIME_OFFSET;
              }
              return currentTime - currentTimelineData.startTime;
            }
            return 0;
          }
          function getInternalModuleRanges() {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges === "function") {
              var ranges = __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges();
              if (shared_isArray(ranges)) {
                return ranges;
              }
            }
            return null;
          }
          function getTimelineData() {
            return currentTimelineData;
          }
          function laneToLanesArray(lanes) {
            var lanesArray = [];
            var lane = 1;
            for (var index = 0;index < REACT_TOTAL_NUM_LANES; index++) {
              if (lane & lanes) {
                lanesArray.push(lane);
              }
              lane *= 2;
            }
            return lanesArray;
          }
          var laneToLabelMap = typeof getLaneLabelMap === "function" ? getLaneLabelMap() : null;
          function markMetadata() {
            markAndClear("--react-version-".concat(reactVersion));
            markAndClear("--profiler-version-".concat(SCHEDULING_PROFILER_VERSION));
            var ranges = getInternalModuleRanges();
            if (ranges) {
              for (var i = 0;i < ranges.length; i++) {
                var range = ranges[i];
                if (shared_isArray(range) && range.length === 2) {
                  var _ranges$i = profilingHooks_slicedToArray(ranges[i], 2), startStackFrame = _ranges$i[0], stopStackFrame = _ranges$i[1];
                  markAndClear("--react-internal-module-start-".concat(startStackFrame));
                  markAndClear("--react-internal-module-stop-".concat(stopStackFrame));
                }
              }
            }
            if (laneToLabelMap != null) {
              var labels = Array.from(laneToLabelMap.values()).join(",");
              markAndClear("--react-lane-labels-".concat(labels));
            }
          }
          function markAndClear(markName) {
            performanceTarget.mark(markName);
            performanceTarget.clearMarks(markName);
          }
          function recordReactMeasureStarted(type, lanes) {
            var depth = 0;
            if (currentReactMeasuresStack.length > 0) {
              var top = currentReactMeasuresStack[currentReactMeasuresStack.length - 1];
              depth = top.type === "render-idle" ? top.depth : top.depth + 1;
            }
            var lanesArray = laneToLanesArray(lanes);
            var reactMeasure = {
              type,
              batchUID: currentBatchUID,
              depth,
              lanes: lanesArray,
              timestamp: getRelativeTime(),
              duration: 0
            };
            currentReactMeasuresStack.push(reactMeasure);
            if (currentTimelineData) {
              var _currentTimelineData = currentTimelineData, batchUIDToMeasuresMap = _currentTimelineData.batchUIDToMeasuresMap, laneToReactMeasureMap = _currentTimelineData.laneToReactMeasureMap;
              var reactMeasures = batchUIDToMeasuresMap.get(currentBatchUID);
              if (reactMeasures != null) {
                reactMeasures.push(reactMeasure);
              } else {
                batchUIDToMeasuresMap.set(currentBatchUID, [reactMeasure]);
              }
              lanesArray.forEach(function(lane) {
                reactMeasures = laneToReactMeasureMap.get(lane);
                if (reactMeasures) {
                  reactMeasures.push(reactMeasure);
                }
              });
            }
          }
          function recordReactMeasureCompleted(type) {
            var currentTime = getRelativeTime();
            if (currentReactMeasuresStack.length === 0) {
              console.error('Unexpected type "%s" completed at %sms while currentReactMeasuresStack is empty.', type, currentTime);
              return;
            }
            var top = currentReactMeasuresStack.pop();
            if (top.type !== type) {
              console.error('Unexpected type "%s" completed at %sms before "%s" completed.', type, currentTime, top.type);
            }
            top.duration = currentTime - top.timestamp;
            if (currentTimelineData) {
              currentTimelineData.duration = getRelativeTime() + TIME_OFFSET;
            }
          }
          function markCommitStarted(lanes) {
            if (!isProfiling) {
              return;
            }
            recordReactMeasureStarted("commit", lanes);
            nextRenderShouldStartNewBatch = true;
            if (supportsUserTimingV3) {
              markAndClear("--commit-start-".concat(lanes));
              markMetadata();
            }
          }
          function markCommitStopped() {
            if (!isProfiling) {
              return;
            }
            recordReactMeasureCompleted("commit");
            recordReactMeasureCompleted("render-idle");
            if (supportsUserTimingV3) {
              markAndClear("--commit-stop");
            }
          }
          function markComponentRenderStarted(fiber) {
            if (!isProfiling) {
              return;
            }
            var componentName = getDisplayNameForFiber(fiber) || "Unknown";
            currentReactComponentMeasure = {
              componentName,
              duration: 0,
              timestamp: getRelativeTime(),
              type: "render",
              warning: null
            };
            if (supportsUserTimingV3) {
              markAndClear("--component-render-start-".concat(componentName));
            }
          }
          function markComponentRenderStopped() {
            if (!isProfiling) {
              return;
            }
            if (currentReactComponentMeasure) {
              if (currentTimelineData) {
                currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
              }
              currentReactComponentMeasure.duration = getRelativeTime() - currentReactComponentMeasure.timestamp;
              currentReactComponentMeasure = null;
            }
            if (supportsUserTimingV3) {
              markAndClear("--component-render-stop");
            }
          }
          function markComponentLayoutEffectMountStarted(fiber) {
            if (!isProfiling) {
              return;
            }
            var componentName = getDisplayNameForFiber(fiber) || "Unknown";
            currentReactComponentMeasure = {
              componentName,
              duration: 0,
              timestamp: getRelativeTime(),
              type: "layout-effect-mount",
              warning: null
            };
            if (supportsUserTimingV3) {
              markAndClear("--component-layout-effect-mount-start-".concat(componentName));
            }
          }
          function markComponentLayoutEffectMountStopped() {
            if (!isProfiling) {
              return;
            }
            if (currentReactComponentMeasure) {
              if (currentTimelineData) {
                currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
              }
              currentReactComponentMeasure.duration = getRelativeTime() - currentReactComponentMeasure.timestamp;
              currentReactComponentMeasure = null;
            }
            if (supportsUserTimingV3) {
              markAndClear("--component-layout-effect-mount-stop");
            }
          }
          function markComponentLayoutEffectUnmountStarted(fiber) {
            if (!isProfiling) {
              return;
            }
            var componentName = getDisplayNameForFiber(fiber) || "Unknown";
            currentReactComponentMeasure = {
              componentName,
              duration: 0,
              timestamp: getRelativeTime(),
              type: "layout-effect-unmount",
              warning: null
            };
            if (supportsUserTimingV3) {
              markAndClear("--component-layout-effect-unmount-start-".concat(componentName));
            }
          }
          function markComponentLayoutEffectUnmountStopped() {
            if (!isProfiling) {
              return;
            }
            if (currentReactComponentMeasure) {
              if (currentTimelineData) {
                currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
              }
              currentReactComponentMeasure.duration = getRelativeTime() - currentReactComponentMeasure.timestamp;
              currentReactComponentMeasure = null;
            }
            if (supportsUserTimingV3) {
              markAndClear("--component-layout-effect-unmount-stop");
            }
          }
          function markComponentPassiveEffectMountStarted(fiber) {
            if (!isProfiling) {
              return;
            }
            var componentName = getDisplayNameForFiber(fiber) || "Unknown";
            currentReactComponentMeasure = {
              componentName,
              duration: 0,
              timestamp: getRelativeTime(),
              type: "passive-effect-mount",
              warning: null
            };
            if (supportsUserTimingV3) {
              markAndClear("--component-passive-effect-mount-start-".concat(componentName));
            }
          }
          function markComponentPassiveEffectMountStopped() {
            if (!isProfiling) {
              return;
            }
            if (currentReactComponentMeasure) {
              if (currentTimelineData) {
                currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
              }
              currentReactComponentMeasure.duration = getRelativeTime() - currentReactComponentMeasure.timestamp;
              currentReactComponentMeasure = null;
            }
            if (supportsUserTimingV3) {
              markAndClear("--component-passive-effect-mount-stop");
            }
          }
          function markComponentPassiveEffectUnmountStarted(fiber) {
            if (!isProfiling) {
              return;
            }
            var componentName = getDisplayNameForFiber(fiber) || "Unknown";
            currentReactComponentMeasure = {
              componentName,
              duration: 0,
              timestamp: getRelativeTime(),
              type: "passive-effect-unmount",
              warning: null
            };
            if (supportsUserTimingV3) {
              markAndClear("--component-passive-effect-unmount-start-".concat(componentName));
            }
          }
          function markComponentPassiveEffectUnmountStopped() {
            if (!isProfiling) {
              return;
            }
            if (currentReactComponentMeasure) {
              if (currentTimelineData) {
                currentTimelineData.componentMeasures.push(currentReactComponentMeasure);
              }
              currentReactComponentMeasure.duration = getRelativeTime() - currentReactComponentMeasure.timestamp;
              currentReactComponentMeasure = null;
            }
            if (supportsUserTimingV3) {
              markAndClear("--component-passive-effect-unmount-stop");
            }
          }
          function markComponentErrored(fiber, thrownValue, lanes) {
            if (!isProfiling) {
              return;
            }
            var componentName = getDisplayNameForFiber(fiber) || "Unknown";
            var phase = fiber.alternate === null ? "mount" : "update";
            var message = "";
            if (thrownValue !== null && profilingHooks_typeof(thrownValue) === "object" && typeof thrownValue.message === "string") {
              message = thrownValue.message;
            } else if (typeof thrownValue === "string") {
              message = thrownValue;
            }
            if (currentTimelineData) {
              currentTimelineData.thrownErrors.push({
                componentName,
                message,
                phase,
                timestamp: getRelativeTime(),
                type: "thrown-error"
              });
            }
            if (supportsUserTimingV3) {
              markAndClear("--error-".concat(componentName, "-").concat(phase, "-").concat(message));
            }
          }
          var PossiblyWeakMap2 = typeof WeakMap === "function" ? WeakMap : Map;
          var wakeableIDs = new PossiblyWeakMap2;
          var wakeableID = 0;
          function getWakeableID(wakeable) {
            if (!wakeableIDs.has(wakeable)) {
              wakeableIDs.set(wakeable, wakeableID++);
            }
            return wakeableIDs.get(wakeable);
          }
          function markComponentSuspended(fiber, wakeable, lanes) {
            if (!isProfiling) {
              return;
            }
            var eventType = wakeableIDs.has(wakeable) ? "resuspend" : "suspend";
            var id = getWakeableID(wakeable);
            var componentName = getDisplayNameForFiber(fiber) || "Unknown";
            var phase = fiber.alternate === null ? "mount" : "update";
            var displayName = wakeable.displayName || "";
            var suspenseEvent = null;
            suspenseEvent = {
              componentName,
              depth: 0,
              duration: 0,
              id: "".concat(id),
              phase,
              promiseName: displayName,
              resolution: "unresolved",
              timestamp: getRelativeTime(),
              type: "suspense",
              warning: null
            };
            if (currentTimelineData) {
              currentTimelineData.suspenseEvents.push(suspenseEvent);
            }
            if (supportsUserTimingV3) {
              markAndClear("--suspense-".concat(eventType, "-").concat(id, "-").concat(componentName, "-").concat(phase, "-").concat(lanes, "-").concat(displayName));
              wakeable.then(function() {
                if (suspenseEvent) {
                  suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;
                  suspenseEvent.resolution = "resolved";
                }
                if (supportsUserTimingV3) {
                  markAndClear("--suspense-resolved-".concat(id, "-").concat(componentName));
                }
              }, function() {
                if (suspenseEvent) {
                  suspenseEvent.duration = getRelativeTime() - suspenseEvent.timestamp;
                  suspenseEvent.resolution = "rejected";
                }
                if (supportsUserTimingV3) {
                  markAndClear("--suspense-rejected-".concat(id, "-").concat(componentName));
                }
              });
            }
          }
          function markLayoutEffectsStarted(lanes) {
            if (!isProfiling) {
              return;
            }
            recordReactMeasureStarted("layout-effects", lanes);
            if (supportsUserTimingV3) {
              markAndClear("--layout-effects-start-".concat(lanes));
            }
          }
          function markLayoutEffectsStopped() {
            if (!isProfiling) {
              return;
            }
            recordReactMeasureCompleted("layout-effects");
            if (supportsUserTimingV3) {
              markAndClear("--layout-effects-stop");
            }
          }
          function markPassiveEffectsStarted(lanes) {
            if (!isProfiling) {
              return;
            }
            recordReactMeasureStarted("passive-effects", lanes);
            if (supportsUserTimingV3) {
              markAndClear("--passive-effects-start-".concat(lanes));
            }
          }
          function markPassiveEffectsStopped() {
            if (!isProfiling) {
              return;
            }
            recordReactMeasureCompleted("passive-effects");
            if (supportsUserTimingV3) {
              markAndClear("--passive-effects-stop");
            }
          }
          function markRenderStarted(lanes) {
            if (!isProfiling) {
              return;
            }
            if (nextRenderShouldStartNewBatch) {
              nextRenderShouldStartNewBatch = false;
              currentBatchUID++;
            }
            if (currentReactMeasuresStack.length === 0 || currentReactMeasuresStack[currentReactMeasuresStack.length - 1].type !== "render-idle") {
              recordReactMeasureStarted("render-idle", lanes);
            }
            recordReactMeasureStarted("render", lanes);
            if (supportsUserTimingV3) {
              markAndClear("--render-start-".concat(lanes));
            }
          }
          function markRenderYielded() {
            if (!isProfiling) {
              return;
            }
            recordReactMeasureCompleted("render");
            if (supportsUserTimingV3) {
              markAndClear("--render-yield");
            }
          }
          function markRenderStopped() {
            if (!isProfiling) {
              return;
            }
            recordReactMeasureCompleted("render");
            if (supportsUserTimingV3) {
              markAndClear("--render-stop");
            }
          }
          function markRenderScheduled(lane) {
            if (!isProfiling) {
              return;
            }
            if (currentTimelineData) {
              currentTimelineData.schedulingEvents.push({
                lanes: laneToLanesArray(lane),
                timestamp: getRelativeTime(),
                type: "schedule-render",
                warning: null
              });
            }
            if (supportsUserTimingV3) {
              markAndClear("--schedule-render-".concat(lane));
            }
          }
          function markForceUpdateScheduled(fiber, lane) {
            if (!isProfiling) {
              return;
            }
            var componentName = getDisplayNameForFiber(fiber) || "Unknown";
            if (currentTimelineData) {
              currentTimelineData.schedulingEvents.push({
                componentName,
                lanes: laneToLanesArray(lane),
                timestamp: getRelativeTime(),
                type: "schedule-force-update",
                warning: null
              });
            }
            if (supportsUserTimingV3) {
              markAndClear("--schedule-forced-update-".concat(lane, "-").concat(componentName));
            }
          }
          function getParentFibers(fiber) {
            var parents = [];
            var parent = fiber;
            while (parent !== null) {
              parents.push(parent);
              parent = parent.return;
            }
            return parents;
          }
          function markStateUpdateScheduled(fiber, lane) {
            if (!isProfiling) {
              return;
            }
            var componentName = getDisplayNameForFiber(fiber) || "Unknown";
            if (currentTimelineData) {
              var event = {
                componentName,
                lanes: laneToLanesArray(lane),
                timestamp: getRelativeTime(),
                type: "schedule-state-update",
                warning: null
              };
              currentFiberStacks.set(event, getParentFibers(fiber));
              currentTimelineData.schedulingEvents.push(event);
            }
            if (supportsUserTimingV3) {
              markAndClear("--schedule-state-update-".concat(lane, "-").concat(componentName));
            }
          }
          function toggleProfilingStatus(value) {
            var recordTimeline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            if (isProfiling !== value) {
              isProfiling = value;
              if (isProfiling) {
                var internalModuleSourceToRanges = new Map;
                if (supportsUserTimingV3) {
                  var ranges = getInternalModuleRanges();
                  if (ranges) {
                    for (var i = 0;i < ranges.length; i++) {
                      var range = ranges[i];
                      if (shared_isArray(range) && range.length === 2) {
                        var _ranges$i2 = profilingHooks_slicedToArray(ranges[i], 2), startStackFrame = _ranges$i2[0], stopStackFrame = _ranges$i2[1];
                        markAndClear("--react-internal-module-start-".concat(startStackFrame));
                        markAndClear("--react-internal-module-stop-".concat(stopStackFrame));
                      }
                    }
                  }
                }
                var laneToReactMeasureMap = new Map;
                var lane = 1;
                for (var index = 0;index < REACT_TOTAL_NUM_LANES; index++) {
                  laneToReactMeasureMap.set(lane, []);
                  lane *= 2;
                }
                currentBatchUID = 0;
                currentReactComponentMeasure = null;
                currentReactMeasuresStack = [];
                currentFiberStacks = new Map;
                if (recordTimeline) {
                  currentTimelineData = {
                    internalModuleSourceToRanges,
                    laneToLabelMap: laneToLabelMap || new Map,
                    reactVersion,
                    componentMeasures: [],
                    schedulingEvents: [],
                    suspenseEvents: [],
                    thrownErrors: [],
                    batchUIDToMeasuresMap: new Map,
                    duration: 0,
                    laneToReactMeasureMap,
                    startTime: 0,
                    flamechart: [],
                    nativeEvents: [],
                    networkMeasures: [],
                    otherUserTimingMarks: [],
                    snapshots: [],
                    snapshotHeight: 0
                  };
                }
                nextRenderShouldStartNewBatch = true;
              } else {
                if (currentTimelineData !== null) {
                  currentTimelineData.schedulingEvents.forEach(function(event) {
                    if (event.type === "schedule-state-update") {
                      var fiberStack = currentFiberStacks.get(event);
                      if (fiberStack && currentDispatcherRef != null) {
                        event.componentStack = fiberStack.reduce(function(trace, fiber) {
                          return trace + describeFiber(workTagMap, fiber, currentDispatcherRef);
                        }, "");
                      }
                    }
                  });
                }
                currentFiberStacks.clear();
              }
            }
          }
          return {
            getTimelineData,
            profilingHooks: {
              markCommitStarted,
              markCommitStopped,
              markComponentRenderStarted,
              markComponentRenderStopped,
              markComponentPassiveEffectMountStarted,
              markComponentPassiveEffectMountStopped,
              markComponentPassiveEffectUnmountStarted,
              markComponentPassiveEffectUnmountStopped,
              markComponentLayoutEffectMountStarted,
              markComponentLayoutEffectMountStopped,
              markComponentLayoutEffectUnmountStarted,
              markComponentLayoutEffectUnmountStopped,
              markComponentErrored,
              markComponentSuspended,
              markLayoutEffectsStarted,
              markLayoutEffectsStopped,
              markPassiveEffectsStarted,
              markPassiveEffectsStopped,
              markRenderStarted,
              markRenderYielded,
              markRenderStopped,
              markRenderScheduled,
              markForceUpdateScheduled,
              markStateUpdateScheduled
            },
            toggleProfilingStatus
          };
        }
        var _excluded = ["batchUIDToMeasuresMap", "internalModuleSourceToRanges", "laneToLabelMap", "laneToReactMeasureMap"];
        function _objectWithoutProperties(source, excluded) {
          if (source == null)
            return {};
          var target = _objectWithoutPropertiesLoose(source, excluded);
          var key, i;
          if (Object.getOwnPropertySymbols) {
            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
            for (i = 0;i < sourceSymbolKeys.length; i++) {
              key = sourceSymbolKeys[i];
              if (excluded.indexOf(key) >= 0)
                continue;
              if (!Object.prototype.propertyIsEnumerable.call(source, key))
                continue;
              target[key] = source[key];
            }
          }
          return target;
        }
        function _objectWithoutPropertiesLoose(source, excluded) {
          if (source == null)
            return {};
          var target = {};
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              if (excluded.indexOf(key) >= 0)
                continue;
              target[key] = source[key];
            }
          }
          return target;
        }
        function renderer_ownKeys(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function(r2) {
              return Object.getOwnPropertyDescriptor(e, r2).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function renderer_objectSpread(e) {
          for (var r = 1;r < arguments.length; r++) {
            var t = arguments[r] != null ? arguments[r] : {};
            r % 2 ? renderer_ownKeys(Object(t), true).forEach(function(r2) {
              renderer_defineProperty(e, r2, t[r2]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : renderer_ownKeys(Object(t)).forEach(function(r2) {
              Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
            });
          }
          return e;
        }
        function renderer_defineProperty(obj, key, value) {
          key = renderer_toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function renderer_toPropertyKey(t) {
          var i = renderer_toPrimitive(t, "string");
          return renderer_typeof(i) == "symbol" ? i : i + "";
        }
        function renderer_toPrimitive(t, r) {
          if (renderer_typeof(t) != "object" || !t)
            return t;
          var e = t[Symbol.toPrimitive];
          if (e !== undefined) {
            var i = e.call(t, r || "default");
            if (renderer_typeof(i) != "object")
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (r === "string" ? String : Number)(t);
        }
        function fiber_renderer_toConsumableArray(arr) {
          return fiber_renderer_arrayWithoutHoles(arr) || fiber_renderer_iterableToArray(arr) || fiber_renderer_unsupportedIterableToArray(arr) || fiber_renderer_nonIterableSpread();
        }
        function fiber_renderer_nonIterableSpread() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function fiber_renderer_iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
            return Array.from(iter);
        }
        function fiber_renderer_arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return fiber_renderer_arrayLikeToArray(arr);
        }
        function _createForOfIteratorHelper(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = fiber_renderer_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it)
                o = it;
              var i = 0;
              var F = function F() {};
              return { s: F, n: function n() {
                if (i >= o.length)
                  return { done: true };
                return { done: false, value: o[i++] };
              }, e: function e(_e) {
                throw _e;
              }, f: F };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var normalCompletion = true, didErr = false, err;
          return { s: function s() {
            it = it.call(o);
          }, n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
          }, e: function e(_e2) {
            didErr = true;
            err = _e2;
          }, f: function f() {
            try {
              if (!normalCompletion && it.return != null)
                it.return();
            } finally {
              if (didErr)
                throw err;
            }
          } };
        }
        function fiber_renderer_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return fiber_renderer_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return fiber_renderer_arrayLikeToArray(o, minLen);
        }
        function fiber_renderer_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len);i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        function renderer_typeof(o) {
          "@babel/helpers - typeof";
          return renderer_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, renderer_typeof(o);
        }
        var renderer_toString = Object.prototype.toString;
        function renderer_isError(object) {
          return renderer_toString.call(object) === "[object Error]";
        }
        var FIBER_INSTANCE = 0;
        var VIRTUAL_INSTANCE = 1;
        var FILTERED_FIBER_INSTANCE = 2;
        function createFiberInstance(fiber) {
          return {
            kind: FIBER_INSTANCE,
            id: getUID(),
            parent: null,
            firstChild: null,
            nextSibling: null,
            source: null,
            logCount: 0,
            treeBaseDuration: 0,
            suspendedBy: null,
            suspenseNode: null,
            data: fiber
          };
        }
        function createFilteredFiberInstance(fiber) {
          return {
            kind: FILTERED_FIBER_INSTANCE,
            id: 0,
            parent: null,
            firstChild: null,
            nextSibling: null,
            source: null,
            logCount: 0,
            treeBaseDuration: 0,
            suspendedBy: null,
            suspenseNode: null,
            data: fiber
          };
        }
        function createVirtualInstance(debugEntry) {
          return {
            kind: VIRTUAL_INSTANCE,
            id: getUID(),
            parent: null,
            firstChild: null,
            nextSibling: null,
            source: null,
            logCount: 0,
            treeBaseDuration: 0,
            suspendedBy: null,
            suspenseNode: null,
            data: debugEntry
          };
        }
        var NoUpdate = 0;
        var ShouldResetChildren = 1;
        var ShouldResetSuspenseChildren = 2;
        var ShouldResetParentSuspenseChildren = 4;
        function createSuspenseNode(instance) {
          return instance.suspenseNode = {
            instance,
            parent: null,
            firstChild: null,
            nextSibling: null,
            rects: null,
            suspendedBy: new Map,
            environments: new Map,
            hasUniqueSuspenders: false,
            hasUnknownSuspenders: false
          };
        }
        function getDispatcherRef(renderer) {
          if (renderer.currentDispatcherRef === undefined) {
            return;
          }
          var injectedRef = renderer.currentDispatcherRef;
          if (typeof injectedRef.H === "undefined" && typeof injectedRef.current !== "undefined") {
            return {
              get H() {
                return injectedRef.current;
              },
              set H(value) {
                injectedRef.current = value;
              }
            };
          }
          return injectedRef;
        }
        function getFiberFlags(fiber) {
          return fiber.flags !== undefined ? fiber.flags : fiber.effectTag;
        }
        var renderer_getCurrentTime = (typeof performance === "undefined" ? "undefined" : renderer_typeof(performance)) === "object" && typeof performance.now === "function" ? function() {
          return performance.now();
        } : function() {
          return Date.now();
        };
        function getInternalReactConstants(version) {
          var ReactPriorityLevels = {
            ImmediatePriority: 99,
            UserBlockingPriority: 98,
            NormalPriority: 97,
            LowPriority: 96,
            IdlePriority: 95,
            NoPriority: 90
          };
          if (gt(version, "17.0.2")) {
            ReactPriorityLevels = {
              ImmediatePriority: 1,
              UserBlockingPriority: 2,
              NormalPriority: 3,
              LowPriority: 4,
              IdlePriority: 5,
              NoPriority: 0
            };
          }
          var StrictModeBits = 0;
          if (gte(version, "18.0.0-alpha")) {
            StrictModeBits = 24;
          } else if (gte(version, "16.9.0")) {
            StrictModeBits = 1;
          } else if (gte(version, "16.3.0")) {
            StrictModeBits = 2;
          }
          var SuspenseyImagesMode = 32;
          var ReactTypeOfWork = null;
          if (gt(version, "17.0.1")) {
            ReactTypeOfWork = {
              CacheComponent: 24,
              ClassComponent: 1,
              ContextConsumer: 9,
              ContextProvider: 10,
              CoroutineComponent: -1,
              CoroutineHandlerPhase: -1,
              DehydratedSuspenseComponent: 18,
              ForwardRef: 11,
              Fragment: 7,
              FunctionComponent: 0,
              HostComponent: 5,
              HostPortal: 4,
              HostRoot: 3,
              HostHoistable: 26,
              HostSingleton: 27,
              HostText: 6,
              IncompleteClassComponent: 17,
              IncompleteFunctionComponent: 28,
              IndeterminateComponent: 2,
              LazyComponent: 16,
              LegacyHiddenComponent: 23,
              MemoComponent: 14,
              Mode: 8,
              OffscreenComponent: 22,
              Profiler: 12,
              ScopeComponent: 21,
              SimpleMemoComponent: 15,
              SuspenseComponent: 13,
              SuspenseListComponent: 19,
              TracingMarkerComponent: 25,
              YieldComponent: -1,
              Throw: 29,
              ViewTransitionComponent: 30,
              ActivityComponent: 31
            };
          } else if (gte(version, "17.0.0-alpha")) {
            ReactTypeOfWork = {
              CacheComponent: -1,
              ClassComponent: 1,
              ContextConsumer: 9,
              ContextProvider: 10,
              CoroutineComponent: -1,
              CoroutineHandlerPhase: -1,
              DehydratedSuspenseComponent: 18,
              ForwardRef: 11,
              Fragment: 7,
              FunctionComponent: 0,
              HostComponent: 5,
              HostPortal: 4,
              HostRoot: 3,
              HostHoistable: -1,
              HostSingleton: -1,
              HostText: 6,
              IncompleteClassComponent: 17,
              IncompleteFunctionComponent: -1,
              IndeterminateComponent: 2,
              LazyComponent: 16,
              LegacyHiddenComponent: 24,
              MemoComponent: 14,
              Mode: 8,
              OffscreenComponent: 23,
              Profiler: 12,
              ScopeComponent: 21,
              SimpleMemoComponent: 15,
              SuspenseComponent: 13,
              SuspenseListComponent: 19,
              TracingMarkerComponent: -1,
              YieldComponent: -1,
              Throw: -1,
              ViewTransitionComponent: -1,
              ActivityComponent: -1
            };
          } else if (gte(version, "16.6.0-beta.0")) {
            ReactTypeOfWork = {
              CacheComponent: -1,
              ClassComponent: 1,
              ContextConsumer: 9,
              ContextProvider: 10,
              CoroutineComponent: -1,
              CoroutineHandlerPhase: -1,
              DehydratedSuspenseComponent: 18,
              ForwardRef: 11,
              Fragment: 7,
              FunctionComponent: 0,
              HostComponent: 5,
              HostPortal: 4,
              HostRoot: 3,
              HostHoistable: -1,
              HostSingleton: -1,
              HostText: 6,
              IncompleteClassComponent: 17,
              IncompleteFunctionComponent: -1,
              IndeterminateComponent: 2,
              LazyComponent: 16,
              LegacyHiddenComponent: -1,
              MemoComponent: 14,
              Mode: 8,
              OffscreenComponent: -1,
              Profiler: 12,
              ScopeComponent: -1,
              SimpleMemoComponent: 15,
              SuspenseComponent: 13,
              SuspenseListComponent: 19,
              TracingMarkerComponent: -1,
              YieldComponent: -1,
              Throw: -1,
              ViewTransitionComponent: -1,
              ActivityComponent: -1
            };
          } else if (gte(version, "16.4.3-alpha")) {
            ReactTypeOfWork = {
              CacheComponent: -1,
              ClassComponent: 2,
              ContextConsumer: 11,
              ContextProvider: 12,
              CoroutineComponent: -1,
              CoroutineHandlerPhase: -1,
              DehydratedSuspenseComponent: -1,
              ForwardRef: 13,
              Fragment: 9,
              FunctionComponent: 0,
              HostComponent: 7,
              HostPortal: 6,
              HostRoot: 5,
              HostHoistable: -1,
              HostSingleton: -1,
              HostText: 8,
              IncompleteClassComponent: -1,
              IncompleteFunctionComponent: -1,
              IndeterminateComponent: 4,
              LazyComponent: -1,
              LegacyHiddenComponent: -1,
              MemoComponent: -1,
              Mode: 10,
              OffscreenComponent: -1,
              Profiler: 15,
              ScopeComponent: -1,
              SimpleMemoComponent: -1,
              SuspenseComponent: 16,
              SuspenseListComponent: -1,
              TracingMarkerComponent: -1,
              YieldComponent: -1,
              Throw: -1,
              ViewTransitionComponent: -1,
              ActivityComponent: -1
            };
          } else {
            ReactTypeOfWork = {
              CacheComponent: -1,
              ClassComponent: 2,
              ContextConsumer: 12,
              ContextProvider: 13,
              CoroutineComponent: 7,
              CoroutineHandlerPhase: 8,
              DehydratedSuspenseComponent: -1,
              ForwardRef: 14,
              Fragment: 10,
              FunctionComponent: 1,
              HostComponent: 5,
              HostPortal: 4,
              HostRoot: 3,
              HostHoistable: -1,
              HostSingleton: -1,
              HostText: 6,
              IncompleteClassComponent: -1,
              IncompleteFunctionComponent: -1,
              IndeterminateComponent: 0,
              LazyComponent: -1,
              LegacyHiddenComponent: -1,
              MemoComponent: -1,
              Mode: 11,
              OffscreenComponent: -1,
              Profiler: 15,
              ScopeComponent: -1,
              SimpleMemoComponent: -1,
              SuspenseComponent: 16,
              SuspenseListComponent: -1,
              TracingMarkerComponent: -1,
              YieldComponent: 9,
              Throw: -1,
              ViewTransitionComponent: -1,
              ActivityComponent: -1
            };
          }
          function getTypeSymbol(type) {
            var symbolOrNumber = renderer_typeof(type) === "object" && type !== null ? type.$$typeof : type;
            return renderer_typeof(symbolOrNumber) === "symbol" ? symbolOrNumber.toString() : symbolOrNumber;
          }
          var _ReactTypeOfWork = ReactTypeOfWork, CacheComponent = _ReactTypeOfWork.CacheComponent, ClassComponent = _ReactTypeOfWork.ClassComponent, IncompleteClassComponent = _ReactTypeOfWork.IncompleteClassComponent, IncompleteFunctionComponent = _ReactTypeOfWork.IncompleteFunctionComponent, FunctionComponent = _ReactTypeOfWork.FunctionComponent, IndeterminateComponent = _ReactTypeOfWork.IndeterminateComponent, ForwardRef = _ReactTypeOfWork.ForwardRef, HostRoot = _ReactTypeOfWork.HostRoot, HostHoistable = _ReactTypeOfWork.HostHoistable, HostSingleton = _ReactTypeOfWork.HostSingleton, HostComponent = _ReactTypeOfWork.HostComponent, HostPortal = _ReactTypeOfWork.HostPortal, HostText = _ReactTypeOfWork.HostText, Fragment = _ReactTypeOfWork.Fragment, LazyComponent = _ReactTypeOfWork.LazyComponent, LegacyHiddenComponent = _ReactTypeOfWork.LegacyHiddenComponent, MemoComponent = _ReactTypeOfWork.MemoComponent, OffscreenComponent = _ReactTypeOfWork.OffscreenComponent, Profiler = _ReactTypeOfWork.Profiler, ScopeComponent = _ReactTypeOfWork.ScopeComponent, SimpleMemoComponent = _ReactTypeOfWork.SimpleMemoComponent, SuspenseComponent = _ReactTypeOfWork.SuspenseComponent, SuspenseListComponent = _ReactTypeOfWork.SuspenseListComponent, TracingMarkerComponent = _ReactTypeOfWork.TracingMarkerComponent, Throw = _ReactTypeOfWork.Throw, ViewTransitionComponent = _ReactTypeOfWork.ViewTransitionComponent, ActivityComponent = _ReactTypeOfWork.ActivityComponent;
          function resolveFiberType(type) {
            var typeSymbol = getTypeSymbol(type);
            switch (typeSymbol) {
              case MEMO_NUMBER:
              case MEMO_SYMBOL_STRING:
                return resolveFiberType(type.type);
              case FORWARD_REF_NUMBER:
              case FORWARD_REF_SYMBOL_STRING:
                return type.render;
              default:
                return type;
            }
          }
          function getDisplayNameForFiber(fiber) {
            var _fiber$updateQueue, _fiber$memoizedState, _fiber$memoizedState$, _fiber$memoizedState2;
            var shouldSkipForgetCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var { elementType, type, tag } = fiber;
            var resolvedType = type;
            if (renderer_typeof(type) === "object" && type !== null) {
              resolvedType = resolveFiberType(type);
            }
            var resolvedContext = null;
            if (!shouldSkipForgetCheck && (((_fiber$updateQueue = fiber.updateQueue) === null || _fiber$updateQueue === undefined ? undefined : _fiber$updateQueue.memoCache) != null || Array.isArray((_fiber$memoizedState = fiber.memoizedState) === null || _fiber$memoizedState === undefined ? undefined : _fiber$memoizedState.memoizedState) && (_fiber$memoizedState$ = fiber.memoizedState.memoizedState[0]) !== null && _fiber$memoizedState$ !== undefined && _fiber$memoizedState$[ReactSymbols_REACT_MEMO_CACHE_SENTINEL] || (_fiber$memoizedState2 = fiber.memoizedState) !== null && _fiber$memoizedState2 !== undefined && (_fiber$memoizedState2 = _fiber$memoizedState2.memoizedState) !== null && _fiber$memoizedState2 !== undefined && _fiber$memoizedState2[ReactSymbols_REACT_MEMO_CACHE_SENTINEL])) {
              var displayNameWithoutForgetWrapper = getDisplayNameForFiber(fiber, true);
              if (displayNameWithoutForgetWrapper == null) {
                return null;
              }
              return "Forget(".concat(displayNameWithoutForgetWrapper, ")");
            }
            switch (tag) {
              case ActivityComponent:
                return "Activity";
              case CacheComponent:
                return "Cache";
              case ClassComponent:
              case IncompleteClassComponent:
              case IncompleteFunctionComponent:
              case FunctionComponent:
              case IndeterminateComponent:
                return getDisplayName(resolvedType);
              case ForwardRef:
                return getWrappedDisplayName(elementType, resolvedType, "ForwardRef", "Anonymous");
              case HostRoot:
                var fiberRoot = fiber.stateNode;
                if (fiberRoot != null && fiberRoot._debugRootType !== null) {
                  return fiberRoot._debugRootType;
                }
                return null;
              case HostComponent:
              case HostSingleton:
              case HostHoistable:
                return type;
              case HostPortal:
              case HostText:
                return null;
              case Fragment:
                return "Fragment";
              case LazyComponent:
                return "Lazy";
              case MemoComponent:
              case SimpleMemoComponent:
                return getWrappedDisplayName(elementType, resolvedType, "Memo", "Anonymous");
              case SuspenseComponent:
                return "Suspense";
              case LegacyHiddenComponent:
                return "LegacyHidden";
              case OffscreenComponent:
                return "Offscreen";
              case ScopeComponent:
                return "Scope";
              case SuspenseListComponent:
                return "SuspenseList";
              case Profiler:
                return "Profiler";
              case TracingMarkerComponent:
                return "TracingMarker";
              case ViewTransitionComponent:
                return "ViewTransition";
              case Throw:
                return "Error";
              default:
                var typeSymbol = getTypeSymbol(type);
                switch (typeSymbol) {
                  case CONCURRENT_MODE_NUMBER:
                  case CONCURRENT_MODE_SYMBOL_STRING:
                  case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
                    return null;
                  case PROVIDER_NUMBER:
                  case PROVIDER_SYMBOL_STRING:
                    resolvedContext = fiber.type._context || fiber.type.context;
                    return "".concat(resolvedContext.displayName || "Context", ".Provider");
                  case CONTEXT_NUMBER:
                  case CONTEXT_SYMBOL_STRING:
                  case SERVER_CONTEXT_SYMBOL_STRING:
                    if (fiber.type._context === undefined && fiber.type.Provider === fiber.type) {
                      resolvedContext = fiber.type;
                      return "".concat(resolvedContext.displayName || "Context", ".Provider");
                    }
                    resolvedContext = fiber.type._context || fiber.type;
                    return "".concat(resolvedContext.displayName || "Context", ".Consumer");
                  case CONSUMER_SYMBOL_STRING:
                    resolvedContext = fiber.type._context;
                    return "".concat(resolvedContext.displayName || "Context", ".Consumer");
                  case STRICT_MODE_NUMBER:
                  case STRICT_MODE_SYMBOL_STRING:
                    return null;
                  case PROFILER_NUMBER:
                  case PROFILER_SYMBOL_STRING:
                    return "Profiler(".concat(fiber.memoizedProps.id, ")");
                  case SCOPE_NUMBER:
                  case SCOPE_SYMBOL_STRING:
                    return "Scope";
                  default:
                    return null;
                }
            }
          }
          return {
            getDisplayNameForFiber,
            getTypeSymbol,
            ReactPriorityLevels,
            ReactTypeOfWork,
            StrictModeBits,
            SuspenseyImagesMode
          };
        }
        var knownEnvironmentNames = new Set;
        var rootToFiberInstanceMap = new Map;
        var idToDevToolsInstanceMap = new Map;
        var idToSuspenseNodeMap = new Map;
        var publicInstanceToDevToolsInstanceMap = new Map;
        var hostResourceToDevToolsInstanceMap = new Map;
        function getPublicInstance(instance) {
          if (renderer_typeof(instance) === "object" && instance !== null) {
            if (renderer_typeof(instance.canonical) === "object" && instance.canonical !== null) {
              if (renderer_typeof(instance.canonical.publicInstance) === "object" && instance.canonical.publicInstance !== null) {
                return instance.canonical.publicInstance;
              }
            }
            if (typeof instance._nativeTag === "number") {
              return instance._nativeTag;
            }
          }
          return instance;
        }
        function getNativeTag(instance) {
          if (renderer_typeof(instance) !== "object" || instance === null) {
            return null;
          }
          if (instance.canonical != null && typeof instance.canonical.nativeTag === "number") {
            return instance.canonical.nativeTag;
          }
          if (typeof instance._nativeTag === "number") {
            return instance._nativeTag;
          }
          return null;
        }
        function aquireHostInstance(nearestInstance, hostInstance) {
          var publicInstance = getPublicInstance(hostInstance);
          publicInstanceToDevToolsInstanceMap.set(publicInstance, nearestInstance);
        }
        function releaseHostInstance(nearestInstance, hostInstance) {
          var publicInstance = getPublicInstance(hostInstance);
          if (publicInstanceToDevToolsInstanceMap.get(publicInstance) === nearestInstance) {
            publicInstanceToDevToolsInstanceMap.delete(publicInstance);
          }
        }
        function aquireHostResource(nearestInstance, resource) {
          var hostInstance = resource && resource.instance;
          if (hostInstance) {
            var publicInstance = getPublicInstance(hostInstance);
            var resourceInstances = hostResourceToDevToolsInstanceMap.get(publicInstance);
            if (resourceInstances === undefined) {
              resourceInstances = new Set;
              hostResourceToDevToolsInstanceMap.set(publicInstance, resourceInstances);
              publicInstanceToDevToolsInstanceMap.set(publicInstance, nearestInstance);
            }
            resourceInstances.add(nearestInstance);
          }
        }
        function releaseHostResource(nearestInstance, resource) {
          var hostInstance = resource && resource.instance;
          if (hostInstance) {
            var publicInstance = getPublicInstance(hostInstance);
            var resourceInstances = hostResourceToDevToolsInstanceMap.get(publicInstance);
            if (resourceInstances !== undefined) {
              resourceInstances.delete(nearestInstance);
              if (resourceInstances.size === 0) {
                hostResourceToDevToolsInstanceMap.delete(publicInstance);
                publicInstanceToDevToolsInstanceMap.delete(publicInstance);
              } else if (publicInstanceToDevToolsInstanceMap.get(publicInstance) === nearestInstance) {
                var _iterator = _createForOfIteratorHelper(resourceInstances), _step;
                try {
                  for (_iterator.s();!(_step = _iterator.n()).done; ) {
                    var firstInstance = _step.value;
                    publicInstanceToDevToolsInstanceMap.set(firstInstance, nearestInstance);
                    break;
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
            }
          }
        }
        function renderer_attach(hook, rendererID, renderer, global2, shouldStartProfilingNow, profilingSettings) {
          var version = renderer.reconcilerVersion || renderer.version;
          var _getInternalReactCons = getInternalReactConstants(version), getDisplayNameForFiber = _getInternalReactCons.getDisplayNameForFiber, getTypeSymbol = _getInternalReactCons.getTypeSymbol, ReactPriorityLevels = _getInternalReactCons.ReactPriorityLevels, ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork, StrictModeBits = _getInternalReactCons.StrictModeBits, SuspenseyImagesMode = _getInternalReactCons.SuspenseyImagesMode;
          var { ActivityComponent, ClassComponent, ContextConsumer, DehydratedSuspenseComponent, ForwardRef, Fragment, FunctionComponent, HostRoot, HostHoistable, HostSingleton, HostPortal, HostComponent, HostText, IncompleteClassComponent, IncompleteFunctionComponent, IndeterminateComponent, LegacyHiddenComponent, MemoComponent, OffscreenComponent, SimpleMemoComponent, SuspenseComponent, SuspenseListComponent, TracingMarkerComponent, Throw, ViewTransitionComponent } = ReactTypeOfWork;
          var { ImmediatePriority, UserBlockingPriority, NormalPriority, LowPriority, IdlePriority, NoPriority } = ReactPriorityLevels;
          var { getLaneLabelMap, injectProfilingHooks, overrideHookState, overrideHookStateDeletePath, overrideHookStateRenamePath, overrideProps, overridePropsDeletePath, overridePropsRenamePath, scheduleRefresh, setErrorHandler, setSuspenseHandler, scheduleUpdate, scheduleRetry, getCurrentFiber } = renderer;
          var supportsTogglingError = typeof setErrorHandler === "function" && typeof scheduleUpdate === "function";
          var supportsTogglingSuspense = typeof setSuspenseHandler === "function" && typeof scheduleUpdate === "function";
          var supportsPerformanceTracks = gte(version, "19.2.0");
          if (typeof scheduleRefresh === "function") {
            renderer.scheduleRefresh = function() {
              try {
                hook.emit("fastRefreshScheduled");
              } finally {
                return scheduleRefresh.apply(undefined, arguments);
              }
            };
          }
          var getTimelineData = null;
          var toggleProfilingStatus = null;
          if (typeof injectProfilingHooks === "function") {
            var response = createProfilingHooks({
              getDisplayNameForFiber,
              getIsProfiling: function getIsProfiling() {
                return isProfiling;
              },
              getLaneLabelMap,
              currentDispatcherRef: getDispatcherRef(renderer),
              workTagMap: ReactTypeOfWork,
              reactVersion: version
            });
            injectProfilingHooks(response.profilingHooks);
            getTimelineData = response.getTimelineData;
            toggleProfilingStatus = response.toggleProfilingStatus;
          }
          var fiberToComponentLogsMap = new WeakMap;
          var needsToFlushComponentLogs = false;
          function bruteForceFlushErrorsAndWarnings() {
            var hasChanges = false;
            var _iterator2 = _createForOfIteratorHelper(idToDevToolsInstanceMap.values()), _step2;
            try {
              for (_iterator2.s();!(_step2 = _iterator2.n()).done; ) {
                var devtoolsInstance = _step2.value;
                if (devtoolsInstance.kind === FIBER_INSTANCE) {
                  var _fiber = devtoolsInstance.data;
                  var componentLogsEntry = fiberToComponentLogsMap.get(_fiber);
                  var changed = recordConsoleLogs(devtoolsInstance, componentLogsEntry);
                  if (changed) {
                    hasChanges = true;
                    updateMostRecentlyInspectedElementIfNecessary(devtoolsInstance.id);
                  }
                } else {}
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            if (hasChanges) {
              flushPendingEvents();
            }
          }
          function clearErrorsAndWarnings() {
            var _iterator3 = _createForOfIteratorHelper(idToDevToolsInstanceMap.values()), _step3;
            try {
              for (_iterator3.s();!(_step3 = _iterator3.n()).done; ) {
                var devtoolsInstance = _step3.value;
                if (devtoolsInstance.kind === FIBER_INSTANCE) {
                  var _fiber2 = devtoolsInstance.data;
                  fiberToComponentLogsMap.delete(_fiber2);
                  if (_fiber2.alternate) {
                    fiberToComponentLogsMap.delete(_fiber2.alternate);
                  }
                } else {
                  componentInfoToComponentLogsMap["delete"](devtoolsInstance.data);
                }
                var changed = recordConsoleLogs(devtoolsInstance, undefined);
                if (changed) {
                  updateMostRecentlyInspectedElementIfNecessary(devtoolsInstance.id);
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
            flushPendingEvents();
          }
          function clearConsoleLogsHelper(instanceID, type) {
            var devtoolsInstance = idToDevToolsInstanceMap.get(instanceID);
            if (devtoolsInstance !== undefined) {
              var componentLogsEntry;
              if (devtoolsInstance.kind === FIBER_INSTANCE) {
                var _fiber3 = devtoolsInstance.data;
                componentLogsEntry = fiberToComponentLogsMap.get(_fiber3);
                if (componentLogsEntry === undefined && _fiber3.alternate !== null) {
                  componentLogsEntry = fiberToComponentLogsMap.get(_fiber3.alternate);
                }
              } else {
                var componentInfo = devtoolsInstance.data;
                componentLogsEntry = componentInfoToComponentLogsMap.get(componentInfo);
              }
              if (componentLogsEntry !== undefined) {
                if (type === "error") {
                  componentLogsEntry.errors.clear();
                  componentLogsEntry.errorsCount = 0;
                } else {
                  componentLogsEntry.warnings.clear();
                  componentLogsEntry.warningsCount = 0;
                }
                var changed = recordConsoleLogs(devtoolsInstance, componentLogsEntry);
                if (changed) {
                  flushPendingEvents();
                  updateMostRecentlyInspectedElementIfNecessary(devtoolsInstance.id);
                }
              }
            }
          }
          function clearErrorsForElementID(instanceID) {
            clearConsoleLogsHelper(instanceID, "error");
          }
          function clearWarningsForElementID(instanceID) {
            clearConsoleLogsHelper(instanceID, "warn");
          }
          function updateMostRecentlyInspectedElementIfNecessary(fiberID) {
            if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === fiberID) {
              hasElementUpdatedSinceLastInspected = true;
            }
          }
          function getComponentStack(topFrame) {
            if (getCurrentFiber == null) {
              return null;
            }
            var current = getCurrentFiber();
            if (current === null) {
              return null;
            }
            if (DevToolsFiberComponentStack_supportsConsoleTasks(current)) {
              return null;
            }
            var dispatcherRef = getDispatcherRef(renderer);
            if (dispatcherRef === undefined) {
              return null;
            }
            var enableOwnerStacks = supportsOwnerStacks(current);
            var componentStack = "";
            if (enableOwnerStacks) {
              var topStackFrames = formatOwnerStack(topFrame);
              if (topStackFrames) {
                componentStack += `
` + topStackFrames;
              }
              componentStack += getOwnerStackByFiberInDev(ReactTypeOfWork, current, dispatcherRef);
            } else {
              componentStack = getStackByFiberInDevAndProd(ReactTypeOfWork, current, dispatcherRef);
            }
            return {
              enableOwnerStacks,
              componentStack
            };
          }
          function onErrorOrWarning(type, args) {
            if (getCurrentFiber == null) {
              return;
            }
            var fiber = getCurrentFiber();
            if (fiber === null) {
              return;
            }
            if (type === "error") {
              if (forceErrorForFibers.get(fiber) === true || fiber.alternate !== null && forceErrorForFibers.get(fiber.alternate) === true) {
                return;
              }
            }
            var message = formatConsoleArgumentsToSingleString.apply(undefined, fiber_renderer_toConsumableArray(args));
            var componentLogsEntry = fiberToComponentLogsMap.get(fiber);
            if (componentLogsEntry === undefined && fiber.alternate !== null) {
              componentLogsEntry = fiberToComponentLogsMap.get(fiber.alternate);
              if (componentLogsEntry !== undefined) {
                fiberToComponentLogsMap.set(fiber, componentLogsEntry);
              }
            }
            if (componentLogsEntry === undefined) {
              componentLogsEntry = {
                errors: new Map,
                errorsCount: 0,
                warnings: new Map,
                warningsCount: 0
              };
              fiberToComponentLogsMap.set(fiber, componentLogsEntry);
            }
            var messageMap = type === "error" ? componentLogsEntry.errors : componentLogsEntry.warnings;
            var count = messageMap.get(message) || 0;
            messageMap.set(message, count + 1);
            if (type === "error") {
              componentLogsEntry.errorsCount++;
            } else {
              componentLogsEntry.warningsCount++;
            }
            needsToFlushComponentLogs = true;
          }
          function debug2(name, instance, parentInstance) {
            var extraString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
            if (__DEBUG__) {
              var displayName = instance.kind === VIRTUAL_INSTANCE ? instance.data.name || "null" : instance.data.tag + ":" + (getDisplayNameForFiber(instance.data) || "null");
              var maybeID = instance.kind === FILTERED_FIBER_INSTANCE ? "<no id>" : instance.id;
              var parentDisplayName = parentInstance === null ? "" : parentInstance.kind === VIRTUAL_INSTANCE ? parentInstance.data.name || "null" : parentInstance.data.tag + ":" + (getDisplayNameForFiber(parentInstance.data) || "null");
              var maybeParentID = parentInstance === null || parentInstance.kind === FILTERED_FIBER_INSTANCE ? "<no id>" : parentInstance.id;
              console.groupCollapsed("[renderer] %c".concat(name, " %c").concat(displayName, " (").concat(maybeID, ") %c").concat(parentInstance ? "".concat(parentDisplayName, " (").concat(maybeParentID, ")") : "", " %c").concat(extraString), "color: red; font-weight: bold;", "color: blue;", "color: purple;", "color: black;");
              console.log(new Error().stack.split(`
`).slice(1).join(`
`));
              console.groupEnd();
            }
          }
          function debugTree(instance) {
            var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            if (__DEBUG__) {
              var name = (instance.kind !== VIRTUAL_INSTANCE ? getDisplayNameForFiber(instance.data) : instance.data.name) || "";
              console.log("  ".repeat(indent) + "- " + (instance.kind === FILTERED_FIBER_INSTANCE ? 0 : instance.id) + " (" + name + ")", "parent", instance.parent === null ? " " : instance.parent.kind === FILTERED_FIBER_INSTANCE ? 0 : instance.parent.id, "next", instance.nextSibling === null ? " " : instance.nextSibling.id);
              var child = instance.firstChild;
              while (child !== null) {
                debugTree(child, indent + 1);
                child = child.nextSibling;
              }
            }
          }
          var hideElementsWithDisplayNames = new Set;
          var hideElementsWithPaths = new Set;
          var hideElementsWithTypes = new Set;
          var hideElementsWithEnvs = new Set;
          var traceUpdatesEnabled = false;
          var traceUpdatesForNodes = new Set;
          function applyComponentFilters(componentFilters) {
            hideElementsWithTypes.clear();
            hideElementsWithDisplayNames.clear();
            hideElementsWithPaths.clear();
            hideElementsWithEnvs.clear();
            componentFilters.forEach(function(componentFilter) {
              if (!componentFilter.isEnabled) {
                return;
              }
              switch (componentFilter.type) {
                case ComponentFilterDisplayName:
                  if (componentFilter.isValid && componentFilter.value !== "") {
                    hideElementsWithDisplayNames.add(new RegExp(componentFilter.value, "i"));
                  }
                  break;
                case ComponentFilterElementType:
                  hideElementsWithTypes.add(componentFilter.value);
                  break;
                case ComponentFilterLocation:
                  if (componentFilter.isValid && componentFilter.value !== "") {
                    hideElementsWithPaths.add(new RegExp(componentFilter.value, "i"));
                  }
                  break;
                case ComponentFilterHOC:
                  hideElementsWithDisplayNames.add(new RegExp("\\("));
                  break;
                case ComponentFilterEnvironmentName:
                  hideElementsWithEnvs.add(componentFilter.value);
                  break;
                default:
                  console.warn('Invalid component filter type "'.concat(componentFilter.type, '"'));
                  break;
              }
            });
          }
          if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ != null) {
            var componentFiltersWithoutLocationBasedOnes = filterOutLocationComponentFilters(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__);
            applyComponentFilters(componentFiltersWithoutLocationBasedOnes);
          } else {
            applyComponentFilters(getDefaultComponentFilters());
          }
          function updateComponentFilters(componentFilters) {
            if (isProfiling) {
              throw Error("Cannot modify filter preferences while profiling");
            }
            hook.getFiberRoots(rendererID).forEach(function(root) {
              var rootInstance = rootToFiberInstanceMap.get(root);
              if (rootInstance === undefined) {
                throw new Error("Expected the root instance to already exist when applying filters");
              }
              currentRoot = rootInstance;
              unmountInstanceRecursively(rootInstance);
              rootToFiberInstanceMap.delete(root);
              flushPendingEvents();
              currentRoot = null;
            });
            applyComponentFilters(componentFilters);
            rootDisplayNameCounter.clear();
            hook.getFiberRoots(rendererID).forEach(function(root) {
              var current = root.current;
              var newRoot = createFiberInstance(current);
              rootToFiberInstanceMap.set(root, newRoot);
              idToDevToolsInstanceMap.set(newRoot.id, newRoot);
              if (trackedPath !== null) {
                mightBeOnTrackedPath = true;
              }
              currentRoot = newRoot;
              setRootPseudoKey(currentRoot.id, root.current);
              mountFiberRecursively(root.current, false);
              flushPendingEvents();
              currentRoot = null;
            });
            flushPendingEvents();
            needsToFlushComponentLogs = false;
          }
          function getEnvironmentNames() {
            return Array.from(knownEnvironmentNames);
          }
          function isFiberHydrated(fiber) {
            if (OffscreenComponent === -1) {
              throw new Error("not implemented for legacy suspense");
            }
            switch (fiber.tag) {
              case HostRoot:
                var rootState = fiber.memoizedState;
                return !rootState.isDehydrated;
              case SuspenseComponent:
                var suspenseState = fiber.memoizedState;
                return suspenseState === null || suspenseState.dehydrated === null;
              default:
                throw new Error("not implemented for work tag " + fiber.tag);
            }
          }
          function shouldFilterVirtual(data, secondaryEnv) {
            if (hideElementsWithTypes.has(types_ElementTypeFunction)) {
              return true;
            }
            if (hideElementsWithDisplayNames.size > 0) {
              var displayName = data.name;
              if (displayName != null) {
                var _iterator4 = _createForOfIteratorHelper(hideElementsWithDisplayNames), _step4;
                try {
                  for (_iterator4.s();!(_step4 = _iterator4.n()).done; ) {
                    var displayNameRegExp = _step4.value;
                    if (displayNameRegExp.test(displayName)) {
                      return true;
                    }
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
              }
            }
            if ((data.env == null || hideElementsWithEnvs.has(data.env)) && (secondaryEnv === null || hideElementsWithEnvs.has(secondaryEnv))) {
              return true;
            }
            return false;
          }
          function shouldFilterFiber(fiber) {
            var { tag, type, key } = fiber;
            switch (tag) {
              case DehydratedSuspenseComponent:
                return true;
              case HostPortal:
              case HostText:
              case LegacyHiddenComponent:
              case OffscreenComponent:
              case Throw:
                return true;
              case HostRoot:
                return false;
              case Fragment:
                return key === null;
              default:
                var typeSymbol = getTypeSymbol(type);
                switch (typeSymbol) {
                  case CONCURRENT_MODE_NUMBER:
                  case CONCURRENT_MODE_SYMBOL_STRING:
                  case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
                  case STRICT_MODE_NUMBER:
                  case STRICT_MODE_SYMBOL_STRING:
                    return true;
                  default:
                    break;
                }
            }
            var elementType = getElementTypeForFiber(fiber);
            if (hideElementsWithTypes.has(elementType)) {
              return true;
            }
            if (hideElementsWithDisplayNames.size > 0) {
              var displayName = getDisplayNameForFiber(fiber);
              if (displayName != null) {
                var _iterator5 = _createForOfIteratorHelper(hideElementsWithDisplayNames), _step5;
                try {
                  for (_iterator5.s();!(_step5 = _iterator5.n()).done; ) {
                    var displayNameRegExp = _step5.value;
                    if (displayNameRegExp.test(displayName)) {
                      return true;
                    }
                  }
                } catch (err) {
                  _iterator5.e(err);
                } finally {
                  _iterator5.f();
                }
              }
            }
            if (hideElementsWithEnvs.has("Client")) {
              switch (tag) {
                case ClassComponent:
                case IncompleteClassComponent:
                case IncompleteFunctionComponent:
                case FunctionComponent:
                case IndeterminateComponent:
                case ForwardRef:
                case MemoComponent:
                case SimpleMemoComponent:
                  return true;
              }
            }
            return false;
          }
          function getElementTypeForFiber(fiber) {
            var { type, tag } = fiber;
            switch (tag) {
              case ActivityComponent:
                return ElementTypeActivity;
              case ClassComponent:
              case IncompleteClassComponent:
                return types_ElementTypeClass;
              case IncompleteFunctionComponent:
              case FunctionComponent:
              case IndeterminateComponent:
                return types_ElementTypeFunction;
              case ForwardRef:
                return types_ElementTypeForwardRef;
              case HostRoot:
                return ElementTypeRoot;
              case HostComponent:
              case HostHoistable:
              case HostSingleton:
                return ElementTypeHostComponent;
              case HostPortal:
              case HostText:
              case Fragment:
                return ElementTypeOtherOrUnknown;
              case MemoComponent:
              case SimpleMemoComponent:
                return types_ElementTypeMemo;
              case SuspenseComponent:
                return ElementTypeSuspense;
              case SuspenseListComponent:
                return ElementTypeSuspenseList;
              case TracingMarkerComponent:
                return ElementTypeTracingMarker;
              case ViewTransitionComponent:
                return ElementTypeViewTransition;
              default:
                var typeSymbol = getTypeSymbol(type);
                switch (typeSymbol) {
                  case CONCURRENT_MODE_NUMBER:
                  case CONCURRENT_MODE_SYMBOL_STRING:
                  case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
                    return ElementTypeOtherOrUnknown;
                  case PROVIDER_NUMBER:
                  case PROVIDER_SYMBOL_STRING:
                    return ElementTypeContext;
                  case CONTEXT_NUMBER:
                  case CONTEXT_SYMBOL_STRING:
                    return ElementTypeContext;
                  case STRICT_MODE_NUMBER:
                  case STRICT_MODE_SYMBOL_STRING:
                    return ElementTypeOtherOrUnknown;
                  case PROFILER_NUMBER:
                  case PROFILER_SYMBOL_STRING:
                    return ElementTypeProfiler;
                  default:
                    return ElementTypeOtherOrUnknown;
                }
            }
          }
          var currentRoot = null;
          function untrackFiber(nearestInstance, fiber) {
            if (forceErrorForFibers.size > 0) {
              forceErrorForFibers.delete(fiber);
              if (fiber.alternate) {
                forceErrorForFibers.delete(fiber.alternate);
              }
              if (forceErrorForFibers.size === 0 && setErrorHandler != null) {
                setErrorHandler(shouldErrorFiberAlwaysNull);
              }
            }
            if (forceFallbackForFibers.size > 0) {
              forceFallbackForFibers.delete(fiber);
              if (fiber.alternate) {
                forceFallbackForFibers.delete(fiber.alternate);
              }
              if (forceFallbackForFibers.size === 0 && setSuspenseHandler != null) {
                setSuspenseHandler(shouldSuspendFiberAlwaysFalse);
              }
            }
            if (fiber.tag === HostHoistable) {
              releaseHostResource(nearestInstance, fiber.memoizedState);
            } else if (fiber.tag === HostComponent || fiber.tag === HostText || fiber.tag === HostSingleton) {
              releaseHostInstance(nearestInstance, fiber.stateNode);
            }
            for (var child = fiber.child;child !== null; child = child.sibling) {
              if (shouldFilterFiber(child)) {
                untrackFiber(nearestInstance, child);
              }
            }
          }
          function getChangeDescription(prevFiber, nextFiber) {
            switch (nextFiber.tag) {
              case ClassComponent:
                if (prevFiber === null) {
                  return {
                    context: null,
                    didHooksChange: false,
                    isFirstMount: true,
                    props: null,
                    state: null
                  };
                } else {
                  var data = {
                    context: getContextChanged(prevFiber, nextFiber),
                    didHooksChange: false,
                    isFirstMount: false,
                    props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),
                    state: getChangedKeys(prevFiber.memoizedState, nextFiber.memoizedState)
                  };
                  return data;
                }
              case IncompleteFunctionComponent:
              case FunctionComponent:
              case IndeterminateComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent:
                if (prevFiber === null) {
                  return {
                    context: null,
                    didHooksChange: false,
                    isFirstMount: true,
                    props: null,
                    state: null
                  };
                } else {
                  var indices = getChangedHooksIndices(prevFiber.memoizedState, nextFiber.memoizedState);
                  var _data = {
                    context: getContextChanged(prevFiber, nextFiber),
                    didHooksChange: indices !== null && indices.length > 0,
                    isFirstMount: false,
                    props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),
                    state: null,
                    hooks: indices
                  };
                  return _data;
                }
              default:
                return null;
            }
          }
          function getContextChanged(prevFiber, nextFiber) {
            var prevContext = prevFiber.dependencies && prevFiber.dependencies.firstContext;
            var nextContext = nextFiber.dependencies && nextFiber.dependencies.firstContext;
            while (prevContext && nextContext) {
              if (prevContext.context !== nextContext.context) {
                return false;
              }
              if (!shared_objectIs(prevContext.memoizedValue, nextContext.memoizedValue)) {
                return true;
              }
              prevContext = prevContext.next;
              nextContext = nextContext.next;
            }
            return false;
          }
          function isHookThatCanScheduleUpdate(hookObject) {
            var queue = hookObject.queue;
            if (!queue) {
              return false;
            }
            var boundHasOwnProperty = shared_hasOwnProperty.bind(queue);
            if (boundHasOwnProperty("pending")) {
              return true;
            }
            return boundHasOwnProperty("value") && boundHasOwnProperty("getSnapshot") && typeof queue.getSnapshot === "function";
          }
          function didStatefulHookChange(prev, next) {
            var prevMemoizedState = prev.memoizedState;
            var nextMemoizedState = next.memoizedState;
            if (isHookThatCanScheduleUpdate(prev)) {
              return prevMemoizedState !== nextMemoizedState;
            }
            return false;
          }
          function getChangedHooksIndices(prev, next) {
            if (prev == null || next == null) {
              return null;
            }
            var indices = [];
            var index = 0;
            while (next !== null) {
              if (didStatefulHookChange(prev, next)) {
                indices.push(index);
              }
              next = next.next;
              prev = prev.next;
              index++;
            }
            return indices;
          }
          function getChangedKeys(prev, next) {
            if (prev == null || next == null) {
              return null;
            }
            var keys = new Set([].concat(fiber_renderer_toConsumableArray(Object.keys(prev)), fiber_renderer_toConsumableArray(Object.keys(next))));
            var changedKeys = [];
            var _iterator6 = _createForOfIteratorHelper(keys), _step6;
            try {
              for (_iterator6.s();!(_step6 = _iterator6.n()).done; ) {
                var key = _step6.value;
                if (prev[key] !== next[key]) {
                  changedKeys.push(key);
                }
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
            return changedKeys;
          }
          function didFiberRender(prevFiber, nextFiber) {
            switch (nextFiber.tag) {
              case ClassComponent:
              case FunctionComponent:
              case ContextConsumer:
              case MemoComponent:
              case SimpleMemoComponent:
              case ForwardRef:
                var PerformedWork = 1;
                return (getFiberFlags(nextFiber) & PerformedWork) === PerformedWork;
              default:
                return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref;
            }
          }
          var pendingOperations = [];
          var pendingRealUnmountedIDs = [];
          var pendingRealUnmountedSuspenseIDs = [];
          var pendingSuspenderChanges = new Set;
          var pendingOperationsQueue = [];
          var pendingStringTable = new Map;
          var pendingStringTableLength = 0;
          var pendingUnmountedRootID = null;
          function pushOperation(op) {
            if (false) {}
            pendingOperations.push(op);
          }
          function shouldBailoutWithPendingOperations() {
            if (isProfiling) {
              if (currentCommitProfilingMetadata != null && currentCommitProfilingMetadata.durations.length > 0) {
                return false;
              }
            }
            return pendingOperations.length === 0 && pendingRealUnmountedIDs.length === 0 && pendingRealUnmountedSuspenseIDs.length === 0 && pendingSuspenderChanges.size === 0 && pendingUnmountedRootID === null;
          }
          function flushOrQueueOperations(operations) {
            if (shouldBailoutWithPendingOperations()) {
              return;
            }
            if (pendingOperationsQueue !== null) {
              pendingOperationsQueue.push(operations);
            } else {
              hook.emit("operations", operations);
            }
          }
          function recordConsoleLogs(instance, componentLogsEntry) {
            if (componentLogsEntry === undefined) {
              if (instance.logCount === 0) {
                return false;
              }
              instance.logCount = 0;
              pushOperation(TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS);
              pushOperation(instance.id);
              pushOperation(0);
              pushOperation(0);
              return true;
            } else {
              var totalCount = componentLogsEntry.errorsCount + componentLogsEntry.warningsCount;
              if (instance.logCount === totalCount) {
                return false;
              }
              instance.logCount = totalCount;
              pushOperation(TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS);
              pushOperation(instance.id);
              pushOperation(componentLogsEntry.errorsCount);
              pushOperation(componentLogsEntry.warningsCount);
              return true;
            }
          }
          function flushPendingEvents() {
            if (shouldBailoutWithPendingOperations()) {
              return;
            }
            var numUnmountIDs = pendingRealUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);
            var numUnmountSuspenseIDs = pendingRealUnmountedSuspenseIDs.length;
            var numSuspenderChanges = pendingSuspenderChanges.size;
            var operations = new Array(2 + 1 + pendingStringTableLength + (numUnmountSuspenseIDs > 0 ? 2 + numUnmountSuspenseIDs : 0) + (numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + pendingOperations.length + (numSuspenderChanges > 0 ? 2 + numSuspenderChanges * 3 : 0));
            var i = 0;
            operations[i++] = rendererID;
            if (currentRoot === null) {
              operations[i++] = -1;
            } else {
              operations[i++] = currentRoot.id;
            }
            operations[i++] = pendingStringTableLength;
            pendingStringTable.forEach(function(entry, stringKey) {
              var encodedString = entry.encodedString;
              var length = encodedString.length;
              operations[i++] = length;
              for (var j2 = 0;j2 < length; j2++) {
                operations[i + j2] = encodedString[j2];
              }
              i += length;
            });
            if (numUnmountSuspenseIDs > 0) {
              operations[i++] = SUSPENSE_TREE_OPERATION_REMOVE;
              operations[i++] = numUnmountSuspenseIDs;
              for (var j = 0;j < pendingRealUnmountedSuspenseIDs.length; j++) {
                operations[i++] = pendingRealUnmountedSuspenseIDs[j];
              }
            }
            if (numUnmountIDs > 0) {
              operations[i++] = TREE_OPERATION_REMOVE;
              operations[i++] = numUnmountIDs;
              for (var _j = 0;_j < pendingRealUnmountedIDs.length; _j++) {
                operations[i++] = pendingRealUnmountedIDs[_j];
              }
              if (pendingUnmountedRootID !== null) {
                operations[i] = pendingUnmountedRootID;
                i++;
              }
            }
            for (var _j2 = 0;_j2 < pendingOperations.length; _j2++) {
              operations[i + _j2] = pendingOperations[_j2];
            }
            i += pendingOperations.length;
            if (numSuspenderChanges > 0) {
              operations[i++] = SUSPENSE_TREE_OPERATION_SUSPENDERS;
              operations[i++] = numSuspenderChanges;
              pendingSuspenderChanges.forEach(function(fiberIdWithChanges) {
                var suspense = idToSuspenseNodeMap.get(fiberIdWithChanges);
                if (suspense === undefined) {
                  throw new Error('Could not send suspender changes for "'.concat(fiberIdWithChanges, '" since the Fiber no longer exists.'));
                }
                operations[i++] = fiberIdWithChanges;
                operations[i++] = suspense.hasUniqueSuspenders ? 1 : 0;
                var instance = suspense.instance;
                var isSuspended = (instance.kind === FIBER_INSTANCE || instance.kind === FILTERED_FIBER_INSTANCE) && instance.data.tag === SuspenseComponent && instance.data.memoizedState !== null;
                operations[i++] = isSuspended ? 1 : 0;
                operations[i++] = suspense.environments.size;
                suspense.environments.forEach(function(count, env2) {
                  operations[i++] = getStringID(env2);
                });
              });
            }
            flushOrQueueOperations(operations);
            pendingOperations.length = 0;
            pendingRealUnmountedIDs.length = 0;
            pendingRealUnmountedSuspenseIDs.length = 0;
            pendingSuspenderChanges.clear();
            pendingUnmountedRootID = null;
            pendingStringTable.clear();
            pendingStringTableLength = 0;
          }
          function measureHostInstance(instance) {
            if (renderer_typeof(instance) !== "object" || instance === null) {
              return null;
            }
            if (typeof instance.getClientRects === "function" || instance.nodeType === 3) {
              var doc = instance.ownerDocument;
              if (instance === doc.documentElement) {
                return [{
                  x: 0,
                  y: 0,
                  width: instance.scrollWidth,
                  height: instance.scrollHeight
                }];
              }
              var result = [];
              var win = doc && doc.defaultView;
              var scrollX = win ? win.scrollX : 0;
              var scrollY = win ? win.scrollY : 0;
              var rects;
              if (instance.nodeType === 3) {
                if (typeof doc.createRange !== "function") {
                  return null;
                }
                var range = doc.createRange();
                if (typeof range.getClientRects !== "function") {
                  return null;
                }
                range.selectNodeContents(instance);
                rects = range.getClientRects();
              } else {
                rects = instance.getClientRects();
              }
              for (var i = 0;i < rects.length; i++) {
                var rect = rects[i];
                result.push({
                  x: rect.x + scrollX,
                  y: rect.y + scrollY,
                  width: rect.width,
                  height: rect.height
                });
              }
              return result;
            }
            if (instance.canonical) {
              var publicInstance = instance.canonical.publicInstance;
              if (!publicInstance) {
                return null;
              }
              if (typeof publicInstance.getBoundingClientRect === "function") {
                return [publicInstance.getBoundingClientRect()];
              }
              if (typeof publicInstance.unstable_getBoundingClientRect === "function") {
                return [publicInstance.unstable_getBoundingClientRect()];
              }
            }
            return null;
          }
          function measureInstance(instance) {
            var hostInstances = findAllCurrentHostInstances(instance);
            var result = null;
            for (var i = 0;i < hostInstances.length; i++) {
              var childResult = measureHostInstance(hostInstances[i]);
              if (childResult !== null) {
                if (result === null) {
                  result = childResult;
                } else {
                  result = result.concat(childResult);
                }
              }
            }
            return result;
          }
          function getStringID(string) {
            if (string === null) {
              return 0;
            }
            var existingEntry = pendingStringTable.get(string);
            if (existingEntry !== undefined) {
              return existingEntry.id;
            }
            var id = pendingStringTable.size + 1;
            var encodedString = utfEncodeString(string);
            pendingStringTable.set(string, {
              encodedString,
              id
            });
            pendingStringTableLength += encodedString.length + 1;
            return id;
          }
          var isInDisconnectedSubtree = false;
          function recordMount(fiber, parentInstance) {
            var isRoot = fiber.tag === HostRoot;
            var fiberInstance;
            if (isRoot) {
              var entry = rootToFiberInstanceMap.get(fiber.stateNode);
              if (entry === undefined) {
                throw new Error("The root should have been registered at this point");
              }
              fiberInstance = entry;
            } else {
              fiberInstance = createFiberInstance(fiber);
            }
            idToDevToolsInstanceMap.set(fiberInstance.id, fiberInstance);
            if (__DEBUG__) {
              debug2("recordMount()", fiberInstance, parentInstance);
            }
            recordReconnect(fiberInstance, parentInstance);
            return fiberInstance;
          }
          function recordReconnect(fiberInstance, parentInstance) {
            if (isInDisconnectedSubtree) {
              return;
            }
            var id = fiberInstance.id;
            var fiber = fiberInstance.data;
            var isProfilingSupported = fiber.hasOwnProperty("treeBaseDuration");
            var isRoot = fiber.tag === HostRoot;
            if (isRoot) {
              var hasOwnerMetadata = fiber.hasOwnProperty("_debugOwner");
              var profilingFlags = 0;
              if (isProfilingSupported) {
                profilingFlags = PROFILING_FLAG_BASIC_SUPPORT;
                if (typeof injectProfilingHooks === "function") {
                  profilingFlags |= PROFILING_FLAG_TIMELINE_SUPPORT;
                }
                if (supportsPerformanceTracks) {
                  profilingFlags |= PROFILING_FLAG_PERFORMANCE_TRACKS_SUPPORT;
                }
              }
              var isProductionBuildOfRenderer = renderer.bundleType === 0;
              pushOperation(TREE_OPERATION_ADD);
              pushOperation(id);
              pushOperation(ElementTypeRoot);
              pushOperation((fiber.mode & StrictModeBits) !== 0 ? 1 : 0);
              pushOperation(profilingFlags);
              pushOperation(!isProductionBuildOfRenderer && StrictModeBits !== 0 ? 1 : 0);
              pushOperation(hasOwnerMetadata ? 1 : 0);
              if (isProfiling) {
                if (displayNamesByRootID !== null) {
                  displayNamesByRootID.set(id, getDisplayNameForRoot(fiber));
                }
              }
            } else {
              var key = fiber.key;
              var displayName = getDisplayNameForFiber(fiber);
              var elementType = getElementTypeForFiber(fiber);
              var debugOwner = getUnfilteredOwner(fiber);
              var ownerInstance = findNearestOwnerInstance(parentInstance, debugOwner);
              if (ownerInstance !== null && debugOwner === fiber._debugOwner && fiber._debugStack != null && ownerInstance.source === null) {
                ownerInstance.source = fiber._debugStack;
              }
              var unfilteredParent = parentInstance;
              while (unfilteredParent !== null && unfilteredParent.kind === FILTERED_FIBER_INSTANCE) {
                unfilteredParent = unfilteredParent.parent;
              }
              var ownerID = ownerInstance === null ? 0 : ownerInstance.id;
              var parentID = unfilteredParent === null ? 0 : unfilteredParent.id;
              var displayNameStringID = getStringID(displayName);
              var keyString = key === null ? null : String(key);
              var keyStringID = getStringID(keyString);
              var nameProp = fiber.tag === SuspenseComponent ? fiber.memoizedProps.name : fiber.tag === ActivityComponent ? fiber.memoizedProps.name : null;
              var namePropString = nameProp == null ? null : String(nameProp);
              var namePropStringID = getStringID(namePropString);
              pushOperation(TREE_OPERATION_ADD);
              pushOperation(id);
              pushOperation(elementType);
              pushOperation(parentID);
              pushOperation(ownerID);
              pushOperation(displayNameStringID);
              pushOperation(keyStringID);
              pushOperation(namePropStringID);
              if ((fiber.mode & StrictModeBits) !== 0) {
                var parentFiber = null;
                var parentFiberInstance = parentInstance;
                while (parentFiberInstance !== null) {
                  if (parentFiberInstance.kind === FIBER_INSTANCE) {
                    parentFiber = parentFiberInstance.data;
                    break;
                  }
                  parentFiberInstance = parentFiberInstance.parent;
                }
                if (parentFiber === null || (parentFiber.mode & StrictModeBits) === 0) {
                  pushOperation(TREE_OPERATION_SET_SUBTREE_MODE);
                  pushOperation(id);
                  pushOperation(StrictMode);
                }
              }
            }
            var componentLogsEntry = fiberToComponentLogsMap.get(fiber);
            if (componentLogsEntry === undefined && fiber.alternate !== null) {
              componentLogsEntry = fiberToComponentLogsMap.get(fiber.alternate);
            }
            recordConsoleLogs(fiberInstance, componentLogsEntry);
            if (isProfilingSupported) {
              recordProfilingDurations(fiberInstance, null);
            }
          }
          function recordVirtualMount(instance, parentInstance, secondaryEnv) {
            var id = instance.id;
            idToDevToolsInstanceMap.set(id, instance);
            recordVirtualReconnect(instance, parentInstance, secondaryEnv);
          }
          function recordVirtualReconnect(instance, parentInstance, secondaryEnv) {
            if (isInDisconnectedSubtree) {
              return;
            }
            var componentInfo = instance.data;
            var key = typeof componentInfo.key === "string" ? componentInfo.key : null;
            var env2 = componentInfo.env;
            var displayName = componentInfo.name || "";
            if (typeof env2 === "string") {
              if (secondaryEnv !== null) {
                displayName = secondaryEnv + "(" + displayName + ")";
              }
              displayName = env2 + "(" + displayName + ")";
            }
            var elementType = types_ElementTypeVirtual;
            var debugOwner = getUnfilteredOwner(componentInfo);
            var ownerInstance = findNearestOwnerInstance(parentInstance, debugOwner);
            if (ownerInstance !== null && debugOwner === componentInfo.owner && componentInfo.debugStack != null && ownerInstance.source === null) {
              ownerInstance.source = componentInfo.debugStack;
            }
            var unfilteredParent = parentInstance;
            while (unfilteredParent !== null && unfilteredParent.kind === FILTERED_FIBER_INSTANCE) {
              unfilteredParent = unfilteredParent.parent;
            }
            var ownerID = ownerInstance === null ? 0 : ownerInstance.id;
            var parentID = unfilteredParent === null ? 0 : unfilteredParent.id;
            var displayNameStringID = getStringID(displayName);
            var keyString = key === null ? null : String(key);
            var keyStringID = getStringID(keyString);
            var namePropStringID = getStringID(null);
            var id = instance.id;
            pushOperation(TREE_OPERATION_ADD);
            pushOperation(id);
            pushOperation(elementType);
            pushOperation(parentID);
            pushOperation(ownerID);
            pushOperation(displayNameStringID);
            pushOperation(keyStringID);
            pushOperation(namePropStringID);
            var componentLogsEntry = componentInfoToComponentLogsMap.get(componentInfo);
            recordConsoleLogs(instance, componentLogsEntry);
          }
          function recordSuspenseMount(suspenseInstance, parentSuspenseInstance) {
            var fiberInstance = suspenseInstance.instance;
            if (fiberInstance.kind === FILTERED_FIBER_INSTANCE) {
              throw new Error("Cannot record a mount for a filtered Fiber instance.");
            }
            var fiberID = fiberInstance.id;
            var unfilteredParent = parentSuspenseInstance;
            while (unfilteredParent !== null && unfilteredParent.instance.kind === FILTERED_FIBER_INSTANCE) {
              unfilteredParent = unfilteredParent.parent;
            }
            var unfilteredParentInstance = unfilteredParent !== null ? unfilteredParent.instance : null;
            if (unfilteredParentInstance !== null && unfilteredParentInstance.kind === FILTERED_FIBER_INSTANCE) {
              throw new Error("Should not have a filtered instance at this point. This is a bug.");
            }
            var parentID = unfilteredParentInstance === null ? 0 : unfilteredParentInstance.id;
            var fiber = fiberInstance.data;
            var props = fiber.memoizedProps;
            var name = fiber.tag !== SuspenseComponent || props === null ? null : props.name || null;
            var nameStringID = getStringID(name);
            var isSuspended = fiber.tag === SuspenseComponent && fiber.memoizedState !== null;
            if (__DEBUG__) {
              console.log("recordSuspenseMount()", suspenseInstance);
            }
            idToSuspenseNodeMap.set(fiberID, suspenseInstance);
            pushOperation(SUSPENSE_TREE_OPERATION_ADD);
            pushOperation(fiberID);
            pushOperation(parentID);
            pushOperation(nameStringID);
            pushOperation(isSuspended ? 1 : 0);
            var rects = suspenseInstance.rects;
            if (rects === null) {
              pushOperation(-1);
            } else {
              pushOperation(rects.length);
              for (var i = 0;i < rects.length; ++i) {
                var rect = rects[i];
                pushOperation(Math.round(rect.x * 1000));
                pushOperation(Math.round(rect.y * 1000));
                pushOperation(Math.round(rect.width * 1000));
                pushOperation(Math.round(rect.height * 1000));
              }
            }
          }
          function recordUnmount(fiberInstance) {
            if (__DEBUG__) {
              debug2("recordUnmount()", fiberInstance, reconcilingParent);
            }
            recordDisconnect(fiberInstance);
            var suspenseNode = fiberInstance.suspenseNode;
            if (suspenseNode !== null) {
              recordSuspenseUnmount(suspenseNode);
            }
            idToDevToolsInstanceMap.delete(fiberInstance.id);
            untrackFiber(fiberInstance, fiberInstance.data);
          }
          function recordDisconnect(fiberInstance) {
            if (isInDisconnectedSubtree) {
              return;
            }
            var fiber = fiberInstance.data;
            if (trackedPathMatchInstance === fiberInstance) {
              setTrackedPath(null);
            }
            var id = fiberInstance.id;
            var isRoot = fiber.tag === HostRoot;
            if (isRoot) {
              pendingUnmountedRootID = id;
            } else {
              pendingRealUnmountedIDs.push(id);
            }
          }
          function recordSuspenseResize(suspenseNode) {
            if (__DEBUG__) {
              console.log("recordSuspenseResize()", suspenseNode);
            }
            var fiberInstance = suspenseNode.instance;
            if (fiberInstance.kind !== FIBER_INSTANCE) {
              return;
            }
            pushOperation(SUSPENSE_TREE_OPERATION_RESIZE);
            pushOperation(fiberInstance.id);
            var rects = suspenseNode.rects;
            if (rects === null) {
              pushOperation(-1);
            } else {
              pushOperation(rects.length);
              for (var i = 0;i < rects.length; ++i) {
                var rect = rects[i];
                pushOperation(Math.round(rect.x * 1000));
                pushOperation(Math.round(rect.y * 1000));
                pushOperation(Math.round(rect.width * 1000));
                pushOperation(Math.round(rect.height * 1000));
              }
            }
          }
          function recordSuspenseSuspenders(suspenseNode) {
            if (__DEBUG__) {
              console.log("recordSuspenseSuspenders()", suspenseNode);
            }
            var fiberInstance = suspenseNode.instance;
            if (fiberInstance.kind !== FIBER_INSTANCE) {
              return;
            }
            suspenseNode.environments.forEach(function(count, env2) {
              getStringID(env2);
            });
            pendingSuspenderChanges.add(fiberInstance.id);
          }
          function recordSuspenseUnmount(suspenseInstance) {
            if (__DEBUG__) {
              console.log("recordSuspenseUnmount()", suspenseInstance, reconcilingParentSuspenseNode);
            }
            var devtoolsInstance = suspenseInstance.instance;
            if (devtoolsInstance.kind !== FIBER_INSTANCE) {
              throw new Error("Can't unmount a filtered SuspenseNode. This is a bug.");
            }
            var fiberInstance = devtoolsInstance;
            var id = fiberInstance.id;
            pendingRealUnmountedSuspenseIDs.push(id);
            pendingSuspenderChanges.delete(id);
            idToSuspenseNodeMap.delete(id);
          }
          var remainingReconcilingChildren = null;
          var previouslyReconciledSibling = null;
          var reconcilingParent = null;
          var remainingReconcilingChildrenSuspenseNodes = null;
          var previouslyReconciledSiblingSuspenseNode = null;
          var reconcilingParentSuspenseNode = null;
          function ioExistsInSuspenseAncestor(suspenseNode, ioInfo) {
            var ancestor = suspenseNode.parent;
            while (ancestor !== null) {
              if (ancestor.suspendedBy.has(ioInfo)) {
                return true;
              }
              ancestor = ancestor.parent;
            }
            return false;
          }
          function insertSuspendedBy(asyncInfo) {
            if (reconcilingParent === null || reconcilingParentSuspenseNode === null) {
              throw new Error("It should not be possible to have suspended data outside the root. " + "Even suspending at the first position is still a child of the root.");
            }
            var parentSuspenseNode = reconcilingParentSuspenseNode;
            var parentInstance = reconcilingParent;
            while (parentInstance.kind === FILTERED_FIBER_INSTANCE && parentInstance.parent !== null && parentInstance !== parentSuspenseNode.instance) {
              parentInstance = parentInstance.parent;
            }
            var suspenseNodeSuspendedBy = parentSuspenseNode.suspendedBy;
            var ioInfo = asyncInfo.awaited;
            var suspendedBySet = suspenseNodeSuspendedBy.get(ioInfo);
            if (suspendedBySet === undefined) {
              suspendedBySet = new Set;
              suspenseNodeSuspendedBy.set(ioInfo, suspendedBySet);
              var env2 = ioInfo.env;
              if (env2 != null) {
                var environmentCounts = parentSuspenseNode.environments;
                var count = environmentCounts.get(env2);
                if (count === undefined || count === 0) {
                  environmentCounts.set(env2, 1);
                  recordSuspenseSuspenders(parentSuspenseNode);
                } else {
                  environmentCounts.set(env2, count + 1);
                }
              }
            }
            if (!suspendedBySet.has(parentInstance)) {
              suspendedBySet.add(parentInstance);
              if (!parentSuspenseNode.hasUniqueSuspenders && !ioExistsInSuspenseAncestor(parentSuspenseNode, ioInfo)) {
                parentSuspenseNode.hasUniqueSuspenders = true;
                recordSuspenseSuspenders(parentSuspenseNode);
              }
            }
            parentSuspenseNode.hasUnknownSuspenders = false;
            var suspendedBy = parentInstance.suspendedBy;
            if (suspendedBy === null) {
              parentInstance.suspendedBy = [asyncInfo];
            } else if (suspendedBy.indexOf(asyncInfo) === -1) {
              suspendedBy.push(asyncInfo);
            }
          }
          function getAwaitInSuspendedByFromIO(suspensedBy, ioInfo) {
            for (var i = 0;i < suspensedBy.length; i++) {
              var asyncInfo = suspensedBy[i];
              if (asyncInfo.awaited === ioInfo) {
                return asyncInfo;
              }
            }
            return null;
          }
          function unblockSuspendedBy(parentSuspenseNode, ioInfo) {
            var firstChild = parentSuspenseNode.firstChild;
            if (firstChild === null) {
              return;
            }
            var node = firstChild;
            while (node !== null) {
              if (node.suspendedBy.has(ioInfo)) {
                if (!node.hasUniqueSuspenders) {
                  recordSuspenseSuspenders(node);
                }
                node.hasUniqueSuspenders = true;
                node.hasUnknownSuspenders = false;
              } else if (node.firstChild !== null) {
                node = node.firstChild;
                continue;
              }
              while (node.nextSibling === null) {
                if (node.parent === null || node.parent === parentSuspenseNode) {
                  return;
                }
                node = node.parent;
              }
              node = node.nextSibling;
            }
          }
          function removePreviousSuspendedBy(instance, previousSuspendedBy, parentSuspenseNode) {
            var suspenseNode = instance.suspenseNode === null ? parentSuspenseNode : instance.suspenseNode;
            if (previousSuspendedBy !== null && suspenseNode !== null) {
              var nextSuspendedBy = instance.suspendedBy;
              var changedEnvironment = false;
              for (var i = 0;i < previousSuspendedBy.length; i++) {
                var asyncInfo = previousSuspendedBy[i];
                if (nextSuspendedBy === null || nextSuspendedBy.indexOf(asyncInfo) === -1 && getAwaitInSuspendedByFromIO(nextSuspendedBy, asyncInfo.awaited) === null) {
                  var ioInfo = asyncInfo.awaited;
                  var suspendedBySet = suspenseNode.suspendedBy.get(ioInfo);
                  if (suspendedBySet === undefined || !suspendedBySet.delete(instance)) {
                    var alreadyRemovedIO = false;
                    for (var j = 0;j < i; j++) {
                      var removedIOInfo = previousSuspendedBy[j].awaited;
                      if (removedIOInfo === ioInfo) {
                        alreadyRemovedIO = true;
                        break;
                      }
                    }
                    if (!alreadyRemovedIO) {
                      throw new Error("We are cleaning up async info that was not on the parent Suspense boundary. " + "This is a bug in React.");
                    }
                  }
                  if (suspendedBySet !== undefined && suspendedBySet.size === 0) {
                    suspenseNode.suspendedBy.delete(ioInfo);
                    var env2 = ioInfo.env;
                    if (env2 != null) {
                      var environmentCounts = suspenseNode.environments;
                      var count = environmentCounts.get(env2);
                      if (count === undefined || count === 0) {
                        throw new Error("We are removing an environment but it was not in the set. " + "This is a bug in React.");
                      }
                      if (count === 1) {
                        environmentCounts.delete(env2);
                        changedEnvironment = true;
                      } else {
                        environmentCounts.set(env2, count - 1);
                      }
                    }
                  }
                  if (suspenseNode.hasUniqueSuspenders && !ioExistsInSuspenseAncestor(suspenseNode, ioInfo)) {
                    unblockSuspendedBy(suspenseNode, ioInfo);
                  }
                }
              }
              if (changedEnvironment) {
                recordSuspenseSuspenders(suspenseNode);
              }
            }
          }
          function insertChild(instance) {
            var parentInstance = reconcilingParent;
            if (parentInstance === null) {
              return;
            }
            instance.parent = parentInstance;
            if (previouslyReconciledSibling === null) {
              previouslyReconciledSibling = instance;
              parentInstance.firstChild = instance;
            } else {
              previouslyReconciledSibling.nextSibling = instance;
              previouslyReconciledSibling = instance;
            }
            instance.nextSibling = null;
            var suspenseNode = instance.suspenseNode;
            if (suspenseNode !== null) {
              var parentNode = reconcilingParentSuspenseNode;
              if (parentNode !== null) {
                suspenseNode.parent = parentNode;
                if (previouslyReconciledSiblingSuspenseNode === null) {
                  previouslyReconciledSiblingSuspenseNode = suspenseNode;
                  parentNode.firstChild = suspenseNode;
                } else {
                  previouslyReconciledSiblingSuspenseNode.nextSibling = suspenseNode;
                  previouslyReconciledSiblingSuspenseNode = suspenseNode;
                }
                suspenseNode.nextSibling = null;
              }
            }
          }
          function moveChild(instance, previousSibling) {
            removeChild(instance, previousSibling);
            insertChild(instance);
          }
          function removeChild(instance, previousSibling) {
            if (instance.parent === null) {
              if (remainingReconcilingChildren === instance) {
                throw new Error("Remaining children should not have items with no parent");
              } else if (instance.nextSibling !== null) {
                throw new Error("A deleted instance should not have next siblings");
              }
              return;
            }
            var parentInstance = reconcilingParent;
            if (parentInstance === null) {
              throw new Error("Should not have a parent if we are at the root");
            }
            if (instance.parent !== parentInstance) {
              throw new Error("Cannot remove a node from a different parent than is being reconciled.");
            }
            if (previousSibling === null) {
              if (remainingReconcilingChildren !== instance) {
                throw new Error("Expected a placed child to be moved from the remaining set.");
              }
              remainingReconcilingChildren = instance.nextSibling;
            } else {
              previousSibling.nextSibling = instance.nextSibling;
            }
            instance.nextSibling = null;
            instance.parent = null;
            var suspenseNode = instance.suspenseNode;
            if (suspenseNode !== null && suspenseNode.parent !== null) {
              var parentNode = reconcilingParentSuspenseNode;
              if (parentNode === null) {
                throw new Error("Should not have a parent if we are at the root");
              }
              if (suspenseNode.parent !== parentNode) {
                throw new Error("Cannot remove a Suspense node from a different parent than is being reconciled.");
              }
              var previousSuspenseSibling = remainingReconcilingChildrenSuspenseNodes;
              if (previousSuspenseSibling === suspenseNode) {
                remainingReconcilingChildrenSuspenseNodes = suspenseNode.nextSibling;
              } else {
                while (previousSuspenseSibling !== null) {
                  if (previousSuspenseSibling.nextSibling === suspenseNode) {
                    previousSuspenseSibling.nextSibling = suspenseNode.nextSibling;
                    break;
                  }
                  previousSuspenseSibling = previousSuspenseSibling.nextSibling;
                }
              }
              suspenseNode.nextSibling = null;
              suspenseNode.parent = null;
            }
          }
          function isHiddenOffscreen(fiber) {
            switch (fiber.tag) {
              case LegacyHiddenComponent:
              case OffscreenComponent:
                return fiber.memoizedState !== null;
              default:
                return false;
            }
          }
          function isSuspendedOffscreen(fiber) {
            switch (fiber.tag) {
              case LegacyHiddenComponent:
              case OffscreenComponent:
                return fiber.memoizedState !== null && fiber.return !== null && fiber.return.tag === SuspenseComponent;
              default:
                return false;
            }
          }
          function unmountRemainingChildren() {
            if (reconcilingParent !== null && (reconcilingParent.kind === FIBER_INSTANCE || reconcilingParent.kind === FILTERED_FIBER_INSTANCE) && isSuspendedOffscreen(reconcilingParent.data) && !isInDisconnectedSubtree) {
              isInDisconnectedSubtree = true;
              try {
                var child = remainingReconcilingChildren;
                while (child !== null) {
                  unmountInstanceRecursively(child);
                  child = remainingReconcilingChildren;
                }
              } finally {
                isInDisconnectedSubtree = false;
              }
            } else {
              var _child = remainingReconcilingChildren;
              while (_child !== null) {
                unmountInstanceRecursively(_child);
                _child = remainingReconcilingChildren;
              }
            }
          }
          function unmountSuspenseChildrenRecursively(contentInstance, stashedSuspenseParent, stashedSuspensePrevious, stashedSuspenseRemaining) {
            unmountInstanceRecursively(contentInstance);
            reconcilingParentSuspenseNode = stashedSuspenseParent;
            previouslyReconciledSiblingSuspenseNode = stashedSuspensePrevious;
            remainingReconcilingChildrenSuspenseNodes = stashedSuspenseRemaining;
            unmountRemainingChildren();
          }
          function isChildOf(parentInstance, childInstance, grandParent) {
            var instance = childInstance.parent;
            while (instance !== null) {
              if (parentInstance === instance) {
                return true;
              }
              if (instance === parentInstance.parent || instance === grandParent) {
                break;
              }
              instance = instance.parent;
            }
            return false;
          }
          function areEqualRects(a, b) {
            if (a === null) {
              return b === null;
            }
            if (b === null) {
              return false;
            }
            if (a.length !== b.length) {
              return false;
            }
            for (var i = 0;i < a.length; i++) {
              var aRect = a[i];
              var bRect = b[i];
              if (aRect.x !== bRect.x || aRect.y !== bRect.y || aRect.width !== bRect.width || aRect.height !== bRect.height) {
                return false;
              }
            }
            return true;
          }
          function measureUnchangedSuspenseNodesRecursively(suspenseNode) {
            if (isInDisconnectedSubtree) {
              return;
            }
            var instance = suspenseNode.instance;
            var isSuspendedSuspenseComponent = (instance.kind === FIBER_INSTANCE || instance.kind === FILTERED_FIBER_INSTANCE) && instance.data.tag === SuspenseComponent && instance.data.memoizedState !== null;
            if (isSuspendedSuspenseComponent) {
              return;
            }
            var parent = instance.parent;
            while (parent !== null) {
              if ((parent.kind === FIBER_INSTANCE || parent.kind === FILTERED_FIBER_INSTANCE) && isHiddenOffscreen(parent.data)) {
                return;
              }
              if (parent.suspenseNode !== null) {
                break;
              }
              parent = parent.parent;
            }
            var nextRects = measureInstance(suspenseNode.instance);
            var prevRects = suspenseNode.rects;
            if (areEqualRects(prevRects, nextRects)) {
              return;
            }
            for (var child = suspenseNode.firstChild;child !== null; child = child.nextSibling) {
              measureUnchangedSuspenseNodesRecursively(child);
            }
            suspenseNode.rects = nextRects;
            recordSuspenseResize(suspenseNode);
          }
          function consumeSuspenseNodesOfExistingInstance(instance) {
            var suspenseNode = remainingReconcilingChildrenSuspenseNodes;
            if (suspenseNode === null) {
              return;
            }
            var parentSuspenseNode = reconcilingParentSuspenseNode;
            if (parentSuspenseNode === null) {
              throw new Error("The should not be any remaining suspense node children if there is no parent.");
            }
            var foundOne = false;
            var previousSkippedSibling = null;
            while (suspenseNode !== null) {
              if (isChildOf(instance, suspenseNode.instance, parentSuspenseNode.instance)) {
                foundOne = true;
                var nextRemainingSibling = suspenseNode.nextSibling;
                if (previousSkippedSibling === null) {
                  remainingReconcilingChildrenSuspenseNodes = nextRemainingSibling;
                } else {
                  previousSkippedSibling.nextSibling = nextRemainingSibling;
                }
                suspenseNode.nextSibling = null;
                if (previouslyReconciledSiblingSuspenseNode === null) {
                  parentSuspenseNode.firstChild = suspenseNode;
                } else {
                  previouslyReconciledSiblingSuspenseNode.nextSibling = suspenseNode;
                }
                previouslyReconciledSiblingSuspenseNode = suspenseNode;
                measureUnchangedSuspenseNodesRecursively(suspenseNode);
                suspenseNode = nextRemainingSibling;
              } else if (foundOne) {
                break;
              } else {
                previousSkippedSibling = suspenseNode;
                suspenseNode = suspenseNode.nextSibling;
              }
            }
          }
          function mountVirtualInstanceRecursively(virtualInstance, firstChild, lastChild, traceNearestHostComponentUpdate, virtualLevel) {
            var mightSiblingsBeOnTrackedPath = updateVirtualTrackedPathStateBeforeMount(virtualInstance, reconcilingParent);
            var stashedParent = reconcilingParent;
            var stashedPrevious = previouslyReconciledSibling;
            var stashedRemaining = remainingReconcilingChildren;
            reconcilingParent = virtualInstance;
            previouslyReconciledSibling = null;
            remainingReconcilingChildren = null;
            try {
              mountVirtualChildrenRecursively(firstChild, lastChild, traceNearestHostComponentUpdate, virtualLevel + 1);
              recordVirtualProfilingDurations(virtualInstance);
            } finally {
              reconcilingParent = stashedParent;
              previouslyReconciledSibling = stashedPrevious;
              remainingReconcilingChildren = stashedRemaining;
              updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);
            }
          }
          function recordVirtualUnmount(instance) {
            recordVirtualDisconnect(instance);
            idToDevToolsInstanceMap.delete(instance.id);
          }
          function recordVirtualDisconnect(instance) {
            if (isInDisconnectedSubtree) {
              return;
            }
            if (trackedPathMatchInstance === instance) {
              setTrackedPath(null);
            }
            var id = instance.id;
            pendingRealUnmountedIDs.push(id);
          }
          function getSecondaryEnvironmentName(debugInfo, index) {
            if (debugInfo != null) {
              var componentInfo = debugInfo[index];
              for (var i = index + 1;i < debugInfo.length; i++) {
                var debugEntry = debugInfo[i];
                if (typeof debugEntry.env === "string") {
                  return componentInfo.env !== debugEntry.env ? debugEntry.env : null;
                }
              }
            }
            return null;
          }
          function trackDebugInfoFromLazyType(fiber) {
            var type = fiber.elementType;
            var typeSymbol = getTypeSymbol(type);
            if (typeSymbol === LAZY_SYMBOL_STRING) {
              var debugInfo = type._debugInfo;
              if (debugInfo) {
                for (var i = 0;i < debugInfo.length; i++) {
                  var debugEntry = debugInfo[i];
                  if (debugEntry.awaited) {
                    var asyncInfo = debugEntry;
                    insertSuspendedBy(asyncInfo);
                  }
                }
              }
            }
          }
          function trackDebugInfoFromUsedThenables(fiber) {
            var dependencies = fiber.dependencies;
            if (dependencies == null) {
              return;
            }
            var thenableState = dependencies._debugThenableState;
            if (thenableState == null) {
              return;
            }
            var usedThenables = thenableState.thenables || thenableState;
            if (!Array.isArray(usedThenables)) {
              return;
            }
            for (var i = 0;i < usedThenables.length; i++) {
              var thenable = usedThenables[i];
              var debugInfo = thenable._debugInfo;
              if (debugInfo) {
                for (var j = 0;j < debugInfo.length; j++) {
                  var debugEntry = debugInfo[j];
                  if (debugEntry.awaited) {
                    var asyncInfo = debugEntry;
                    insertSuspendedBy(asyncInfo);
                  }
                }
              }
            }
          }
          var hostAsyncInfoCache = new WeakMap;
          function trackDebugInfoFromHostResource(devtoolsInstance, fiber) {
            var resource = fiber.memoizedState;
            if (resource == null) {
              return;
            }
            var existingEntry = hostAsyncInfoCache.get(resource);
            if (existingEntry !== undefined) {
              insertSuspendedBy(existingEntry);
              return;
            }
            var props = fiber.memoizedProps;
            var mayResourceSuspendCommit = resource.type === "stylesheet" && (typeof props.media !== "string" || typeof matchMedia !== "function" || matchMedia(props.media));
            if (!mayResourceSuspendCommit) {
              return;
            }
            var instance = resource.instance;
            if (instance == null) {
              return;
            }
            var href = instance.href;
            if (typeof href !== "string") {
              return;
            }
            var start = -1;
            var end = -1;
            var byteSize = 0;
            if (typeof performance.getEntriesByType === "function") {
              var resourceEntries = performance.getEntriesByType("resource");
              for (var i = 0;i < resourceEntries.length; i++) {
                var resourceEntry = resourceEntries[i];
                if (resourceEntry.name === href) {
                  start = resourceEntry.startTime;
                  end = start + resourceEntry.duration;
                  byteSize = resourceEntry.transferSize || 0;
                }
              }
            }
            var value = instance.sheet;
            var promise = Promise.resolve(value);
            promise.status = "fulfilled";
            promise.value = value;
            var ioInfo = {
              name: "stylesheet",
              start,
              end,
              value: promise,
              owner: fiber
            };
            if (byteSize > 0) {
              ioInfo.byteSize = byteSize;
            }
            var asyncInfo = {
              awaited: ioInfo,
              owner: fiber._debugOwner == null ? null : fiber._debugOwner,
              debugStack: fiber._debugStack == null ? null : fiber._debugStack,
              debugTask: fiber._debugTask == null ? null : fiber._debugTask
            };
            hostAsyncInfoCache.set(resource, asyncInfo);
            insertSuspendedBy(asyncInfo);
          }
          function trackDebugInfoFromHostComponent(devtoolsInstance, fiber) {
            if (fiber.tag !== HostComponent) {
              return;
            }
            if ((fiber.mode & SuspenseyImagesMode) === 0) {
              return;
            }
            var type = fiber.type;
            var props = fiber.memoizedProps;
            var maySuspendCommit = type === "img" && props.src != null && props.src !== "" && props.onLoad == null && props.loading !== "lazy";
            if (!maySuspendCommit) {
              return;
            }
            var instance = fiber.stateNode;
            if (instance == null) {
              return;
            }
            var src = instance.currentSrc;
            if (typeof src !== "string" || src === "") {
              return;
            }
            var start = -1;
            var end = -1;
            var byteSize = 0;
            var fileSize = 0;
            if (typeof performance.getEntriesByType === "function") {
              var resourceEntries = performance.getEntriesByType("resource");
              for (var i = 0;i < resourceEntries.length; i++) {
                var resourceEntry = resourceEntries[i];
                if (resourceEntry.name === src) {
                  start = resourceEntry.startTime;
                  end = start + resourceEntry.duration;
                  fileSize = resourceEntry.decodedBodySize || 0;
                  byteSize = resourceEntry.transferSize || 0;
                }
              }
            }
            var value = {
              currentSrc: src
            };
            if (instance.naturalWidth > 0 && instance.naturalHeight > 0) {
              value.naturalWidth = instance.naturalWidth;
              value.naturalHeight = instance.naturalHeight;
            }
            if (fileSize > 0) {
              value.fileSize = fileSize;
            }
            var promise = Promise.resolve(value);
            promise.status = "fulfilled";
            promise.value = value;
            var ioInfo = {
              name: "img",
              start,
              end,
              value: promise,
              owner: fiber
            };
            if (byteSize > 0) {
              ioInfo.byteSize = byteSize;
            }
            var asyncInfo = {
              awaited: ioInfo,
              owner: fiber._debugOwner == null ? null : fiber._debugOwner,
              debugStack: fiber._debugStack == null ? null : fiber._debugStack,
              debugTask: fiber._debugTask == null ? null : fiber._debugTask
            };
            insertSuspendedBy(asyncInfo);
          }
          function trackThrownPromisesFromRetryCache(suspenseNode, retryCache) {
            if (retryCache != null) {
              if (!suspenseNode.hasUniqueSuspenders) {
                recordSuspenseSuspenders(suspenseNode);
              }
              suspenseNode.hasUniqueSuspenders = true;
              suspenseNode.hasUnknownSuspenders = true;
            }
          }
          function mountVirtualChildrenRecursively(firstChild, lastChild, traceNearestHostComponentUpdate, virtualLevel) {
            var fiber = firstChild;
            var previousVirtualInstance = null;
            var previousVirtualInstanceFirstFiber = firstChild;
            while (fiber !== null && fiber !== lastChild) {
              var level = 0;
              if (fiber._debugInfo) {
                for (var i = 0;i < fiber._debugInfo.length; i++) {
                  var debugEntry = fiber._debugInfo[i];
                  if (debugEntry.awaited) {
                    var asyncInfo = debugEntry;
                    if (level === virtualLevel) {
                      insertSuspendedBy(asyncInfo);
                    }
                    continue;
                  }
                  if (typeof debugEntry.name !== "string") {
                    continue;
                  }
                  var componentInfo = debugEntry;
                  var secondaryEnv = getSecondaryEnvironmentName(fiber._debugInfo, i);
                  if (componentInfo.env != null) {
                    knownEnvironmentNames.add(componentInfo.env);
                  }
                  if (secondaryEnv !== null) {
                    knownEnvironmentNames.add(secondaryEnv);
                  }
                  if (shouldFilterVirtual(componentInfo, secondaryEnv)) {
                    continue;
                  }
                  if (level === virtualLevel) {
                    if (previousVirtualInstance === null || previousVirtualInstance.data !== debugEntry) {
                      if (previousVirtualInstance !== null) {
                        mountVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceFirstFiber, fiber, traceNearestHostComponentUpdate, virtualLevel);
                      }
                      previousVirtualInstance = createVirtualInstance(componentInfo);
                      recordVirtualMount(previousVirtualInstance, reconcilingParent, secondaryEnv);
                      insertChild(previousVirtualInstance);
                      previousVirtualInstanceFirstFiber = fiber;
                    }
                    level++;
                    break;
                  } else {
                    level++;
                  }
                }
              }
              if (level === virtualLevel) {
                if (previousVirtualInstance !== null) {
                  mountVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceFirstFiber, fiber, traceNearestHostComponentUpdate, virtualLevel);
                  previousVirtualInstance = null;
                }
                mountFiberRecursively(fiber, traceNearestHostComponentUpdate);
              }
              fiber = fiber.sibling;
            }
            if (previousVirtualInstance !== null) {
              mountVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceFirstFiber, null, traceNearestHostComponentUpdate, virtualLevel);
            }
          }
          function mountChildrenRecursively(firstChild, traceNearestHostComponentUpdate) {
            mountVirtualChildrenRecursively(firstChild, null, traceNearestHostComponentUpdate, 0);
          }
          function mountSuspenseChildrenRecursively(contentFiber, traceNearestHostComponentUpdate, stashedSuspenseParent, stashedSuspensePrevious, stashedSuspenseRemaining) {
            var fallbackFiber = contentFiber.sibling;
            mountVirtualChildrenRecursively(contentFiber, fallbackFiber, traceNearestHostComponentUpdate, 0);
            reconcilingParentSuspenseNode = stashedSuspenseParent;
            previouslyReconciledSiblingSuspenseNode = stashedSuspensePrevious;
            remainingReconcilingChildrenSuspenseNodes = stashedSuspenseRemaining;
            if (fallbackFiber !== null) {
              mountVirtualChildrenRecursively(fallbackFiber, null, traceNearestHostComponentUpdate, 0);
            }
          }
          function mountFiberRecursively(fiber, traceNearestHostComponentUpdate) {
            var shouldIncludeInTree = !shouldFilterFiber(fiber);
            var newInstance = null;
            var newSuspenseNode = null;
            if (shouldIncludeInTree) {
              newInstance = recordMount(fiber, reconcilingParent);
              if (fiber.tag === SuspenseComponent || fiber.tag === HostRoot) {
                newSuspenseNode = createSuspenseNode(newInstance);
                if (fiber.tag === SuspenseComponent) {
                  if (OffscreenComponent === -1) {
                    var isTimedOut = fiber.memoizedState !== null;
                    if (!isTimedOut) {
                      newSuspenseNode.rects = measureInstance(newInstance);
                    }
                  } else {
                    var hydrated = isFiberHydrated(fiber);
                    if (hydrated) {
                      var contentFiber = fiber.child;
                      if (contentFiber === null) {
                        throw new Error("There should always be an Offscreen Fiber child in a hydrated Suspense boundary.");
                      }
                    } else {}
                    var _isTimedOut = fiber.memoizedState !== null;
                    if (!_isTimedOut) {
                      newSuspenseNode.rects = measureInstance(newInstance);
                    }
                  }
                } else {
                  newSuspenseNode.rects = measureInstance(newInstance);
                }
                recordSuspenseMount(newSuspenseNode, reconcilingParentSuspenseNode);
              }
              insertChild(newInstance);
              if (__DEBUG__) {
                debug2("mountFiberRecursively()", newInstance, reconcilingParent);
              }
            } else if (reconcilingParent !== null && reconcilingParent.kind === VIRTUAL_INSTANCE || fiber.tag === SuspenseComponent || fiber.tag === OffscreenComponent || fiber.tag === LegacyHiddenComponent) {
              if (reconcilingParent !== null && reconcilingParent.kind === VIRTUAL_INSTANCE && reconcilingParent.data === fiber._debugOwner && fiber._debugStack != null && reconcilingParent.source === null) {
                reconcilingParent.source = fiber._debugStack;
              }
              newInstance = createFilteredFiberInstance(fiber);
              if (fiber.tag === SuspenseComponent) {
                newSuspenseNode = createSuspenseNode(newInstance);
                if (OffscreenComponent === -1) {
                  var _isTimedOut2 = fiber.memoizedState !== null;
                  if (!_isTimedOut2) {
                    newSuspenseNode.rects = measureInstance(newInstance);
                  }
                } else {
                  var _hydrated = isFiberHydrated(fiber);
                  if (_hydrated) {
                    var _contentFiber = fiber.child;
                    if (_contentFiber === null) {
                      throw new Error("There should always be an Offscreen Fiber child in a hydrated Suspense boundary.");
                    }
                  } else {}
                  var suspenseState = fiber.memoizedState;
                  var _isTimedOut3 = suspenseState !== null;
                  if (!_isTimedOut3) {
                    newSuspenseNode.rects = measureInstance(newInstance);
                  }
                }
              }
              insertChild(newInstance);
              if (__DEBUG__) {
                debug2("mountFiberRecursively()", newInstance, reconcilingParent);
              }
            }
            var mightSiblingsBeOnTrackedPath = updateTrackedPathStateBeforeMount(fiber, newInstance);
            var stashedParent = reconcilingParent;
            var stashedPrevious = previouslyReconciledSibling;
            var stashedRemaining = remainingReconcilingChildren;
            var stashedSuspenseParent = reconcilingParentSuspenseNode;
            var stashedSuspensePrevious = previouslyReconciledSiblingSuspenseNode;
            var stashedSuspenseRemaining = remainingReconcilingChildrenSuspenseNodes;
            if (newInstance !== null) {
              reconcilingParent = newInstance;
              previouslyReconciledSibling = null;
              remainingReconcilingChildren = null;
            }
            var shouldPopSuspenseNode = false;
            if (newSuspenseNode !== null) {
              reconcilingParentSuspenseNode = newSuspenseNode;
              previouslyReconciledSiblingSuspenseNode = null;
              remainingReconcilingChildrenSuspenseNodes = null;
              shouldPopSuspenseNode = true;
            }
            try {
              if (traceUpdatesEnabled) {
                if (traceNearestHostComponentUpdate) {
                  var elementType = getElementTypeForFiber(fiber);
                  if (elementType === ElementTypeHostComponent) {
                    traceUpdatesForNodes.add(fiber.stateNode);
                    traceNearestHostComponentUpdate = false;
                  }
                }
              }
              trackDebugInfoFromLazyType(fiber);
              trackDebugInfoFromUsedThenables(fiber);
              if (fiber.tag === HostHoistable) {
                var nearestInstance = reconcilingParent;
                if (nearestInstance === null) {
                  throw new Error("Did not expect a host hoistable to be the root");
                }
                aquireHostResource(nearestInstance, fiber.memoizedState);
                trackDebugInfoFromHostResource(nearestInstance, fiber);
              } else if (fiber.tag === HostComponent || fiber.tag === HostText || fiber.tag === HostSingleton) {
                var _nearestInstance = reconcilingParent;
                if (_nearestInstance === null) {
                  throw new Error("Did not expect a host hoistable to be the root");
                }
                aquireHostInstance(_nearestInstance, fiber.stateNode);
                trackDebugInfoFromHostComponent(_nearestInstance, fiber);
              }
              if (isSuspendedOffscreen(fiber)) {
                var stashedDisconnected = isInDisconnectedSubtree;
                isInDisconnectedSubtree = true;
                try {
                  if (fiber.child !== null) {
                    mountChildrenRecursively(fiber.child, false);
                  }
                } finally {
                  isInDisconnectedSubtree = stashedDisconnected;
                }
              } else if (isHiddenOffscreen(fiber)) {} else if (fiber.tag === SuspenseComponent && OffscreenComponent === -1) {
                if (newSuspenseNode !== null) {
                  trackThrownPromisesFromRetryCache(newSuspenseNode, fiber.stateNode);
                }
                var _isTimedOut4 = fiber.memoizedState !== null;
                if (_isTimedOut4) {
                  var primaryChildFragment = fiber.child;
                  var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;
                  if (fallbackChildFragment) {
                    var fallbackChild = fallbackChildFragment.child;
                    if (fallbackChild !== null) {
                      updateTrackedPathStateBeforeMount(fallbackChildFragment, null);
                      mountChildrenRecursively(fallbackChild, traceNearestHostComponentUpdate);
                    }
                  }
                } else {
                  var primaryChild = fiber.child;
                  if (primaryChild !== null) {
                    mountChildrenRecursively(primaryChild, traceNearestHostComponentUpdate);
                  }
                }
              } else if (fiber.tag === SuspenseComponent && OffscreenComponent !== -1 && newInstance !== null && newSuspenseNode !== null) {
                var _contentFiber2 = fiber.child;
                var _hydrated2 = isFiberHydrated(fiber);
                if (_hydrated2) {
                  if (_contentFiber2 === null) {
                    throw new Error("There should always be an Offscreen Fiber child in a hydrated Suspense boundary.");
                  }
                  trackThrownPromisesFromRetryCache(newSuspenseNode, fiber.stateNode);
                  mountSuspenseChildrenRecursively(_contentFiber2, traceNearestHostComponentUpdate, stashedSuspenseParent, stashedSuspensePrevious, stashedSuspenseRemaining);
                  shouldPopSuspenseNode = false;
                } else {}
              } else {
                if (fiber.child !== null) {
                  mountChildrenRecursively(fiber.child, traceNearestHostComponentUpdate);
                }
              }
            } finally {
              if (newInstance !== null) {
                reconcilingParent = stashedParent;
                previouslyReconciledSibling = stashedPrevious;
                remainingReconcilingChildren = stashedRemaining;
              }
              if (shouldPopSuspenseNode) {
                reconcilingParentSuspenseNode = stashedSuspenseParent;
                previouslyReconciledSiblingSuspenseNode = stashedSuspensePrevious;
                remainingReconcilingChildrenSuspenseNodes = stashedSuspenseRemaining;
              }
            }
            updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);
          }
          function unmountInstanceRecursively(instance) {
            if (__DEBUG__) {
              debug2("unmountInstanceRecursively()", instance, reconcilingParent);
            }
            var shouldPopSuspenseNode = false;
            var stashedParent = reconcilingParent;
            var stashedPrevious = previouslyReconciledSibling;
            var stashedRemaining = remainingReconcilingChildren;
            var stashedSuspenseParent = reconcilingParentSuspenseNode;
            var stashedSuspensePrevious = previouslyReconciledSiblingSuspenseNode;
            var stashedSuspenseRemaining = remainingReconcilingChildrenSuspenseNodes;
            var previousSuspendedBy = instance.suspendedBy;
            reconcilingParent = instance;
            previouslyReconciledSibling = null;
            remainingReconcilingChildren = instance.firstChild;
            instance.firstChild = null;
            instance.suspendedBy = null;
            if (instance.suspenseNode !== null) {
              reconcilingParentSuspenseNode = instance.suspenseNode;
              previouslyReconciledSiblingSuspenseNode = null;
              remainingReconcilingChildrenSuspenseNodes = instance.suspenseNode.firstChild;
              shouldPopSuspenseNode = true;
            }
            try {
              if ((instance.kind === FIBER_INSTANCE || instance.kind === FILTERED_FIBER_INSTANCE) && instance.data.tag === SuspenseComponent && OffscreenComponent !== -1) {
                var _fiber4 = instance.data;
                var contentFiberInstance = remainingReconcilingChildren;
                var hydrated = isFiberHydrated(_fiber4);
                if (hydrated) {
                  if (contentFiberInstance === null) {
                    throw new Error("There should always be an Offscreen Fiber child in a hydrated Suspense boundary.");
                  }
                  unmountSuspenseChildrenRecursively(contentFiberInstance, stashedSuspenseParent, stashedSuspensePrevious, stashedSuspenseRemaining);
                  shouldPopSuspenseNode = false;
                } else {
                  if (contentFiberInstance !== null) {
                    throw new Error("A dehydrated Suspense node should not have a content Fiber.");
                  }
                }
              } else {
                unmountRemainingChildren();
              }
              removePreviousSuspendedBy(instance, previousSuspendedBy, reconcilingParentSuspenseNode);
            } finally {
              reconcilingParent = stashedParent;
              previouslyReconciledSibling = stashedPrevious;
              remainingReconcilingChildren = stashedRemaining;
              if (shouldPopSuspenseNode) {
                reconcilingParentSuspenseNode = stashedSuspenseParent;
                previouslyReconciledSiblingSuspenseNode = stashedSuspensePrevious;
                remainingReconcilingChildrenSuspenseNodes = stashedSuspenseRemaining;
              }
            }
            if (instance.kind === FIBER_INSTANCE) {
              recordUnmount(instance);
            } else if (instance.kind === VIRTUAL_INSTANCE) {
              recordVirtualUnmount(instance);
            } else {
              untrackFiber(instance, instance.data);
            }
            removeChild(instance, null);
          }
          function recordProfilingDurations(fiberInstance, prevFiber) {
            var id = fiberInstance.id;
            var fiber = fiberInstance.data;
            var { actualDuration, treeBaseDuration } = fiber;
            fiberInstance.treeBaseDuration = treeBaseDuration || 0;
            if (isProfiling) {
              if (prevFiber == null || treeBaseDuration !== prevFiber.treeBaseDuration) {
                var convertedTreeBaseDuration = Math.floor((treeBaseDuration || 0) * 1000);
                pushOperation(TREE_OPERATION_UPDATE_TREE_BASE_DURATION);
                pushOperation(id);
                pushOperation(convertedTreeBaseDuration);
              }
              if (prevFiber == null || didFiberRender(prevFiber, fiber)) {
                if (actualDuration != null) {
                  var selfDuration = actualDuration;
                  var child = fiber.child;
                  while (child !== null) {
                    selfDuration -= child.actualDuration || 0;
                    child = child.sibling;
                  }
                  var metadata = currentCommitProfilingMetadata;
                  metadata.durations.push(id, actualDuration, selfDuration);
                  metadata.maxActualDuration = Math.max(metadata.maxActualDuration, actualDuration);
                  if (recordChangeDescriptions) {
                    var changeDescription = getChangeDescription(prevFiber, fiber);
                    if (changeDescription !== null) {
                      if (metadata.changeDescriptions !== null) {
                        metadata.changeDescriptions.set(id, changeDescription);
                      }
                    }
                  }
                }
              }
              var fiberRoot = currentRoot.data.stateNode;
              var updaters = fiberRoot.memoizedUpdaters;
              if (updaters != null && (updaters.has(fiber) || fiber.alternate !== null && updaters.has(fiber.alternate))) {
                var _metadata = currentCommitProfilingMetadata;
                if (_metadata.updaters === null) {
                  _metadata.updaters = [];
                }
                _metadata.updaters.push(instanceToSerializedElement(fiberInstance));
              }
            }
          }
          function recordVirtualProfilingDurations(virtualInstance) {
            var id = virtualInstance.id;
            var treeBaseDuration = 0;
            for (var child = virtualInstance.firstChild;child !== null; child = child.nextSibling) {
              treeBaseDuration += child.treeBaseDuration;
            }
            if (isProfiling) {
              var previousTreeBaseDuration = virtualInstance.treeBaseDuration;
              if (treeBaseDuration !== previousTreeBaseDuration) {
                var convertedTreeBaseDuration = Math.floor((treeBaseDuration || 0) * 1000);
                pushOperation(TREE_OPERATION_UPDATE_TREE_BASE_DURATION);
                pushOperation(id);
                pushOperation(convertedTreeBaseDuration);
              }
            }
            virtualInstance.treeBaseDuration = treeBaseDuration;
          }
          function addUnfilteredChildrenIDs(parentInstance, nextChildren) {
            var child = parentInstance.firstChild;
            while (child !== null) {
              if (child.kind === FILTERED_FIBER_INSTANCE) {
                var _fiber5 = child.data;
                if (isHiddenOffscreen(_fiber5)) {} else {
                  addUnfilteredChildrenIDs(child, nextChildren);
                }
              } else {
                nextChildren.push(child.id);
              }
              child = child.nextSibling;
            }
          }
          function recordResetChildren(parentInstance) {
            if (__DEBUG__) {
              if (parentInstance.firstChild !== null) {
                debug2("recordResetChildren()", parentInstance.firstChild, parentInstance);
              }
            }
            var nextChildren = [];
            addUnfilteredChildrenIDs(parentInstance, nextChildren);
            var numChildren = nextChildren.length;
            if (numChildren < 2) {
              return;
            }
            pushOperation(TREE_OPERATION_REORDER_CHILDREN);
            pushOperation(parentInstance.id);
            pushOperation(numChildren);
            for (var i = 0;i < nextChildren.length; i++) {
              pushOperation(nextChildren[i]);
            }
          }
          function addUnfilteredSuspenseChildrenIDs(parentInstance, nextChildren) {
            var child = parentInstance.firstChild;
            while (child !== null) {
              if (child.instance.kind === FILTERED_FIBER_INSTANCE) {
                addUnfilteredSuspenseChildrenIDs(child, nextChildren);
              } else {
                nextChildren.push(child.instance.id);
              }
              child = child.nextSibling;
            }
          }
          function recordResetSuspenseChildren(parentInstance) {
            if (__DEBUG__) {
              if (parentInstance.firstChild !== null) {
                console.log("recordResetSuspenseChildren()", parentInstance.firstChild, parentInstance);
              }
            }
            var nextChildren = [];
            addUnfilteredSuspenseChildrenIDs(parentInstance, nextChildren);
            var numChildren = nextChildren.length;
            if (numChildren < 2) {
              return;
            }
            pushOperation(SUSPENSE_TREE_OPERATION_REORDER_CHILDREN);
            pushOperation(parentInstance.instance.id);
            pushOperation(numChildren);
            for (var i = 0;i < nextChildren.length; i++) {
              pushOperation(nextChildren[i]);
            }
          }
          function updateVirtualInstanceRecursively(virtualInstance, nextFirstChild, nextLastChild, prevFirstChild, traceNearestHostComponentUpdate, virtualLevel) {
            var stashedParent = reconcilingParent;
            var stashedPrevious = previouslyReconciledSibling;
            var stashedRemaining = remainingReconcilingChildren;
            var previousSuspendedBy = virtualInstance.suspendedBy;
            reconcilingParent = virtualInstance;
            previouslyReconciledSibling = null;
            remainingReconcilingChildren = virtualInstance.firstChild;
            virtualInstance.firstChild = null;
            virtualInstance.suspendedBy = null;
            try {
              var updateFlags = updateVirtualChildrenRecursively(nextFirstChild, nextLastChild, prevFirstChild, traceNearestHostComponentUpdate, virtualLevel + 1);
              if ((updateFlags & ShouldResetChildren) !== NoUpdate) {
                if (!isInDisconnectedSubtree) {
                  recordResetChildren(virtualInstance);
                }
                updateFlags &= ~ShouldResetChildren;
              }
              removePreviousSuspendedBy(virtualInstance, previousSuspendedBy, reconcilingParentSuspenseNode);
              var componentLogsEntry = componentInfoToComponentLogsMap.get(virtualInstance.data);
              recordConsoleLogs(virtualInstance, componentLogsEntry);
              recordVirtualProfilingDurations(virtualInstance);
              return updateFlags;
            } finally {
              unmountRemainingChildren();
              reconcilingParent = stashedParent;
              previouslyReconciledSibling = stashedPrevious;
              remainingReconcilingChildren = stashedRemaining;
            }
          }
          function updateVirtualChildrenRecursively(nextFirstChild, nextLastChild, prevFirstChild, traceNearestHostComponentUpdate, virtualLevel) {
            var updateFlags = NoUpdate;
            var nextChild = nextFirstChild;
            var prevChildAtSameIndex = prevFirstChild;
            var previousVirtualInstance = null;
            var previousVirtualInstanceWasMount = false;
            var previousVirtualInstanceNextFirstFiber = nextFirstChild;
            var previousVirtualInstancePrevFirstFiber = prevFirstChild;
            while (nextChild !== null && nextChild !== nextLastChild) {
              var level = 0;
              if (nextChild._debugInfo) {
                for (var i = 0;i < nextChild._debugInfo.length; i++) {
                  var debugEntry = nextChild._debugInfo[i];
                  if (debugEntry.awaited) {
                    var asyncInfo = debugEntry;
                    if (level === virtualLevel) {
                      insertSuspendedBy(asyncInfo);
                    }
                    continue;
                  }
                  if (typeof debugEntry.name !== "string") {
                    continue;
                  }
                  var componentInfo = debugEntry;
                  var secondaryEnv = getSecondaryEnvironmentName(nextChild._debugInfo, i);
                  if (componentInfo.env != null) {
                    knownEnvironmentNames.add(componentInfo.env);
                  }
                  if (secondaryEnv !== null) {
                    knownEnvironmentNames.add(secondaryEnv);
                  }
                  if (shouldFilterVirtual(componentInfo, secondaryEnv)) {
                    continue;
                  }
                  if (level === virtualLevel) {
                    if (previousVirtualInstance === null || previousVirtualInstance.data !== componentInfo) {
                      if (previousVirtualInstance !== null) {
                        if (previousVirtualInstanceWasMount) {
                          mountVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceNextFirstFiber, nextChild, traceNearestHostComponentUpdate, virtualLevel);
                          updateFlags |= ShouldResetChildren | ShouldResetSuspenseChildren;
                        } else {
                          updateFlags |= updateVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceNextFirstFiber, nextChild, previousVirtualInstancePrevFirstFiber, traceNearestHostComponentUpdate, virtualLevel);
                        }
                      }
                      var previousSiblingOfBestMatch = null;
                      var bestMatch = remainingReconcilingChildren;
                      if (componentInfo.key != null) {
                        bestMatch = remainingReconcilingChildren;
                        while (bestMatch !== null) {
                          if (bestMatch.kind === VIRTUAL_INSTANCE && bestMatch.data.key === componentInfo.key) {
                            break;
                          }
                          previousSiblingOfBestMatch = bestMatch;
                          bestMatch = bestMatch.nextSibling;
                        }
                      }
                      if (bestMatch !== null && bestMatch.kind === VIRTUAL_INSTANCE && bestMatch.data.name === componentInfo.name && bestMatch.data.env === componentInfo.env && bestMatch.data.key === componentInfo.key) {
                        bestMatch.data = componentInfo;
                        moveChild(bestMatch, previousSiblingOfBestMatch);
                        previousVirtualInstance = bestMatch;
                        previousVirtualInstanceWasMount = false;
                      } else {
                        var newVirtualInstance = createVirtualInstance(componentInfo);
                        recordVirtualMount(newVirtualInstance, reconcilingParent, secondaryEnv);
                        insertChild(newVirtualInstance);
                        previousVirtualInstance = newVirtualInstance;
                        previousVirtualInstanceWasMount = true;
                        updateFlags |= ShouldResetChildren;
                      }
                      previousVirtualInstanceNextFirstFiber = nextChild;
                      previousVirtualInstancePrevFirstFiber = prevChildAtSameIndex;
                    }
                    level++;
                    break;
                  } else {
                    level++;
                  }
                }
              }
              if (level === virtualLevel) {
                if (previousVirtualInstance !== null) {
                  if (previousVirtualInstanceWasMount) {
                    mountVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceNextFirstFiber, nextChild, traceNearestHostComponentUpdate, virtualLevel);
                    updateFlags |= ShouldResetChildren | ShouldResetSuspenseChildren;
                  } else {
                    updateFlags |= updateVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceNextFirstFiber, nextChild, previousVirtualInstancePrevFirstFiber, traceNearestHostComponentUpdate, virtualLevel);
                  }
                  previousVirtualInstance = null;
                }
                var prevChild = undefined;
                if (prevChildAtSameIndex === nextChild) {
                  prevChild = nextChild;
                } else {
                  prevChild = nextChild.alternate;
                }
                var previousSiblingOfExistingInstance = null;
                var existingInstance = null;
                if (prevChild !== null) {
                  existingInstance = remainingReconcilingChildren;
                  while (existingInstance !== null) {
                    if (existingInstance.data === prevChild) {
                      break;
                    }
                    previousSiblingOfExistingInstance = existingInstance;
                    existingInstance = existingInstance.nextSibling;
                  }
                }
                if (existingInstance !== null) {
                  var fiberInstance = existingInstance;
                  if (prevChild !== prevChildAtSameIndex) {
                    updateFlags |= ShouldResetChildren | ShouldResetSuspenseChildren;
                  }
                  moveChild(fiberInstance, previousSiblingOfExistingInstance);
                  updateFlags |= updateFiberRecursively(fiberInstance, nextChild, prevChild, traceNearestHostComponentUpdate);
                } else if (prevChild !== null && shouldFilterFiber(nextChild)) {
                  if (prevChild !== prevChildAtSameIndex) {
                    updateFlags |= ShouldResetChildren | ShouldResetSuspenseChildren;
                  }
                  updateFlags |= updateFiberRecursively(null, nextChild, prevChild, traceNearestHostComponentUpdate);
                } else {
                  mountFiberRecursively(nextChild, traceNearestHostComponentUpdate);
                  updateFlags |= ShouldResetChildren | ShouldResetSuspenseChildren;
                }
              }
              nextChild = nextChild.sibling;
              if ((updateFlags & ShouldResetChildren) === NoUpdate && prevChildAtSameIndex !== null) {
                prevChildAtSameIndex = prevChildAtSameIndex.sibling;
              }
            }
            if (previousVirtualInstance !== null) {
              if (previousVirtualInstanceWasMount) {
                mountVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceNextFirstFiber, null, traceNearestHostComponentUpdate, virtualLevel);
                updateFlags |= ShouldResetChildren | ShouldResetSuspenseChildren;
              } else {
                updateFlags |= updateVirtualInstanceRecursively(previousVirtualInstance, previousVirtualInstanceNextFirstFiber, null, previousVirtualInstancePrevFirstFiber, traceNearestHostComponentUpdate, virtualLevel);
              }
            }
            if (prevChildAtSameIndex !== null) {
              updateFlags |= ShouldResetChildren | ShouldResetSuspenseChildren;
            }
            return updateFlags;
          }
          function updateChildrenRecursively(nextFirstChild, prevFirstChild, traceNearestHostComponentUpdate) {
            if (nextFirstChild === null) {
              return prevFirstChild !== null ? ShouldResetChildren : NoUpdate;
            }
            return updateVirtualChildrenRecursively(nextFirstChild, null, prevFirstChild, traceNearestHostComponentUpdate, 0);
          }
          function updateSuspenseChildrenRecursively(nextContentFiber, prevContentFiber, traceNearestHostComponentUpdate, stashedSuspenseParent, stashedSuspensePrevious, stashedSuspenseRemaining) {
            var updateFlags = NoUpdate;
            var prevFallbackFiber = prevContentFiber.sibling;
            var nextFallbackFiber = nextContentFiber.sibling;
            updateFlags |= updateVirtualChildrenRecursively(nextContentFiber, nextFallbackFiber, prevContentFiber, traceNearestHostComponentUpdate, 0);
            reconcilingParentSuspenseNode = stashedSuspenseParent;
            previouslyReconciledSiblingSuspenseNode = stashedSuspensePrevious;
            remainingReconcilingChildrenSuspenseNodes = stashedSuspenseRemaining;
            if (prevFallbackFiber !== null || nextFallbackFiber !== null) {
              if (nextFallbackFiber === null) {
                unmountRemainingChildren();
              } else {
                updateFlags |= updateVirtualChildrenRecursively(nextFallbackFiber, null, prevFallbackFiber, traceNearestHostComponentUpdate, 0);
                if ((updateFlags & ShouldResetSuspenseChildren) !== NoUpdate) {
                  updateFlags |= ShouldResetParentSuspenseChildren;
                  updateFlags &= ~ShouldResetSuspenseChildren;
                }
              }
            }
            return updateFlags;
          }
          function updateFiberRecursively(fiberInstance, nextFiber, prevFiber, traceNearestHostComponentUpdate) {
            if (__DEBUG__) {
              if (fiberInstance !== null) {
                debug2("updateFiberRecursively()", fiberInstance, reconcilingParent);
              }
            }
            if (traceUpdatesEnabled) {
              var elementType = getElementTypeForFiber(nextFiber);
              if (traceNearestHostComponentUpdate) {
                if (elementType === ElementTypeHostComponent) {
                  traceUpdatesForNodes.add(nextFiber.stateNode);
                  traceNearestHostComponentUpdate = false;
                }
              } else {
                if (elementType === types_ElementTypeFunction || elementType === types_ElementTypeClass || elementType === ElementTypeContext || elementType === types_ElementTypeMemo || elementType === types_ElementTypeForwardRef) {
                  traceNearestHostComponentUpdate = didFiberRender(prevFiber, nextFiber);
                }
              }
            }
            var stashedParent = reconcilingParent;
            var stashedPrevious = previouslyReconciledSibling;
            var stashedRemaining = remainingReconcilingChildren;
            var stashedSuspenseParent = reconcilingParentSuspenseNode;
            var stashedSuspensePrevious = previouslyReconciledSiblingSuspenseNode;
            var stashedSuspenseRemaining = remainingReconcilingChildrenSuspenseNodes;
            var updateFlags = NoUpdate;
            var shouldMeasureSuspenseNode = false;
            var shouldPopSuspenseNode = false;
            var previousSuspendedBy = null;
            if (fiberInstance !== null) {
              previousSuspendedBy = fiberInstance.suspendedBy;
              fiberInstance.data = nextFiber;
              if (mostRecentlyInspectedElement !== null && (mostRecentlyInspectedElement.id === fiberInstance.id || mostRecentlyInspectedElement.type === ElementTypeRoot && nextFiber.tag === HostRoot) && didFiberRender(prevFiber, nextFiber)) {
                hasElementUpdatedSinceLastInspected = true;
              }
              reconcilingParent = fiberInstance;
              previouslyReconciledSibling = null;
              remainingReconcilingChildren = fiberInstance.firstChild;
              fiberInstance.firstChild = null;
              fiberInstance.suspendedBy = null;
              var suspenseNode = fiberInstance.suspenseNode;
              if (suspenseNode !== null) {
                reconcilingParentSuspenseNode = suspenseNode;
                previouslyReconciledSiblingSuspenseNode = null;
                remainingReconcilingChildrenSuspenseNodes = suspenseNode.firstChild;
                suspenseNode.firstChild = null;
                shouldMeasureSuspenseNode = true;
                shouldPopSuspenseNode = true;
              }
            }
            try {
              trackDebugInfoFromLazyType(nextFiber);
              trackDebugInfoFromUsedThenables(nextFiber);
              if (nextFiber.tag === HostHoistable) {
                var nearestInstance = reconcilingParent;
                if (nearestInstance === null) {
                  throw new Error("Did not expect a host hoistable to be the root");
                }
                if (prevFiber.memoizedState !== nextFiber.memoizedState) {
                  releaseHostResource(nearestInstance, prevFiber.memoizedState);
                  aquireHostResource(nearestInstance, nextFiber.memoizedState);
                }
                trackDebugInfoFromHostResource(nearestInstance, nextFiber);
              } else if (nextFiber.tag === HostComponent || nextFiber.tag === HostText || nextFiber.tag === HostSingleton) {
                var _nearestInstance2 = reconcilingParent;
                if (_nearestInstance2 === null) {
                  throw new Error("Did not expect a host hoistable to be the root");
                }
                if (prevFiber.stateNode !== nextFiber.stateNode) {
                  releaseHostInstance(_nearestInstance2, prevFiber.stateNode);
                  aquireHostInstance(_nearestInstance2, nextFiber.stateNode);
                }
                trackDebugInfoFromHostComponent(_nearestInstance2, nextFiber);
              }
              var isLegacySuspense = nextFiber.tag === SuspenseComponent && OffscreenComponent === -1;
              var prevDidTimeout = isLegacySuspense && prevFiber.memoizedState !== null;
              var nextDidTimeOut = isLegacySuspense && nextFiber.memoizedState !== null;
              var prevWasHidden = isHiddenOffscreen(prevFiber);
              var nextIsHidden = isHiddenOffscreen(nextFiber);
              var prevWasSuspended = isSuspendedOffscreen(prevFiber);
              var nextIsSuspended = isSuspendedOffscreen(nextFiber);
              if (isLegacySuspense) {
                if (fiberInstance !== null && fiberInstance.suspenseNode !== null) {
                  var _suspenseNode = fiberInstance.suspenseNode;
                  if (prevFiber.stateNode === null !== (nextFiber.stateNode === null)) {
                    trackThrownPromisesFromRetryCache(_suspenseNode, nextFiber.stateNode);
                  }
                  if (prevFiber.memoizedState === null !== (nextFiber.memoizedState === null)) {
                    recordSuspenseSuspenders(_suspenseNode);
                  }
                }
              }
              if (prevDidTimeout && nextDidTimeOut) {
                var nextFiberChild = nextFiber.child;
                var nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null;
                var prevFiberChild = prevFiber.child;
                var prevFallbackChildSet = prevFiberChild ? prevFiberChild.sibling : null;
                if (prevFallbackChildSet == null && nextFallbackChildSet != null) {
                  mountChildrenRecursively(nextFallbackChildSet, traceNearestHostComponentUpdate);
                  updateFlags |= ShouldResetChildren | ShouldResetSuspenseChildren;
                }
                var childrenUpdateFlags = nextFallbackChildSet != null && prevFallbackChildSet != null ? updateChildrenRecursively(nextFallbackChildSet, prevFallbackChildSet, traceNearestHostComponentUpdate) : NoUpdate;
                updateFlags |= childrenUpdateFlags;
              } else if (prevDidTimeout && !nextDidTimeOut) {
                var nextPrimaryChildSet = nextFiber.child;
                if (nextPrimaryChildSet !== null) {
                  mountChildrenRecursively(nextPrimaryChildSet, traceNearestHostComponentUpdate);
                  updateFlags |= ShouldResetChildren | ShouldResetSuspenseChildren;
                }
              } else if (!prevDidTimeout && nextDidTimeOut) {
                var _nextFiberChild = nextFiber.child;
                var _nextFallbackChildSet = _nextFiberChild ? _nextFiberChild.sibling : null;
                if (_nextFallbackChildSet != null) {
                  mountChildrenRecursively(_nextFallbackChildSet, traceNearestHostComponentUpdate);
                  updateFlags |= ShouldResetChildren | ShouldResetSuspenseChildren;
                }
              } else if (nextIsSuspended) {
                if (!prevWasSuspended) {
                  if (fiberInstance !== null && !isInDisconnectedSubtree) {
                    disconnectChildrenRecursively(remainingReconcilingChildren);
                  }
                }
                var stashedDisconnected = isInDisconnectedSubtree;
                isInDisconnectedSubtree = true;
                try {
                  updateFlags |= updateChildrenRecursively(nextFiber.child, prevFiber.child, false);
                } finally {
                  isInDisconnectedSubtree = stashedDisconnected;
                }
              } else if (prevWasSuspended && !nextIsSuspended) {
                var _stashedDisconnected = isInDisconnectedSubtree;
                isInDisconnectedSubtree = true;
                try {
                  if (nextFiber.child !== null) {
                    updateFlags |= updateChildrenRecursively(nextFiber.child, prevFiber.child, false);
                  }
                  unmountRemainingChildren();
                  remainingReconcilingChildren = null;
                } finally {
                  isInDisconnectedSubtree = _stashedDisconnected;
                }
                if (fiberInstance !== null && !isInDisconnectedSubtree) {
                  reconnectChildrenRecursively(fiberInstance);
                  updateFlags |= ShouldResetChildren | ShouldResetSuspenseChildren;
                }
              } else if (nextIsHidden) {
                if (prevWasHidden) {} else {
                  unmountRemainingChildren();
                }
              } else if (nextFiber.tag === SuspenseComponent && OffscreenComponent !== -1 && fiberInstance !== null && fiberInstance.suspenseNode !== null) {
                var _suspenseNode2 = fiberInstance.suspenseNode;
                var prevContentFiber = prevFiber.child;
                var nextContentFiber = nextFiber.child;
                var previousHydrated = isFiberHydrated(prevFiber);
                var nextHydrated = isFiberHydrated(nextFiber);
                if (previousHydrated && nextHydrated) {
                  if (nextContentFiber === null || prevContentFiber === null) {
                    throw new Error("There should always be an Offscreen Fiber child in a hydrated Suspense boundary.");
                  }
                  if (prevFiber.stateNode === null !== (nextFiber.stateNode === null)) {
                    trackThrownPromisesFromRetryCache(_suspenseNode2, nextFiber.stateNode);
                  }
                  if (prevFiber.memoizedState === null !== (nextFiber.memoizedState === null)) {
                    recordSuspenseSuspenders(_suspenseNode2);
                  }
                  shouldMeasureSuspenseNode = false;
                  updateFlags |= updateSuspenseChildrenRecursively(nextContentFiber, prevContentFiber, traceNearestHostComponentUpdate, stashedSuspenseParent, stashedSuspensePrevious, stashedSuspenseRemaining);
                  shouldPopSuspenseNode = false;
                  if (nextFiber.memoizedState === null) {
                    shouldMeasureSuspenseNode = !isInDisconnectedSubtree;
                  }
                } else if (!previousHydrated && nextHydrated) {
                  if (nextContentFiber === null) {
                    throw new Error("There should always be an Offscreen Fiber child in a hydrated Suspense boundary.");
                  }
                  trackThrownPromisesFromRetryCache(_suspenseNode2, nextFiber.stateNode);
                  recordSuspenseSuspenders(_suspenseNode2);
                  mountSuspenseChildrenRecursively(nextContentFiber, traceNearestHostComponentUpdate, stashedSuspenseParent, stashedSuspensePrevious, stashedSuspenseRemaining);
                  shouldPopSuspenseNode = false;
                } else if (previousHydrated && !nextHydrated) {
                  throw new Error("Encountered a dehydrated Suspense boundary that was previously hydrated.");
                } else {}
              } else {
                if (nextFiber.child !== prevFiber.child) {
                  updateFlags |= updateChildrenRecursively(nextFiber.child, prevFiber.child, traceNearestHostComponentUpdate);
                } else {
                  if (fiberInstance !== null) {
                    fiberInstance.firstChild = remainingReconcilingChildren;
                    remainingReconcilingChildren = null;
                    consumeSuspenseNodesOfExistingInstance(fiberInstance);
                    if (traceUpdatesEnabled) {
                      if (traceNearestHostComponentUpdate) {
                        var hostInstances = findAllCurrentHostInstances(fiberInstance);
                        hostInstances.forEach(function(hostInstance) {
                          traceUpdatesForNodes.add(hostInstance);
                        });
                      }
                    }
                  } else {
                    var _childrenUpdateFlags = updateChildrenRecursively(nextFiber.child, prevFiber.child, false);
                    if ((_childrenUpdateFlags & ShouldResetChildren) !== NoUpdate) {
                      throw new Error("The children should not have changed if we pass in the same set.");
                    }
                    updateFlags |= _childrenUpdateFlags;
                  }
                }
              }
              if (fiberInstance !== null) {
                removePreviousSuspendedBy(fiberInstance, previousSuspendedBy, shouldPopSuspenseNode ? reconcilingParentSuspenseNode : stashedSuspenseParent);
                if (fiberInstance.kind === FIBER_INSTANCE) {
                  var componentLogsEntry = fiberToComponentLogsMap.get(fiberInstance.data);
                  if (componentLogsEntry === undefined && fiberInstance.data.alternate) {
                    componentLogsEntry = fiberToComponentLogsMap.get(fiberInstance.data.alternate);
                  }
                  recordConsoleLogs(fiberInstance, componentLogsEntry);
                  var isProfilingSupported = nextFiber.hasOwnProperty("treeBaseDuration");
                  if (isProfilingSupported) {
                    recordProfilingDurations(fiberInstance, prevFiber);
                  }
                }
              }
              if ((updateFlags & ShouldResetChildren) !== NoUpdate) {
                if (fiberInstance !== null && fiberInstance.kind === FIBER_INSTANCE) {
                  if (!nextIsSuspended && !isInDisconnectedSubtree) {
                    recordResetChildren(fiberInstance);
                  }
                  updateFlags &= ~ShouldResetChildren;
                } else {}
              } else {}
              if ((updateFlags & ShouldResetSuspenseChildren) !== NoUpdate) {
                if (fiberInstance !== null && fiberInstance.kind === FIBER_INSTANCE) {
                  var _suspenseNode3 = fiberInstance.suspenseNode;
                  if (_suspenseNode3 !== null) {
                    recordResetSuspenseChildren(_suspenseNode3);
                    updateFlags &= ~ShouldResetSuspenseChildren;
                  }
                } else {}
              }
              if ((updateFlags & ShouldResetParentSuspenseChildren) !== NoUpdate) {
                if (fiberInstance !== null && fiberInstance.kind === FIBER_INSTANCE) {
                  var _suspenseNode4 = fiberInstance.suspenseNode;
                  if (_suspenseNode4 !== null) {
                    updateFlags &= ~ShouldResetParentSuspenseChildren;
                    updateFlags |= ShouldResetSuspenseChildren;
                  }
                } else {}
              }
              return updateFlags;
            } finally {
              if (fiberInstance !== null) {
                unmountRemainingChildren();
                reconcilingParent = stashedParent;
                previouslyReconciledSibling = stashedPrevious;
                remainingReconcilingChildren = stashedRemaining;
                if (shouldMeasureSuspenseNode) {
                  if (!isInDisconnectedSubtree) {
                    var _suspenseNode5 = fiberInstance.suspenseNode;
                    if (_suspenseNode5 === null) {
                      throw new Error("Attempted to measure a Suspense node that does not exist.");
                    }
                    var prevRects = _suspenseNode5.rects;
                    var nextRects = measureInstance(fiberInstance);
                    if (!areEqualRects(prevRects, nextRects)) {
                      _suspenseNode5.rects = nextRects;
                      recordSuspenseResize(_suspenseNode5);
                    }
                  }
                }
                if (shouldPopSuspenseNode) {
                  reconcilingParentSuspenseNode = stashedSuspenseParent;
                  previouslyReconciledSiblingSuspenseNode = stashedSuspensePrevious;
                  remainingReconcilingChildrenSuspenseNodes = stashedSuspenseRemaining;
                }
              }
            }
          }
          function disconnectChildrenRecursively(firstChild) {
            for (var child = firstChild;child !== null; child = child.nextSibling) {
              if ((child.kind === FIBER_INSTANCE || child.kind === FILTERED_FIBER_INSTANCE) && isSuspendedOffscreen(child.data)) {} else {
                disconnectChildrenRecursively(child.firstChild);
              }
              if (child.kind === FIBER_INSTANCE) {
                recordDisconnect(child);
              } else if (child.kind === VIRTUAL_INSTANCE) {
                recordVirtualDisconnect(child);
              }
            }
          }
          function reconnectChildrenRecursively(parentInstance) {
            for (var child = parentInstance.firstChild;child !== null; child = child.nextSibling) {
              if (child.kind === FIBER_INSTANCE) {
                recordReconnect(child, parentInstance);
              } else if (child.kind === VIRTUAL_INSTANCE) {
                var secondaryEnv = null;
                recordVirtualReconnect(child, parentInstance, secondaryEnv);
              }
              if ((child.kind === FIBER_INSTANCE || child.kind === FILTERED_FIBER_INSTANCE) && isHiddenOffscreen(child.data)) {} else {
                reconnectChildrenRecursively(child);
              }
            }
          }
          function cleanup() {
            isProfiling = false;
          }
          function rootSupportsProfiling(root) {
            if (root.memoizedInteractions != null) {
              return true;
            } else if (root.current != null && root.current.hasOwnProperty("treeBaseDuration")) {
              return true;
            } else {
              return false;
            }
          }
          function flushInitialOperations() {
            var localPendingOperationsQueue = pendingOperationsQueue;
            pendingOperationsQueue = null;
            if (localPendingOperationsQueue !== null && localPendingOperationsQueue.length > 0) {
              localPendingOperationsQueue.forEach(function(operations) {
                hook.emit("operations", operations);
              });
            } else {
              if (trackedPath !== null) {
                mightBeOnTrackedPath = true;
              }
              hook.getFiberRoots(rendererID).forEach(function(root) {
                var current = root.current;
                var newRoot = createFiberInstance(current);
                rootToFiberInstanceMap.set(root, newRoot);
                idToDevToolsInstanceMap.set(newRoot.id, newRoot);
                currentRoot = newRoot;
                setRootPseudoKey(currentRoot.id, root.current);
                if (isProfiling && rootSupportsProfiling(root)) {
                  currentCommitProfilingMetadata = {
                    changeDescriptions: recordChangeDescriptions ? new Map : null,
                    durations: [],
                    commitTime: renderer_getCurrentTime() - profilingStartTime,
                    maxActualDuration: 0,
                    priorityLevel: null,
                    updaters: null,
                    effectDuration: null,
                    passiveEffectDuration: null
                  };
                }
                mountFiberRecursively(root.current, false);
                flushPendingEvents();
                needsToFlushComponentLogs = false;
                currentRoot = null;
              });
            }
          }
          function handleCommitFiberUnmount(fiber) {}
          function handlePostCommitFiberRoot(root) {
            if (isProfiling && rootSupportsProfiling(root)) {
              if (currentCommitProfilingMetadata !== null) {
                var _getEffectDurations = getEffectDurations(root), effectDuration = _getEffectDurations.effectDuration, passiveEffectDuration = _getEffectDurations.passiveEffectDuration;
                currentCommitProfilingMetadata.effectDuration = effectDuration;
                currentCommitProfilingMetadata.passiveEffectDuration = passiveEffectDuration;
              }
            }
            if (needsToFlushComponentLogs) {
              bruteForceFlushErrorsAndWarnings();
            }
          }
          function handleCommitFiberRoot(root, priorityLevel) {
            var nextFiber = root.current;
            var prevFiber = null;
            var rootInstance = rootToFiberInstanceMap.get(root);
            if (!rootInstance) {
              rootInstance = createFiberInstance(nextFiber);
              rootToFiberInstanceMap.set(root, rootInstance);
              idToDevToolsInstanceMap.set(rootInstance.id, rootInstance);
            } else {
              prevFiber = rootInstance.data;
            }
            currentRoot = rootInstance;
            if (trackedPath !== null) {
              mightBeOnTrackedPath = true;
            }
            if (traceUpdatesEnabled) {
              traceUpdatesForNodes.clear();
            }
            var isProfilingSupported = rootSupportsProfiling(root);
            if (isProfiling && isProfilingSupported) {
              currentCommitProfilingMetadata = {
                changeDescriptions: recordChangeDescriptions ? new Map : null,
                durations: [],
                commitTime: renderer_getCurrentTime() - profilingStartTime,
                maxActualDuration: 0,
                priorityLevel: priorityLevel == null ? null : formatPriorityLevel(priorityLevel),
                updaters: null,
                effectDuration: null,
                passiveEffectDuration: null
              };
            }
            var nextIsMounted = nextFiber.child !== null;
            var prevWasMounted = prevFiber !== null && prevFiber.child !== null;
            if (!prevWasMounted && nextIsMounted) {
              setRootPseudoKey(currentRoot.id, nextFiber);
              mountFiberRecursively(nextFiber, false);
            } else if (prevWasMounted && nextIsMounted) {
              if (prevFiber === null) {
                throw new Error("Expected a previous Fiber when updating an existing root.");
              }
              updateFiberRecursively(rootInstance, nextFiber, prevFiber, false);
            } else if (prevWasMounted && !nextIsMounted) {
              unmountInstanceRecursively(rootInstance);
              removeRootPseudoKey(currentRoot.id);
              rootToFiberInstanceMap.delete(root);
            } else if (!prevWasMounted && !nextIsMounted) {
              rootToFiberInstanceMap.delete(root);
            }
            if (isProfiling && isProfilingSupported) {
              if (!shouldBailoutWithPendingOperations()) {
                var commitProfilingMetadata = rootToCommitProfilingMetadataMap.get(currentRoot.id);
                if (commitProfilingMetadata != null) {
                  commitProfilingMetadata.push(currentCommitProfilingMetadata);
                } else {
                  rootToCommitProfilingMetadataMap.set(currentRoot.id, [currentCommitProfilingMetadata]);
                }
              }
            }
            flushPendingEvents();
            needsToFlushComponentLogs = false;
            if (traceUpdatesEnabled) {
              hook.emit("traceUpdates", traceUpdatesForNodes);
            }
            currentRoot = null;
          }
          function getResourceInstance(fiber) {
            if (fiber.tag === HostHoistable) {
              var resource = fiber.memoizedState;
              if (renderer_typeof(resource) === "object" && resource !== null && resource.instance != null) {
                return resource.instance;
              }
            }
            return null;
          }
          function appendHostInstancesByDevToolsInstance(devtoolsInstance, hostInstances) {
            if (devtoolsInstance.kind !== VIRTUAL_INSTANCE) {
              var _fiber6 = devtoolsInstance.data;
              appendHostInstancesByFiber(_fiber6, hostInstances);
              return;
            }
            for (var child = devtoolsInstance.firstChild;child !== null; child = child.nextSibling) {
              appendHostInstancesByDevToolsInstance(child, hostInstances);
            }
          }
          function appendHostInstancesByFiber(fiber, hostInstances) {
            var node = fiber;
            while (true) {
              if (node.tag === HostComponent || node.tag === HostText || node.tag === HostSingleton || node.tag === HostHoistable) {
                var hostInstance = node.stateNode || getResourceInstance(node);
                if (hostInstance) {
                  hostInstances.push(hostInstance);
                }
              } else if (node.child) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === fiber) {
                return;
              }
              while (!node.sibling) {
                if (!node.return || node.return === fiber) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function findAllCurrentHostInstances(devtoolsInstance) {
            var hostInstances = [];
            appendHostInstancesByDevToolsInstance(devtoolsInstance, hostInstances);
            return hostInstances;
          }
          function findHostInstancesForElementID(id) {
            try {
              var devtoolsInstance = idToDevToolsInstanceMap.get(id);
              if (devtoolsInstance === undefined) {
                console.warn('Could not find DevToolsInstance with id "'.concat(id, '"'));
                return null;
              }
              return findAllCurrentHostInstances(devtoolsInstance);
            } catch (err) {
              return null;
            }
          }
          function findLastKnownRectsForID(id) {
            try {
              var devtoolsInstance = idToDevToolsInstanceMap.get(id);
              if (devtoolsInstance === undefined) {
                console.warn('Could not find DevToolsInstance with id "'.concat(id, '"'));
                return null;
              }
              if (devtoolsInstance.suspenseNode === null) {
                return null;
              }
              return devtoolsInstance.suspenseNode.rects;
            } catch (err) {
              return null;
            }
          }
          function getDisplayNameForElementID(id) {
            var devtoolsInstance = idToDevToolsInstanceMap.get(id);
            if (devtoolsInstance === undefined) {
              return null;
            }
            if (devtoolsInstance.kind === FIBER_INSTANCE) {
              var _fiber7 = devtoolsInstance.data;
              if (_fiber7.tag === HostRoot) {
                return "Initial Paint";
              }
              if (_fiber7.tag === SuspenseComponent || _fiber7.tag === ActivityComponent) {
                var props = _fiber7.memoizedProps;
                if (props.name != null) {
                  return props.name;
                }
                var owner = getUnfilteredOwner(_fiber7);
                if (owner != null) {
                  if (typeof owner.tag === "number") {
                    return getDisplayNameForFiber(owner);
                  } else {
                    return owner.name || "";
                  }
                }
              }
              return getDisplayNameForFiber(_fiber7);
            } else {
              return devtoolsInstance.data.name || "";
            }
          }
          function getNearestSuspenseNode(instance) {
            while (instance.suspenseNode === null) {
              if (instance.parent === null) {
                throw new Error("There should always be a SuspenseNode parent on a mounted instance.");
              }
              instance = instance.parent;
            }
            return instance.suspenseNode;
          }
          function getNearestMountedDOMNode(publicInstance) {
            var domNode = publicInstance;
            while (domNode && !publicInstanceToDevToolsInstanceMap.has(domNode)) {
              domNode = domNode.parentNode;
            }
            return domNode;
          }
          function getElementIDForHostInstance(publicInstance) {
            var instance = publicInstanceToDevToolsInstanceMap.get(publicInstance);
            if (instance !== undefined) {
              if (instance.kind === FILTERED_FIBER_INSTANCE) {
                return instance.parent.id;
              }
              return instance.id;
            }
            return null;
          }
          function getSuspenseNodeIDForHostInstance(publicInstance) {
            var instance = publicInstanceToDevToolsInstanceMap.get(publicInstance);
            if (instance !== undefined) {
              var suspenseInstance = instance;
              while (suspenseInstance.suspenseNode === null || suspenseInstance.kind === FILTERED_FIBER_INSTANCE) {
                if (suspenseInstance.parent === null) {
                  return null;
                }
                suspenseInstance = suspenseInstance.parent;
              }
              return suspenseInstance.id;
            }
            return null;
          }
          function getElementAttributeByPath(id, path) {
            if (isMostRecentlyInspectedElement(id)) {
              return utils_getInObject(mostRecentlyInspectedElement, path);
            }
            return;
          }
          function getElementSourceFunctionById(id) {
            var devtoolsInstance = idToDevToolsInstanceMap.get(id);
            if (devtoolsInstance === undefined) {
              console.warn('Could not find DevToolsInstance with id "'.concat(id, '"'));
              return null;
            }
            if (devtoolsInstance.kind !== FIBER_INSTANCE) {
              return null;
            }
            var fiber = devtoolsInstance.data;
            var { elementType, tag, type } = fiber;
            switch (tag) {
              case ClassComponent:
              case IncompleteClassComponent:
              case IncompleteFunctionComponent:
              case IndeterminateComponent:
              case FunctionComponent:
                return type;
              case ForwardRef:
                return type.render;
              case MemoComponent:
              case SimpleMemoComponent:
                return elementType != null && elementType.type != null ? elementType.type : type;
              default:
                return null;
            }
          }
          function instanceToSerializedElement(instance) {
            if (instance.kind === FIBER_INSTANCE) {
              var _fiber8 = instance.data;
              return {
                displayName: getDisplayNameForFiber(_fiber8) || "Anonymous",
                id: instance.id,
                key: _fiber8.key,
                env: null,
                stack: _fiber8._debugOwner == null || _fiber8._debugStack == null ? null : parseStackTrace(_fiber8._debugStack, 1),
                type: getElementTypeForFiber(_fiber8)
              };
            } else {
              var componentInfo = instance.data;
              return {
                displayName: componentInfo.name || "Anonymous",
                id: instance.id,
                key: componentInfo.key == null ? null : componentInfo.key,
                env: componentInfo.env == null ? null : componentInfo.env,
                stack: componentInfo.owner == null || componentInfo.debugStack == null ? null : parseStackTrace(componentInfo.debugStack, 1),
                type: types_ElementTypeVirtual
              };
            }
          }
          function getOwnersList(id) {
            var devtoolsInstance = idToDevToolsInstanceMap.get(id);
            if (devtoolsInstance === undefined) {
              console.warn('Could not find DevToolsInstance with id "'.concat(id, '"'));
              return null;
            }
            var self2 = instanceToSerializedElement(devtoolsInstance);
            var owners = getOwnersListFromInstance(devtoolsInstance);
            if (owners === null) {
              return [self2];
            }
            owners.unshift(self2);
            owners.reverse();
            return owners;
          }
          function getOwnersListFromInstance(instance) {
            var owner = getUnfilteredOwner(instance.data);
            if (owner === null) {
              return null;
            }
            var owners = [];
            var parentInstance = instance.parent;
            while (parentInstance !== null && owner !== null) {
              var ownerInstance = findNearestOwnerInstance(parentInstance, owner);
              if (ownerInstance !== null) {
                owners.push(instanceToSerializedElement(ownerInstance));
                owner = getUnfilteredOwner(owner);
                parentInstance = ownerInstance.parent;
              } else {
                break;
              }
            }
            return owners;
          }
          function getUnfilteredOwner(owner) {
            if (owner == null) {
              return null;
            }
            if (typeof owner.tag === "number") {
              var ownerFiber = owner;
              owner = ownerFiber._debugOwner;
            } else {
              var ownerInfo = owner;
              owner = ownerInfo.owner;
            }
            while (owner) {
              if (typeof owner.tag === "number") {
                var _ownerFiber = owner;
                if (!shouldFilterFiber(_ownerFiber)) {
                  return _ownerFiber;
                }
                owner = _ownerFiber._debugOwner;
              } else {
                var _ownerInfo = owner;
                if (!shouldFilterVirtual(_ownerInfo, null)) {
                  return _ownerInfo;
                }
                owner = _ownerInfo.owner;
              }
            }
            return null;
          }
          function findNearestOwnerInstance(parentInstance, owner) {
            if (owner == null) {
              return null;
            }
            while (parentInstance !== null) {
              if (parentInstance.data === owner || parentInstance.data === owner.alternate) {
                if (parentInstance.kind === FILTERED_FIBER_INSTANCE) {
                  return null;
                }
                return parentInstance;
              }
              parentInstance = parentInstance.parent;
            }
            return null;
          }
          function inspectHooks(fiber) {
            var originalConsoleMethods = {};
            for (var method in console) {
              try {
                originalConsoleMethods[method] = console[method];
                console[method] = function() {};
              } catch (error) {}
            }
            try {
              return (0, react_debug_tools.inspectHooksOfFiber)(fiber, getDispatcherRef(renderer));
            } finally {
              for (var _method in originalConsoleMethods) {
                try {
                  console[_method] = originalConsoleMethods[_method];
                } catch (error) {}
              }
            }
          }
          function getSuspendedByOfSuspenseNode(suspenseNode, filterByChildInstance) {
            var result = [];
            if (!suspenseNode.hasUniqueSuspenders) {
              return result;
            }
            var hooksCacheKey = null;
            var hooksCache = null;
            var streamEntries = new Map;
            suspenseNode.suspendedBy.forEach(function(set, ioInfo) {
              var parentNode = suspenseNode.parent;
              while (parentNode !== null) {
                if (parentNode.suspendedBy.has(ioInfo)) {
                  return;
                }
                parentNode = parentNode.parent;
              }
              if (set.size === 0) {
                return;
              }
              var firstInstance = null;
              if (filterByChildInstance === null) {
                firstInstance = set.values().next().value;
              } else {
                var _iterator7 = _createForOfIteratorHelper(set.values()), _step7;
                try {
                  for (_iterator7.s();!(_step7 = _iterator7.n()).done; ) {
                    var childInstance = _step7.value;
                    if (firstInstance === null) {
                      firstInstance = childInstance;
                    }
                    if (childInstance !== filterByChildInstance && !isChildOf(filterByChildInstance, childInstance, suspenseNode.instance)) {
                      return;
                    }
                  }
                } catch (err) {
                  _iterator7.e(err);
                } finally {
                  _iterator7.f();
                }
              }
              if (firstInstance !== null && firstInstance.suspendedBy !== null) {
                var asyncInfo = getAwaitInSuspendedByFromIO(firstInstance.suspendedBy, ioInfo);
                if (asyncInfo !== null) {
                  var hooks = null;
                  if (asyncInfo.stack == null && asyncInfo.owner == null) {
                    if (hooksCacheKey === firstInstance) {
                      hooks = hooksCache;
                    } else if (firstInstance.kind !== VIRTUAL_INSTANCE) {
                      var _fiber9 = firstInstance.data;
                      if (_fiber9.dependencies && _fiber9.dependencies._debugThenableState) {
                        hooksCacheKey = firstInstance;
                        hooksCache = hooks = inspectHooks(_fiber9);
                      }
                    }
                  }
                  var newIO = asyncInfo.awaited;
                  if ((newIO.name === "RSC stream" || newIO.name === "rsc stream") && newIO.value != null) {
                    var streamPromise = newIO.value;
                    var existingEntry = streamEntries.get(streamPromise);
                    if (existingEntry === undefined) {
                      streamEntries.set(streamPromise, {
                        asyncInfo,
                        instance: firstInstance,
                        hooks
                      });
                    } else {
                      var existingIO = existingEntry.asyncInfo.awaited;
                      if (newIO !== existingIO && (newIO.byteSize !== undefined && existingIO.byteSize !== undefined && newIO.byteSize > existingIO.byteSize || newIO.end > existingIO.end)) {
                        existingEntry.asyncInfo = asyncInfo;
                        existingEntry.instance = firstInstance;
                        existingEntry.hooks = hooks;
                      }
                    }
                  } else {
                    result.push(serializeAsyncInfo(asyncInfo, firstInstance, hooks));
                  }
                }
              }
            });
            streamEntries.forEach(function(_ref) {
              var { asyncInfo, instance, hooks } = _ref;
              result.push(serializeAsyncInfo(asyncInfo, instance, hooks));
            });
            return result;
          }
          function getSuspendedByOfInstance(devtoolsInstance, hooks) {
            var suspendedBy = devtoolsInstance.suspendedBy;
            if (suspendedBy === null) {
              return [];
            }
            var foundIOEntries = new Set;
            var streamEntries = new Map;
            var result = [];
            for (var i = 0;i < suspendedBy.length; i++) {
              var asyncInfo = suspendedBy[i];
              var ioInfo = asyncInfo.awaited;
              if (foundIOEntries.has(ioInfo)) {
                continue;
              }
              foundIOEntries.add(ioInfo);
              if ((ioInfo.name === "RSC stream" || ioInfo.name === "rsc stream") && ioInfo.value != null) {
                var streamPromise = ioInfo.value;
                var existingEntry = streamEntries.get(streamPromise);
                if (existingEntry === undefined) {
                  streamEntries.set(streamPromise, asyncInfo);
                } else {
                  var existingIO = existingEntry.awaited;
                  if (ioInfo !== existingIO && (ioInfo.byteSize !== undefined && existingIO.byteSize !== undefined && ioInfo.byteSize > existingIO.byteSize || ioInfo.end > existingIO.end)) {
                    streamEntries.set(streamPromise, asyncInfo);
                  }
                }
              } else {
                result.push(serializeAsyncInfo(asyncInfo, devtoolsInstance, hooks));
              }
            }
            streamEntries.forEach(function(asyncInfo2) {
              result.push(serializeAsyncInfo(asyncInfo2, devtoolsInstance, hooks));
            });
            return result;
          }
          function getSuspendedByOfInstanceSubtree(devtoolsInstance) {
            var suspenseParentInstance = devtoolsInstance;
            while (suspenseParentInstance.suspenseNode === null) {
              if (suspenseParentInstance.parent === null) {
                return [];
              }
              suspenseParentInstance = suspenseParentInstance.parent;
            }
            var suspenseNode = suspenseParentInstance.suspenseNode;
            return getSuspendedByOfSuspenseNode(suspenseNode, devtoolsInstance);
          }
          var FALLBACK_THROTTLE_MS = 300;
          function getSuspendedByRange(suspenseNode) {
            var min = Infinity;
            var max = -Infinity;
            suspenseNode.suspendedBy.forEach(function(_, ioInfo) {
              if (ioInfo.end > max) {
                max = ioInfo.end;
              }
              if (ioInfo.start < min) {
                min = ioInfo.start;
              }
            });
            var parentSuspenseNode = suspenseNode.parent;
            if (parentSuspenseNode !== null) {
              var parentMax = -Infinity;
              parentSuspenseNode.suspendedBy.forEach(function(_, ioInfo) {
                if (ioInfo.end > parentMax) {
                  parentMax = ioInfo.end;
                }
              });
              var throttleTime = parentMax + FALLBACK_THROTTLE_MS;
              if (throttleTime > max) {
                max = throttleTime;
              }
              var startTime = max - FALLBACK_THROTTLE_MS;
              if (parentMax > startTime) {
                startTime = parentMax;
              }
              if (startTime < min) {
                min = startTime;
              }
            }
            if (min < Infinity && max > -Infinity) {
              return [min, max];
            }
            return null;
          }
          function getAwaitStackFromHooks(hooks, asyncInfo) {
            for (var i = 0;i < hooks.length; i++) {
              var node = hooks[i];
              var debugInfo = node.debugInfo;
              if (debugInfo != null && debugInfo.indexOf(asyncInfo) !== -1) {
                var source = node.hookSource;
                if (source != null && source.functionName !== null && source.fileName !== null && source.lineNumber !== null && source.columnNumber !== null) {
                  var callSite = [source.functionName, source.fileName, source.lineNumber, source.columnNumber, 0, 0, false];
                  return [callSite];
                } else {
                  return [];
                }
              }
              var matchedStack = getAwaitStackFromHooks(node.subHooks, asyncInfo);
              if (matchedStack !== null) {
                var _source = node.hookSource;
                if (_source != null && _source.functionName !== null && _source.fileName !== null && _source.lineNumber !== null && _source.columnNumber !== null) {
                  var _callSite = [_source.functionName, _source.fileName, _source.lineNumber, _source.columnNumber, 0, 0, false];
                  matchedStack.push(_callSite);
                }
                return matchedStack;
              }
            }
            return null;
          }
          function serializeAsyncInfo(asyncInfo, parentInstance, hooks) {
            var ioInfo = asyncInfo.awaited;
            var ioOwnerInstance = findNearestOwnerInstance(parentInstance, ioInfo.owner);
            var awaitStack = asyncInfo.debugStack == null ? null : parseStackTrace(asyncInfo.debugStack, 1);
            var awaitOwnerInstance;
            if (asyncInfo.owner == null && (awaitStack === null || awaitStack.length === 0)) {
              awaitStack = null;
              awaitOwnerInstance = parentInstance.kind === FILTERED_FIBER_INSTANCE ? null : parentInstance;
              if (parentInstance.kind === FIBER_INSTANCE || parentInstance.kind === FILTERED_FIBER_INSTANCE) {
                var _fiber10 = parentInstance.data;
                switch (_fiber10.tag) {
                  case ClassComponent:
                  case FunctionComponent:
                  case IncompleteClassComponent:
                  case IncompleteFunctionComponent:
                  case IndeterminateComponent:
                  case MemoComponent:
                  case SimpleMemoComponent:
                    if (hooks !== null) {
                      awaitStack = getAwaitStackFromHooks(hooks, asyncInfo);
                    }
                    break;
                  default:
                    if (_fiber10._debugOwner != null && _fiber10._debugStack != null && typeof _fiber10._debugStack !== "string") {
                      awaitStack = parseStackTrace(_fiber10._debugStack, 1);
                      awaitOwnerInstance = findNearestOwnerInstance(parentInstance, _fiber10._debugOwner);
                    }
                }
              }
            } else {
              awaitOwnerInstance = findNearestOwnerInstance(parentInstance, asyncInfo.owner);
            }
            var value = ioInfo.value;
            var resolvedValue = undefined;
            if (renderer_typeof(value) === "object" && value !== null && typeof value.then === "function") {
              switch (value.status) {
                case "fulfilled":
                  resolvedValue = value.value;
                  break;
                case "rejected":
                  resolvedValue = value.reason;
                  break;
              }
            }
            return {
              awaited: {
                name: ioInfo.name,
                description: getIODescription(resolvedValue),
                start: ioInfo.start,
                end: ioInfo.end,
                byteSize: ioInfo.byteSize == null ? null : ioInfo.byteSize,
                value: ioInfo.value == null ? null : ioInfo.value,
                env: ioInfo.env == null ? null : ioInfo.env,
                owner: ioOwnerInstance === null ? null : instanceToSerializedElement(ioOwnerInstance),
                stack: ioInfo.debugStack == null ? null : parseStackTrace(ioInfo.debugStack, 1)
              },
              env: asyncInfo.env == null ? null : asyncInfo.env,
              owner: awaitOwnerInstance === null ? null : instanceToSerializedElement(awaitOwnerInstance),
              stack: awaitStack
            };
          }
          function getInstanceAndStyle(id) {
            var instance = null;
            var style = null;
            var devtoolsInstance = idToDevToolsInstanceMap.get(id);
            if (devtoolsInstance === undefined) {
              console.warn('Could not find DevToolsInstance with id "'.concat(id, '"'));
              return {
                instance,
                style
              };
            }
            if (devtoolsInstance.kind !== FIBER_INSTANCE) {
              return {
                instance,
                style
              };
            }
            var fiber = devtoolsInstance.data;
            if (fiber !== null) {
              instance = fiber.stateNode;
              if (fiber.memoizedProps !== null) {
                style = fiber.memoizedProps.style;
              }
            }
            return {
              instance,
              style
            };
          }
          function isErrorBoundary(fiber) {
            var { tag, type } = fiber;
            switch (tag) {
              case ClassComponent:
              case IncompleteClassComponent:
                var instance = fiber.stateNode;
                return typeof type.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function";
              default:
                return false;
            }
          }
          function inspectElementRaw(id) {
            var devtoolsInstance = idToDevToolsInstanceMap.get(id);
            if (devtoolsInstance === undefined) {
              console.warn('Could not find DevToolsInstance with id "'.concat(id, '"'));
              return null;
            }
            if (devtoolsInstance.kind === VIRTUAL_INSTANCE) {
              return inspectVirtualInstanceRaw(devtoolsInstance);
            }
            if (devtoolsInstance.kind === FIBER_INSTANCE) {
              var isRoot = devtoolsInstance.parent === null;
              return isRoot ? inspectRootsRaw(devtoolsInstance.id) : inspectFiberInstanceRaw(devtoolsInstance);
            }
            throw new Error("Unsupported instance kind");
          }
          function inspectFiberInstanceRaw(fiberInstance) {
            var fiber = fiberInstance.data;
            if (fiber == null) {
              return null;
            }
            var { stateNode, key, memoizedProps, memoizedState, dependencies, tag, type } = fiber;
            var elementType = getElementTypeForFiber(fiber);
            var usesHooks = (tag === FunctionComponent || tag === SimpleMemoComponent || tag === ForwardRef) && (!!memoizedState || !!dependencies);
            var showState = tag === ClassComponent || tag === IncompleteClassComponent;
            var typeSymbol = getTypeSymbol(type);
            var canViewSource = false;
            var context = null;
            if (tag === ClassComponent || tag === FunctionComponent || tag === IncompleteClassComponent || tag === IncompleteFunctionComponent || tag === IndeterminateComponent || tag === MemoComponent || tag === ForwardRef || tag === SimpleMemoComponent) {
              canViewSource = true;
              if (stateNode && stateNode.context != null) {
                var shouldHideContext = elementType === types_ElementTypeClass && !(type.contextTypes || type.contextType);
                if (!shouldHideContext) {
                  context = stateNode.context;
                }
              }
            } else if ((typeSymbol === CONTEXT_NUMBER || typeSymbol === CONTEXT_SYMBOL_STRING) && !(type._context === undefined && type.Provider === type)) {
              var consumerResolvedContext = type._context || type;
              context = consumerResolvedContext._currentValue || null;
              var _current = fiber.return;
              while (_current !== null) {
                var currentType = _current.type;
                var currentTypeSymbol = getTypeSymbol(currentType);
                if (currentTypeSymbol === PROVIDER_NUMBER || currentTypeSymbol === PROVIDER_SYMBOL_STRING) {
                  var providerResolvedContext = currentType._context || currentType.context;
                  if (providerResolvedContext === consumerResolvedContext) {
                    context = _current.memoizedProps.value;
                    break;
                  }
                }
                _current = _current.return;
              }
            } else if (typeSymbol === CONSUMER_SYMBOL_STRING) {
              var _consumerResolvedContext = type._context;
              context = _consumerResolvedContext._currentValue || null;
              var _current2 = fiber.return;
              while (_current2 !== null) {
                var _currentType = _current2.type;
                var _currentTypeSymbol = getTypeSymbol(_currentType);
                if (_currentTypeSymbol === CONTEXT_SYMBOL_STRING) {
                  var _providerResolvedContext = _currentType;
                  if (_providerResolvedContext === _consumerResolvedContext) {
                    context = _current2.memoizedProps.value;
                    break;
                  }
                }
                _current2 = _current2.return;
              }
            }
            var hasLegacyContext = false;
            if (context !== null) {
              hasLegacyContext = !!type.contextTypes;
              context = {
                value: context
              };
            }
            var owners = getOwnersListFromInstance(fiberInstance);
            var hooks = null;
            if (usesHooks) {
              hooks = inspectHooks(fiber);
            }
            var rootType = null;
            var current = fiber;
            var hasErrorBoundary = false;
            var hasSuspenseBoundary = false;
            while (current.return !== null) {
              var temp = current;
              current = current.return;
              if (temp.tag === SuspenseComponent) {
                hasSuspenseBoundary = true;
              } else if (isErrorBoundary(temp)) {
                hasErrorBoundary = true;
              }
            }
            var fiberRoot = current.stateNode;
            if (fiberRoot != null && fiberRoot._debugRootType !== null) {
              rootType = fiberRoot._debugRootType;
            }
            var isErrored = false;
            if (isErrorBoundary(fiber)) {
              var DidCapture = 128;
              isErrored = (fiber.flags & DidCapture) !== 0 || forceErrorForFibers.get(fiber) === true || fiber.alternate !== null && forceErrorForFibers.get(fiber.alternate) === true;
            }
            var plugins = {
              stylex: null
            };
            if (enableStyleXFeatures) {
              if (memoizedProps != null && memoizedProps.hasOwnProperty("xstyle")) {
                plugins.stylex = getStyleXData(memoizedProps.xstyle);
              }
            }
            var source = null;
            if (canViewSource) {
              source = getSourceForFiberInstance(fiberInstance);
            }
            var componentLogsEntry = fiberToComponentLogsMap.get(fiber);
            if (componentLogsEntry === undefined && fiber.alternate !== null) {
              componentLogsEntry = fiberToComponentLogsMap.get(fiber.alternate);
            }
            var nativeTag = null;
            if (elementType === ElementTypeHostComponent) {
              nativeTag = getNativeTag(fiber.stateNode);
            }
            var isSuspended = null;
            if (tag === SuspenseComponent) {
              isSuspended = memoizedState !== null;
            }
            var suspendedBy = fiberInstance.suspenseNode !== null ? getSuspendedByOfSuspenseNode(fiberInstance.suspenseNode, null) : tag === ActivityComponent ? getSuspendedByOfInstanceSubtree(fiberInstance) : getSuspendedByOfInstance(fiberInstance, hooks);
            var suspendedByRange = getSuspendedByRange(getNearestSuspenseNode(fiberInstance));
            var unknownSuspenders = UNKNOWN_SUSPENDERS_NONE;
            if (fiberInstance.suspenseNode !== null && fiberInstance.suspenseNode.hasUnknownSuspenders && !isSuspended) {
              if (renderer.bundleType === 0) {
                unknownSuspenders = UNKNOWN_SUSPENDERS_REASON_PRODUCTION;
              } else if (!("_debugInfo" in fiber)) {
                unknownSuspenders = UNKNOWN_SUSPENDERS_REASON_OLD_VERSION;
              } else {
                unknownSuspenders = UNKNOWN_SUSPENDERS_REASON_THROWN_PROMISE;
              }
            }
            return {
              id: fiberInstance.id,
              canEditHooks: typeof overrideHookState === "function",
              canEditFunctionProps: typeof overrideProps === "function",
              canEditHooksAndDeletePaths: typeof overrideHookStateDeletePath === "function",
              canEditHooksAndRenamePaths: typeof overrideHookStateRenamePath === "function",
              canEditFunctionPropsDeletePaths: typeof overridePropsDeletePath === "function",
              canEditFunctionPropsRenamePaths: typeof overridePropsRenamePath === "function",
              canToggleError: supportsTogglingError && hasErrorBoundary,
              isErrored,
              canToggleSuspense: supportsTogglingSuspense && hasSuspenseBoundary && (!isSuspended || forceFallbackForFibers.has(fiber) || fiber.alternate !== null && forceFallbackForFibers.has(fiber.alternate)),
              isSuspended,
              source,
              stack: fiber._debugOwner == null || fiber._debugStack == null ? null : parseStackTrace(fiber._debugStack, 1),
              hasLegacyContext,
              key: key != null ? key : null,
              type: elementType,
              context,
              hooks,
              props: memoizedProps,
              state: showState ? memoizedState : null,
              errors: componentLogsEntry === undefined ? [] : Array.from(componentLogsEntry.errors.entries()),
              warnings: componentLogsEntry === undefined ? [] : Array.from(componentLogsEntry.warnings.entries()),
              suspendedBy,
              suspendedByRange,
              unknownSuspenders,
              owners,
              env: null,
              rootType,
              rendererPackageName: renderer.rendererPackageName,
              rendererVersion: renderer.version,
              plugins,
              nativeTag
            };
          }
          function inspectVirtualInstanceRaw(virtualInstance) {
            var source = getSourceForInstance(virtualInstance);
            var componentInfo = virtualInstance.data;
            var key = typeof componentInfo.key === "string" ? componentInfo.key : null;
            var props = componentInfo.props == null ? null : componentInfo.props;
            var owners = getOwnersListFromInstance(virtualInstance);
            var rootType = null;
            var hasErrorBoundary = false;
            var hasSuspenseBoundary = false;
            var nearestFiber = getNearestFiber(virtualInstance);
            if (nearestFiber !== null) {
              var current = nearestFiber;
              while (current.return !== null) {
                var temp = current;
                current = current.return;
                if (temp.tag === SuspenseComponent) {
                  hasSuspenseBoundary = true;
                } else if (isErrorBoundary(temp)) {
                  hasErrorBoundary = true;
                }
              }
              var fiberRoot = current.stateNode;
              if (fiberRoot != null && fiberRoot._debugRootType !== null) {
                rootType = fiberRoot._debugRootType;
              }
            }
            var plugins = {
              stylex: null
            };
            var componentLogsEntry = componentInfoToComponentLogsMap.get(componentInfo);
            var isSuspended = null;
            var suspendedBy = getSuspendedByOfInstance(virtualInstance, null);
            var suspendedByRange = getSuspendedByRange(getNearestSuspenseNode(virtualInstance));
            return {
              id: virtualInstance.id,
              canEditHooks: false,
              canEditFunctionProps: false,
              canEditHooksAndDeletePaths: false,
              canEditHooksAndRenamePaths: false,
              canEditFunctionPropsDeletePaths: false,
              canEditFunctionPropsRenamePaths: false,
              canToggleError: supportsTogglingError && hasErrorBoundary,
              isErrored: false,
              canToggleSuspense: supportsTogglingSuspense && hasSuspenseBoundary,
              isSuspended,
              source,
              stack: componentInfo.owner == null || componentInfo.debugStack == null ? null : parseStackTrace(componentInfo.debugStack, 1),
              hasLegacyContext: false,
              key,
              type: types_ElementTypeVirtual,
              context: null,
              hooks: null,
              props,
              state: null,
              errors: componentLogsEntry === undefined ? [] : Array.from(componentLogsEntry.errors.entries()),
              warnings: componentLogsEntry === undefined ? [] : Array.from(componentLogsEntry.warnings.entries()),
              suspendedBy,
              suspendedByRange,
              unknownSuspenders: UNKNOWN_SUSPENDERS_NONE,
              owners,
              env: componentInfo.env == null ? null : componentInfo.env,
              rootType,
              rendererPackageName: renderer.rendererPackageName,
              rendererVersion: renderer.version,
              plugins,
              nativeTag: null
            };
          }
          var mostRecentlyInspectedElement = null;
          var hasElementUpdatedSinceLastInspected = false;
          var currentlyInspectedPaths = {};
          function isMostRecentlyInspectedElement(id) {
            if (mostRecentlyInspectedElement === null) {
              return false;
            }
            if (mostRecentlyInspectedElement.id === id) {
              return true;
            }
            if (mostRecentlyInspectedElement.type === ElementTypeRoot) {
              var instance = idToDevToolsInstanceMap.get(id);
              return instance !== undefined && instance.kind === FIBER_INSTANCE && instance.parent === null;
            }
            return false;
          }
          function isMostRecentlyInspectedElementCurrent(id) {
            return isMostRecentlyInspectedElement(id) && !hasElementUpdatedSinceLastInspected;
          }
          function mergeInspectedPaths(path) {
            var current = currentlyInspectedPaths;
            path.forEach(function(key) {
              if (!current[key]) {
                current[key] = {};
              }
              current = current[key];
            });
          }
          function createIsPathAllowed(key, secondaryCategory) {
            return function isPathAllowed(path) {
              switch (secondaryCategory) {
                case "hooks":
                  if (path.length === 1) {
                    return true;
                  }
                  if (path[path.length - 2] === "hookSource" && path[path.length - 1] === "fileName") {
                    return true;
                  }
                  if (path[path.length - 1] === "subHooks" || path[path.length - 2] === "subHooks") {
                    return true;
                  }
                  break;
                case "suspendedBy":
                  if (path.length < 5) {
                    return true;
                  }
                  break;
                default:
                  break;
              }
              var current = key === null ? currentlyInspectedPaths : currentlyInspectedPaths[key];
              if (!current) {
                return false;
              }
              for (var i = 0;i < path.length; i++) {
                current = current[path[i]];
                if (!current) {
                  return false;
                }
              }
              return true;
            };
          }
          function updateSelectedElement(inspectedElement) {
            var { hooks, id, props } = inspectedElement;
            var devtoolsInstance = idToDevToolsInstanceMap.get(id);
            if (devtoolsInstance === undefined) {
              console.warn('Could not find DevToolsInstance with id "'.concat(id, '"'));
              return;
            }
            if (devtoolsInstance.kind !== FIBER_INSTANCE) {
              return;
            }
            var fiber = devtoolsInstance.data;
            var { elementType, stateNode, tag, type } = fiber;
            switch (tag) {
              case ClassComponent:
              case IncompleteClassComponent:
              case IndeterminateComponent:
                global2.$r = stateNode;
                break;
              case IncompleteFunctionComponent:
              case FunctionComponent:
                global2.$r = {
                  hooks,
                  props,
                  type
                };
                break;
              case ForwardRef:
                global2.$r = {
                  hooks,
                  props,
                  type: type.render
                };
                break;
              case MemoComponent:
              case SimpleMemoComponent:
                global2.$r = {
                  hooks,
                  props,
                  type: elementType != null && elementType.type != null ? elementType.type : type
                };
                break;
              default:
                global2.$r = null;
                break;
            }
          }
          function storeAsGlobal(id, path, count) {
            if (isMostRecentlyInspectedElement(id)) {
              var value = utils_getInObject(mostRecentlyInspectedElement, path);
              var key = "$reactTemp".concat(count);
              window[key] = value;
              console.log(key);
              console.log(value);
            }
          }
          function getSerializedElementValueByPath(id, path) {
            if (isMostRecentlyInspectedElement(id)) {
              var valueToCopy = utils_getInObject(mostRecentlyInspectedElement, path);
              return serializeToString(valueToCopy);
            }
          }
          function inspectElement(requestID, id, path, forceFullData) {
            if (path !== null) {
              mergeInspectedPaths(path);
            }
            if (isMostRecentlyInspectedElement(id) && !forceFullData) {
              if (!hasElementUpdatedSinceLastInspected) {
                if (path !== null) {
                  var secondaryCategory = null;
                  if (path[0] === "hooks" || path[0] === "suspendedBy") {
                    secondaryCategory = path[0];
                  }
                  return {
                    id,
                    responseID: requestID,
                    type: "hydrated-path",
                    path,
                    value: cleanForBridge(utils_getInObject(mostRecentlyInspectedElement, path), createIsPathAllowed(null, secondaryCategory), path)
                  };
                } else {
                  return {
                    id,
                    responseID: requestID,
                    type: "no-change"
                  };
                }
              }
            } else {
              currentlyInspectedPaths = {};
            }
            hasElementUpdatedSinceLastInspected = false;
            try {
              mostRecentlyInspectedElement = inspectElementRaw(id);
            } catch (error) {
              if (error.name === "ReactDebugToolsRenderError") {
                var message = "Error rendering inspected element.";
                var stack;
                console.error(message + `

`, error);
                if (error.cause != null) {
                  var componentName = getDisplayNameForElementID(id);
                  console.error("React DevTools encountered an error while trying to inspect hooks. " + "This is most likely caused by an error in current inspected component" + (componentName != null ? ': "'.concat(componentName, '".') : ".") + `
The error thrown in the component is: 

`, error.cause);
                  if (error.cause instanceof Error) {
                    message = error.cause.message || message;
                    stack = error.cause.stack;
                  }
                }
                return {
                  type: "error",
                  errorType: "user",
                  id,
                  responseID: requestID,
                  message,
                  stack
                };
              }
              if (error.name === "ReactDebugToolsUnsupportedHookError") {
                return {
                  type: "error",
                  errorType: "unknown-hook",
                  id,
                  responseID: requestID,
                  message: "Unsupported hook in the react-debug-tools package: " + error.message
                };
              }
              console.error(`Error inspecting element.

`, error);
              return {
                type: "error",
                errorType: "uncaught",
                id,
                responseID: requestID,
                message: error.message,
                stack: error.stack
              };
            }
            if (mostRecentlyInspectedElement === null) {
              return {
                id,
                responseID: requestID,
                type: "not-found"
              };
            }
            var inspectedElement = mostRecentlyInspectedElement;
            updateSelectedElement(inspectedElement);
            var cleanedInspectedElement = renderer_objectSpread({}, inspectedElement);
            cleanedInspectedElement.context = cleanForBridge(inspectedElement.context, createIsPathAllowed("context", null));
            cleanedInspectedElement.hooks = cleanForBridge(inspectedElement.hooks, createIsPathAllowed("hooks", "hooks"));
            cleanedInspectedElement.props = cleanForBridge(inspectedElement.props, createIsPathAllowed("props", null));
            cleanedInspectedElement.state = cleanForBridge(inspectedElement.state, createIsPathAllowed("state", null));
            cleanedInspectedElement.suspendedBy = cleanForBridge(inspectedElement.suspendedBy, createIsPathAllowed("suspendedBy", "suspendedBy"));
            return {
              id,
              responseID: requestID,
              type: "full-data",
              value: cleanedInspectedElement
            };
          }
          function inspectRootsRaw(arbitraryRootID) {
            var roots = hook.getFiberRoots(rendererID);
            if (roots.size === 0) {
              return null;
            }
            var inspectedRoots = {
              id: arbitraryRootID,
              type: ElementTypeRoot,
              isErrored: false,
              errors: [],
              warnings: [],
              suspendedBy: [],
              suspendedByRange: null,
              unknownSuspenders: UNKNOWN_SUSPENDERS_NONE,
              rootType: null,
              plugins: {
                stylex: null
              },
              nativeTag: null,
              env: null,
              source: null,
              stack: null,
              rendererPackageName: null,
              rendererVersion: null,
              key: null,
              canEditFunctionProps: false,
              canEditHooks: false,
              canEditFunctionPropsDeletePaths: false,
              canEditFunctionPropsRenamePaths: false,
              canEditHooksAndDeletePaths: false,
              canEditHooksAndRenamePaths: false,
              canToggleError: false,
              canToggleSuspense: false,
              isSuspended: false,
              hasLegacyContext: false,
              context: null,
              hooks: null,
              props: null,
              state: null,
              owners: null
            };
            var minSuspendedByRange = Infinity;
            var maxSuspendedByRange = -Infinity;
            roots.forEach(function(root) {
              var rootInstance = rootToFiberInstanceMap.get(root);
              if (rootInstance === undefined) {
                throw new Error("Expected a root instance to exist for this Fiber root");
              }
              var inspectedRoot = inspectFiberInstanceRaw(rootInstance);
              if (inspectedRoot === null) {
                return;
              }
              if (inspectedRoot.isErrored) {
                inspectedRoots.isErrored = true;
              }
              for (var i = 0;i < inspectedRoot.errors.length; i++) {
                inspectedRoots.errors.push(inspectedRoot.errors[i]);
              }
              for (var _i = 0;_i < inspectedRoot.warnings.length; _i++) {
                inspectedRoots.warnings.push(inspectedRoot.warnings[_i]);
              }
              for (var _i2 = 0;_i2 < inspectedRoot.suspendedBy.length; _i2++) {
                inspectedRoots.suspendedBy.push(inspectedRoot.suspendedBy[_i2]);
              }
              var suspendedByRange = inspectedRoot.suspendedByRange;
              if (suspendedByRange !== null) {
                if (suspendedByRange[0] < minSuspendedByRange) {
                  minSuspendedByRange = suspendedByRange[0];
                }
                if (suspendedByRange[1] > maxSuspendedByRange) {
                  maxSuspendedByRange = suspendedByRange[1];
                }
              }
            });
            if (minSuspendedByRange !== Infinity || maxSuspendedByRange !== -Infinity) {
              inspectedRoots.suspendedByRange = [minSuspendedByRange, maxSuspendedByRange];
            }
            return inspectedRoots;
          }
          function logElementToConsole(id) {
            var result = isMostRecentlyInspectedElementCurrent(id) ? mostRecentlyInspectedElement : inspectElementRaw(id);
            if (result === null) {
              console.warn('Could not find DevToolsInstance with id "'.concat(id, '"'));
              return;
            }
            var displayName = getDisplayNameForElementID(id);
            var supportsGroup = typeof console.groupCollapsed === "function";
            if (supportsGroup) {
              console.groupCollapsed("[Click to expand] %c<".concat(displayName || "Component", " />"), "color: var(--dom-tag-name-color); font-weight: normal;");
            }
            if (result.props !== null) {
              console.log("Props:", result.props);
            }
            if (result.state !== null) {
              console.log("State:", result.state);
            }
            if (result.hooks !== null) {
              console.log("Hooks:", result.hooks);
            }
            var hostInstances = findHostInstancesForElementID(id);
            if (hostInstances !== null) {
              console.log("Nodes:", hostInstances);
            }
            if (window.chrome || /firefox/i.test(navigator.userAgent)) {
              console.log("Right-click any value to save it as a global variable for further inspection.");
            }
            if (supportsGroup) {
              console.groupEnd();
            }
          }
          function deletePath(type, id, hookID, path) {
            var devtoolsInstance = idToDevToolsInstanceMap.get(id);
            if (devtoolsInstance === undefined) {
              console.warn('Could not find DevToolsInstance with id "'.concat(id, '"'));
              return;
            }
            if (devtoolsInstance.kind !== FIBER_INSTANCE) {
              return;
            }
            var fiber = devtoolsInstance.data;
            if (fiber !== null) {
              var instance = fiber.stateNode;
              switch (type) {
                case "context":
                  path = path.slice(1);
                  switch (fiber.tag) {
                    case ClassComponent:
                      if (path.length === 0) {} else {
                        deletePathInObject(instance.context, path);
                      }
                      instance.forceUpdate();
                      break;
                    case FunctionComponent:
                      break;
                  }
                  break;
                case "hooks":
                  if (typeof overrideHookStateDeletePath === "function") {
                    overrideHookStateDeletePath(fiber, hookID, path);
                  }
                  break;
                case "props":
                  if (instance === null) {
                    if (typeof overridePropsDeletePath === "function") {
                      overridePropsDeletePath(fiber, path);
                    }
                  } else {
                    fiber.pendingProps = copyWithDelete(instance.props, path);
                    instance.forceUpdate();
                  }
                  break;
                case "state":
                  deletePathInObject(instance.state, path);
                  instance.forceUpdate();
                  break;
              }
            }
          }
          function renamePath(type, id, hookID, oldPath, newPath) {
            var devtoolsInstance = idToDevToolsInstanceMap.get(id);
            if (devtoolsInstance === undefined) {
              console.warn('Could not find DevToolsInstance with id "'.concat(id, '"'));
              return;
            }
            if (devtoolsInstance.kind !== FIBER_INSTANCE) {
              return;
            }
            var fiber = devtoolsInstance.data;
            if (fiber !== null) {
              var instance = fiber.stateNode;
              switch (type) {
                case "context":
                  oldPath = oldPath.slice(1);
                  newPath = newPath.slice(1);
                  switch (fiber.tag) {
                    case ClassComponent:
                      if (oldPath.length === 0) {} else {
                        renamePathInObject(instance.context, oldPath, newPath);
                      }
                      instance.forceUpdate();
                      break;
                    case FunctionComponent:
                      break;
                  }
                  break;
                case "hooks":
                  if (typeof overrideHookStateRenamePath === "function") {
                    overrideHookStateRenamePath(fiber, hookID, oldPath, newPath);
                  }
                  break;
                case "props":
                  if (instance === null) {
                    if (typeof overridePropsRenamePath === "function") {
                      overridePropsRenamePath(fiber, oldPath, newPath);
                    }
                  } else {
                    fiber.pendingProps = copyWithRename(instance.props, oldPath, newPath);
                    instance.forceUpdate();
                  }
                  break;
                case "state":
                  renamePathInObject(instance.state, oldPath, newPath);
                  instance.forceUpdate();
                  break;
              }
            }
          }
          function overrideValueAtPath(type, id, hookID, path, value) {
            var devtoolsInstance = idToDevToolsInstanceMap.get(id);
            if (devtoolsInstance === undefined) {
              console.warn('Could not find DevToolsInstance with id "'.concat(id, '"'));
              return;
            }
            if (devtoolsInstance.kind !== FIBER_INSTANCE) {
              return;
            }
            var fiber = devtoolsInstance.data;
            if (fiber !== null) {
              var instance = fiber.stateNode;
              switch (type) {
                case "context":
                  path = path.slice(1);
                  switch (fiber.tag) {
                    case ClassComponent:
                      if (path.length === 0) {
                        instance.context = value;
                      } else {
                        utils_setInObject(instance.context, path, value);
                      }
                      instance.forceUpdate();
                      break;
                    case FunctionComponent:
                      break;
                  }
                  break;
                case "hooks":
                  if (typeof overrideHookState === "function") {
                    overrideHookState(fiber, hookID, path, value);
                  }
                  break;
                case "props":
                  switch (fiber.tag) {
                    case ClassComponent:
                      fiber.pendingProps = copyWithSet(instance.props, path, value);
                      instance.forceUpdate();
                      break;
                    default:
                      if (typeof overrideProps === "function") {
                        overrideProps(fiber, path, value);
                      }
                      break;
                  }
                  break;
                case "state":
                  switch (fiber.tag) {
                    case ClassComponent:
                      utils_setInObject(instance.state, path, value);
                      instance.forceUpdate();
                      break;
                  }
                  break;
              }
            }
          }
          var currentCommitProfilingMetadata = null;
          var displayNamesByRootID = null;
          var initialTreeBaseDurationsMap = null;
          var isProfiling = false;
          var profilingStartTime = 0;
          var recordChangeDescriptions = false;
          var recordTimeline = false;
          var rootToCommitProfilingMetadataMap = null;
          function getProfilingData() {
            var dataForRoots = [];
            if (rootToCommitProfilingMetadataMap === null) {
              throw Error("getProfilingData() called before any profiling data was recorded");
            }
            rootToCommitProfilingMetadataMap.forEach(function(commitProfilingMetadata, rootID) {
              var commitData = [];
              var displayName = displayNamesByRootID !== null && displayNamesByRootID.get(rootID) || "Unknown";
              var initialTreeBaseDurations = initialTreeBaseDurationsMap !== null && initialTreeBaseDurationsMap.get(rootID) || [];
              commitProfilingMetadata.forEach(function(commitProfilingData, commitIndex) {
                var { changeDescriptions, durations, effectDuration, maxActualDuration, passiveEffectDuration, priorityLevel, commitTime, updaters } = commitProfilingData;
                var fiberActualDurations = [];
                var fiberSelfDurations = [];
                for (var i = 0;i < durations.length; i += 3) {
                  var fiberID = durations[i];
                  fiberActualDurations.push([fiberID, formatDurationToMicrosecondsGranularity(durations[i + 1])]);
                  fiberSelfDurations.push([fiberID, formatDurationToMicrosecondsGranularity(durations[i + 2])]);
                }
                commitData.push({
                  changeDescriptions: changeDescriptions !== null ? Array.from(changeDescriptions.entries()) : null,
                  duration: formatDurationToMicrosecondsGranularity(maxActualDuration),
                  effectDuration: effectDuration !== null ? formatDurationToMicrosecondsGranularity(effectDuration) : null,
                  fiberActualDurations,
                  fiberSelfDurations,
                  passiveEffectDuration: passiveEffectDuration !== null ? formatDurationToMicrosecondsGranularity(passiveEffectDuration) : null,
                  priorityLevel,
                  timestamp: commitTime,
                  updaters
                });
              });
              dataForRoots.push({
                commitData,
                displayName,
                initialTreeBaseDurations,
                rootID
              });
            });
            var timelineData = null;
            if (typeof getTimelineData === "function") {
              var currentTimelineData = getTimelineData();
              if (currentTimelineData) {
                var { batchUIDToMeasuresMap, internalModuleSourceToRanges, laneToLabelMap, laneToReactMeasureMap } = currentTimelineData, rest = _objectWithoutProperties(currentTimelineData, _excluded);
                timelineData = renderer_objectSpread(renderer_objectSpread({}, rest), {}, {
                  batchUIDToMeasuresKeyValueArray: Array.from(batchUIDToMeasuresMap.entries()),
                  internalModuleSourceToRanges: Array.from(internalModuleSourceToRanges.entries()),
                  laneToLabelKeyValueArray: Array.from(laneToLabelMap.entries()),
                  laneToReactMeasureKeyValueArray: Array.from(laneToReactMeasureMap.entries())
                });
              }
            }
            return {
              dataForRoots,
              rendererID,
              timelineData
            };
          }
          function snapshotTreeBaseDurations(instance, target) {
            if (instance.kind !== FILTERED_FIBER_INSTANCE) {
              target.push([instance.id, instance.treeBaseDuration]);
            }
            for (var child = instance.firstChild;child !== null; child = child.nextSibling) {
              snapshotTreeBaseDurations(child, target);
            }
          }
          function startProfiling(shouldRecordChangeDescriptions, shouldRecordTimeline) {
            if (isProfiling) {
              return;
            }
            recordChangeDescriptions = shouldRecordChangeDescriptions;
            recordTimeline = shouldRecordTimeline;
            displayNamesByRootID = new Map;
            initialTreeBaseDurationsMap = new Map;
            hook.getFiberRoots(rendererID).forEach(function(root) {
              var rootInstance = rootToFiberInstanceMap.get(root);
              if (rootInstance === undefined) {
                throw new Error("Expected the root instance to already exist when starting profiling");
              }
              var rootID = rootInstance.id;
              displayNamesByRootID.set(rootID, getDisplayNameForRoot(root.current));
              var initialTreeBaseDurations = [];
              snapshotTreeBaseDurations(rootInstance, initialTreeBaseDurations);
              initialTreeBaseDurationsMap.set(rootID, initialTreeBaseDurations);
            });
            isProfiling = true;
            profilingStartTime = renderer_getCurrentTime();
            rootToCommitProfilingMetadataMap = new Map;
            if (toggleProfilingStatus !== null) {
              toggleProfilingStatus(true, recordTimeline);
            }
          }
          function stopProfiling() {
            isProfiling = false;
            recordChangeDescriptions = false;
            if (toggleProfilingStatus !== null) {
              toggleProfilingStatus(false, recordTimeline);
            }
            recordTimeline = false;
          }
          if (shouldStartProfilingNow) {
            startProfiling(profilingSettings.recordChangeDescriptions, profilingSettings.recordTimeline);
          }
          function getNearestFiber(devtoolsInstance) {
            if (devtoolsInstance.kind === VIRTUAL_INSTANCE) {
              var inst = devtoolsInstance;
              while (inst.kind === VIRTUAL_INSTANCE) {
                if (inst.firstChild === null) {
                  return null;
                }
                inst = inst.firstChild;
              }
              return inst.data.return;
            } else {
              return devtoolsInstance.data;
            }
          }
          function shouldErrorFiberAlwaysNull() {
            return null;
          }
          var forceErrorForFibers = new Map;
          function shouldErrorFiberAccordingToMap(fiber) {
            if (typeof setErrorHandler !== "function") {
              throw new Error("Expected overrideError() to not get called for earlier React versions.");
            }
            var status = forceErrorForFibers.get(fiber);
            if (status === false) {
              forceErrorForFibers.delete(fiber);
              if (forceErrorForFibers.size === 0) {
                setErrorHandler(shouldErrorFiberAlwaysNull);
              }
              return false;
            }
            if (status === undefined && fiber.alternate !== null) {
              status = forceErrorForFibers.get(fiber.alternate);
              if (status === false) {
                forceErrorForFibers.delete(fiber.alternate);
                if (forceErrorForFibers.size === 0) {
                  setErrorHandler(shouldErrorFiberAlwaysNull);
                }
              }
            }
            if (status === undefined) {
              return false;
            }
            return status;
          }
          function overrideError(id, forceError) {
            if (typeof setErrorHandler !== "function" || typeof scheduleUpdate !== "function") {
              throw new Error("Expected overrideError() to not get called for earlier React versions.");
            }
            var devtoolsInstance = idToDevToolsInstanceMap.get(id);
            if (devtoolsInstance === undefined) {
              return;
            }
            var nearestFiber = getNearestFiber(devtoolsInstance);
            if (nearestFiber === null) {
              return;
            }
            var fiber = nearestFiber;
            while (!isErrorBoundary(fiber)) {
              if (fiber.return === null) {
                return;
              }
              fiber = fiber.return;
            }
            forceErrorForFibers.set(fiber, forceError);
            if (fiber.alternate !== null) {
              forceErrorForFibers.delete(fiber.alternate);
            }
            if (forceErrorForFibers.size === 1) {
              setErrorHandler(shouldErrorFiberAccordingToMap);
            }
            if (!forceError && typeof scheduleRetry === "function") {
              scheduleRetry(fiber);
            } else {
              scheduleUpdate(fiber);
            }
          }
          function shouldSuspendFiberAlwaysFalse() {
            return false;
          }
          var forceFallbackForFibers = new Set;
          function shouldSuspendFiberAccordingToSet(fiber) {
            return forceFallbackForFibers.has(fiber) || fiber.alternate !== null && forceFallbackForFibers.has(fiber.alternate);
          }
          function overrideSuspense(id, forceFallback) {
            if (typeof setSuspenseHandler !== "function" || typeof scheduleUpdate !== "function") {
              throw new Error("Expected overrideSuspense() to not get called for earlier React versions.");
            }
            var devtoolsInstance = idToDevToolsInstanceMap.get(id);
            if (devtoolsInstance === undefined) {
              return;
            }
            var nearestFiber = getNearestFiber(devtoolsInstance);
            if (nearestFiber === null) {
              return;
            }
            var fiber = nearestFiber;
            while (fiber.tag !== SuspenseComponent) {
              if (fiber.return === null) {
                return;
              }
              fiber = fiber.return;
            }
            if (fiber.alternate !== null) {
              forceFallbackForFibers.delete(fiber.alternate);
            }
            if (forceFallback) {
              forceFallbackForFibers.add(fiber);
              if (forceFallbackForFibers.size === 1) {
                setSuspenseHandler(shouldSuspendFiberAccordingToSet);
              }
            } else {
              forceFallbackForFibers.delete(fiber);
              if (forceFallbackForFibers.size === 0) {
                setSuspenseHandler(shouldSuspendFiberAlwaysFalse);
              }
            }
            if (!forceFallback && typeof scheduleRetry === "function") {
              scheduleRetry(fiber);
            } else {
              scheduleUpdate(fiber);
            }
          }
          function overrideSuspenseMilestone(suspendedSet) {
            if (typeof setSuspenseHandler !== "function" || typeof scheduleUpdate !== "function") {
              throw new Error("Expected overrideSuspenseMilestone() to not get called for earlier React versions.");
            }
            var unsuspendedSet = new Set(forceFallbackForFibers);
            var resuspended = false;
            for (var i = 0;i < suspendedSet.length; ++i) {
              var instance = idToDevToolsInstanceMap.get(suspendedSet[i]);
              if (instance === undefined) {
                console.warn("Could not suspend ID '".concat(suspendedSet[i], "' since the instance can't be found."));
                continue;
              }
              if (instance.kind === FIBER_INSTANCE) {
                var _fiber11 = instance.data;
                if (forceFallbackForFibers.has(_fiber11) || _fiber11.alternate !== null && forceFallbackForFibers.has(_fiber11.alternate)) {
                  unsuspendedSet.delete(_fiber11);
                  if (_fiber11.alternate !== null) {
                    unsuspendedSet.delete(_fiber11.alternate);
                  }
                } else {
                  forceFallbackForFibers.add(_fiber11);
                  scheduleUpdate(_fiber11);
                  resuspended = true;
                }
              } else {
                console.warn("Cannot not suspend ID '".concat(suspendedSet[i], "'."));
              }
            }
            unsuspendedSet.forEach(function(fiber) {
              forceFallbackForFibers.delete(fiber);
              if (!resuspended && typeof scheduleRetry === "function") {
                scheduleRetry(fiber);
              } else {
                scheduleUpdate(fiber);
              }
            });
            if (forceFallbackForFibers.size > 0) {
              setSuspenseHandler(shouldSuspendFiberAccordingToSet);
            } else {
              setSuspenseHandler(shouldSuspendFiberAlwaysFalse);
            }
          }
          var trackedPath = null;
          var trackedPathMatchFiber = null;
          var trackedPathMatchInstance = null;
          var trackedPathMatchDepth = -1;
          var mightBeOnTrackedPath = false;
          function setTrackedPath(path) {
            if (path === null) {
              trackedPathMatchFiber = null;
              trackedPathMatchInstance = null;
              trackedPathMatchDepth = -1;
              mightBeOnTrackedPath = false;
            }
            trackedPath = path;
          }
          function updateTrackedPathStateBeforeMount(fiber, fiberInstance) {
            if (trackedPath === null || !mightBeOnTrackedPath) {
              return false;
            }
            var returnFiber = fiber.return;
            var returnAlternate = returnFiber !== null ? returnFiber.alternate : null;
            if (trackedPathMatchFiber === returnFiber || trackedPathMatchFiber === returnAlternate && returnAlternate !== null) {
              var actualFrame = getPathFrame(fiber);
              var expectedFrame = trackedPath[trackedPathMatchDepth + 1];
              if (expectedFrame === undefined) {
                throw new Error("Expected to see a frame at the next depth.");
              }
              if (actualFrame.index === expectedFrame.index && actualFrame.key === expectedFrame.key && actualFrame.displayName === expectedFrame.displayName) {
                trackedPathMatchFiber = fiber;
                if (fiberInstance !== null && fiberInstance.kind === FIBER_INSTANCE) {
                  trackedPathMatchInstance = fiberInstance;
                }
                trackedPathMatchDepth++;
                if (trackedPathMatchDepth === trackedPath.length - 1) {
                  mightBeOnTrackedPath = false;
                } else {
                  mightBeOnTrackedPath = true;
                }
                return false;
              }
            }
            if (trackedPathMatchFiber === null && fiberInstance === null) {
              return true;
            }
            mightBeOnTrackedPath = false;
            return true;
          }
          function updateVirtualTrackedPathStateBeforeMount(virtualInstance, parentInstance) {
            if (trackedPath === null || !mightBeOnTrackedPath) {
              return false;
            }
            if (trackedPathMatchInstance === parentInstance) {
              var actualFrame = getVirtualPathFrame(virtualInstance);
              var expectedFrame = trackedPath[trackedPathMatchDepth + 1];
              if (expectedFrame === undefined) {
                throw new Error("Expected to see a frame at the next depth.");
              }
              if (actualFrame.index === expectedFrame.index && actualFrame.key === expectedFrame.key && actualFrame.displayName === expectedFrame.displayName) {
                trackedPathMatchFiber = null;
                trackedPathMatchInstance = virtualInstance;
                trackedPathMatchDepth++;
                if (trackedPathMatchDepth === trackedPath.length - 1) {
                  mightBeOnTrackedPath = false;
                } else {
                  mightBeOnTrackedPath = true;
                }
                return false;
              }
            }
            if (trackedPathMatchFiber !== null) {
              return true;
            }
            mightBeOnTrackedPath = false;
            return true;
          }
          function updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath) {
            mightBeOnTrackedPath = mightSiblingsBeOnTrackedPath;
          }
          var rootPseudoKeys = new Map;
          var rootDisplayNameCounter = new Map;
          function setRootPseudoKey(id, fiber) {
            var name = getDisplayNameForRoot(fiber);
            var counter = rootDisplayNameCounter.get(name) || 0;
            rootDisplayNameCounter.set(name, counter + 1);
            var pseudoKey = "".concat(name, ":").concat(counter);
            rootPseudoKeys.set(id, pseudoKey);
          }
          function removeRootPseudoKey(id) {
            var pseudoKey = rootPseudoKeys.get(id);
            if (pseudoKey === undefined) {
              throw new Error("Expected root pseudo key to be known.");
            }
            var name = pseudoKey.slice(0, pseudoKey.lastIndexOf(":"));
            var counter = rootDisplayNameCounter.get(name);
            if (counter === undefined) {
              throw new Error("Expected counter to be known.");
            }
            if (counter > 1) {
              rootDisplayNameCounter.set(name, counter - 1);
            } else {
              rootDisplayNameCounter.delete(name);
            }
            rootPseudoKeys.delete(id);
          }
          function getDisplayNameForRoot(fiber) {
            var preferredDisplayName = null;
            var fallbackDisplayName = null;
            var child = fiber.child;
            for (var i = 0;i < 3; i++) {
              if (child === null) {
                break;
              }
              var displayName = getDisplayNameForFiber(child);
              if (displayName !== null) {
                if (typeof child.type === "function") {
                  preferredDisplayName = displayName;
                } else if (fallbackDisplayName === null) {
                  fallbackDisplayName = displayName;
                }
              }
              if (preferredDisplayName !== null) {
                break;
              }
              child = child.child;
            }
            return preferredDisplayName || fallbackDisplayName || "Anonymous";
          }
          function getPathFrame(fiber) {
            var key = fiber.key;
            var displayName = getDisplayNameForFiber(fiber);
            var index = fiber.index;
            switch (fiber.tag) {
              case HostRoot:
                var rootInstance = rootToFiberInstanceMap.get(fiber.stateNode);
                if (rootInstance === undefined) {
                  throw new Error("Expected the root instance to exist when computing a path");
                }
                var pseudoKey = rootPseudoKeys.get(rootInstance.id);
                if (pseudoKey === undefined) {
                  throw new Error("Expected mounted root to have known pseudo key.");
                }
                displayName = pseudoKey;
                break;
              case HostComponent:
                displayName = fiber.type;
                break;
              default:
                break;
            }
            return {
              displayName,
              key,
              index
            };
          }
          function getVirtualPathFrame(virtualInstance) {
            return {
              displayName: virtualInstance.data.name || "",
              key: virtualInstance.data.key == null ? null : virtualInstance.data.key,
              index: -1
            };
          }
          function getPathForElement(id) {
            var devtoolsInstance = idToDevToolsInstanceMap.get(id);
            if (devtoolsInstance === undefined) {
              return null;
            }
            var keyPath = [];
            var inst = devtoolsInstance;
            while (inst.kind === VIRTUAL_INSTANCE) {
              keyPath.push(getVirtualPathFrame(inst));
              if (inst.parent === null) {
                return null;
              }
              inst = inst.parent;
            }
            var fiber = inst.data;
            while (fiber !== null) {
              keyPath.push(getPathFrame(fiber));
              fiber = fiber.return;
            }
            keyPath.reverse();
            return keyPath;
          }
          function getBestMatchForTrackedPath() {
            if (trackedPath === null) {
              return null;
            }
            if (trackedPathMatchInstance === null) {
              return null;
            }
            return {
              id: trackedPathMatchInstance.id,
              isFullMatch: trackedPathMatchDepth === trackedPath.length - 1
            };
          }
          var formatPriorityLevel = function formatPriorityLevel(priorityLevel) {
            if (priorityLevel == null) {
              return "Unknown";
            }
            switch (priorityLevel) {
              case ImmediatePriority:
                return "Immediate";
              case UserBlockingPriority:
                return "User-Blocking";
              case NormalPriority:
                return "Normal";
              case LowPriority:
                return "Low";
              case IdlePriority:
                return "Idle";
              case NoPriority:
              default:
                return "Unknown";
            }
          };
          function setTraceUpdatesEnabled(isEnabled2) {
            traceUpdatesEnabled = isEnabled2;
          }
          function hasElementWithId(id) {
            return idToDevToolsInstanceMap.has(id);
          }
          function getSourceForFiberInstance(fiberInstance) {
            var ownerSource = getSourceForInstance(fiberInstance);
            if (ownerSource !== null) {
              return ownerSource;
            }
            var dispatcherRef = getDispatcherRef(renderer);
            var stackFrame = dispatcherRef == null ? null : getSourceLocationByFiber(ReactTypeOfWork, fiberInstance.data, dispatcherRef);
            if (stackFrame === null) {
              return null;
            }
            var source = extractLocationFromComponentStack(stackFrame);
            fiberInstance.source = source;
            return source;
          }
          function getSourceForInstance(instance) {
            var unresolvedSource = instance.source;
            if (unresolvedSource === null) {
              return null;
            }
            if (instance.kind === VIRTUAL_INSTANCE) {
              var debugLocation = instance.data.debugLocation;
              if (debugLocation != null) {
                unresolvedSource = debugLocation;
              }
            }
            if (renderer_isError(unresolvedSource)) {
              return instance.source = extractLocationFromOwnerStack(unresolvedSource);
            }
            if (typeof unresolvedSource === "string") {
              var idx = unresolvedSource.lastIndexOf(`
`);
              var lastLine = idx === -1 ? unresolvedSource : unresolvedSource.slice(idx + 1);
              return instance.source = extractLocationFromComponentStack(lastLine);
            }
            return unresolvedSource;
          }
          var internalMcpFunctions = {};
          if (false) {}
          return renderer_objectSpread({
            cleanup,
            clearErrorsAndWarnings,
            clearErrorsForElementID,
            clearWarningsForElementID,
            getSerializedElementValueByPath,
            deletePath,
            findHostInstancesForElementID,
            findLastKnownRectsForID,
            flushInitialOperations,
            getBestMatchForTrackedPath,
            getDisplayNameForElementID,
            getNearestMountedDOMNode,
            getElementIDForHostInstance,
            getSuspenseNodeIDForHostInstance,
            getInstanceAndStyle,
            getOwnersList,
            getPathForElement,
            getProfilingData,
            handleCommitFiberRoot,
            handleCommitFiberUnmount,
            handlePostCommitFiberRoot,
            hasElementWithId,
            inspectElement,
            logElementToConsole,
            getComponentStack,
            getElementAttributeByPath,
            getElementSourceFunctionById,
            onErrorOrWarning,
            overrideError,
            overrideSuspense,
            overrideSuspenseMilestone,
            overrideValueAtPath,
            renamePath,
            renderer,
            setTraceUpdatesEnabled,
            setTrackedPath,
            startProfiling,
            stopProfiling,
            storeAsGlobal,
            supportsTogglingSuspense,
            updateComponentFilters,
            getEnvironmentNames
          }, internalMcpFunctions);
        }
        function decorate(object, attr, fn) {
          var old = object[attr];
          object[attr] = function(instance) {
            return fn.call(this, old, arguments);
          };
          return old;
        }
        function decorateMany(source, fns) {
          var olds = {};
          for (var name in fns) {
            olds[name] = decorate(source, name, fns[name]);
          }
          return olds;
        }
        function restoreMany(source, olds) {
          for (var name in olds) {
            source[name] = olds[name];
          }
        }
        function forceUpdate(instance) {
          if (typeof instance.forceUpdate === "function") {
            instance.forceUpdate();
          } else if (instance.updater != null && typeof instance.updater.enqueueForceUpdate === "function") {
            instance.updater.enqueueForceUpdate(this, function() {}, "forceUpdate");
          }
        }
        function legacy_renderer_ownKeys(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function(r2) {
              return Object.getOwnPropertyDescriptor(e, r2).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function legacy_renderer_objectSpread(e) {
          for (var r = 1;r < arguments.length; r++) {
            var t = arguments[r] != null ? arguments[r] : {};
            r % 2 ? legacy_renderer_ownKeys(Object(t), true).forEach(function(r2) {
              legacy_renderer_defineProperty(e, r2, t[r2]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : legacy_renderer_ownKeys(Object(t)).forEach(function(r2) {
              Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
            });
          }
          return e;
        }
        function legacy_renderer_defineProperty(obj, key, value) {
          key = legacy_renderer_toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function legacy_renderer_toPropertyKey(t) {
          var i = legacy_renderer_toPrimitive(t, "string");
          return legacy_renderer_typeof(i) == "symbol" ? i : i + "";
        }
        function legacy_renderer_toPrimitive(t, r) {
          if (legacy_renderer_typeof(t) != "object" || !t)
            return t;
          var e = t[Symbol.toPrimitive];
          if (e !== undefined) {
            var i = e.call(t, r || "default");
            if (legacy_renderer_typeof(i) != "object")
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (r === "string" ? String : Number)(t);
        }
        function legacy_renderer_typeof(o) {
          "@babel/helpers - typeof";
          return legacy_renderer_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, legacy_renderer_typeof(o);
        }
        function getData(internalInstance) {
          var displayName = null;
          var key = null;
          if (internalInstance._currentElement != null) {
            if (internalInstance._currentElement.key) {
              key = String(internalInstance._currentElement.key);
            }
            var elementType = internalInstance._currentElement.type;
            if (typeof elementType === "string") {
              displayName = elementType;
            } else if (typeof elementType === "function") {
              displayName = getDisplayName(elementType);
            }
          }
          return {
            displayName,
            key
          };
        }
        function getElementType(internalInstance) {
          if (internalInstance._currentElement != null) {
            var elementType = internalInstance._currentElement.type;
            if (typeof elementType === "function") {
              var publicInstance = internalInstance.getPublicInstance();
              if (publicInstance !== null) {
                return types_ElementTypeClass;
              } else {
                return types_ElementTypeFunction;
              }
            } else if (typeof elementType === "string") {
              return ElementTypeHostComponent;
            }
          }
          return ElementTypeOtherOrUnknown;
        }
        function getChildren(internalInstance) {
          var children = [];
          if (legacy_renderer_typeof(internalInstance) !== "object") {} else if (internalInstance._currentElement === null || internalInstance._currentElement === false) {} else if (internalInstance._renderedComponent) {
            var child = internalInstance._renderedComponent;
            if (getElementType(child) !== ElementTypeOtherOrUnknown) {
              children.push(child);
            }
          } else if (internalInstance._renderedChildren) {
            var renderedChildren = internalInstance._renderedChildren;
            for (var name in renderedChildren) {
              var _child = renderedChildren[name];
              if (getElementType(_child) !== ElementTypeOtherOrUnknown) {
                children.push(_child);
              }
            }
          }
          return children;
        }
        function legacy_renderer_attach(hook, rendererID, renderer, global2) {
          var idToInternalInstanceMap = new Map;
          var internalInstanceToIDMap = new WeakMap;
          var internalInstanceToRootIDMap = new WeakMap;
          var getElementIDForHostInstance = null;
          var findHostInstanceForInternalID;
          var getNearestMountedDOMNode = function getNearestMountedDOMNode(node) {
            return null;
          };
          if (renderer.ComponentTree) {
            getElementIDForHostInstance = function getElementIDForHostInstance(node) {
              var internalInstance = renderer.ComponentTree.getClosestInstanceFromNode(node);
              return internalInstanceToIDMap.get(internalInstance) || null;
            };
            findHostInstanceForInternalID = function findHostInstanceForInternalID(id) {
              var internalInstance = idToInternalInstanceMap.get(id);
              return renderer.ComponentTree.getNodeFromInstance(internalInstance);
            };
            getNearestMountedDOMNode = function getNearestMountedDOMNode(node) {
              var internalInstance = renderer.ComponentTree.getClosestInstanceFromNode(node);
              if (internalInstance != null) {
                return renderer.ComponentTree.getNodeFromInstance(internalInstance);
              }
              return null;
            };
          } else if (renderer.Mount.getID && renderer.Mount.getNode) {
            getElementIDForHostInstance = function getElementIDForHostInstance(node) {
              return null;
            };
            findHostInstanceForInternalID = function findHostInstanceForInternalID(id) {
              return null;
            };
          }
          var supportsTogglingSuspense = false;
          function getDisplayNameForElementID(id) {
            var internalInstance = idToInternalInstanceMap.get(id);
            return internalInstance ? getData(internalInstance).displayName : null;
          }
          function getID(internalInstance) {
            if (legacy_renderer_typeof(internalInstance) !== "object" || internalInstance === null) {
              throw new Error("Invalid internal instance: " + internalInstance);
            }
            if (!internalInstanceToIDMap.has(internalInstance)) {
              var _id = getUID();
              internalInstanceToIDMap.set(internalInstance, _id);
              idToInternalInstanceMap.set(_id, internalInstance);
            }
            return internalInstanceToIDMap.get(internalInstance);
          }
          function areEqualArrays(a, b) {
            if (a.length !== b.length) {
              return false;
            }
            for (var i = 0;i < a.length; i++) {
              if (a[i] !== b[i]) {
                return false;
              }
            }
            return true;
          }
          var parentIDStack = [];
          var oldReconcilerMethods = null;
          if (renderer.Reconciler) {
            oldReconcilerMethods = decorateMany(renderer.Reconciler, {
              mountComponent: function mountComponent(fn, args) {
                var internalInstance = args[0];
                var hostContainerInfo = args[3];
                if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {
                  return fn.apply(this, args);
                }
                if (hostContainerInfo._topLevelWrapper === undefined) {
                  return fn.apply(this, args);
                }
                var id = getID(internalInstance);
                var parentID = parentIDStack.length > 0 ? parentIDStack[parentIDStack.length - 1] : 0;
                recordMount(internalInstance, id, parentID);
                parentIDStack.push(id);
                internalInstanceToRootIDMap.set(internalInstance, getID(hostContainerInfo._topLevelWrapper));
                try {
                  var result = fn.apply(this, args);
                  parentIDStack.pop();
                  return result;
                } catch (err) {
                  parentIDStack = [];
                  throw err;
                } finally {
                  if (parentIDStack.length === 0) {
                    var rootID = internalInstanceToRootIDMap.get(internalInstance);
                    if (rootID === undefined) {
                      throw new Error("Expected to find root ID.");
                    }
                    flushPendingEvents(rootID);
                  }
                }
              },
              performUpdateIfNecessary: function performUpdateIfNecessary(fn, args) {
                var internalInstance = args[0];
                if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {
                  return fn.apply(this, args);
                }
                var id = getID(internalInstance);
                parentIDStack.push(id);
                var prevChildren = getChildren(internalInstance);
                try {
                  var result = fn.apply(this, args);
                  var nextChildren = getChildren(internalInstance);
                  if (!areEqualArrays(prevChildren, nextChildren)) {
                    recordReorder(internalInstance, id, nextChildren);
                  }
                  parentIDStack.pop();
                  return result;
                } catch (err) {
                  parentIDStack = [];
                  throw err;
                } finally {
                  if (parentIDStack.length === 0) {
                    var rootID = internalInstanceToRootIDMap.get(internalInstance);
                    if (rootID === undefined) {
                      throw new Error("Expected to find root ID.");
                    }
                    flushPendingEvents(rootID);
                  }
                }
              },
              receiveComponent: function receiveComponent(fn, args) {
                var internalInstance = args[0];
                if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {
                  return fn.apply(this, args);
                }
                var id = getID(internalInstance);
                parentIDStack.push(id);
                var prevChildren = getChildren(internalInstance);
                try {
                  var result = fn.apply(this, args);
                  var nextChildren = getChildren(internalInstance);
                  if (!areEqualArrays(prevChildren, nextChildren)) {
                    recordReorder(internalInstance, id, nextChildren);
                  }
                  parentIDStack.pop();
                  return result;
                } catch (err) {
                  parentIDStack = [];
                  throw err;
                } finally {
                  if (parentIDStack.length === 0) {
                    var rootID = internalInstanceToRootIDMap.get(internalInstance);
                    if (rootID === undefined) {
                      throw new Error("Expected to find root ID.");
                    }
                    flushPendingEvents(rootID);
                  }
                }
              },
              unmountComponent: function unmountComponent(fn, args) {
                var internalInstance = args[0];
                if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {
                  return fn.apply(this, args);
                }
                var id = getID(internalInstance);
                parentIDStack.push(id);
                try {
                  var result = fn.apply(this, args);
                  parentIDStack.pop();
                  recordUnmount(internalInstance, id);
                  return result;
                } catch (err) {
                  parentIDStack = [];
                  throw err;
                } finally {
                  if (parentIDStack.length === 0) {
                    var rootID = internalInstanceToRootIDMap.get(internalInstance);
                    if (rootID === undefined) {
                      throw new Error("Expected to find root ID.");
                    }
                    flushPendingEvents(rootID);
                  }
                }
              }
            });
          }
          function cleanup() {
            if (oldReconcilerMethods !== null) {
              if (renderer.Component) {
                restoreMany(renderer.Component.Mixin, oldReconcilerMethods);
              } else {
                restoreMany(renderer.Reconciler, oldReconcilerMethods);
              }
            }
            oldReconcilerMethods = null;
          }
          function recordMount(internalInstance, id, parentID) {
            var isRoot = parentID === 0;
            if (__DEBUG__) {
              console.log("%crecordMount()", "color: green; font-weight: bold;", id, getData(internalInstance).displayName);
            }
            if (isRoot) {
              var hasOwnerMetadata = internalInstance._currentElement != null && internalInstance._currentElement._owner != null;
              pushOperation(TREE_OPERATION_ADD);
              pushOperation(id);
              pushOperation(ElementTypeRoot);
              pushOperation(0);
              pushOperation(0);
              pushOperation(0);
              pushOperation(hasOwnerMetadata ? 1 : 0);
              pushOperation(SUSPENSE_TREE_OPERATION_ADD);
              pushOperation(id);
              pushOperation(parentID);
              pushOperation(getStringID(null));
              pushOperation(0);
              pushOperation(-1);
            } else {
              var type = getElementType(internalInstance);
              var _getData = getData(internalInstance), displayName = _getData.displayName, key = _getData.key;
              var ownerID = internalInstance._currentElement != null && internalInstance._currentElement._owner != null ? getID(internalInstance._currentElement._owner) : 0;
              var displayNameStringID = getStringID(displayName);
              var keyStringID = getStringID(key);
              pushOperation(TREE_OPERATION_ADD);
              pushOperation(id);
              pushOperation(type);
              pushOperation(parentID);
              pushOperation(ownerID);
              pushOperation(displayNameStringID);
              pushOperation(keyStringID);
              pushOperation(getStringID(null));
            }
          }
          function recordReorder(internalInstance, id, nextChildren) {
            pushOperation(TREE_OPERATION_REORDER_CHILDREN);
            pushOperation(id);
            var nextChildIDs = nextChildren.map(getID);
            pushOperation(nextChildIDs.length);
            for (var i = 0;i < nextChildIDs.length; i++) {
              pushOperation(nextChildIDs[i]);
            }
          }
          function recordUnmount(internalInstance, id) {
            var isRoot = parentIDStack.length === 0;
            if (isRoot) {
              pendingUnmountedRootID = id;
            } else {
              pendingUnmountedIDs.push(id);
            }
            idToInternalInstanceMap.delete(id);
          }
          function crawlAndRecordInitialMounts(id, parentID, rootID) {
            if (__DEBUG__) {
              console.group("crawlAndRecordInitialMounts() id:", id);
            }
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance != null) {
              internalInstanceToRootIDMap.set(internalInstance, rootID);
              recordMount(internalInstance, id, parentID);
              getChildren(internalInstance).forEach(function(child) {
                return crawlAndRecordInitialMounts(getID(child), id, rootID);
              });
            }
            if (__DEBUG__) {
              console.groupEnd();
            }
          }
          function flushInitialOperations() {
            var roots = renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID;
            for (var key in roots) {
              var internalInstance = roots[key];
              var _id2 = getID(internalInstance);
              crawlAndRecordInitialMounts(_id2, 0, _id2);
              flushPendingEvents(_id2);
            }
          }
          var pendingOperations = [];
          var pendingStringTable = new Map;
          var pendingUnmountedIDs = [];
          var pendingStringTableLength = 0;
          var pendingUnmountedRootID = null;
          function flushPendingEvents(rootID) {
            if (pendingOperations.length === 0 && pendingUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {
              return;
            }
            var numUnmountIDs = pendingUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);
            var operations = new Array(2 + 1 + pendingStringTableLength + (numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + (pendingUnmountedRootID === null ? 0 : 3) + pendingOperations.length);
            var i = 0;
            operations[i++] = rendererID;
            operations[i++] = rootID;
            operations[i++] = pendingStringTableLength;
            pendingStringTable.forEach(function(value, key) {
              operations[i++] = key.length;
              var encodedKey = utfEncodeString(key);
              for (var j2 = 0;j2 < encodedKey.length; j2++) {
                operations[i + j2] = encodedKey[j2];
              }
              i += key.length;
            });
            if (numUnmountIDs > 0) {
              operations[i++] = TREE_OPERATION_REMOVE;
              operations[i++] = numUnmountIDs;
              for (var j = 0;j < pendingUnmountedIDs.length; j++) {
                operations[i++] = pendingUnmountedIDs[j];
              }
              if (pendingUnmountedRootID !== null) {
                operations[i] = pendingUnmountedRootID;
                i++;
                operations[i++] = SUSPENSE_TREE_OPERATION_REMOVE;
                operations[i++] = 1;
                operations[i++] = pendingUnmountedRootID;
              }
            }
            for (var _j = 0;_j < pendingOperations.length; _j++) {
              operations[i + _j] = pendingOperations[_j];
            }
            i += pendingOperations.length;
            if (__DEBUG__) {
              printOperationsArray(operations);
            }
            hook.emit("operations", operations);
            pendingOperations.length = 0;
            pendingUnmountedIDs = [];
            pendingUnmountedRootID = null;
            pendingStringTable.clear();
            pendingStringTableLength = 0;
          }
          function pushOperation(op) {
            if (false) {}
            pendingOperations.push(op);
          }
          function getStringID(str) {
            if (str === null) {
              return 0;
            }
            var existingID = pendingStringTable.get(str);
            if (existingID !== undefined) {
              return existingID;
            }
            var stringID = pendingStringTable.size + 1;
            pendingStringTable.set(str, stringID);
            pendingStringTableLength += str.length + 1;
            return stringID;
          }
          var currentlyInspectedElementID = null;
          var currentlyInspectedPaths = {};
          function mergeInspectedPaths(path) {
            var current = currentlyInspectedPaths;
            path.forEach(function(key) {
              if (!current[key]) {
                current[key] = {};
              }
              current = current[key];
            });
          }
          function createIsPathAllowed(key) {
            return function isPathAllowed(path) {
              var current = currentlyInspectedPaths[key];
              if (!current) {
                return false;
              }
              for (var i = 0;i < path.length; i++) {
                current = current[path[i]];
                if (!current) {
                  return false;
                }
              }
              return true;
            };
          }
          function getInstanceAndStyle(id) {
            var instance = null;
            var style = null;
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance != null) {
              instance = internalInstance._instance || null;
              var element = internalInstance._currentElement;
              if (element != null && element.props != null) {
                style = element.props.style || null;
              }
            }
            return {
              instance,
              style
            };
          }
          function updateSelectedElement(id) {
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance == null) {
              console.warn('Could not find instance with id "'.concat(id, '"'));
              return;
            }
            switch (getElementType(internalInstance)) {
              case types_ElementTypeClass:
                global2.$r = internalInstance._instance;
                break;
              case types_ElementTypeFunction:
                var element = internalInstance._currentElement;
                if (element == null) {
                  console.warn('Could not find element with id "'.concat(id, '"'));
                  return;
                }
                global2.$r = {
                  props: element.props,
                  type: element.type
                };
                break;
              default:
                global2.$r = null;
                break;
            }
          }
          function storeAsGlobal(id, path, count) {
            var inspectedElement = inspectElementRaw(id);
            if (inspectedElement !== null) {
              var value = utils_getInObject(inspectedElement, path);
              var key = "$reactTemp".concat(count);
              window[key] = value;
              console.log(key);
              console.log(value);
            }
          }
          function getSerializedElementValueByPath(id, path) {
            var inspectedElement = inspectElementRaw(id);
            if (inspectedElement !== null) {
              var valueToCopy = utils_getInObject(inspectedElement, path);
              return serializeToString(valueToCopy);
            }
          }
          function inspectElement(requestID, id, path, forceFullData) {
            if (forceFullData || currentlyInspectedElementID !== id) {
              currentlyInspectedElementID = id;
              currentlyInspectedPaths = {};
            }
            var inspectedElement = inspectElementRaw(id);
            if (inspectedElement === null) {
              return {
                id,
                responseID: requestID,
                type: "not-found"
              };
            }
            if (path !== null) {
              mergeInspectedPaths(path);
            }
            updateSelectedElement(id);
            inspectedElement.context = cleanForBridge(inspectedElement.context, createIsPathAllowed("context"));
            inspectedElement.props = cleanForBridge(inspectedElement.props, createIsPathAllowed("props"));
            inspectedElement.state = cleanForBridge(inspectedElement.state, createIsPathAllowed("state"));
            inspectedElement.suspendedBy = cleanForBridge(inspectedElement.suspendedBy, createIsPathAllowed("suspendedBy"));
            return {
              id,
              responseID: requestID,
              type: "full-data",
              value: inspectedElement
            };
          }
          function inspectElementRaw(id) {
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance == null) {
              return null;
            }
            var rootID = internalInstanceToRootIDMap.get(internalInstance);
            if (rootID === undefined) {
              throw new Error("Expected to find root ID.");
            }
            var isRoot = rootID === id;
            return isRoot ? inspectRootsRaw(rootID) : inspectInternalInstanceRaw(id, internalInstance);
          }
          function inspectInternalInstanceRaw(id, internalInstance) {
            var _getData2 = getData(internalInstance), key = _getData2.key;
            var type = getElementType(internalInstance);
            var context = null;
            var owners = null;
            var props = null;
            var state = null;
            var element = internalInstance._currentElement;
            if (element !== null) {
              props = element.props;
              var owner = element._owner;
              if (owner) {
                owners = [];
                while (owner != null) {
                  owners.push({
                    displayName: getData(owner).displayName || "Unknown",
                    id: getID(owner),
                    key: element.key,
                    env: null,
                    stack: null,
                    type: getElementType(owner)
                  });
                  if (owner._currentElement) {
                    owner = owner._currentElement._owner;
                  }
                }
              }
            }
            var publicInstance = internalInstance._instance;
            if (publicInstance != null) {
              context = publicInstance.context || null;
              state = publicInstance.state || null;
            }
            var errors = [];
            var warnings = [];
            return {
              id,
              canEditHooks: false,
              canEditFunctionProps: false,
              canEditHooksAndDeletePaths: false,
              canEditHooksAndRenamePaths: false,
              canEditFunctionPropsDeletePaths: false,
              canEditFunctionPropsRenamePaths: false,
              canToggleError: false,
              isErrored: false,
              canToggleSuspense: false,
              isSuspended: null,
              source: null,
              stack: null,
              hasLegacyContext: true,
              type,
              key: key != null ? key : null,
              context,
              hooks: null,
              props,
              state,
              errors,
              warnings,
              suspendedBy: [],
              suspendedByRange: null,
              unknownSuspenders: UNKNOWN_SUSPENDERS_NONE,
              owners,
              env: null,
              rootType: null,
              rendererPackageName: null,
              rendererVersion: null,
              plugins: {
                stylex: null
              },
              nativeTag: null
            };
          }
          function inspectRootsRaw(arbitraryRootID) {
            var roots = renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID;
            var inspectedRoots = {
              id: arbitraryRootID,
              type: ElementTypeRoot,
              isErrored: false,
              errors: [],
              warnings: [],
              suspendedBy: [],
              suspendedByRange: null,
              unknownSuspenders: UNKNOWN_SUSPENDERS_NONE,
              rootType: null,
              plugins: {
                stylex: null
              },
              nativeTag: null,
              env: null,
              source: null,
              stack: null,
              rendererPackageName: null,
              rendererVersion: null,
              key: null,
              canEditFunctionProps: false,
              canEditHooks: false,
              canEditFunctionPropsDeletePaths: false,
              canEditFunctionPropsRenamePaths: false,
              canEditHooksAndDeletePaths: false,
              canEditHooksAndRenamePaths: false,
              canToggleError: false,
              canToggleSuspense: false,
              isSuspended: false,
              hasLegacyContext: false,
              context: null,
              hooks: null,
              props: null,
              state: null,
              owners: null
            };
            var minSuspendedByRange = Infinity;
            var maxSuspendedByRange = -Infinity;
            for (var rootKey in roots) {
              var internalInstance = roots[rootKey];
              var _id3 = getID(internalInstance);
              var inspectedRoot = inspectInternalInstanceRaw(_id3, internalInstance);
              if (inspectedRoot === null) {
                return null;
              }
              if (inspectedRoot.isErrored) {
                inspectedRoots.isErrored = true;
              }
              for (var i = 0;i < inspectedRoot.errors.length; i++) {
                inspectedRoots.errors.push(inspectedRoot.errors[i]);
              }
              for (var _i = 0;_i < inspectedRoot.warnings.length; _i++) {
                inspectedRoots.warnings.push(inspectedRoot.warnings[_i]);
              }
              for (var _i2 = 0;_i2 < inspectedRoot.suspendedBy.length; _i2++) {
                inspectedRoots.suspendedBy.push(inspectedRoot.suspendedBy[_i2]);
              }
              var suspendedByRange = inspectedRoot.suspendedByRange;
              if (suspendedByRange !== null) {
                if (suspendedByRange[0] < minSuspendedByRange) {
                  minSuspendedByRange = suspendedByRange[0];
                }
                if (suspendedByRange[1] > maxSuspendedByRange) {
                  maxSuspendedByRange = suspendedByRange[1];
                }
              }
            }
            if (minSuspendedByRange !== Infinity || maxSuspendedByRange !== -Infinity) {
              inspectedRoots.suspendedByRange = [minSuspendedByRange, maxSuspendedByRange];
            }
            return inspectedRoots;
          }
          function logElementToConsole(id) {
            var result = inspectElementRaw(id);
            if (result === null) {
              console.warn('Could not find element with id "'.concat(id, '"'));
              return;
            }
            var displayName = getDisplayNameForElementID(id);
            var supportsGroup = typeof console.groupCollapsed === "function";
            if (supportsGroup) {
              console.groupCollapsed("[Click to expand] %c<".concat(displayName || "Component", " />"), "color: var(--dom-tag-name-color); font-weight: normal;");
            }
            if (result.props !== null) {
              console.log("Props:", result.props);
            }
            if (result.state !== null) {
              console.log("State:", result.state);
            }
            if (result.context !== null) {
              console.log("Context:", result.context);
            }
            var hostInstance = findHostInstanceForInternalID(id);
            if (hostInstance !== null) {
              console.log("Node:", hostInstance);
            }
            if (window.chrome || /firefox/i.test(navigator.userAgent)) {
              console.log("Right-click any value to save it as a global variable for further inspection.");
            }
            if (supportsGroup) {
              console.groupEnd();
            }
          }
          function getElementAttributeByPath(id, path) {
            var inspectedElement = inspectElementRaw(id);
            if (inspectedElement !== null) {
              return utils_getInObject(inspectedElement, path);
            }
            return;
          }
          function getElementSourceFunctionById(id) {
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance == null) {
              console.warn('Could not find instance with id "'.concat(id, '"'));
              return null;
            }
            var element = internalInstance._currentElement;
            if (element == null) {
              console.warn('Could not find element with id "'.concat(id, '"'));
              return null;
            }
            return element.type;
          }
          function deletePath(type, id, hookID, path) {
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance != null) {
              var publicInstance = internalInstance._instance;
              if (publicInstance != null) {
                switch (type) {
                  case "context":
                    deletePathInObject(publicInstance.context, path);
                    forceUpdate(publicInstance);
                    break;
                  case "hooks":
                    throw new Error("Hooks not supported by this renderer");
                  case "props":
                    var element = internalInstance._currentElement;
                    internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {
                      props: copyWithDelete(element.props, path)
                    });
                    forceUpdate(publicInstance);
                    break;
                  case "state":
                    deletePathInObject(publicInstance.state, path);
                    forceUpdate(publicInstance);
                    break;
                }
              }
            }
          }
          function renamePath(type, id, hookID, oldPath, newPath) {
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance != null) {
              var publicInstance = internalInstance._instance;
              if (publicInstance != null) {
                switch (type) {
                  case "context":
                    renamePathInObject(publicInstance.context, oldPath, newPath);
                    forceUpdate(publicInstance);
                    break;
                  case "hooks":
                    throw new Error("Hooks not supported by this renderer");
                  case "props":
                    var element = internalInstance._currentElement;
                    internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {
                      props: copyWithRename(element.props, oldPath, newPath)
                    });
                    forceUpdate(publicInstance);
                    break;
                  case "state":
                    renamePathInObject(publicInstance.state, oldPath, newPath);
                    forceUpdate(publicInstance);
                    break;
                }
              }
            }
          }
          function overrideValueAtPath(type, id, hookID, path, value) {
            var internalInstance = idToInternalInstanceMap.get(id);
            if (internalInstance != null) {
              var publicInstance = internalInstance._instance;
              if (publicInstance != null) {
                switch (type) {
                  case "context":
                    utils_setInObject(publicInstance.context, path, value);
                    forceUpdate(publicInstance);
                    break;
                  case "hooks":
                    throw new Error("Hooks not supported by this renderer");
                  case "props":
                    var element = internalInstance._currentElement;
                    internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {
                      props: copyWithSet(element.props, path, value)
                    });
                    forceUpdate(publicInstance);
                    break;
                  case "state":
                    utils_setInObject(publicInstance.state, path, value);
                    forceUpdate(publicInstance);
                    break;
                }
              }
            }
          }
          var getProfilingData = function getProfilingData() {
            throw new Error("getProfilingData not supported by this renderer");
          };
          var handleCommitFiberRoot = function handleCommitFiberRoot() {
            throw new Error("handleCommitFiberRoot not supported by this renderer");
          };
          var handleCommitFiberUnmount = function handleCommitFiberUnmount() {
            throw new Error("handleCommitFiberUnmount not supported by this renderer");
          };
          var handlePostCommitFiberRoot = function handlePostCommitFiberRoot() {
            throw new Error("handlePostCommitFiberRoot not supported by this renderer");
          };
          var overrideError = function overrideError() {
            throw new Error("overrideError not supported by this renderer");
          };
          var overrideSuspense = function overrideSuspense() {
            throw new Error("overrideSuspense not supported by this renderer");
          };
          var overrideSuspenseMilestone = function overrideSuspenseMilestone() {
            throw new Error("overrideSuspenseMilestone not supported by this renderer");
          };
          var startProfiling = function startProfiling() {};
          var stopProfiling = function stopProfiling() {};
          function getBestMatchForTrackedPath() {
            return null;
          }
          function getPathForElement(id) {
            return null;
          }
          function updateComponentFilters(componentFilters) {}
          function getEnvironmentNames() {
            return [];
          }
          function setTraceUpdatesEnabled(enabled) {}
          function setTrackedPath(path) {}
          function getOwnersList(id) {
            return null;
          }
          function clearErrorsAndWarnings() {}
          function clearErrorsForElementID(id) {}
          function clearWarningsForElementID(id) {}
          function hasElementWithId(id) {
            return idToInternalInstanceMap.has(id);
          }
          return {
            clearErrorsAndWarnings,
            clearErrorsForElementID,
            clearWarningsForElementID,
            cleanup,
            getSerializedElementValueByPath,
            deletePath,
            flushInitialOperations,
            getBestMatchForTrackedPath,
            getDisplayNameForElementID,
            getNearestMountedDOMNode,
            getElementIDForHostInstance,
            getSuspenseNodeIDForHostInstance: function getSuspenseNodeIDForHostInstance(id) {
              return null;
            },
            getInstanceAndStyle,
            findHostInstancesForElementID: function findHostInstancesForElementID(id) {
              var hostInstance = findHostInstanceForInternalID(id);
              return hostInstance == null ? null : [hostInstance];
            },
            findLastKnownRectsForID: function findLastKnownRectsForID() {
              return null;
            },
            getOwnersList,
            getPathForElement,
            getProfilingData,
            handleCommitFiberRoot,
            handleCommitFiberUnmount,
            handlePostCommitFiberRoot,
            hasElementWithId,
            inspectElement,
            logElementToConsole,
            overrideError,
            overrideSuspense,
            overrideSuspenseMilestone,
            overrideValueAtPath,
            renamePath,
            getElementAttributeByPath,
            getElementSourceFunctionById,
            renderer,
            setTraceUpdatesEnabled,
            setTrackedPath,
            startProfiling,
            stopProfiling,
            storeAsGlobal,
            supportsTogglingSuspense,
            updateComponentFilters,
            getEnvironmentNames
          };
        }
        function isMatchingRender(version) {
          return !hasAssignedBackend(version);
        }
        function attachRenderer(hook, id, renderer, global2, shouldStartProfilingNow, profilingSettings) {
          if (!isMatchingRender(renderer.reconcilerVersion || renderer.version)) {
            return;
          }
          var rendererInterface = hook.rendererInterfaces.get(id);
          if (rendererInterface == null) {
            if (typeof renderer.getCurrentComponentInfo === "function") {
              rendererInterface = attach(hook, id, renderer, global2);
            } else if (typeof renderer.findFiberByHostInstance === "function" || renderer.currentDispatcherRef != null) {
              rendererInterface = renderer_attach(hook, id, renderer, global2, shouldStartProfilingNow, profilingSettings);
            } else if (renderer.ComponentTree) {
              rendererInterface = legacy_renderer_attach(hook, id, renderer, global2);
            } else {}
          }
          return rendererInterface;
        }
        function formatConsoleArguments_toConsumableArray(arr) {
          return formatConsoleArguments_arrayWithoutHoles(arr) || formatConsoleArguments_iterableToArray(arr) || formatConsoleArguments_unsupportedIterableToArray(arr) || formatConsoleArguments_nonIterableSpread();
        }
        function formatConsoleArguments_nonIterableSpread() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function formatConsoleArguments_iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
            return Array.from(iter);
        }
        function formatConsoleArguments_arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return formatConsoleArguments_arrayLikeToArray(arr);
        }
        function formatConsoleArguments_slicedToArray(arr, i) {
          return formatConsoleArguments_arrayWithHoles(arr) || formatConsoleArguments_iterableToArrayLimit(arr, i) || formatConsoleArguments_unsupportedIterableToArray(arr, i) || formatConsoleArguments_nonIterableRest();
        }
        function formatConsoleArguments_nonIterableRest() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function formatConsoleArguments_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return formatConsoleArguments_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return formatConsoleArguments_arrayLikeToArray(o, minLen);
        }
        function formatConsoleArguments_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len);i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        function formatConsoleArguments_iterableToArrayLimit(r, l) {
          var t = r == null ? null : typeof Symbol != "undefined" && r[Symbol.iterator] || r["@@iterator"];
          if (t != null) {
            var e, n, i, u, a = [], f = true, o = false;
            try {
              if (i = (t = t.call(r)).next, l === 0) {
                if (Object(t) !== t)
                  return;
                f = false;
              } else
                for (;!(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
                  ;
            } catch (r2) {
              o = true, n = r2;
            } finally {
              try {
                if (!f && t.return != null && (u = t.return(), Object(u) !== u))
                  return;
              } finally {
                if (o)
                  throw n;
              }
            }
            return a;
          }
        }
        function formatConsoleArguments_arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        function formatConsoleArguments(maybeMessage) {
          for (var _len = arguments.length, inputArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
            inputArgs[_key - 1] = arguments[_key];
          }
          if (inputArgs.length === 0 || typeof maybeMessage !== "string") {
            return [maybeMessage].concat(inputArgs);
          }
          var args = inputArgs.slice();
          var template = "";
          var argumentsPointer = 0;
          for (var i = 0;i < maybeMessage.length; ++i) {
            var currentChar = maybeMessage[i];
            if (currentChar !== "%") {
              template += currentChar;
              continue;
            }
            var nextChar = maybeMessage[i + 1];
            ++i;
            switch (nextChar) {
              case "c":
              case "O":
              case "o": {
                ++argumentsPointer;
                template += "%".concat(nextChar);
                break;
              }
              case "d":
              case "i": {
                var _args$splice = args.splice(argumentsPointer, 1), _args$splice2 = formatConsoleArguments_slicedToArray(_args$splice, 1), arg = _args$splice2[0];
                template += parseInt(arg, 10).toString();
                break;
              }
              case "f": {
                var _args$splice3 = args.splice(argumentsPointer, 1), _args$splice4 = formatConsoleArguments_slicedToArray(_args$splice3, 1), _arg = _args$splice4[0];
                template += parseFloat(_arg).toString();
                break;
              }
              case "s": {
                var _args$splice5 = args.splice(argumentsPointer, 1), _args$splice6 = formatConsoleArguments_slicedToArray(_args$splice5, 1), _arg2 = _args$splice6[0];
                template += String(_arg2);
                break;
              }
              default:
                template += "%".concat(nextChar);
            }
          }
          return [template].concat(formatConsoleArguments_toConsumableArray(args));
        }
        function hook_createForOfIteratorHelper(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = hook_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it)
                o = it;
              var i = 0;
              var F = function F() {};
              return { s: F, n: function n() {
                if (i >= o.length)
                  return { done: true };
                return { done: false, value: o[i++] };
              }, e: function e(_e) {
                throw _e;
              }, f: F };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var normalCompletion = true, didErr = false, err;
          return { s: function s() {
            it = it.call(o);
          }, n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
          }, e: function e(_e2) {
            didErr = true;
            err = _e2;
          }, f: function f() {
            try {
              if (!normalCompletion && it.return != null)
                it.return();
            } finally {
              if (didErr)
                throw err;
            }
          } };
        }
        function hook_toConsumableArray(arr) {
          return hook_arrayWithoutHoles(arr) || hook_iterableToArray(arr) || hook_unsupportedIterableToArray(arr) || hook_nonIterableSpread();
        }
        function hook_nonIterableSpread() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        function hook_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return hook_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return hook_arrayLikeToArray(o, minLen);
        }
        function hook_iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
            return Array.from(iter);
        }
        function hook_arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return hook_arrayLikeToArray(arr);
        }
        function hook_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len);i < len; i++)
            arr2[i] = arr[i];
          return arr2;
        }
        var PREFIX_REGEX = /\s{4}(in|at)\s{1}/;
        var ROW_COLUMN_NUMBER_REGEX = /:\d+:\d+(\n|$)/;
        function isStringComponentStack(text) {
          return PREFIX_REGEX.test(text) || ROW_COLUMN_NUMBER_REGEX.test(text);
        }
        var frameDiffs = / \(\<anonymous\>\)$|\@unknown\:0\:0$|\(|\)|\[|\]/gm;
        function areStackTracesEqual(a, b) {
          return a.replace(frameDiffs, "") === b.replace(frameDiffs, "");
        }
        var targetConsole = console;
        var defaultProfilingSettings = {
          recordChangeDescriptions: false,
          recordTimeline: false
        };
        function installHook(target, maybeSettingsOrSettingsPromise) {
          var shouldStartProfilingNow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var profilingSettings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultProfilingSettings;
          if (target.hasOwnProperty("__REACT_DEVTOOLS_GLOBAL_HOOK__")) {
            return null;
          }
          function detectReactBuildType(renderer) {
            try {
              if (typeof renderer.version === "string") {
                if (renderer.bundleType > 0) {
                  return "development";
                }
                return "production";
              }
              var _toString = Function.prototype.toString;
              if (renderer.Mount && renderer.Mount._renderNewRootComponent) {
                var renderRootCode = _toString.call(renderer.Mount._renderNewRootComponent);
                if (renderRootCode.indexOf("function") !== 0) {
                  return "production";
                }
                if (renderRootCode.indexOf("storedMeasure") !== -1) {
                  return "development";
                }
                if (renderRootCode.indexOf("should be a pure function") !== -1) {
                  if (renderRootCode.indexOf("NODE_ENV") !== -1) {
                    return "development";
                  }
                  if (renderRootCode.indexOf("development") !== -1) {
                    return "development";
                  }
                  if (renderRootCode.indexOf("true") !== -1) {
                    return "development";
                  }
                  if (renderRootCode.indexOf("nextElement") !== -1 || renderRootCode.indexOf("nextComponent") !== -1) {
                    return "unminified";
                  } else {
                    return "development";
                  }
                }
                if (renderRootCode.indexOf("nextElement") !== -1 || renderRootCode.indexOf("nextComponent") !== -1) {
                  return "unminified";
                }
                return "outdated";
              }
            } catch (err) {}
            return "production";
          }
          function checkDCE(fn) {
            try {
              var _toString2 = Function.prototype.toString;
              var code = _toString2.call(fn);
              if (code.indexOf("^_^") > -1) {
                hasDetectedBadDCE = true;
                setTimeout(function() {
                  throw new Error("React is running in production mode, but dead code " + "elimination has not been applied. Read how to correctly " + "configure React for production: " + "https://react.dev/link/perf-use-production-build");
                });
              }
            } catch (err) {}
          }
          var isProfiling = shouldStartProfilingNow;
          var uidCounter2 = 0;
          function inject(renderer) {
            var id = ++uidCounter2;
            renderers.set(id, renderer);
            var reactBuildType = hasDetectedBadDCE ? "deadcode" : detectReactBuildType(renderer);
            hook.emit("renderer", {
              id,
              renderer,
              reactBuildType
            });
            var rendererInterface = attachRenderer(hook, id, renderer, target, isProfiling, profilingSettings);
            if (rendererInterface != null) {
              hook.rendererInterfaces.set(id, rendererInterface);
              hook.emit("renderer-attached", {
                id,
                rendererInterface
              });
            } else {
              hook.hasUnsupportedRendererAttached = true;
              hook.emit("unsupported-renderer-version");
            }
            return id;
          }
          var hasDetectedBadDCE = false;
          function sub(event, fn) {
            hook.on(event, fn);
            return function() {
              return hook.off(event, fn);
            };
          }
          function on(event, fn) {
            if (!listeners[event]) {
              listeners[event] = [];
            }
            listeners[event].push(fn);
          }
          function off(event, fn) {
            if (!listeners[event]) {
              return;
            }
            var index = listeners[event].indexOf(fn);
            if (index !== -1) {
              listeners[event].splice(index, 1);
            }
            if (!listeners[event].length) {
              delete listeners[event];
            }
          }
          function emit(event, data) {
            if (listeners[event]) {
              listeners[event].map(function(fn) {
                return fn(data);
              });
            }
          }
          function getFiberRoots(rendererID) {
            var roots = fiberRoots;
            if (!roots[rendererID]) {
              roots[rendererID] = new Set;
            }
            return roots[rendererID];
          }
          function onCommitFiberUnmount(rendererID, fiber) {
            var rendererInterface = rendererInterfaces.get(rendererID);
            if (rendererInterface != null) {
              rendererInterface.handleCommitFiberUnmount(fiber);
            }
          }
          function onCommitFiberRoot(rendererID, root, priorityLevel) {
            var mountedRoots = hook.getFiberRoots(rendererID);
            var current = root.current;
            var isKnownRoot = mountedRoots.has(root);
            var isUnmounting = current.memoizedState == null || current.memoizedState.element == null;
            if (!isKnownRoot && !isUnmounting) {
              mountedRoots.add(root);
            } else if (isKnownRoot && isUnmounting) {
              mountedRoots.delete(root);
            }
            var rendererInterface = rendererInterfaces.get(rendererID);
            if (rendererInterface != null) {
              rendererInterface.handleCommitFiberRoot(root, priorityLevel);
            }
          }
          function onPostCommitFiberRoot(rendererID, root) {
            var rendererInterface = rendererInterfaces.get(rendererID);
            if (rendererInterface != null) {
              rendererInterface.handlePostCommitFiberRoot(root);
            }
          }
          var isRunningDuringStrictModeInvocation = false;
          function setStrictMode(rendererID, isStrictMode) {
            isRunningDuringStrictModeInvocation = isStrictMode;
            if (isStrictMode) {
              patchConsoleForStrictMode();
            } else {
              unpatchConsoleForStrictMode();
            }
          }
          var unpatchConsoleCallbacks = [];
          function patchConsoleForStrictMode() {
            if (!hook.settings) {
              return;
            }
            if (unpatchConsoleCallbacks.length > 0) {
              return;
            }
            var consoleMethodsToOverrideForStrictMode = ["group", "groupCollapsed", "info", "log"];
            var _loop = function _loop() {
              var method = _consoleMethodsToOver[_i];
              var originalMethod = targetConsole[method];
              var overrideMethod = function overrideMethod() {
                var settings = hook.settings;
                for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                if (settings == null) {
                  originalMethod.apply(undefined, args);
                  return;
                }
                if (settings.hideConsoleLogsInStrictMode) {
                  return;
                }
                if (false) {} else {
                  originalMethod.apply(undefined, [ANSI_STYLE_DIMMING_TEMPLATE].concat(hook_toConsumableArray(formatConsoleArguments.apply(undefined, args))));
                }
              };
              targetConsole[method] = overrideMethod;
              unpatchConsoleCallbacks.push(function() {
                targetConsole[method] = originalMethod;
              });
            };
            for (var _i = 0, _consoleMethodsToOver = consoleMethodsToOverrideForStrictMode;_i < _consoleMethodsToOver.length; _i++) {
              _loop();
            }
          }
          function unpatchConsoleForStrictMode() {
            unpatchConsoleCallbacks.forEach(function(callback) {
              return callback();
            });
            unpatchConsoleCallbacks.length = 0;
          }
          var openModuleRangesStack = [];
          var moduleRanges = [];
          function getTopStackFrameString(error) {
            var frames = error.stack.split(`
`);
            var frame = frames.length > 1 ? frames[1] : null;
            return frame;
          }
          function getInternalModuleRanges() {
            return moduleRanges;
          }
          function registerInternalModuleStart(error) {
            var startStackFrame = getTopStackFrameString(error);
            if (startStackFrame !== null) {
              openModuleRangesStack.push(startStackFrame);
            }
          }
          function registerInternalModuleStop(error) {
            if (openModuleRangesStack.length > 0) {
              var startStackFrame = openModuleRangesStack.pop();
              var stopStackFrame = getTopStackFrameString(error);
              if (stopStackFrame !== null) {
                moduleRanges.push([startStackFrame, stopStackFrame]);
              }
            }
          }
          function patchConsoleForErrorsAndWarnings() {
            if (!hook.settings) {
              return;
            }
            var consoleMethodsToOverrideForErrorsAndWarnings = ["error", "trace", "warn"];
            var _loop2 = function _loop2() {
              var method = _consoleMethodsToOver2[_i2];
              var originalMethod = targetConsole[method];
              var overrideMethod = function overrideMethod() {
                var settings = hook.settings;
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;_key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                if (settings == null) {
                  originalMethod.apply(undefined, args);
                  return;
                }
                if (isRunningDuringStrictModeInvocation && settings.hideConsoleLogsInStrictMode) {
                  return;
                }
                var injectedComponentStackAsFakeError = false;
                var alreadyHasComponentStack = false;
                if (settings.appendComponentStack) {
                  var lastArg = args.length > 0 ? args[args.length - 1] : null;
                  alreadyHasComponentStack = typeof lastArg === "string" && isStringComponentStack(lastArg);
                }
                var shouldShowInlineWarningsAndErrors = settings.showInlineWarningsAndErrors && (method === "error" || method === "warn");
                var _iterator = hook_createForOfIteratorHelper(hook.rendererInterfaces.values()), _step;
                try {
                  var _loop3 = function _loop3() {
                    var rendererInterface = _step.value;
                    var { onErrorOrWarning, getComponentStack } = rendererInterface;
                    try {
                      if (shouldShowInlineWarningsAndErrors) {
                        if (onErrorOrWarning != null) {
                          onErrorOrWarning(method, args.slice());
                        }
                      }
                    } catch (error) {
                      setTimeout(function() {
                        throw error;
                      }, 0);
                    }
                    try {
                      if (settings.appendComponentStack && getComponentStack != null) {
                        var topFrame = Error("react-stack-top-frame");
                        var match = getComponentStack(topFrame);
                        if (match !== null) {
                          var { enableOwnerStacks, componentStack } = match;
                          if (componentStack !== "") {
                            var fakeError = new Error("");
                            if (false) {} else {
                              fakeError.name = enableOwnerStacks ? "Stack" : "Component Stack";
                            }
                            fakeError.stack = (enableOwnerStacks ? "Error Stack:" : "Error Component Stack:") + componentStack;
                            if (alreadyHasComponentStack) {
                              if (areStackTracesEqual(args[args.length - 1], componentStack)) {
                                var firstArg = args[0];
                                if (args.length > 1 && typeof firstArg === "string" && firstArg.endsWith("%s")) {
                                  args[0] = firstArg.slice(0, firstArg.length - 2);
                                }
                                args[args.length - 1] = fakeError;
                                injectedComponentStackAsFakeError = true;
                              }
                            } else {
                              args.push(fakeError);
                              injectedComponentStackAsFakeError = true;
                            }
                          }
                          return 1;
                        }
                      }
                    } catch (error) {
                      setTimeout(function() {
                        throw error;
                      }, 0);
                    }
                  };
                  for (_iterator.s();!(_step = _iterator.n()).done; ) {
                    if (_loop3())
                      break;
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                if (settings.breakOnConsoleErrors) {
                  debugger;
                }
                if (isRunningDuringStrictModeInvocation) {
                  if (false) {
                    var argsWithCSSStyles;
                  } else {
                    originalMethod.apply(undefined, [injectedComponentStackAsFakeError ? ANSI_STYLE_DIMMING_TEMPLATE_WITH_COMPONENT_STACK : ANSI_STYLE_DIMMING_TEMPLATE].concat(hook_toConsumableArray(formatConsoleArguments.apply(undefined, args))));
                  }
                } else {
                  originalMethod.apply(undefined, args);
                }
              };
              targetConsole[method] = overrideMethod;
            };
            for (var _i2 = 0, _consoleMethodsToOver2 = consoleMethodsToOverrideForErrorsAndWarnings;_i2 < _consoleMethodsToOver2.length; _i2++) {
              _loop2();
            }
          }
          var fiberRoots = {};
          var rendererInterfaces = new Map;
          var listeners = {};
          var renderers = new Map;
          var backends = new Map;
          var hook = {
            rendererInterfaces,
            listeners,
            backends,
            renderers,
            hasUnsupportedRendererAttached: false,
            emit,
            getFiberRoots,
            inject,
            on,
            off,
            sub,
            supportsFiber: true,
            supportsFlight: true,
            checkDCE,
            onCommitFiberUnmount,
            onCommitFiberRoot,
            onPostCommitFiberRoot,
            setStrictMode,
            getInternalModuleRanges,
            registerInternalModuleStart,
            registerInternalModuleStop
          };
          if (maybeSettingsOrSettingsPromise == null) {
            hook.settings = {
              appendComponentStack: true,
              breakOnConsoleErrors: false,
              showInlineWarningsAndErrors: true,
              hideConsoleLogsInStrictMode: false
            };
            patchConsoleForErrorsAndWarnings();
          } else {
            Promise.resolve(maybeSettingsOrSettingsPromise).then(function(settings) {
              hook.settings = settings;
              hook.emit("settingsInitialized", settings);
              patchConsoleForErrorsAndWarnings();
            }).catch(function() {
              targetConsole.error("React DevTools failed to get Console Patching settings. Console won't be patched and some console features will not work.");
            });
          }
          Object.defineProperty(target, "__REACT_DEVTOOLS_GLOBAL_HOOK__", {
            configurable: false,
            enumerable: false,
            get: function get() {
              return hook;
            }
          });
          return hook;
        }
        function initBackend(hook, agent2, global2, isReloadAndProfileSupported) {
          if (hook == null) {
            return function() {};
          }
          function registerRendererInterface(id, rendererInterface) {
            agent2.registerRendererInterface(id, rendererInterface);
            rendererInterface.flushInitialOperations();
          }
          var subs = [hook.sub("renderer-attached", function(_ref) {
            var { id, rendererInterface } = _ref;
            registerRendererInterface(id, rendererInterface);
          }), hook.sub("unsupported-renderer-version", function() {
            agent2.onUnsupportedRenderer();
          }), hook.sub("fastRefreshScheduled", agent2.onFastRefreshScheduled), hook.sub("operations", agent2.onHookOperations), hook.sub("traceUpdates", agent2.onTraceUpdates), hook.sub("settingsInitialized", agent2.onHookSettings)];
          agent2.addListener("getIfHasUnsupportedRendererVersion", function() {
            if (hook.hasUnsupportedRendererAttached) {
              agent2.onUnsupportedRenderer();
            }
          });
          hook.rendererInterfaces.forEach(function(rendererInterface, id) {
            registerRendererInterface(id, rendererInterface);
          });
          hook.emit("react-devtools", agent2);
          hook.reactDevtoolsAgent = agent2;
          var onAgentShutdown = function onAgentShutdown() {
            subs.forEach(function(fn) {
              return fn();
            });
            hook.rendererInterfaces.forEach(function(rendererInterface) {
              rendererInterface.cleanup();
            });
            hook.reactDevtoolsAgent = null;
          };
          agent2.addListener("shutdown", onAgentShutdown);
          agent2.addListener("updateHookSettings", function(settings) {
            hook.settings = settings;
          });
          agent2.addListener("getHookSettings", function() {
            if (hook.settings != null) {
              agent2.onHookSettings(hook.settings);
            }
          });
          if (isReloadAndProfileSupported) {
            agent2.onReloadAndProfileSupportedByHost();
          }
          return function() {
            subs.forEach(function(fn) {
              return fn();
            });
          };
        }
        function resolveBoxStyle(prefix2, style) {
          var hasParts = false;
          var result = {
            bottom: 0,
            left: 0,
            right: 0,
            top: 0
          };
          var styleForAll = style[prefix2];
          if (styleForAll != null) {
            for (var _i = 0, _Object$keys = Object.keys(result);_i < _Object$keys.length; _i++) {
              var key = _Object$keys[_i];
              result[key] = styleForAll;
            }
            hasParts = true;
          }
          var styleForHorizontal = style[prefix2 + "Horizontal"];
          if (styleForHorizontal != null) {
            result.left = styleForHorizontal;
            result.right = styleForHorizontal;
            hasParts = true;
          } else {
            var styleForLeft = style[prefix2 + "Left"];
            if (styleForLeft != null) {
              result.left = styleForLeft;
              hasParts = true;
            }
            var styleForRight = style[prefix2 + "Right"];
            if (styleForRight != null) {
              result.right = styleForRight;
              hasParts = true;
            }
            var styleForEnd = style[prefix2 + "End"];
            if (styleForEnd != null) {
              result.right = styleForEnd;
              hasParts = true;
            }
            var styleForStart = style[prefix2 + "Start"];
            if (styleForStart != null) {
              result.left = styleForStart;
              hasParts = true;
            }
          }
          var styleForVertical = style[prefix2 + "Vertical"];
          if (styleForVertical != null) {
            result.bottom = styleForVertical;
            result.top = styleForVertical;
            hasParts = true;
          } else {
            var styleForBottom = style[prefix2 + "Bottom"];
            if (styleForBottom != null) {
              result.bottom = styleForBottom;
              hasParts = true;
            }
            var styleForTop = style[prefix2 + "Top"];
            if (styleForTop != null) {
              result.top = styleForTop;
              hasParts = true;
            }
          }
          return hasParts ? result : null;
        }
        function setupNativeStyleEditor_typeof(o) {
          "@babel/helpers - typeof";
          return setupNativeStyleEditor_typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, setupNativeStyleEditor_typeof(o);
        }
        function setupNativeStyleEditor_defineProperty(obj, key, value) {
          key = setupNativeStyleEditor_toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function setupNativeStyleEditor_toPropertyKey(t) {
          var i = setupNativeStyleEditor_toPrimitive(t, "string");
          return setupNativeStyleEditor_typeof(i) == "symbol" ? i : i + "";
        }
        function setupNativeStyleEditor_toPrimitive(t, r) {
          if (setupNativeStyleEditor_typeof(t) != "object" || !t)
            return t;
          var e = t[Symbol.toPrimitive];
          if (e !== undefined) {
            var i = e.call(t, r || "default");
            if (setupNativeStyleEditor_typeof(i) != "object")
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (r === "string" ? String : Number)(t);
        }
        function setupNativeStyleEditor(bridge, agent2, resolveNativeStyle, validAttributes) {
          bridge.addListener("NativeStyleEditor_measure", function(_ref) {
            var { id, rendererID } = _ref;
            measureStyle(agent2, bridge, resolveNativeStyle, id, rendererID);
          });
          bridge.addListener("NativeStyleEditor_renameAttribute", function(_ref2) {
            var { id, rendererID, oldName, newName, value } = _ref2;
            renameStyle(agent2, id, rendererID, oldName, newName, value);
            setTimeout(function() {
              return measureStyle(agent2, bridge, resolveNativeStyle, id, rendererID);
            });
          });
          bridge.addListener("NativeStyleEditor_setValue", function(_ref3) {
            var { id, rendererID, name, value } = _ref3;
            setStyle2(agent2, id, rendererID, name, value);
            setTimeout(function() {
              return measureStyle(agent2, bridge, resolveNativeStyle, id, rendererID);
            });
          });
          bridge.send("isNativeStyleEditorSupported", {
            isSupported: true,
            validAttributes
          });
        }
        var EMPTY_BOX_STYLE = {
          top: 0,
          left: 0,
          right: 0,
          bottom: 0
        };
        var componentIDToStyleOverrides = new Map;
        function measureStyle(agent2, bridge, resolveNativeStyle, id, rendererID) {
          var data = agent2.getInstanceAndStyle({
            id,
            rendererID
          });
          if (!data || !data.style) {
            bridge.send("NativeStyleEditor_styleAndLayout", {
              id,
              layout: null,
              style: null
            });
            return;
          }
          var { instance, style } = data;
          var resolvedStyle = resolveNativeStyle(style);
          var styleOverrides = componentIDToStyleOverrides.get(id);
          if (styleOverrides != null) {
            resolvedStyle = Object.assign({}, resolvedStyle, styleOverrides);
          }
          if (!instance || typeof instance.measure !== "function") {
            bridge.send("NativeStyleEditor_styleAndLayout", {
              id,
              layout: null,
              style: resolvedStyle || null
            });
            return;
          }
          instance.measure(function(x, y, width, height, left, top) {
            if (typeof x !== "number") {
              bridge.send("NativeStyleEditor_styleAndLayout", {
                id,
                layout: null,
                style: resolvedStyle || null
              });
              return;
            }
            var margin = resolvedStyle != null && resolveBoxStyle("margin", resolvedStyle) || EMPTY_BOX_STYLE;
            var padding = resolvedStyle != null && resolveBoxStyle("padding", resolvedStyle) || EMPTY_BOX_STYLE;
            bridge.send("NativeStyleEditor_styleAndLayout", {
              id,
              layout: {
                x,
                y,
                width,
                height,
                left,
                top,
                margin,
                padding
              },
              style: resolvedStyle || null
            });
          });
        }
        function shallowClone(object) {
          var cloned = {};
          for (var n in object) {
            cloned[n] = object[n];
          }
          return cloned;
        }
        function renameStyle(agent2, id, rendererID, oldName, newName, value) {
          var data = agent2.getInstanceAndStyle({
            id,
            rendererID
          });
          if (!data || !data.style) {
            return;
          }
          var { instance, style } = data;
          var newStyle = newName ? setupNativeStyleEditor_defineProperty(setupNativeStyleEditor_defineProperty({}, oldName, undefined), newName, value) : setupNativeStyleEditor_defineProperty({}, oldName, undefined);
          var customStyle;
          if (instance !== null && typeof instance.setNativeProps === "function") {
            var styleOverrides = componentIDToStyleOverrides.get(id);
            if (!styleOverrides) {
              componentIDToStyleOverrides.set(id, newStyle);
            } else {
              Object.assign(styleOverrides, newStyle);
            }
            instance.setNativeProps({
              style: newStyle
            });
          } else if (src_isArray(style)) {
            var lastIndex = style.length - 1;
            if (setupNativeStyleEditor_typeof(style[lastIndex]) === "object" && !src_isArray(style[lastIndex])) {
              customStyle = shallowClone(style[lastIndex]);
              delete customStyle[oldName];
              if (newName) {
                customStyle[newName] = value;
              } else {
                customStyle[oldName] = undefined;
              }
              agent2.overrideValueAtPath({
                type: "props",
                id,
                rendererID,
                path: ["style", lastIndex],
                value: customStyle
              });
            } else {
              agent2.overrideValueAtPath({
                type: "props",
                id,
                rendererID,
                path: ["style"],
                value: style.concat([newStyle])
              });
            }
          } else if (setupNativeStyleEditor_typeof(style) === "object") {
            customStyle = shallowClone(style);
            delete customStyle[oldName];
            if (newName) {
              customStyle[newName] = value;
            } else {
              customStyle[oldName] = undefined;
            }
            agent2.overrideValueAtPath({
              type: "props",
              id,
              rendererID,
              path: ["style"],
              value: customStyle
            });
          } else {
            agent2.overrideValueAtPath({
              type: "props",
              id,
              rendererID,
              path: ["style"],
              value: [style, newStyle]
            });
          }
          agent2.emit("hideNativeHighlight");
        }
        function setStyle2(agent2, id, rendererID, name, value) {
          var data = agent2.getInstanceAndStyle({
            id,
            rendererID
          });
          if (!data || !data.style) {
            return;
          }
          var { instance, style } = data;
          var newStyle = setupNativeStyleEditor_defineProperty({}, name, value);
          if (instance !== null && typeof instance.setNativeProps === "function") {
            var styleOverrides = componentIDToStyleOverrides.get(id);
            if (!styleOverrides) {
              componentIDToStyleOverrides.set(id, newStyle);
            } else {
              Object.assign(styleOverrides, newStyle);
            }
            instance.setNativeProps({
              style: newStyle
            });
          } else if (src_isArray(style)) {
            var lastLength = style.length - 1;
            if (setupNativeStyleEditor_typeof(style[lastLength]) === "object" && !src_isArray(style[lastLength])) {
              agent2.overrideValueAtPath({
                type: "props",
                id,
                rendererID,
                path: ["style", lastLength, name],
                value
              });
            } else {
              agent2.overrideValueAtPath({
                type: "props",
                id,
                rendererID,
                path: ["style"],
                value: style.concat([newStyle])
              });
            }
          } else {
            agent2.overrideValueAtPath({
              type: "props",
              id,
              rendererID,
              path: ["style"],
              value: [style, newStyle]
            });
          }
          agent2.emit("hideNativeHighlight");
        }
        var savedComponentFilters = getDefaultComponentFilters();
        function backend_debug(methodName) {
          if (__DEBUG__) {
            var _console;
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            (_console = console).log.apply(_console, ["%c[core/backend] %c".concat(methodName), "color: teal; font-weight: bold;", "font-weight: bold;"].concat(args));
          }
        }
        function backend_initialize(maybeSettingsOrSettingsPromise) {
          var shouldStartProfilingNow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var profilingSettings = arguments.length > 2 ? arguments[2] : undefined;
          installHook(window, maybeSettingsOrSettingsPromise, shouldStartProfilingNow, profilingSettings);
        }
        function connectToDevTools(options) {
          var hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook == null) {
            return;
          }
          var _ref = options || {}, _ref$host = _ref.host, host = _ref$host === undefined ? "localhost" : _ref$host, nativeStyleEditorValidAttributes = _ref.nativeStyleEditorValidAttributes, _ref$useHttps = _ref.useHttps, useHttps = _ref$useHttps === undefined ? false : _ref$useHttps, _ref$port = _ref.port, port = _ref$port === undefined ? 8097 : _ref$port, websocket = _ref.websocket, _ref$resolveRNStyle = _ref.resolveRNStyle, resolveRNStyle = _ref$resolveRNStyle === undefined ? null : _ref$resolveRNStyle, _ref$retryConnectionD = _ref.retryConnectionDelay, retryConnectionDelay = _ref$retryConnectionD === undefined ? 2000 : _ref$retryConnectionD, _ref$isAppActive = _ref.isAppActive, isAppActive = _ref$isAppActive === undefined ? function() {
            return true;
          } : _ref$isAppActive, onSettingsUpdated = _ref.onSettingsUpdated, _ref$isReloadAndProfi = _ref.isReloadAndProfileSupported, isReloadAndProfileSupported = _ref$isReloadAndProfi === undefined ? getIsReloadAndProfileSupported() : _ref$isReloadAndProfi, isProfiling = _ref.isProfiling, onReloadAndProfile2 = _ref.onReloadAndProfile, onReloadAndProfileFlagsReset2 = _ref.onReloadAndProfileFlagsReset;
          var protocol = useHttps ? "wss" : "ws";
          var retryTimeoutID = null;
          function scheduleRetry() {
            if (retryTimeoutID === null) {
              retryTimeoutID = setTimeout(function() {
                return connectToDevTools(options);
              }, retryConnectionDelay);
            }
          }
          if (!isAppActive()) {
            scheduleRetry();
            return;
          }
          var bridge = null;
          var messageListeners = [];
          var uri = protocol + "://" + host + ":" + port;
          var ws = websocket ? websocket : new window.WebSocket(uri);
          ws.onclose = handleClose;
          ws.onerror = handleFailed;
          ws.onmessage = handleMessage;
          ws.onopen = function() {
            bridge = new src_bridge({
              listen: function listen(fn) {
                messageListeners.push(fn);
                return function() {
                  var index = messageListeners.indexOf(fn);
                  if (index >= 0) {
                    messageListeners.splice(index, 1);
                  }
                };
              },
              send: function send(event, payload, transferable) {
                if (ws.readyState === ws.OPEN) {
                  if (__DEBUG__) {
                    backend_debug("wall.send()", event, payload);
                  }
                  ws.send(JSON.stringify({
                    event,
                    payload
                  }));
                } else {
                  if (__DEBUG__) {
                    backend_debug("wall.send()", "Shutting down bridge because of closed WebSocket connection");
                  }
                  if (bridge !== null) {
                    bridge.shutdown();
                  }
                  scheduleRetry();
                }
              }
            });
            bridge.addListener("updateComponentFilters", function(componentFilters) {
              savedComponentFilters = componentFilters;
            });
            if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ == null) {
              bridge.send("overrideComponentFilters", savedComponentFilters);
            }
            var agent2 = new Agent(bridge, isProfiling, onReloadAndProfile2);
            if (typeof onReloadAndProfileFlagsReset2 === "function") {
              onReloadAndProfileFlagsReset2();
            }
            if (onSettingsUpdated != null) {
              agent2.addListener("updateHookSettings", onSettingsUpdated);
            }
            agent2.addListener("shutdown", function() {
              if (onSettingsUpdated != null) {
                agent2.removeListener("updateHookSettings", onSettingsUpdated);
              }
              hook.emit("shutdown");
            });
            initBackend(hook, agent2, window, isReloadAndProfileSupported);
            if (resolveRNStyle != null || hook.resolveRNStyle != null) {
              setupNativeStyleEditor(bridge, agent2, resolveRNStyle || hook.resolveRNStyle, nativeStyleEditorValidAttributes || hook.nativeStyleEditorValidAttributes || null);
            } else {
              var lazyResolveRNStyle;
              var lazyNativeStyleEditorValidAttributes;
              var initAfterTick = function initAfterTick() {
                if (bridge !== null) {
                  setupNativeStyleEditor(bridge, agent2, lazyResolveRNStyle, lazyNativeStyleEditorValidAttributes);
                }
              };
              if (!hook.hasOwnProperty("resolveRNStyle")) {
                Object.defineProperty(hook, "resolveRNStyle", {
                  enumerable: false,
                  get: function get() {
                    return lazyResolveRNStyle;
                  },
                  set: function set(value) {
                    lazyResolveRNStyle = value;
                    initAfterTick();
                  }
                });
              }
              if (!hook.hasOwnProperty("nativeStyleEditorValidAttributes")) {
                Object.defineProperty(hook, "nativeStyleEditorValidAttributes", {
                  enumerable: false,
                  get: function get() {
                    return lazyNativeStyleEditorValidAttributes;
                  },
                  set: function set(value) {
                    lazyNativeStyleEditorValidAttributes = value;
                    initAfterTick();
                  }
                });
              }
            }
          };
          function handleClose() {
            if (__DEBUG__) {
              backend_debug("WebSocket.onclose");
            }
            if (bridge !== null) {
              bridge.emit("shutdown");
            }
            scheduleRetry();
          }
          function handleFailed() {
            if (__DEBUG__) {
              backend_debug("WebSocket.onerror");
            }
            scheduleRetry();
          }
          function handleMessage(event) {
            var data;
            try {
              if (typeof event.data === "string") {
                data = JSON.parse(event.data);
                if (__DEBUG__) {
                  backend_debug("WebSocket.onmessage", data);
                }
              } else {
                throw Error();
              }
            } catch (e) {
              console.error("[React DevTools] Failed to parse JSON: " + event.data);
              return;
            }
            messageListeners.forEach(function(fn) {
              try {
                fn(data);
              } catch (error) {
                console.log("[React DevTools] Error calling listener", data);
                console.log("error:", error);
                throw error;
              }
            });
          }
        }
        function connectWithCustomMessagingProtocol(_ref2) {
          var { onSubscribe, onUnsubscribe, onMessage, nativeStyleEditorValidAttributes, resolveRNStyle, onSettingsUpdated, isReloadAndProfileSupported: _ref2$isReloadAndProf } = _ref2, isReloadAndProfileSupported = _ref2$isReloadAndProf === undefined ? getIsReloadAndProfileSupported() : _ref2$isReloadAndProf, isProfiling = _ref2.isProfiling, onReloadAndProfile2 = _ref2.onReloadAndProfile, onReloadAndProfileFlagsReset2 = _ref2.onReloadAndProfileFlagsReset;
          var hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook == null) {
            return;
          }
          var wall = {
            listen: function listen(fn) {
              onSubscribe(fn);
              return function() {
                onUnsubscribe(fn);
              };
            },
            send: function send(event, payload) {
              onMessage(event, payload);
            }
          };
          var bridge = new src_bridge(wall);
          bridge.addListener("updateComponentFilters", function(componentFilters) {
            savedComponentFilters = componentFilters;
          });
          if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ == null) {
            bridge.send("overrideComponentFilters", savedComponentFilters);
          }
          var agent2 = new Agent(bridge, isProfiling, onReloadAndProfile2);
          if (typeof onReloadAndProfileFlagsReset2 === "function") {
            onReloadAndProfileFlagsReset2();
          }
          if (onSettingsUpdated != null) {
            agent2.addListener("updateHookSettings", onSettingsUpdated);
          }
          agent2.addListener("shutdown", function() {
            if (onSettingsUpdated != null) {
              agent2.removeListener("updateHookSettings", onSettingsUpdated);
            }
            hook.emit("shutdown");
          });
          var unsubscribeBackend = initBackend(hook, agent2, window, isReloadAndProfileSupported);
          var nativeStyleResolver = resolveRNStyle || hook.resolveRNStyle;
          if (nativeStyleResolver != null) {
            var validAttributes = nativeStyleEditorValidAttributes || hook.nativeStyleEditorValidAttributes || null;
            setupNativeStyleEditor(bridge, agent2, nativeStyleResolver, validAttributes);
          }
          return unsubscribeBackend;
        }
      })();
      return __webpack_exports__;
    })();
  });
});

// node_modules/ink/build/devtools.js
var exports_devtools = {};
var import_react_devtools_core;
var init_devtools = __esm(() => {
  init_devtools_window_polyfill();
  import_react_devtools_core = __toESM(require_backend(), 1);
  import_react_devtools_core.default.initialize();
  import_react_devtools_core.default.connectToDevTools();
});

// node_modules/cli-boxes/boxes.json
var require_boxes = __commonJS((exports, module) => {
  module.exports = {
    single: {
      topLeft: "",
      top: "",
      topRight: "",
      right: "",
      bottomRight: "",
      bottom: "",
      bottomLeft: "",
      left: ""
    },
    double: {
      topLeft: "",
      top: "",
      topRight: "",
      right: "",
      bottomRight: "",
      bottom: "",
      bottomLeft: "",
      left: ""
    },
    round: {
      topLeft: "",
      top: "",
      topRight: "",
      right: "",
      bottomRight: "",
      bottom: "",
      bottomLeft: "",
      left: ""
    },
    bold: {
      topLeft: "",
      top: "",
      topRight: "",
      right: "",
      bottomRight: "",
      bottom: "",
      bottomLeft: "",
      left: ""
    },
    singleDouble: {
      topLeft: "",
      top: "",
      topRight: "",
      right: "",
      bottomRight: "",
      bottom: "",
      bottomLeft: "",
      left: ""
    },
    doubleSingle: {
      topLeft: "",
      top: "",
      topRight: "",
      right: "",
      bottomRight: "",
      bottom: "",
      bottomLeft: "",
      left: ""
    },
    classic: {
      topLeft: "+",
      top: "-",
      topRight: "+",
      right: "|",
      bottomRight: "+",
      bottom: "-",
      bottomLeft: "+",
      left: "|"
    },
    arrow: {
      topLeft: "",
      top: "",
      topRight: "",
      right: "",
      bottomRight: "",
      bottom: "",
      bottomLeft: "",
      left: ""
    }
  };
});

// node_modules/cli-boxes/index.js
var require_cli_boxes = __commonJS((exports, module) => {
  var cliBoxes = require_boxes();
  module.exports = cliBoxes;
  module.exports.default = cliBoxes;
});

// node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS((exports, module) => {
  var mimicFn = (to, from) => {
    for (const prop of Reflect.ownKeys(from)) {
      Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
    }
    return to;
  };
  module.exports = mimicFn;
  module.exports.default = mimicFn;
});

// node_modules/onetime/index.js
var require_onetime = __commonJS((exports, module) => {
  var mimicFn = require_mimic_fn();
  var calledFunctions = new WeakMap;
  var onetime = (function_, options = {}) => {
    if (typeof function_ !== "function") {
      throw new TypeError("Expected a function");
    }
    let returnValue;
    let callCount = 0;
    const functionName = function_.displayName || function_.name || "<anonymous>";
    const onetime2 = function(...arguments_) {
      calledFunctions.set(onetime2, ++callCount);
      if (callCount === 1) {
        returnValue = function_.apply(this, arguments_);
        function_ = null;
      } else if (options.throw === true) {
        throw new Error(`Function \`${functionName}\` can only be called once`);
      }
      return returnValue;
    };
    mimicFn(onetime2, function_);
    calledFunctions.set(onetime2, callCount);
    return onetime2;
  };
  module.exports = onetime;
  module.exports.default = onetime;
  module.exports.callCount = (function_) => {
    if (!calledFunctions.has(function_)) {
      throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    }
    return calledFunctions.get(function_);
  };
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS((exports, module) => {
  var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
  module.exports = (string) => {
    if (typeof string !== "string") {
      throw new TypeError("Expected a string");
    }
    return string.replace(matchOperatorsRegex, "\\$&");
  };
});

// node_modules/stack-utils/index.js
var require_stack_utils = __commonJS((exports, module) => {
  var escapeStringRegexp = require_escape_string_regexp();
  var cwd = typeof process === "object" && process && typeof process.cwd === "function" ? process.cwd() : ".";
  var natives = [].concat(__require("module").builtinModules, "bootstrap_node", "node").map((n) => new RegExp(`(?:\\((?:node:)?${n}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${n}(?:\\.js)?:\\d+:\\d+$)`));
  natives.push(/\((?:node:)?internal\/[^:]+:\d+:\d+\)$/, /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/, /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/);

  class StackUtils {
    constructor(opts) {
      opts = {
        ignoredPackages: [],
        ...opts
      };
      if ("internals" in opts === false) {
        opts.internals = StackUtils.nodeInternals();
      }
      if ("cwd" in opts === false) {
        opts.cwd = cwd;
      }
      this._cwd = opts.cwd.replace(/\\/g, "/");
      this._internals = [].concat(opts.internals, ignoredPackagesRegExp(opts.ignoredPackages));
      this._wrapCallSite = opts.wrapCallSite || false;
    }
    static nodeInternals() {
      return [...natives];
    }
    clean(stack, indent = 0) {
      indent = " ".repeat(indent);
      if (!Array.isArray(stack)) {
        stack = stack.split(`
`);
      }
      if (!/^\s*at /.test(stack[0]) && /^\s*at /.test(stack[1])) {
        stack = stack.slice(1);
      }
      let outdent = false;
      let lastNonAtLine = null;
      const result = [];
      stack.forEach((st) => {
        st = st.replace(/\\/g, "/");
        if (this._internals.some((internal) => internal.test(st))) {
          return;
        }
        const isAtLine = /^\s*at /.test(st);
        if (outdent) {
          st = st.trimEnd().replace(/^(\s+)at /, "$1");
        } else {
          st = st.trim();
          if (isAtLine) {
            st = st.slice(3);
          }
        }
        st = st.replace(`${this._cwd}/`, "");
        if (st) {
          if (isAtLine) {
            if (lastNonAtLine) {
              result.push(lastNonAtLine);
              lastNonAtLine = null;
            }
            result.push(st);
          } else {
            outdent = true;
            lastNonAtLine = st;
          }
        }
      });
      return result.map((line) => `${indent}${line}
`).join("");
    }
    captureString(limit, fn = this.captureString) {
      if (typeof limit === "function") {
        fn = limit;
        limit = Infinity;
      }
      const { stackTraceLimit } = Error;
      if (limit) {
        Error.stackTraceLimit = limit;
      }
      const obj = {};
      Error.captureStackTrace(obj, fn);
      const { stack } = obj;
      Error.stackTraceLimit = stackTraceLimit;
      return this.clean(stack);
    }
    capture(limit, fn = this.capture) {
      if (typeof limit === "function") {
        fn = limit;
        limit = Infinity;
      }
      const { prepareStackTrace, stackTraceLimit } = Error;
      Error.prepareStackTrace = (obj2, site) => {
        if (this._wrapCallSite) {
          return site.map(this._wrapCallSite);
        }
        return site;
      };
      if (limit) {
        Error.stackTraceLimit = limit;
      }
      const obj = {};
      Error.captureStackTrace(obj, fn);
      const { stack } = obj;
      Object.assign(Error, { prepareStackTrace, stackTraceLimit });
      return stack;
    }
    at(fn = this.at) {
      const [site] = this.capture(1, fn);
      if (!site) {
        return {};
      }
      const res = {
        line: site.getLineNumber(),
        column: site.getColumnNumber()
      };
      setFile(res, site.getFileName(), this._cwd);
      if (site.isConstructor()) {
        Object.defineProperty(res, "constructor", {
          value: true,
          configurable: true
        });
      }
      if (site.isEval()) {
        res.evalOrigin = site.getEvalOrigin();
      }
      if (site.isNative()) {
        res.native = true;
      }
      let typename;
      try {
        typename = site.getTypeName();
      } catch (_) {}
      if (typename && typename !== "Object" && typename !== "[object Object]") {
        res.type = typename;
      }
      const fname = site.getFunctionName();
      if (fname) {
        res.function = fname;
      }
      const meth = site.getMethodName();
      if (meth && fname !== meth) {
        res.method = meth;
      }
      return res;
    }
    parseLine(line) {
      const match = line && line.match(re);
      if (!match) {
        return null;
      }
      const ctor = match[1] === "new";
      let fname = match[2];
      const evalOrigin = match[3];
      const evalFile = match[4];
      const evalLine = Number(match[5]);
      const evalCol = Number(match[6]);
      let file = match[7];
      const lnum = match[8];
      const col = match[9];
      const native = match[10] === "native";
      const closeParen = match[11] === ")";
      let method;
      const res = {};
      if (lnum) {
        res.line = Number(lnum);
      }
      if (col) {
        res.column = Number(col);
      }
      if (closeParen && file) {
        let closes = 0;
        for (let i = file.length - 1;i > 0; i--) {
          if (file.charAt(i) === ")") {
            closes++;
          } else if (file.charAt(i) === "(" && file.charAt(i - 1) === " ") {
            closes--;
            if (closes === -1 && file.charAt(i - 1) === " ") {
              const before = file.slice(0, i - 1);
              const after = file.slice(i + 1);
              file = after;
              fname += ` (${before}`;
              break;
            }
          }
        }
      }
      if (fname) {
        const methodMatch = fname.match(methodRe);
        if (methodMatch) {
          fname = methodMatch[1];
          method = methodMatch[2];
        }
      }
      setFile(res, file, this._cwd);
      if (ctor) {
        Object.defineProperty(res, "constructor", {
          value: true,
          configurable: true
        });
      }
      if (evalOrigin) {
        res.evalOrigin = evalOrigin;
        res.evalLine = evalLine;
        res.evalColumn = evalCol;
        res.evalFile = evalFile && evalFile.replace(/\\/g, "/");
      }
      if (native) {
        res.native = true;
      }
      if (fname) {
        res.function = fname;
      }
      if (method && fname !== method) {
        res.method = method;
      }
      return res;
    }
  }
  function setFile(result, filename, cwd2) {
    if (filename) {
      filename = filename.replace(/\\/g, "/");
      if (filename.startsWith(`${cwd2}/`)) {
        filename = filename.slice(cwd2.length + 1);
      }
      result.file = filename;
    }
  }
  function ignoredPackagesRegExp(ignoredPackages) {
    if (ignoredPackages.length === 0) {
      return [];
    }
    const packages = ignoredPackages.map((mod2) => escapeStringRegexp(mod2));
    return new RegExp(`[/\\\\]node_modules[/\\\\](?:${packages.join("|")})[/\\\\][^:]+:\\d+:\\d+`);
  }
  var re = new RegExp("^" + "(?:\\s*at )?" + "(?:(new) )?" + "(?:(.*?) \\()?" + "(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?" + "(?:(.+?):(\\d+):(\\d+)|(native))" + "(\\)?)$");
  var methodRe = /^(.*?) \[as (.*?)\]$/;
  module.exports = StackUtils;
});

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports, module) => {
  module.exports = isexe;
  isexe.sync = sync;
  var fs5 = __require("fs");
  function checkPathExt(path, options) {
    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0;i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path, options);
  }
  function isexe(path, options, cb) {
    fs5.stat(path, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path, options));
    });
  }
  function sync(path, options) {
    return checkStat(fs5.statSync(path), path, options);
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports, module) => {
  module.exports = isexe;
  isexe.sync = sync;
  var fs5 = __require("fs");
  function isexe(path, options, cb) {
    fs5.stat(path, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }
  function sync(path, options) {
    return checkStat(fs5.statSync(path), options);
  }
  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }
  function checkMode(stat, options) {
    var mod2 = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;
    return ret;
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports, module) => {
  var fs5 = __require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows();
  } else {
    core = require_mode();
  }
  module.exports = isexe;
  isexe.sync = sync;
  function isexe(path, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve2, reject2) {
        isexe(path, options || {}, function(er, is) {
          if (er) {
            reject2(er);
          } else {
            resolve2(is);
          }
        });
      });
    }
    core(path, options || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync(path, options) {
    try {
      return core.sync(path, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS((exports, module) => {
  var isWindows3 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path = __require("path");
  var COLON = isWindows3 ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows3 && cmd.match(/\\/) ? [""] : [
      ...isWindows3 ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows3 ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows3 ? pathExtExe.split(colon) : [""];
    if (isWindows3) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve2, reject2) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve2(found) : reject2(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve2(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve2, reject2) => {
      if (ii === pathExt.length)
        return resolve2(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve2(p + ext);
        }
        return resolve2(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0;i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0;j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is = isexe.sync(cur, { pathExt: pathExtExe });
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {}
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module.exports = which;
  which.sync = whichSync;
});

// node_modules/path-key/index.js
var require_path_key = __commonJS((exports, module) => {
  var pathKey = (options = {}) => {
    const environment = options.env || process.env;
    const platform3 = options.platform || process.platform;
    if (platform3 !== "win32") {
      return "PATH";
    }
    return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
  };
  module.exports = pathKey;
  module.exports.default = pathKey;
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS((exports, module) => {
  var path = __require("path");
  var which = require_which();
  var getPathKey = require_path_key();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const env3 = parsed.options.env || process.env;
    const cwd2 = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
    if (shouldSwitchCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {}
    }
    let resolved;
    try {
      resolved = which.sync(parsed.command, {
        path: env3[getPathKey({ env: env3 })],
        pathExt: withoutPathExt ? path.delimiter : undefined
      });
    } catch (e) {} finally {
      if (shouldSwitchCwd) {
        process.chdir(cwd2);
      }
    }
    if (resolved) {
      resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  module.exports = resolveCommand;
});

// node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS((exports, module) => {
  var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg) {
    arg = arg.replace(metaCharsRegExp, "^$1");
    return arg;
  }
  function escapeArgument(arg, doubleEscapeMetaChars) {
    arg = `${arg}`;
    arg = arg.replace(/(?=(\\+?)?)\1"/g, "$1$1\\\"");
    arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
    arg = `"${arg}"`;
    arg = arg.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg = arg.replace(metaCharsRegExp, "^$1");
    }
    return arg;
  }
  exports.command = escapeCommand;
  exports.argument = escapeArgument;
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS((exports, module) => {
  module.exports = /^#!(.*)/;
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS((exports, module) => {
  var shebangRegex = require_shebang_regex();
  module.exports = (string = "") => {
    const match = string.match(shebangRegex);
    if (!match) {
      return null;
    }
    const [path, argument] = match[0].replace(/#! ?/, "").split(" ");
    const binary = path.split("/").pop();
    if (binary === "env") {
      return argument;
    }
    return argument ? `${binary} ${argument}` : binary;
  };
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS((exports, module) => {
  var fs5 = __require("fs");
  var shebangCommand = require_shebang_command();
  function readShebang(command) {
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
      fd = fs5.openSync(command, "r");
      fs5.readSync(fd, buffer, 0, size, 0);
      fs5.closeSync(fd);
    } catch (e) {}
    return shebangCommand(buffer.toString());
  }
  module.exports = readShebang;
});

// node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var path = __require("path");
  var resolveCommand = require_resolveCommand();
  var escape2 = require_escape();
  var readShebang = require_readShebang();
  var isWin = process.platform === "win32";
  var isExecutableRegExp = /\.(?:com|exe)$/i;
  var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path.normalize(parsed.command);
      parsed.command = escape2.command(parsed.command);
      parsed.args = parsed.args.map((arg) => escape2.argument(arg, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parse(command, args, options) {
    if (args && !Array.isArray(args)) {
      options = args;
      args = null;
    }
    args = args ? args.slice(0) : [];
    options = Object.assign({}, options);
    const parsed = {
      command,
      args,
      options,
      file: undefined,
      original: {
        command,
        args
      }
    };
    return options.shell ? parsed : parseNonShell(parsed);
  }
  module.exports = parse;
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS((exports, module) => {
  var isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed);
        if (err) {
          return originalEmit.call(cp, "error", err);
        }
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS((exports, module) => {
  var cp = __require("child_process");
  var parse = require_parse();
  var enoent = require_enoent();
  function spawn(command, args, options) {
    const parsed = parse(command, args, options);
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync(command, args, options) {
    const parsed = parse(command, args, options);
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  module.exports = spawn;
  module.exports.spawn = spawn;
  module.exports.sync = spawnSync;
  module.exports._parse = parse;
  module.exports._enoent = enoent;
});

// node_modules/base32-decode/index.js
var require_base32_decode = __commonJS((exports, module) => {
  var RFC4648 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  var RFC4648_HEX = "0123456789ABCDEFGHIJKLMNOPQRSTUV";
  var CROCKFORD = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
  function readChar(alphabet, char) {
    var idx = alphabet.indexOf(char);
    if (idx === -1) {
      throw new Error("Invalid character found: " + char);
    }
    return idx;
  }
  module.exports = function base32Decode(input, variant) {
    var alphabet;
    switch (variant) {
      case "RFC3548":
      case "RFC4648":
        alphabet = RFC4648;
        input = input.replace(/=+$/, "");
        break;
      case "RFC4648-HEX":
        alphabet = RFC4648_HEX;
        input = input.replace(/=+$/, "");
        break;
      case "Crockford":
        alphabet = CROCKFORD;
        input = input.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1");
        break;
      default:
        throw new Error("Unknown base32 variant: " + variant);
    }
    var length = input.length;
    var bits = 0;
    var value = 0;
    var index = 0;
    var output = new Uint8Array(length * 5 / 8 | 0);
    for (var i2 = 0;i2 < length; i2++) {
      value = value << 5 | readChar(alphabet, input[i2]);
      bits += 5;
      if (bits >= 8) {
        output[index++] = value >>> bits - 8 & 255;
        bits -= 8;
      }
    }
    return output.buffer;
  };
});

// node_modules/keytar/build/Release/keytar.node
var require_keytar = __commonJS((exports, module) => {
  module.exports = __require("./keytar-f6bnxfss.node");
});

// node_modules/keytar/lib/keytar.js
var require_keytar2 = __commonJS((exports, module) => {
  var keytar = require_keytar();
  function checkRequired(val, name) {
    if (!val || val.length <= 0) {
      throw new Error(name + " is required.");
    }
  }
  module.exports = {
    getPassword: function(service, account) {
      checkRequired(service, "Service");
      checkRequired(account, "Account");
      return keytar.getPassword(service, account);
    },
    setPassword: function(service, account, password) {
      checkRequired(service, "Service");
      checkRequired(account, "Account");
      checkRequired(password, "Password");
      return keytar.setPassword(service, account, password);
    },
    deletePassword: function(service, account) {
      checkRequired(service, "Service");
      checkRequired(account, "Account");
      return keytar.deletePassword(service, account);
    },
    findPassword: function(service) {
      checkRequired(service, "Service");
      return keytar.findPassword(service);
    },
    findCredentials: function(service) {
      checkRequired(service, "Service");
      return keytar.findCredentials(service);
    }
  };
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS((exports, module) => {
  module.exports = asPromise;
  function asPromise(fn, ctx) {
    var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
    while (index < arguments.length)
      params[offset++] = arguments[index++];
    return new Promise(function executor(resolve2, reject2) {
      params[offset] = function callback(err) {
        if (pending) {
          pending = false;
          if (err)
            reject2(err);
          else {
            var params2 = new Array(arguments.length - 1), offset2 = 0;
            while (offset2 < params2.length)
              params2[offset2++] = arguments[offset2];
            resolve2.apply(null, params2);
          }
        }
      };
      try {
        fn.apply(ctx || null, params);
      } catch (err) {
        if (pending) {
          pending = false;
          reject2(err);
        }
      }
    });
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS((exports) => {
  var base64 = exports;
  base64.length = function length(string) {
    var p = string.length;
    if (!p)
      return 0;
    var n2 = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
      ++n2;
    return Math.ceil(string.length * 3) / 4 - n2;
  };
  var b64 = new Array(64);
  var s64 = new Array(123);
  for (i2 = 0;i2 < 64; )
    s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
  var i2;
  base64.encode = function encode(buffer, start, end) {
    var parts = null, chunk = [];
    var i3 = 0, j = 0, t;
    while (start < end) {
      var b = buffer[start++];
      switch (j) {
        case 0:
          chunk[i3++] = b64[b >> 2];
          t = (b & 3) << 4;
          j = 1;
          break;
        case 1:
          chunk[i3++] = b64[t | b >> 4];
          t = (b & 15) << 2;
          j = 2;
          break;
        case 2:
          chunk[i3++] = b64[t | b >> 6];
          chunk[i3++] = b64[b & 63];
          j = 0;
          break;
      }
      if (i3 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i3 = 0;
      }
    }
    if (j) {
      chunk[i3++] = b64[t];
      chunk[i3++] = 61;
      if (j === 1)
        chunk[i3++] = 61;
    }
    if (parts) {
      if (i3)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i3));
  };
  var invalidEncoding = "invalid encoding";
  base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, t;
    for (var i3 = 0;i3 < string.length; ) {
      var c3 = string.charCodeAt(i3++);
      if (c3 === 61 && j > 1)
        break;
      if ((c3 = s64[c3]) === undefined)
        throw Error(invalidEncoding);
      switch (j) {
        case 0:
          t = c3;
          j = 1;
          break;
        case 1:
          buffer[offset++] = t << 2 | (c3 & 48) >> 4;
          t = c3;
          j = 2;
          break;
        case 2:
          buffer[offset++] = (t & 15) << 4 | (c3 & 60) >> 2;
          t = c3;
          j = 3;
          break;
        case 3:
          buffer[offset++] = (t & 3) << 6 | c3;
          j = 0;
          break;
      }
    }
    if (j === 1)
      throw Error(invalidEncoding);
    return offset - start;
  };
  base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
  };
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS((exports, module) => {
  module.exports = EventEmitter4;
  function EventEmitter4() {
    this._listeners = {};
  }
  EventEmitter4.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
      fn,
      ctx: ctx || this
    });
    return this;
  };
  EventEmitter4.prototype.off = function off(evt, fn) {
    if (evt === undefined)
      this._listeners = {};
    else {
      if (fn === undefined)
        this._listeners[evt] = [];
      else {
        var listeners = this._listeners[evt];
        for (var i2 = 0;i2 < listeners.length; )
          if (listeners[i2].fn === fn)
            listeners.splice(i2, 1);
          else
            ++i2;
      }
    }
    return this;
  };
  EventEmitter4.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
      var args = [], i2 = 1;
      for (;i2 < arguments.length; )
        args.push(arguments[i2++]);
      for (i2 = 0;i2 < listeners.length; )
        listeners[i2].fn.apply(listeners[i2++].ctx, args);
    }
    return this;
  };
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS((exports, module) => {
  module.exports = factory(factory);
  function factory(exports2) {
    if (typeof Float32Array !== "undefined")
      (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports2.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports2.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports2.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports2.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
    else
      (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 340282346638528860000000000000000000000)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 0.000000000000000000000000000000000000011754943508222875)
            writeUint((sign << 31 | Math.round(val / 0.000000000000000000000000000000000000000000001401298464324817)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports2.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports2.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 0.000000000000000000000000000000000000000000001401298464324817 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports2.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports2.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
    if (typeof Float64Array !== "undefined")
      (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports2.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports2.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports2.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports2.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
    else
      (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022250738585072014) {
              mantissa = val / 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports2.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports2.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports2.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports2.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
    return exports2;
  }
  function writeUintLE(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  function writeUintBE(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
  }
  function readUintLE(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
  }
  function readUintBE(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS((exports, module) => {
  module.exports = inquire;
  function inquire(moduleName) {
    try {
      var mod = eval("quire".replace(/^/, "re"))(moduleName);
      if (mod && (mod.length || Object.keys(mod).length))
        return mod;
    } catch (e) {}
    return null;
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS((exports) => {
  var utf8 = exports;
  utf8.length = function utf8_length(string) {
    var len = 0, c3 = 0;
    for (var i2 = 0;i2 < string.length; ++i2) {
      c3 = string.charCodeAt(i2);
      if (c3 < 128)
        len += 1;
      else if (c3 < 2048)
        len += 2;
      else if ((c3 & 64512) === 55296 && (string.charCodeAt(i2 + 1) & 64512) === 56320) {
        ++i2;
        len += 4;
      } else
        len += 3;
    }
    return len;
  };
  utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
      return "";
    var parts = null, chunk = [], i2 = 0, t;
    while (start < end) {
      t = buffer[start++];
      if (t < 128)
        chunk[i2++] = t;
      else if (t > 191 && t < 224)
        chunk[i2++] = (t & 31) << 6 | buffer[start++] & 63;
      else if (t > 239 && t < 365) {
        t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
        chunk[i2++] = 55296 + (t >> 10);
        chunk[i2++] = 56320 + (t & 1023);
      } else
        chunk[i2++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
      if (i2 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i2 = 0;
      }
    }
    if (parts) {
      if (i2)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i2));
  };
  utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset, c1, c22;
    for (var i2 = 0;i2 < string.length; ++i2) {
      c1 = string.charCodeAt(i2);
      if (c1 < 128) {
        buffer[offset++] = c1;
      } else if (c1 < 2048) {
        buffer[offset++] = c1 >> 6 | 192;
        buffer[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c22 = string.charCodeAt(i2 + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c22 & 1023);
        ++i2;
        buffer[offset++] = c1 >> 18 | 240;
        buffer[offset++] = c1 >> 12 & 63 | 128;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      } else {
        buffer[offset++] = c1 >> 12 | 224;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start;
  };
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS((exports, module) => {
  module.exports = pool;
  function pool(alloc, slice, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size2) {
      if (size2 < 1 || size2 > MAX)
        return alloc(size2);
      if (offset + size2 > SIZE) {
        slab = alloc(SIZE);
        offset = 0;
      }
      var buf = slice.call(slab, offset, offset += size2);
      if (offset & 7)
        offset = (offset | 7) + 1;
      return buf;
    };
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS((exports, module) => {
  module.exports = LongBits;
  var util = require_minimal();
  function LongBits(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }
  var zero = LongBits.zero = new LongBits(0, 0);
  zero.toNumber = function() {
    return 0;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var zeroHash = LongBits.zeroHash = "\x00\x00\x00\x00\x00\x00\x00\x00";
  LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign = value < 0;
    if (sign)
      value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new LongBits(lo, hi);
  };
  LongBits.from = function from(value) {
    if (typeof value === "number")
      return LongBits.fromNumber(value);
    if (util.isString(value)) {
      if (util.Long)
        value = util.Long.fromString(value);
      else
        return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  };
  LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
      if (!lo)
        hi = hi + 1 >>> 0;
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
      return zero;
    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
  };
  LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
  };
  LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS((exports) => {
  var util = exports;
  util.asPromise = require_aspromise();
  util.base64 = require_base64();
  util.EventEmitter = require_eventemitter();
  util.float = require_float();
  util.inquire = require_inquire();
  util.utf8 = require_utf8();
  util.pool = require_pool();
  util.LongBits = require_longbits();
  util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
  util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports;
  util.emptyArray = Object.freeze ? Object.freeze([]) : [];
  util.emptyObject = Object.freeze ? Object.freeze({}) : {};
  util.isInteger = Number.isInteger || function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
  util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
  };
  util.isObject = function isObject(value) {
    return value && typeof value === "object";
  };
  util.isset = util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop))
      return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
  };
  util.Buffer = function() {
    try {
      var Buffer7 = util.inquire("buffer").Buffer;
      return Buffer7.prototype.utf8Write ? Buffer7 : null;
    } catch (e) {
      return null;
    }
  }();
  util._Buffer_from = null;
  util._Buffer_allocUnsafe = null;
  util.newBuffer = function newBuffer(sizeOrArray) {
    return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
  };
  util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
  util.key2Re = /^true|false|0|1$/;
  util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
  util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
  util.longToHash = function longToHash(value) {
    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
  };
  util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
      return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
  };
  function merge(dst, src, ifNotSet) {
    for (var keys = Object.keys(src), i2 = 0;i2 < keys.length; ++i2)
      if (dst[keys[i2]] === undefined || !ifNotSet)
        dst[keys[i2]] = src[keys[i2]];
    return dst;
  }
  util.merge = merge;
  util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
  };
  function newError(name) {
    function CustomError(message, properties) {
      if (!(this instanceof CustomError))
        return new CustomError(message, properties);
      Object.defineProperty(this, "message", { get: function() {
        return message;
      } });
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, CustomError);
      else
        Object.defineProperty(this, "stack", { value: new Error().stack || "" });
      if (properties)
        merge(this, properties);
    }
    CustomError.prototype = Object.create(Error.prototype, {
      constructor: {
        value: CustomError,
        writable: true,
        enumerable: false,
        configurable: true
      },
      name: {
        get: function get() {
          return name;
        },
        set: undefined,
        enumerable: false,
        configurable: true
      },
      toString: {
        value: function value() {
          return this.name + ": " + this.message;
        },
        writable: true,
        enumerable: false,
        configurable: true
      }
    });
    return CustomError;
  }
  util.newError = newError;
  util.ProtocolError = newError("ProtocolError");
  util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i2 = 0;i2 < fieldNames.length; ++i2)
      fieldMap[fieldNames[i2]] = 1;
    return function() {
      for (var keys = Object.keys(this), i3 = keys.length - 1;i3 > -1; --i3)
        if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== undefined && this[keys[i3]] !== null)
          return keys[i3];
    };
  };
  util.oneOfSetter = function setOneOf(fieldNames) {
    return function(name) {
      for (var i2 = 0;i2 < fieldNames.length; ++i2)
        if (fieldNames[i2] !== name)
          delete this[fieldNames[i2]];
    };
  };
  util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
  };
  util._configure = function() {
    var Buffer7 = util.Buffer;
    if (!Buffer7) {
      util._Buffer_from = util._Buffer_allocUnsafe = null;
      return;
    }
    util._Buffer_from = Buffer7.from !== Uint8Array.from && Buffer7.from || function Buffer_from(value, encoding) {
      return new Buffer7(value, encoding);
    };
    util._Buffer_allocUnsafe = Buffer7.allocUnsafe || function Buffer_allocUnsafe(size) {
      return new Buffer7(size);
    };
  };
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS((exports, module) => {
  module.exports = Writer;
  var util = require_minimal();
  var BufferWriter;
  var LongBits = util.LongBits;
  var base64 = util.base64;
  var utf8 = util.utf8;
  function Op(fn, len, val) {
    this.fn = fn;
    this.len = len;
    this.next = undefined;
    this.val = val;
  }
  function noop4() {}
  function State(writer) {
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }
  function Writer() {
    this.len = 0;
    this.head = new Op(noop4, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  var create2 = function create() {
    return util.Buffer ? function create_buffer_setup() {
      return (Writer.create = function create_buffer() {
        return new BufferWriter;
      })();
    } : function create_array() {
      return new Writer;
    };
  };
  Writer.create = create2();
  Writer.alloc = function alloc(size) {
    return new util.Array(size);
  };
  if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
  Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  };
  function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
  }
  function writeVarint32(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  }
  function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
  }
  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;
  Writer.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
  };
  Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
  };
  Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  };
  function writeVarint64(val, buf, pos) {
    while (val.hi) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  }
  Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.int64 = Writer.prototype.uint64;
  Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  };
  function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  };
  Writer.prototype.sfixed32 = Writer.prototype.fixed32;
  Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  };
  Writer.prototype.sfixed64 = Writer.prototype.fixed64;
  Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
  };
  Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
  };
  var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytes_for(val, buf, pos) {
    for (var i2 = 0;i2 < val.length; ++i2)
      buf[pos + i2] = val[i2];
  };
  Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
      var buf = Writer.alloc(len = base64.length(value));
      base64.decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
  };
  Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
  };
  Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop4, 0, 0);
    this.len = 0;
    return this;
  };
  Writer.prototype.reset = function reset() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop4, 0, 0);
      this.len = 0;
    }
    return this;
  };
  Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  };
  Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while (head) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  };
  Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create2();
    BufferWriter._configure();
  };
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS((exports, module) => {
  module.exports = BufferWriter;
  var Writer = require_writer();
  (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
  var util = require_minimal();
  function BufferWriter() {
    Writer.call(this);
  }
  BufferWriter._configure = function() {
    BufferWriter.alloc = util._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else
        for (var i2 = 0;i2 < val.length; )
          buf[pos++] = val[i2++];
    };
  };
  BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
      value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
      this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
  };
  function writeStringBuffer(val, buf, pos) {
    if (val.length < 40)
      util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
      buf.utf8Write(val, pos);
    else
      buf.write(val, pos);
  }
  BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
      this._push(writeStringBuffer, len, value);
    return this;
  };
  BufferWriter._configure();
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS((exports, module) => {
  module.exports = Reader;
  var util = require_minimal();
  var BufferReader;
  var LongBits = util.LongBits;
  var utf8 = util.utf8;
  function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
  }
  function Reader(buffer) {
    this.buf = buffer;
    this.pos = 0;
    this.len = buffer.length;
  }
  var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
    if (buffer instanceof Uint8Array || Array.isArray(buffer))
      return new Reader(buffer);
    throw Error("illegal buffer");
  } : function create_array(buffer) {
    if (Array.isArray(buffer))
      return new Reader(buffer);
    throw Error("illegal buffer");
  };
  var create2 = function create() {
    return util.Buffer ? function create_buffer_setup(buffer) {
      return (Reader.create = function create_buffer(buffer2) {
        return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
      })(buffer);
    } : create_array;
  };
  Reader.create = create2();
  Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
  Reader.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295;
    return function read_uint32() {
      value = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value;
    };
  }();
  Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
  };
  Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  };
  function readLongVarint() {
    var bits = new LongBits(0, 0);
    var i2 = 0;
    if (this.len - this.pos > 4) {
      for (;i2 < 4; ++i2) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
      i2 = 0;
    } else {
      for (;i2 < 3; ++i2) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (;i2 < 5; ++i2) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    } else {
      for (;i2 < 5; ++i2) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    }
    throw Error("invalid varint encoding");
  }
  Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
  };
  function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
  }
  Reader.prototype.fixed32 = function read_fixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
  };
  Reader.prototype.sfixed32 = function read_sfixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
  };
  function readFixed64() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  }
  Reader.prototype.float = function read_float() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  };
  Reader.prototype.double = function read_double() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  };
  Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    if (end > this.len)
      throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf))
      return this.buf.slice(start, end);
    if (start === end) {
      var nativeBuffer = util.Buffer;
      return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
  };
  Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
  };
  Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
      if (this.pos + length > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
    } else {
      do {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
      } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create2();
    BufferReader._configure();
    var fn = util.Long ? "toLong" : "toNumber";
    util.merge(Reader.prototype, {
      int64: function read_int64() {
        return readLongVarint.call(this)[fn](false);
      },
      uint64: function read_uint64() {
        return readLongVarint.call(this)[fn](true);
      },
      sint64: function read_sint64() {
        return readLongVarint.call(this).zzDecode()[fn](false);
      },
      fixed64: function read_fixed64() {
        return readFixed64.call(this)[fn](true);
      },
      sfixed64: function read_sfixed64() {
        return readFixed64.call(this)[fn](false);
      }
    });
  };
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS((exports, module) => {
  module.exports = BufferReader;
  var Reader = require_reader();
  (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
  var util = require_minimal();
  function BufferReader(buffer) {
    Reader.call(this, buffer);
  }
  BufferReader._configure = function() {
    if (util.Buffer)
      BufferReader.prototype._slice = util.Buffer.prototype.slice;
  };
  BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32();
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
  };
  BufferReader._configure();
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS((exports, module) => {
  module.exports = Service;
  var util = require_minimal();
  (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
  function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function")
      throw TypeError("rpcImpl must be a function");
    util.EventEmitter.call(this);
    this.rpcImpl = rpcImpl;
    this.requestDelimited = Boolean(requestDelimited);
    this.responseDelimited = Boolean(responseDelimited);
  }
  Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
    if (!request)
      throw TypeError("request must be specified");
    var self2 = this;
    if (!callback)
      return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
    if (!self2.rpcImpl) {
      setTimeout(function() {
        callback(Error("already ended"));
      }, 0);
      return;
    }
    try {
      return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
        if (err) {
          self2.emit("error", err, method);
          return callback(err);
        }
        if (response === null) {
          self2.end(true);
          return;
        }
        if (!(response instanceof responseCtor)) {
          try {
            response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
          } catch (err2) {
            self2.emit("error", err2, method);
            return callback(err2);
          }
        }
        self2.emit("data", response, method);
        return callback(null, response);
      });
    } catch (err) {
      self2.emit("error", err, method);
      setTimeout(function() {
        callback(err);
      }, 0);
      return;
    }
  };
  Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
      if (!endedByRPC)
        this.rpcImpl(null, null, null);
      this.rpcImpl = null;
      this.emit("end").off();
    }
    return this;
  };
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS((exports) => {
  var rpc = exports;
  rpc.Service = require_service();
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS((exports, module) => {
  module.exports = {};
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS((exports) => {
  var protobuf = exports;
  protobuf.build = "minimal";
  protobuf.Writer = require_writer();
  protobuf.BufferWriter = require_writer_buffer();
  protobuf.Reader = require_reader();
  protobuf.BufferReader = require_reader_buffer();
  protobuf.util = require_minimal();
  protobuf.rpc = require_rpc();
  protobuf.roots = require_roots();
  protobuf.configure = configure;
  function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
  }
  configure();
});

// node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS((exports, module) => {
  module.exports = codegen;
  function codegen(functionParams, functionName) {
    if (typeof functionParams === "string") {
      functionName = functionParams;
      functionParams = undefined;
    }
    var body = [];
    function Codegen(formatStringOrScope) {
      if (typeof formatStringOrScope !== "string") {
        var source = toString2();
        if (codegen.verbose)
          console.log("codegen: " + source);
        source = "return " + source;
        if (formatStringOrScope) {
          var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
          while (scopeOffset < scopeKeys.length) {
            scopeParams[scopeOffset] = scopeKeys[scopeOffset];
            scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
          }
          scopeParams[scopeOffset] = source;
          return Function.apply(null, scopeParams).apply(null, scopeValues);
        }
        return Function(source)();
      }
      var formatParams = new Array(arguments.length - 1), formatOffset = 0;
      while (formatOffset < formatParams.length)
        formatParams[formatOffset] = arguments[++formatOffset];
      formatOffset = 0;
      formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
        var value = formatParams[formatOffset++];
        switch ($1) {
          case "d":
          case "f":
            return String(Number(value));
          case "i":
            return String(Math.floor(value));
          case "j":
            return JSON.stringify(value);
          case "s":
            return String(value);
        }
        return "%";
      });
      if (formatOffset !== formatParams.length)
        throw Error("parameter count mismatch");
      body.push(formatStringOrScope);
      return Codegen;
    }
    function toString2(functionNameOverride) {
      return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + `){
  ` + body.join(`
  `) + `
}`;
    }
    Codegen.toString = toString2;
    return Codegen;
  }
  codegen.verbose = false;
});

// node_modules/@protobufjs/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  module.exports = fetch2;
  var asPromise = require_aspromise();
  var inquire = require_inquire();
  var fs5 = inquire("fs");
  function fetch2(filename, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (!options)
      options = {};
    if (!callback)
      return asPromise(fetch2, this, filename, options);
    if (!options.xhr && fs5 && fs5.readFile)
      return fs5.readFile(filename, function fetchReadFileCallback(err, contents) {
        return err && typeof XMLHttpRequest !== "undefined" ? fetch2.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
      });
    return fetch2.xhr(filename, options, callback);
  }
  fetch2.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest;
    xhr.onreadystatechange = function fetchOnReadyStateChange() {
      if (xhr.readyState !== 4)
        return;
      if (xhr.status !== 0 && xhr.status !== 200)
        return callback(Error("status " + xhr.status));
      if (options.binary) {
        var buffer = xhr.response;
        if (!buffer) {
          buffer = [];
          for (var i2 = 0;i2 < xhr.responseText.length; ++i2)
            buffer.push(xhr.responseText.charCodeAt(i2) & 255);
        }
        return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
      }
      return callback(null, xhr.responseText);
    };
    if (options.binary) {
      if ("overrideMimeType" in xhr)
        xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.responseType = "arraybuffer";
    }
    xhr.open("GET", filename);
    xhr.send();
  };
});

// node_modules/@protobufjs/path/index.js
var require_path = __commonJS((exports) => {
  var path8 = exports;
  var isAbsolute = path8.isAbsolute = function isAbsolute(path9) {
    return /^(?:\/|\w+:)/.test(path9);
  };
  var normalize = path8.normalize = function normalize(path9) {
    path9 = path9.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
    var parts = path9.split("/"), absolute = isAbsolute(path9), prefix = "";
    if (absolute)
      prefix = parts.shift() + "/";
    for (var i2 = 0;i2 < parts.length; ) {
      if (parts[i2] === "..") {
        if (i2 > 0 && parts[i2 - 1] !== "..")
          parts.splice(--i2, 2);
        else if (absolute)
          parts.splice(i2, 1);
        else
          ++i2;
      } else if (parts[i2] === ".")
        parts.splice(i2, 1);
      else
        ++i2;
    }
    return prefix + parts.join("/");
  };
  path8.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
      includePath = normalize(includePath);
    if (isAbsolute(includePath))
      return includePath;
    if (!alreadyNormalized)
      originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
  };
});

// node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS((exports, module) => {
  module.exports = Namespace;
  var ReflectionObject = require_object();
  ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
  var Field = require_field();
  var util = require_util();
  var OneOf = require_oneof();
  var Type;
  var Service;
  var Enum;
  Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
  };
  function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
      return;
    var obj = {};
    for (var i2 = 0;i2 < array.length; ++i2)
      obj[array[i2].name] = array[i2].toJSON(toJSONOptions);
    return obj;
  }
  Namespace.arrayToJSON = arrayToJSON;
  Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved) {
      for (var i2 = 0;i2 < reserved.length; ++i2)
        if (typeof reserved[i2] !== "string" && reserved[i2][0] <= id && reserved[i2][1] > id)
          return true;
    }
    return false;
  };
  Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved) {
      for (var i2 = 0;i2 < reserved.length; ++i2)
        if (reserved[i2] === name)
          return true;
    }
    return false;
  };
  function Namespace(name, options) {
    ReflectionObject.call(this, name, options);
    this.nested = undefined;
    this._nestedArray = null;
    this._lookupCache = {};
    this._needsRecursiveFeatureResolution = true;
    this._needsRecursiveResolve = true;
  }
  function clearCache(namespace) {
    namespace._nestedArray = null;
    namespace._lookupCache = {};
    var parent = namespace;
    while (parent = parent.parent) {
      parent._lookupCache = {};
    }
    return namespace;
  }
  Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
      return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
  });
  Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
      "options",
      this.options,
      "nested",
      arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
  };
  Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    if (nestedJson) {
      for (var names = Object.keys(nestedJson), i2 = 0, nested;i2 < names.length; ++i2) {
        nested = nestedJson[names[i2]];
        ns.add((nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : nested.id !== undefined ? Field.fromJSON : Namespace.fromJSON)(names[i2], nested));
      }
    }
    return this;
  };
  Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name] || null;
  };
  Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
      return this.nested[name].values;
    throw Error("no such enum: " + name);
  };
  Namespace.prototype.add = function add(object) {
    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
      throw TypeError("object must be a valid nested object");
    if (!this.nested)
      this.nested = {};
    else {
      var prev = this.get(object.name);
      if (prev) {
        if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
          var nested = prev.nestedArray;
          for (var i2 = 0;i2 < nested.length; ++i2)
            object.add(nested[i2]);
          this.remove(prev);
          if (!this.nested)
            this.nested = {};
          object.setOptions(prev.options, true);
        } else
          throw Error("duplicate name '" + object.name + "' in " + this);
      }
    }
    this.nested[object.name] = object;
    if (!(this instanceof Type || this instanceof Service || this instanceof Enum || this instanceof Field)) {
      if (!object._edition) {
        object._edition = object._defaultEdition;
      }
    }
    this._needsRecursiveFeatureResolution = true;
    this._needsRecursiveResolve = true;
    var parent = this;
    while (parent = parent.parent) {
      parent._needsRecursiveFeatureResolution = true;
      parent._needsRecursiveResolve = true;
    }
    object.onAdd(this);
    return clearCache(this);
  };
  Namespace.prototype.remove = function remove(object) {
    if (!(object instanceof ReflectionObject))
      throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
      throw Error(object + " is not a member of " + this);
    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
      this.nested = undefined;
    object.onRemove(this);
    return clearCache(this);
  };
  Namespace.prototype.define = function define(path8, json) {
    if (util.isString(path8))
      path8 = path8.split(".");
    else if (!Array.isArray(path8))
      throw TypeError("illegal path");
    if (path8 && path8.length && path8[0] === "")
      throw Error("path must be relative");
    var ptr = this;
    while (path8.length > 0) {
      var part = path8.shift();
      if (ptr.nested && ptr.nested[part]) {
        ptr = ptr.nested[part];
        if (!(ptr instanceof Namespace))
          throw Error("path conflicts with non-namespace objects");
      } else
        ptr.add(ptr = new Namespace(part));
    }
    if (json)
      ptr.addJSON(json);
    return ptr;
  };
  Namespace.prototype.resolveAll = function resolveAll() {
    if (!this._needsRecursiveResolve)
      return this;
    this._resolveFeaturesRecursive(this._edition);
    var nested = this.nestedArray, i2 = 0;
    this.resolve();
    while (i2 < nested.length)
      if (nested[i2] instanceof Namespace)
        nested[i2++].resolveAll();
      else
        nested[i2++].resolve();
    this._needsRecursiveResolve = false;
    return this;
  };
  Namespace.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
    if (!this._needsRecursiveFeatureResolution)
      return this;
    this._needsRecursiveFeatureResolution = false;
    edition = this._edition || edition;
    ReflectionObject.prototype._resolveFeaturesRecursive.call(this, edition);
    this.nestedArray.forEach((nested) => {
      nested._resolveFeaturesRecursive(edition);
    });
    return this;
  };
  Namespace.prototype.lookup = function lookup(path8, filterTypes, parentAlreadyChecked) {
    if (typeof filterTypes === "boolean") {
      parentAlreadyChecked = filterTypes;
      filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
      filterTypes = [filterTypes];
    if (util.isString(path8) && path8.length) {
      if (path8 === ".")
        return this.root;
      path8 = path8.split(".");
    } else if (!path8.length)
      return this;
    var flatPath = path8.join(".");
    if (path8[0] === "")
      return this.root.lookup(path8.slice(1), filterTypes);
    var found = this.root._fullyQualifiedObjects && this.root._fullyQualifiedObjects["." + flatPath];
    if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {
      return found;
    }
    found = this._lookupImpl(path8, flatPath);
    if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {
      return found;
    }
    if (parentAlreadyChecked)
      return null;
    var current = this;
    while (current.parent) {
      found = current.parent._lookupImpl(path8, flatPath);
      if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {
        return found;
      }
      current = current.parent;
    }
    return null;
  };
  Namespace.prototype._lookupImpl = function lookup(path8, flatPath) {
    if (Object.prototype.hasOwnProperty.call(this._lookupCache, flatPath)) {
      return this._lookupCache[flatPath];
    }
    var found = this.get(path8[0]);
    var exact = null;
    if (found) {
      if (path8.length === 1) {
        exact = found;
      } else if (found instanceof Namespace) {
        path8 = path8.slice(1);
        exact = found._lookupImpl(path8, path8.join("."));
      }
    } else {
      for (var i2 = 0;i2 < this.nestedArray.length; ++i2)
        if (this._nestedArray[i2] instanceof Namespace && (found = this._nestedArray[i2]._lookupImpl(path8, flatPath)))
          exact = found;
    }
    this._lookupCache[flatPath] = exact;
    return exact;
  };
  Namespace.prototype.lookupType = function lookupType(path8) {
    var found = this.lookup(path8, [Type]);
    if (!found)
      throw Error("no such type: " + path8);
    return found;
  };
  Namespace.prototype.lookupEnum = function lookupEnum(path8) {
    var found = this.lookup(path8, [Enum]);
    if (!found)
      throw Error("no such Enum '" + path8 + "' in " + this);
    return found;
  };
  Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path8) {
    var found = this.lookup(path8, [Type, Enum]);
    if (!found)
      throw Error("no such Type or Enum '" + path8 + "' in " + this);
    return found;
  };
  Namespace.prototype.lookupService = function lookupService(path8) {
    var found = this.lookup(path8, [Service]);
    if (!found)
      throw Error("no such Service '" + path8 + "' in " + this);
    return found;
  };
  Namespace._configure = function(Type_, Service_, Enum_) {
    Type = Type_;
    Service = Service_;
    Enum = Enum_;
  };
});

// node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS((exports, module) => {
  module.exports = MapField;
  var Field = require_field();
  ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
  var types = require_types();
  var util = require_util();
  function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);
    if (!util.isString(keyType))
      throw TypeError("keyType must be a string");
    this.keyType = keyType;
    this.resolvedKeyType = null;
    this.map = true;
  }
  MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
  };
  MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "keyType",
      this.keyType,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : undefined
    ]);
  };
  MapField.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if (types.mapKey[this.keyType] === undefined)
      throw Error("invalid key type: " + this.keyType);
    return Field.prototype.resolve.call(this);
  };
  MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
    if (typeof fieldValueType === "function")
      fieldValueType = util.decorateType(fieldValueType).name;
    else if (fieldValueType && typeof fieldValueType === "object")
      fieldValueType = util.decorateEnum(fieldValueType).name;
    return function mapFieldDecorator(prototype, fieldName) {
      util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
  };
});

// node_modules/protobufjs/src/method.js
var require_method = __commonJS((exports, module) => {
  module.exports = Method;
  var ReflectionObject = require_object();
  ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
  var util = require_util();
  function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
    if (util.isObject(requestStream)) {
      options = requestStream;
      requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
      options = responseStream;
      responseStream = undefined;
    }
    if (!(type === undefined || util.isString(type)))
      throw TypeError("type must be a string");
    if (!util.isString(requestType))
      throw TypeError("requestType must be a string");
    if (!util.isString(responseType))
      throw TypeError("responseType must be a string");
    ReflectionObject.call(this, name, options);
    this.type = type || "rpc";
    this.requestType = requestType;
    this.requestStream = requestStream ? true : undefined;
    this.responseType = responseType;
    this.responseStream = responseStream ? true : undefined;
    this.resolvedRequestType = null;
    this.resolvedResponseType = null;
    this.comment = comment;
    this.parsedOptions = parsedOptions;
  }
  Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
  };
  Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "type",
      this.type !== "rpc" && this.type || undefined,
      "requestType",
      this.requestType,
      "requestStream",
      this.requestStream,
      "responseType",
      this.responseType,
      "responseStream",
      this.responseStream,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : undefined,
      "parsedOptions",
      this.parsedOptions
    ]);
  };
  Method.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);
    return ReflectionObject.prototype.resolve.call(this);
  };
});

// node_modules/protobufjs/src/service.js
var require_service2 = __commonJS((exports, module) => {
  module.exports = Service;
  var Namespace = require_namespace();
  ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
  var Method = require_method();
  var util = require_util();
  var rpc = require_rpc();
  function Service(name, options) {
    Namespace.call(this, name, options);
    this.methods = {};
    this._methodsArray = null;
  }
  Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    if (json.methods)
      for (var names = Object.keys(json.methods), i2 = 0;i2 < names.length; ++i2)
        service.add(Method.fromJSON(names[i2], json.methods[names[i2]]));
    if (json.nested)
      service.addJSON(json.nested);
    if (json.edition)
      service._edition = json.edition;
    service.comment = json.comment;
    service._defaultEdition = "proto3";
    return service;
  };
  Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "edition",
      this._editionToJSON(),
      "options",
      inherited && inherited.options || undefined,
      "methods",
      Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || {},
      "nested",
      inherited && inherited.nested || undefined,
      "comment",
      keepComments ? this.comment : undefined
    ]);
  };
  Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
      return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
  });
  function clearCache(service) {
    service._methodsArray = null;
    return service;
  }
  Service.prototype.get = function get(name) {
    return this.methods[name] || Namespace.prototype.get.call(this, name);
  };
  Service.prototype.resolveAll = function resolveAll() {
    if (!this._needsRecursiveResolve)
      return this;
    Namespace.prototype.resolve.call(this);
    var methods = this.methodsArray;
    for (var i2 = 0;i2 < methods.length; ++i2)
      methods[i2].resolve();
    return this;
  };
  Service.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
    if (!this._needsRecursiveFeatureResolution)
      return this;
    edition = this._edition || edition;
    Namespace.prototype._resolveFeaturesRecursive.call(this, edition);
    this.methodsArray.forEach((method) => {
      method._resolveFeaturesRecursive(edition);
    });
    return this;
  };
  Service.prototype.add = function add(object) {
    if (this.get(object.name))
      throw Error("duplicate name '" + object.name + "' in " + this);
    if (object instanceof Method) {
      this.methods[object.name] = object;
      object.parent = this;
      return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
  };
  Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {
      if (this.methods[object.name] !== object)
        throw Error(object + " is not a member of " + this);
      delete this.methods[object.name];
      object.parent = null;
      return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
  };
  Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i2 = 0, method;i2 < this.methodsArray.length; ++i2) {
      var methodName = util.lcFirst((method = this._methodsArray[i2]).resolve().name).replace(/[^$\w_]/g, "");
      rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
        m: method,
        q: method.resolvedRequestType.ctor,
        s: method.resolvedResponseType.ctor
      });
    }
    return rpcService;
  };
});

// node_modules/protobufjs/src/message.js
var require_message = __commonJS((exports, module) => {
  module.exports = Message;
  var util = require_minimal();
  function Message(properties) {
    if (properties)
      for (var keys = Object.keys(properties), i2 = 0;i2 < keys.length; ++i2)
        this[keys[i2]] = properties[keys[i2]];
  }
  Message.create = function create(properties) {
    return this.$type.create(properties);
  };
  Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
  };
  Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
  };
  Message.decode = function decode(reader) {
    return this.$type.decode(reader);
  };
  Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
  };
  Message.verify = function verify(message) {
    return this.$type.verify(message);
  };
  Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
  };
  Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
  };
  Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
  };
});

// node_modules/protobufjs/src/decoder.js
var require_decoder = __commonJS((exports, module) => {
  module.exports = decoder;
  var Enum = require_enum();
  var types = require_types();
  var util = require_util();
  function missing(field) {
    return "missing required '" + field.name + "'";
  }
  function decoder(mtype) {
    var gen = util.codegen(["r", "l", "e"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
      return field2.map;
    }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()")("if(t===e)")("break")("switch(t>>>3){");
    var i2 = 0;
    for (;i2 < mtype.fieldsArray.length; ++i2) {
      var field = mtype._fieldsArray[i2].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util.safeProp(field.name);
      gen("case %i: {", field.id);
      if (field.map) {
        gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
        if (types.defaults[field.keyType] !== undefined)
          gen("k=%j", types.defaults[field.keyType]);
        else
          gen("k=null");
        if (types.defaults[type] !== undefined)
          gen("value=%j", types.defaults[type]);
        else
          gen("value=null");
        gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
        if (types.basic[type] === undefined)
          gen("value=types[%i].decode(r,r.uint32())", i2);
        else
          gen("value=r.%s()", type);
        gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
        if (types.long[field.keyType] !== undefined)
          gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
        else
          gen("%s[k]=value", ref);
      } else if (field.repeated) {
        gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
        if (types.packed[type] !== undefined)
          gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
        if (types.basic[type] === undefined)
          gen(field.delimited ? "%s.push(types[%i].decode(r,undefined,((t&~7)|4)))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i2);
        else
          gen("%s.push(r.%s())", ref, type);
      } else if (types.basic[type] === undefined)
        gen(field.delimited ? "%s=types[%i].decode(r,undefined,((t&~7)|4))" : "%s=types[%i].decode(r,r.uint32())", ref, i2);
      else
        gen("%s=r.%s()", ref, type);
      gen("break")("}");
    }
    gen("default:")("r.skipType(t&7)")("break")("}")("}");
    for (i2 = 0;i2 < mtype._fieldsArray.length; ++i2) {
      var rfield = mtype._fieldsArray[i2];
      if (rfield.required)
        gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }
    return gen("return m");
  }
});

// node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS((exports, module) => {
  module.exports = verifier;
  var Enum = require_enum();
  var util = require_util();
  function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
  }
  function genVerifyValue(gen, field, fieldIndex, ref) {
    if (field.resolvedType) {
      if (field.resolvedType instanceof Enum) {
        gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
        for (var keys = Object.keys(field.resolvedType.values), j = 0;j < keys.length; ++j)
          gen("case %i:", field.resolvedType.values[keys[j]]);
        gen("break")("}");
      } else {
        gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
      }
    } else {
      switch (field.type) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
          break;
        case "float":
        case "double":
          gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
          break;
        case "bool":
          gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
          break;
        case "string":
          gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
          break;
        case "bytes":
          gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
          break;
      }
    }
    return gen;
  }
  function genVerifyKey(gen, field, ref) {
    switch (field.keyType) {
      case "int32":
      case "uint32":
      case "sint32":
      case "fixed32":
      case "sfixed32":
        gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
        break;
      case "int64":
      case "uint64":
      case "sint64":
      case "fixed64":
      case "sfixed64":
        gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
        break;
      case "bool":
        gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
        break;
    }
    return gen;
  }
  function verifier(mtype) {
    var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
    var oneofs = mtype.oneofsArray, seenFirstField = {};
    if (oneofs.length)
      gen("var p={}");
    for (var i2 = 0;i2 < mtype.fieldsArray.length; ++i2) {
      var field = mtype._fieldsArray[i2].resolve(), ref = "m" + util.safeProp(field.name);
      if (field.optional)
        gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
      if (field.map) {
        gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
        genVerifyKey(gen, field, "k[i]");
        genVerifyValue(gen, field, i2, ref + "[k[i]]")("}");
      } else if (field.repeated) {
        gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
        genVerifyValue(gen, field, i2, ref + "[i]")("}");
      } else {
        if (field.partOf) {
          var oneofProp = util.safeProp(field.partOf.name);
          if (seenFirstField[field.partOf.name] === 1)
            gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
          seenFirstField[field.partOf.name] = 1;
          gen("p%s=1", oneofProp);
        }
        genVerifyValue(gen, field, i2, ref);
      }
      if (field.optional)
        gen("}");
    }
    return gen("return null");
  }
});

// node_modules/protobufjs/src/converter.js
var require_converter = __commonJS((exports) => {
  var converter = exports;
  var Enum = require_enum();
  var util = require_util();
  function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    var defaultAlreadyEmitted = false;
    if (field.resolvedType) {
      if (field.resolvedType instanceof Enum) {
        gen("switch(d%s){", prop);
        for (var values = field.resolvedType.values, keys = Object.keys(values), i2 = 0;i2 < keys.length; ++i2) {
          if (values[keys[i2]] === field.typeDefault && !defaultAlreadyEmitted) {
            gen("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', prop, prop, prop);
            if (!field.repeated)
              gen("break");
            defaultAlreadyEmitted = true;
          }
          gen("case%j:", keys[i2])("case %i:", values[keys[i2]])("m%s=%j", prop, values[keys[i2]])("break");
        }
        gen("}");
      } else
        gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
      var isUnsigned = false;
      switch (field.type) {
        case "double":
        case "float":
          gen("m%s=Number(d%s)", prop, prop);
          break;
        case "uint32":
        case "fixed32":
          gen("m%s=d%s>>>0", prop, prop);
          break;
        case "int32":
        case "sint32":
        case "sfixed32":
          gen("m%s=d%s|0", prop, prop);
          break;
        case "uint64":
          isUnsigned = true;
        case "int64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
          break;
        case "bytes":
          gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length >= 0)", prop)("m%s=d%s", prop, prop);
          break;
        case "string":
          gen("m%s=String(d%s)", prop, prop);
          break;
        case "bool":
          gen("m%s=Boolean(d%s)", prop, prop);
          break;
      }
    }
    return gen;
  }
  converter.fromObject = function fromObject(mtype) {
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
    if (!fields.length)
      return gen("return new this.ctor");
    gen("var m=new this.ctor");
    for (var i2 = 0;i2 < fields.length; ++i2) {
      var field = fields[i2].resolve(), prop = util.safeProp(field.name);
      if (field.map) {
        gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
        genValuePartial_fromObject(gen, field, i2, prop + "[ks[i]]")("}")("}");
      } else if (field.repeated) {
        gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
        genValuePartial_fromObject(gen, field, i2, prop + "[i]")("}")("}");
      } else {
        if (!(field.resolvedType instanceof Enum))
          gen("if(d%s!=null){", prop);
        genValuePartial_fromObject(gen, field, i2, prop);
        if (!(field.resolvedType instanceof Enum))
          gen("}");
      }
    }
    return gen("return m");
  };
  function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    if (field.resolvedType) {
      if (field.resolvedType instanceof Enum)
        gen("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
      else
        gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
      var isUnsigned = false;
      switch (field.type) {
        case "double":
        case "float":
          gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
          break;
        case "uint64":
          isUnsigned = true;
        case "int64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
          break;
        case "bytes":
          gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
          break;
        default:
          gen("d%s=m%s", prop, prop);
          break;
      }
    }
    return gen;
  }
  converter.toObject = function toObject(mtype) {
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
      return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
    var repeatedFields = [], mapFields = [], normalFields = [], i2 = 0;
    for (;i2 < fields.length; ++i2)
      if (!fields[i2].partOf)
        (fields[i2].resolve().repeated ? repeatedFields : fields[i2].map ? mapFields : normalFields).push(fields[i2]);
    if (repeatedFields.length) {
      gen("if(o.arrays||o.defaults){");
      for (i2 = 0;i2 < repeatedFields.length; ++i2)
        gen("d%s=[]", util.safeProp(repeatedFields[i2].name));
      gen("}");
    }
    if (mapFields.length) {
      gen("if(o.objects||o.defaults){");
      for (i2 = 0;i2 < mapFields.length; ++i2)
        gen("d%s={}", util.safeProp(mapFields[i2].name));
      gen("}");
    }
    if (normalFields.length) {
      gen("if(o.defaults){");
      for (i2 = 0;i2 < normalFields.length; ++i2) {
        var field = normalFields[i2], prop = util.safeProp(field.name);
        if (field.resolvedType instanceof Enum)
          gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
        else if (field.long)
          gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
        else if (field.bytes) {
          var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
          gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
        } else
          gen("d%s=%j", prop, field.typeDefault);
      }
      gen("}");
    }
    var hasKs2 = false;
    for (i2 = 0;i2 < fields.length; ++i2) {
      var field = fields[i2], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);
      if (field.map) {
        if (!hasKs2) {
          hasKs2 = true;
          gen("var ks2");
        }
        gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
        genValuePartial_toObject(gen, field, index, prop + "[ks2[j]]")("}");
      } else if (field.repeated) {
        gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
        genValuePartial_toObject(gen, field, index, prop + "[j]")("}");
      } else {
        gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
        genValuePartial_toObject(gen, field, index, prop);
        if (field.partOf)
          gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
      }
      gen("}");
    }
    return gen("return d");
  };
});

// node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS((exports) => {
  var wrappers = exports;
  var Message = require_message();
  wrappers[".google.protobuf.Any"] = {
    fromObject: function(object) {
      if (object && object["@type"]) {
        var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
        var type = this.lookup(name);
        if (type) {
          var type_url = object["@type"].charAt(0) === "." ? object["@type"].slice(1) : object["@type"];
          if (type_url.indexOf("/") === -1) {
            type_url = "/" + type_url;
          }
          return this.create({
            type_url,
            value: type.encode(type.fromObject(object)).finish()
          });
        }
      }
      return this.fromObject(object);
    },
    toObject: function(message, options) {
      var googleApi = "type.googleapis.com/";
      var prefix = "";
      var name = "";
      if (options && options.json && message.type_url && message.value) {
        name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
        prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
        var type = this.lookup(name);
        if (type)
          message = type.decode(message.value);
      }
      if (!(message instanceof this.ctor) && message instanceof Message) {
        var object = message.$type.toObject(message, options);
        var messageName = message.$type.fullName[0] === "." ? message.$type.fullName.slice(1) : message.$type.fullName;
        if (prefix === "") {
          prefix = googleApi;
        }
        name = prefix + messageName;
        object["@type"] = name;
        return object;
      }
      return this.toObject(message, options);
    }
  };
});

// node_modules/protobufjs/src/type.js
var require_type = __commonJS((exports, module) => {
  module.exports = Type;
  var Namespace = require_namespace();
  ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
  var Enum = require_enum();
  var OneOf = require_oneof();
  var Field = require_field();
  var MapField = require_mapfield();
  var Service = require_service2();
  var Message = require_message();
  var Reader = require_reader();
  var Writer = require_writer();
  var util = require_util();
  var encoder = require_encoder();
  var decoder = require_decoder();
  var verifier = require_verifier();
  var converter = require_converter();
  var wrappers = require_wrappers();
  function Type(name, options) {
    Namespace.call(this, name, options);
    this.fields = {};
    this.oneofs = undefined;
    this.extensions = undefined;
    this.reserved = undefined;
    this.group = undefined;
    this._fieldsById = null;
    this._fieldsArray = null;
    this._oneofsArray = null;
    this._ctor = null;
  }
  Object.defineProperties(Type.prototype, {
    fieldsById: {
      get: function() {
        if (this._fieldsById)
          return this._fieldsById;
        this._fieldsById = {};
        for (var names = Object.keys(this.fields), i2 = 0;i2 < names.length; ++i2) {
          var field = this.fields[names[i2]], id = field.id;
          if (this._fieldsById[id])
            throw Error("duplicate id " + id + " in " + this);
          this._fieldsById[id] = field;
        }
        return this._fieldsById;
      }
    },
    fieldsArray: {
      get: function() {
        return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
      }
    },
    oneofsArray: {
      get: function() {
        return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
      }
    },
    ctor: {
      get: function() {
        return this._ctor || (this.ctor = Type.generateConstructor(this)());
      },
      set: function(ctor) {
        var prototype = ctor.prototype;
        if (!(prototype instanceof Message)) {
          (ctor.prototype = new Message).constructor = ctor;
          util.merge(ctor.prototype, prototype);
        }
        ctor.$type = ctor.prototype.$type = this;
        util.merge(ctor, Message, true);
        this._ctor = ctor;
        var i2 = 0;
        for (;i2 < this.fieldsArray.length; ++i2)
          this._fieldsArray[i2].resolve();
        var ctorProperties = {};
        for (i2 = 0;i2 < this.oneofsArray.length; ++i2)
          ctorProperties[this._oneofsArray[i2].resolve().name] = {
            get: util.oneOfGetter(this._oneofsArray[i2].oneof),
            set: util.oneOfSetter(this._oneofsArray[i2].oneof)
          };
        if (i2)
          Object.defineProperties(ctor.prototype, ctorProperties);
      }
    }
  });
  Type.generateConstructor = function generateConstructor(mtype) {
    var gen = util.codegen(["p"], mtype.name);
    for (var i2 = 0, field;i2 < mtype.fieldsArray.length; ++i2)
      if ((field = mtype._fieldsArray[i2]).map)
        gen("this%s={}", util.safeProp(field.name));
      else if (field.repeated)
        gen("this%s=[]", util.safeProp(field.name));
    return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
  };
  function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
  }
  Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields), i2 = 0;
    for (;i2 < names.length; ++i2)
      type.add((typeof json.fields[names[i2]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i2], json.fields[names[i2]]));
    if (json.oneofs)
      for (names = Object.keys(json.oneofs), i2 = 0;i2 < names.length; ++i2)
        type.add(OneOf.fromJSON(names[i2], json.oneofs[names[i2]]));
    if (json.nested)
      for (names = Object.keys(json.nested), i2 = 0;i2 < names.length; ++i2) {
        var nested = json.nested[names[i2]];
        type.add((nested.id !== undefined ? Field.fromJSON : nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : Namespace.fromJSON)(names[i2], nested));
      }
    if (json.extensions && json.extensions.length)
      type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
      type.reserved = json.reserved;
    if (json.group)
      type.group = true;
    if (json.comment)
      type.comment = json.comment;
    if (json.edition)
      type._edition = json.edition;
    type._defaultEdition = "proto3";
    return type;
  };
  Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "edition",
      this._editionToJSON(),
      "options",
      inherited && inherited.options || undefined,
      "oneofs",
      Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
      "fields",
      Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
        return !obj.declaringField;
      }), toJSONOptions) || {},
      "extensions",
      this.extensions && this.extensions.length ? this.extensions : undefined,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : undefined,
      "group",
      this.group || undefined,
      "nested",
      inherited && inherited.nested || undefined,
      "comment",
      keepComments ? this.comment : undefined
    ]);
  };
  Type.prototype.resolveAll = function resolveAll() {
    if (!this._needsRecursiveResolve)
      return this;
    Namespace.prototype.resolveAll.call(this);
    var oneofs = this.oneofsArray;
    i2 = 0;
    while (i2 < oneofs.length)
      oneofs[i2++].resolve();
    var fields = this.fieldsArray, i2 = 0;
    while (i2 < fields.length)
      fields[i2++].resolve();
    return this;
  };
  Type.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
    if (!this._needsRecursiveFeatureResolution)
      return this;
    edition = this._edition || edition;
    Namespace.prototype._resolveFeaturesRecursive.call(this, edition);
    this.oneofsArray.forEach((oneof) => {
      oneof._resolveFeatures(edition);
    });
    this.fieldsArray.forEach((field) => {
      field._resolveFeatures(edition);
    });
    return this;
  };
  Type.prototype.get = function get(name) {
    return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
  };
  Type.prototype.add = function add(object) {
    if (this.get(object.name))
      throw Error("duplicate name '" + object.name + "' in " + this);
    if (object instanceof Field && object.extend === undefined) {
      if (this._fieldsById ? this._fieldsById[object.id] : this.fieldsById[object.id])
        throw Error("duplicate id " + object.id + " in " + this);
      if (this.isReservedId(object.id))
        throw Error("id " + object.id + " is reserved in " + this);
      if (this.isReservedName(object.name))
        throw Error("name '" + object.name + "' is reserved in " + this);
      if (object.parent)
        object.parent.remove(object);
      this.fields[object.name] = object;
      object.message = this;
      object.onAdd(this);
      return clearCache(this);
    }
    if (object instanceof OneOf) {
      if (!this.oneofs)
        this.oneofs = {};
      this.oneofs[object.name] = object;
      object.onAdd(this);
      return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
  };
  Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
      if (!this.fields || this.fields[object.name] !== object)
        throw Error(object + " is not a member of " + this);
      delete this.fields[object.name];
      object.parent = null;
      object.onRemove(this);
      return clearCache(this);
    }
    if (object instanceof OneOf) {
      if (!this.oneofs || this.oneofs[object.name] !== object)
        throw Error(object + " is not a member of " + this);
      delete this.oneofs[object.name];
      object.parent = null;
      object.onRemove(this);
      return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
  };
  Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
  };
  Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
  };
  Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
  };
  Type.prototype.setup = function setup() {
    var fullName = this.fullName, types = [];
    for (var i2 = 0;i2 < this.fieldsArray.length; ++i2)
      types.push(this._fieldsArray[i2].resolve().resolvedType);
    this.encode = encoder(this)({
      Writer,
      types,
      util
    });
    this.decode = decoder(this)({
      Reader,
      types,
      util
    });
    this.verify = verifier(this)({
      types,
      util
    });
    this.fromObject = converter.fromObject(this)({
      types,
      util
    });
    this.toObject = converter.toObject(this)({
      types,
      util
    });
    var wrapper = wrappers[fullName];
    if (wrapper) {
      var originalThis = Object.create(this);
      originalThis.fromObject = this.fromObject;
      this.fromObject = wrapper.fromObject.bind(originalThis);
      originalThis.toObject = this.toObject;
      this.toObject = wrapper.toObject.bind(originalThis);
    }
    return this;
  };
  Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer);
  };
  Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
  };
  Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length);
  };
  Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
      reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
  };
  Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message);
  };
  Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
  };
  Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
  };
  Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
      util.decorateType(target, typeName);
    };
  };
});

// node_modules/protobufjs/src/root.js
var require_root = __commonJS((exports, module) => {
  module.exports = Root;
  var Namespace = require_namespace();
  ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";
  var Field = require_field();
  var Enum = require_enum();
  var OneOf = require_oneof();
  var util = require_util();
  var Type;
  var parse;
  var common2;
  function Root(options) {
    Namespace.call(this, "", options);
    this.deferred = [];
    this.files = [];
    this._edition = "proto2";
    this._fullyQualifiedObjects = {};
  }
  Root.fromJSON = function fromJSON(json, root) {
    if (!root)
      root = new Root;
    if (json.options)
      root.setOptions(json.options);
    return root.addJSON(json.nested).resolveAll();
  };
  Root.prototype.resolvePath = util.path.resolve;
  Root.prototype.fetch = util.fetch;
  function SYNC() {}
  Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = undefined;
    }
    var self2 = this;
    if (!callback) {
      return util.asPromise(load, self2, filename, options);
    }
    var sync = callback === SYNC;
    function finish(err, root) {
      if (!callback) {
        return;
      }
      if (sync) {
        throw err;
      }
      if (root) {
        root.resolveAll();
      }
      var cb = callback;
      callback = null;
      cb(err, root);
    }
    function getBundledFileName(filename2) {
      var idx = filename2.lastIndexOf("google/protobuf/");
      if (idx > -1) {
        var altname = filename2.substring(idx);
        if (altname in common2)
          return altname;
      }
      return null;
    }
    function process25(filename2, source) {
      try {
        if (util.isString(source) && source.charAt(0) === "{")
          source = JSON.parse(source);
        if (!util.isString(source))
          self2.setOptions(source.options).addJSON(source.nested);
        else {
          parse.filename = filename2;
          var parsed = parse(source, self2, options), resolved2, i3 = 0;
          if (parsed.imports) {
            for (;i3 < parsed.imports.length; ++i3)
              if (resolved2 = getBundledFileName(parsed.imports[i3]) || self2.resolvePath(filename2, parsed.imports[i3]))
                fetch2(resolved2);
          }
          if (parsed.weakImports) {
            for (i3 = 0;i3 < parsed.weakImports.length; ++i3)
              if (resolved2 = getBundledFileName(parsed.weakImports[i3]) || self2.resolvePath(filename2, parsed.weakImports[i3]))
                fetch2(resolved2, true);
          }
        }
      } catch (err) {
        finish(err);
      }
      if (!sync && !queued) {
        finish(null, self2);
      }
    }
    function fetch2(filename2, weak) {
      filename2 = getBundledFileName(filename2) || filename2;
      if (self2.files.indexOf(filename2) > -1) {
        return;
      }
      self2.files.push(filename2);
      if (filename2 in common2) {
        if (sync) {
          process25(filename2, common2[filename2]);
        } else {
          ++queued;
          setTimeout(function() {
            --queued;
            process25(filename2, common2[filename2]);
          });
        }
        return;
      }
      if (sync) {
        var source;
        try {
          source = util.fs.readFileSync(filename2).toString("utf8");
        } catch (err) {
          if (!weak)
            finish(err);
          return;
        }
        process25(filename2, source);
      } else {
        ++queued;
        self2.fetch(filename2, function(err, source2) {
          --queued;
          if (!callback) {
            return;
          }
          if (err) {
            if (!weak)
              finish(err);
            else if (!queued)
              finish(null, self2);
            return;
          }
          process25(filename2, source2);
        });
      }
    }
    var queued = 0;
    if (util.isString(filename)) {
      filename = [filename];
    }
    for (var i2 = 0, resolved;i2 < filename.length; ++i2)
      if (resolved = self2.resolvePath("", filename[i2]))
        fetch2(resolved);
    if (sync) {
      self2.resolveAll();
      return self2;
    }
    if (!queued) {
      finish(null, self2);
    }
    return self2;
  };
  Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
      throw Error("not supported");
    return this.load(filename, options, SYNC);
  };
  Root.prototype.resolveAll = function resolveAll() {
    if (!this._needsRecursiveResolve)
      return this;
    if (this.deferred.length)
      throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
        return "'extend " + field.extend + "' in " + field.parent.fullName;
      }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
  };
  var exposeRe = /^[A-Z]/;
  function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
      var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
      if (extendedType.get(sisterField.name)) {
        return true;
      }
      sisterField.declaringField = field;
      field.extensionField = sisterField;
      extendedType.add(sisterField);
      return true;
    }
    return false;
  }
  Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {
      if (object.extend !== undefined && !object.extensionField) {
        if (!tryHandleExtension(this, object))
          this.deferred.push(object);
      }
    } else if (object instanceof Enum) {
      if (exposeRe.test(object.name))
        object.parent[object.name] = object.values;
    } else if (!(object instanceof OneOf)) {
      if (object instanceof Type)
        for (var i2 = 0;i2 < this.deferred.length; )
          if (tryHandleExtension(this, this.deferred[i2]))
            this.deferred.splice(i2, 1);
          else
            ++i2;
      for (var j = 0;j < object.nestedArray.length; ++j)
        this._handleAdd(object._nestedArray[j]);
      if (exposeRe.test(object.name))
        object.parent[object.name] = object;
    }
    if (object instanceof Type || object instanceof Enum || object instanceof Field) {
      this._fullyQualifiedObjects[object.fullName] = object;
    }
  };
  Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {
      if (object.extend !== undefined) {
        if (object.extensionField) {
          object.extensionField.parent.remove(object.extensionField);
          object.extensionField = null;
        } else {
          var index = this.deferred.indexOf(object);
          if (index > -1)
            this.deferred.splice(index, 1);
        }
      }
    } else if (object instanceof Enum) {
      if (exposeRe.test(object.name))
        delete object.parent[object.name];
    } else if (object instanceof Namespace) {
      for (var i2 = 0;i2 < object.nestedArray.length; ++i2)
        this._handleRemove(object._nestedArray[i2]);
      if (exposeRe.test(object.name))
        delete object.parent[object.name];
    }
    delete this._fullyQualifiedObjects[object.fullName];
  };
  Root._configure = function(Type_, parse_, common_) {
    Type = Type_;
    parse = parse_;
    common2 = common_;
  };
});

// node_modules/protobufjs/src/util.js
var require_util = __commonJS((exports, module) => {
  var util = module.exports = require_minimal();
  var roots = require_roots();
  var Type;
  var Enum;
  util.codegen = require_codegen();
  util.fetch = require_fetch();
  util.path = require_path();
  util.fs = util.inquire("fs");
  util.toArray = function toArray(object) {
    if (object) {
      var keys = Object.keys(object), array = new Array(keys.length), index = 0;
      while (index < keys.length)
        array[index] = object[keys[index++]];
      return array;
    }
    return [];
  };
  util.toObject = function toObject(array) {
    var object = {}, index = 0;
    while (index < array.length) {
      var key = array[index++], val = array[index++];
      if (val !== undefined)
        object[key] = val;
    }
    return object;
  };
  var safePropBackslashRe = /\\/g;
  var safePropQuoteRe = /"/g;
  util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
  };
  util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
      return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + '"]';
    return "." + prop;
  };
  util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
  };
  var camelCaseRe = /_([a-z])/g;
  util.camelCase = function camelCase(str) {
    return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
      return $1.toUpperCase();
    });
  };
  util.compareFieldsById = function compareFieldsById(a2, b) {
    return a2.id - b.id;
  };
  util.decorateType = function decorateType(ctor, typeName) {
    if (ctor.$type) {
      if (typeName && ctor.$type.name !== typeName) {
        util.decorateRoot.remove(ctor.$type);
        ctor.$type.name = typeName;
        util.decorateRoot.add(ctor.$type);
      }
      return ctor.$type;
    }
    if (!Type)
      Type = require_type();
    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor;
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
  };
  var decorateEnumIndex = 0;
  util.decorateEnum = function decorateEnum(object) {
    if (object.$type)
      return object.$type;
    if (!Enum)
      Enum = require_enum();
    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
  };
  util.setProperty = function setProperty(dst, path8, value, ifNotSet) {
    function setProp(dst2, path9, value2) {
      var part = path9.shift();
      if (part === "__proto__" || part === "prototype") {
        return dst2;
      }
      if (path9.length > 0) {
        dst2[part] = setProp(dst2[part] || {}, path9, value2);
      } else {
        var prevValue = dst2[part];
        if (prevValue && ifNotSet)
          return dst2;
        if (prevValue)
          value2 = [].concat(prevValue).concat(value2);
        dst2[part] = value2;
      }
      return dst2;
    }
    if (typeof dst !== "object")
      throw TypeError("dst must be an object");
    if (!path8)
      throw TypeError("path must be specified");
    path8 = path8.split(".");
    return setProp(dst, path8, value);
  };
  Object.defineProperty(util, "decorateRoot", {
    get: function() {
      return roots["decorated"] || (roots["decorated"] = new (require_root()));
    }
  });
});

// node_modules/protobufjs/src/types.js
var require_types = __commonJS((exports) => {
  var types = exports;
  var util = require_util();
  var s = [
    "double",
    "float",
    "int32",
    "uint32",
    "sint32",
    "fixed32",
    "sfixed32",
    "int64",
    "uint64",
    "sint64",
    "fixed64",
    "sfixed64",
    "bool",
    "string",
    "bytes"
  ];
  function bake(values, offset) {
    var i2 = 0, o2 = {};
    offset |= 0;
    while (i2 < values.length)
      o2[s[i2 + offset]] = values[i2++];
    return o2;
  }
  types.basic = bake([
    1,
    5,
    0,
    0,
    0,
    5,
    5,
    0,
    0,
    0,
    1,
    1,
    0,
    2,
    2
  ]);
  types.defaults = bake([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    false,
    "",
    util.emptyArray,
    null
  ]);
  types.long = bake([
    0,
    0,
    0,
    1,
    1
  ], 7);
  types.mapKey = bake([
    0,
    0,
    0,
    5,
    5,
    0,
    0,
    0,
    1,
    1,
    0,
    2
  ], 2);
  types.packed = bake([
    1,
    5,
    0,
    0,
    0,
    5,
    5,
    0,
    0,
    0,
    1,
    1,
    0
  ]);
});

// node_modules/protobufjs/src/field.js
var require_field = __commonJS((exports, module) => {
  module.exports = Field;
  var ReflectionObject = require_object();
  ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
  var Enum = require_enum();
  var types = require_types();
  var util = require_util();
  var Type;
  var ruleRe = /^required|optional|repeated$/;
  Field.fromJSON = function fromJSON(name, json) {
    var field = new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
    if (json.edition)
      field._edition = json.edition;
    field._defaultEdition = "proto3";
    return field;
  };
  function Field(name, id, type, rule, extend, options, comment) {
    if (util.isObject(rule)) {
      comment = extend;
      options = rule;
      rule = extend = undefined;
    } else if (util.isObject(extend)) {
      comment = options;
      options = extend;
      extend = undefined;
    }
    ReflectionObject.call(this, name, options);
    if (!util.isInteger(id) || id < 0)
      throw TypeError("id must be a non-negative integer");
    if (!util.isString(type))
      throw TypeError("type must be a string");
    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
      throw TypeError("rule must be a string rule");
    if (extend !== undefined && !util.isString(extend))
      throw TypeError("extend must be a string");
    if (rule === "proto3_optional") {
      rule = "optional";
    }
    this.rule = rule && rule !== "optional" ? rule : undefined;
    this.type = type;
    this.id = id;
    this.extend = extend || undefined;
    this.repeated = rule === "repeated";
    this.map = false;
    this.message = null;
    this.partOf = null;
    this.typeDefault = null;
    this.defaultValue = null;
    this.long = util.Long ? types.long[type] !== undefined : false;
    this.bytes = type === "bytes";
    this.resolvedType = null;
    this.extensionField = null;
    this.declaringField = null;
    this.comment = comment;
  }
  Object.defineProperty(Field.prototype, "required", {
    get: function() {
      return this._features.field_presence === "LEGACY_REQUIRED";
    }
  });
  Object.defineProperty(Field.prototype, "optional", {
    get: function() {
      return !this.required;
    }
  });
  Object.defineProperty(Field.prototype, "delimited", {
    get: function() {
      return this.resolvedType instanceof Type && this._features.message_encoding === "DELIMITED";
    }
  });
  Object.defineProperty(Field.prototype, "packed", {
    get: function() {
      return this._features.repeated_field_encoding === "PACKED";
    }
  });
  Object.defineProperty(Field.prototype, "hasPresence", {
    get: function() {
      if (this.repeated || this.map) {
        return false;
      }
      return this.partOf || this.declaringField || this.extensionField || this._features.field_presence !== "IMPLICIT";
    }
  });
  Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
  };
  Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "edition",
      this._editionToJSON(),
      "rule",
      this.rule !== "optional" && this.rule || undefined,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : undefined
    ]);
  };
  Field.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if ((this.typeDefault = types.defaults[this.type]) === undefined) {
      this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
      if (this.resolvedType instanceof Type)
        this.typeDefault = null;
      else
        this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
    } else if (this.options && this.options.proto3_optional) {
      this.typeDefault = null;
    }
    if (this.options && this.options["default"] != null) {
      this.typeDefault = this.options["default"];
      if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
        this.typeDefault = this.resolvedType.values[this.typeDefault];
    }
    if (this.options) {
      if (this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
        delete this.options.packed;
      if (!Object.keys(this.options).length)
        this.options = undefined;
    }
    if (this.long) {
      this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
      if (Object.freeze)
        Object.freeze(this.typeDefault);
    } else if (this.bytes && typeof this.typeDefault === "string") {
      var buf;
      if (util.base64.test(this.typeDefault))
        util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
      else
        util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
      this.typeDefault = buf;
    }
    if (this.map)
      this.defaultValue = util.emptyObject;
    else if (this.repeated)
      this.defaultValue = util.emptyArray;
    else
      this.defaultValue = this.typeDefault;
    if (this.parent instanceof Type)
      this.parent.ctor.prototype[this.name] = this.defaultValue;
    return ReflectionObject.prototype.resolve.call(this);
  };
  Field.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures(edition) {
    if (edition !== "proto2" && edition !== "proto3") {
      return {};
    }
    var features = {};
    if (this.rule === "required") {
      features.field_presence = "LEGACY_REQUIRED";
    }
    if (this.parent && types.defaults[this.type] === undefined) {
      var type = this.parent.get(this.type.split(".").pop());
      if (type && type instanceof Type && type.group) {
        features.message_encoding = "DELIMITED";
      }
    }
    if (this.getOption("packed") === true) {
      features.repeated_field_encoding = "PACKED";
    } else if (this.getOption("packed") === false) {
      features.repeated_field_encoding = "EXPANDED";
    }
    return features;
  };
  Field.prototype._resolveFeatures = function _resolveFeatures(edition) {
    return ReflectionObject.prototype._resolveFeatures.call(this, this._edition || edition);
  };
  Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
    if (typeof fieldType === "function")
      fieldType = util.decorateType(fieldType).name;
    else if (fieldType && typeof fieldType === "object")
      fieldType = util.decorateEnum(fieldType).name;
    return function fieldDecorator(prototype, fieldName) {
      util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { default: defaultValue }));
    };
  };
  Field._configure = function configure(Type_) {
    Type = Type_;
  };
});

// node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS((exports, module) => {
  module.exports = OneOf;
  var ReflectionObject = require_object();
  ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
  var Field = require_field();
  var util = require_util();
  function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
      options = fieldNames;
      fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
      throw TypeError("fieldNames must be an Array");
    this.oneof = fieldNames || [];
    this.fieldsArray = [];
    this.comment = comment;
  }
  OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
  };
  OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "options",
      this.options,
      "oneof",
      this.oneof,
      "comment",
      keepComments ? this.comment : undefined
    ]);
  };
  function addFieldsToParent(oneof) {
    if (oneof.parent) {
      for (var i2 = 0;i2 < oneof.fieldsArray.length; ++i2)
        if (!oneof.fieldsArray[i2].parent)
          oneof.parent.add(oneof.fieldsArray[i2]);
    }
  }
  OneOf.prototype.add = function add(field) {
    if (!(field instanceof Field))
      throw TypeError("field must be a Field");
    if (field.parent && field.parent !== this.parent)
      field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this;
    addFieldsToParent(this);
    return this;
  };
  OneOf.prototype.remove = function remove(field) {
    if (!(field instanceof Field))
      throw TypeError("field must be a Field");
    var index = this.fieldsArray.indexOf(field);
    if (index < 0)
      throw Error(field + " is not a member of " + this);
    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);
    if (index > -1)
      this.oneof.splice(index, 1);
    field.partOf = null;
    return this;
  };
  OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self2 = this;
    for (var i2 = 0;i2 < this.oneof.length; ++i2) {
      var field = parent.get(this.oneof[i2]);
      if (field && !field.partOf) {
        field.partOf = self2;
        self2.fieldsArray.push(field);
      }
    }
    addFieldsToParent(this);
  };
  OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i2 = 0, field;i2 < this.fieldsArray.length; ++i2)
      if ((field = this.fieldsArray[i2]).parent)
        field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
  };
  Object.defineProperty(OneOf.prototype, "isProto3Optional", {
    get: function() {
      if (this.fieldsArray == null || this.fieldsArray.length !== 1) {
        return false;
      }
      var field = this.fieldsArray[0];
      return field.options != null && field.options["proto3_optional"] === true;
    }
  });
  OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length), index = 0;
    while (index < arguments.length)
      fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
      util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
      Object.defineProperty(prototype, oneofName, {
        get: util.oneOfGetter(fieldNames),
        set: util.oneOfSetter(fieldNames)
      });
    };
  };
});

// node_modules/protobufjs/src/object.js
var require_object = __commonJS((exports, module) => {
  module.exports = ReflectionObject;
  ReflectionObject.className = "ReflectionObject";
  var OneOf = require_oneof();
  var util = require_util();
  var Root;
  var editions2023Defaults = { enum_type: "OPEN", field_presence: "EXPLICIT", json_format: "ALLOW", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "PACKED", utf8_validation: "VERIFY" };
  var proto2Defaults = { enum_type: "CLOSED", field_presence: "EXPLICIT", json_format: "LEGACY_BEST_EFFORT", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "EXPANDED", utf8_validation: "NONE" };
  var proto3Defaults = { enum_type: "OPEN", field_presence: "IMPLICIT", json_format: "ALLOW", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "PACKED", utf8_validation: "VERIFY" };
  function ReflectionObject(name, options) {
    if (!util.isString(name))
      throw TypeError("name must be a string");
    if (options && !util.isObject(options))
      throw TypeError("options must be an object");
    this.options = options;
    this.parsedOptions = null;
    this.name = name;
    this._edition = null;
    this._defaultEdition = "proto2";
    this._features = {};
    this._featuresResolved = false;
    this.parent = null;
    this.resolved = false;
    this.comment = null;
    this.filename = null;
  }
  Object.defineProperties(ReflectionObject.prototype, {
    root: {
      get: function() {
        var ptr = this;
        while (ptr.parent !== null)
          ptr = ptr.parent;
        return ptr;
      }
    },
    fullName: {
      get: function() {
        var path8 = [this.name], ptr = this.parent;
        while (ptr) {
          path8.unshift(ptr.name);
          ptr = ptr.parent;
        }
        return path8.join(".");
      }
    }
  });
  ReflectionObject.prototype.toJSON = function toJSON() {
    throw Error();
  };
  ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
      this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
      root._handleAdd(this);
  };
  ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
      root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
  };
  ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if (this.root instanceof Root)
      this.resolved = true;
    return this;
  };
  ReflectionObject.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
    return this._resolveFeatures(this._edition || edition);
  };
  ReflectionObject.prototype._resolveFeatures = function _resolveFeatures(edition) {
    if (this._featuresResolved) {
      return;
    }
    var defaults = {};
    if (!edition) {
      throw new Error("Unknown edition for " + this.fullName);
    }
    var protoFeatures = Object.assign(this.options ? Object.assign({}, this.options.features) : {}, this._inferLegacyProtoFeatures(edition));
    if (this._edition) {
      if (edition === "proto2") {
        defaults = Object.assign({}, proto2Defaults);
      } else if (edition === "proto3") {
        defaults = Object.assign({}, proto3Defaults);
      } else if (edition === "2023") {
        defaults = Object.assign({}, editions2023Defaults);
      } else {
        throw new Error("Unknown edition: " + edition);
      }
      this._features = Object.assign(defaults, protoFeatures || {});
      this._featuresResolved = true;
      return;
    }
    if (this.partOf instanceof OneOf) {
      var lexicalParentFeaturesCopy = Object.assign({}, this.partOf._features);
      this._features = Object.assign(lexicalParentFeaturesCopy, protoFeatures || {});
    } else if (this.declaringField) {} else if (this.parent) {
      var parentFeaturesCopy = Object.assign({}, this.parent._features);
      this._features = Object.assign(parentFeaturesCopy, protoFeatures || {});
    } else {
      throw new Error("Unable to find a parent for " + this.fullName);
    }
    if (this.extensionField) {
      this.extensionField._features = this._features;
    }
    this._featuresResolved = true;
  };
  ReflectionObject.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures() {
    return {};
  };
  ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
      return this.options[name];
    return;
  };
  ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!this.options)
      this.options = {};
    if (/^features\./.test(name)) {
      util.setProperty(this.options, name, value, ifNotSet);
    } else if (!ifNotSet || this.options[name] === undefined) {
      if (this.getOption(name) !== value)
        this.resolved = false;
      this.options[name] = value;
    }
    return this;
  };
  ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
    if (!this.parsedOptions) {
      this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
      var opt = parsedOptions.find(function(opt2) {
        return Object.prototype.hasOwnProperty.call(opt2, name);
      });
      if (opt) {
        var newValue = opt[name];
        util.setProperty(newValue, propName, value);
      } else {
        opt = {};
        opt[name] = util.setProperty({}, propName, value);
        parsedOptions.push(opt);
      }
    } else {
      var newOpt = {};
      newOpt[name] = value;
      parsedOptions.push(newOpt);
    }
    return this;
  };
  ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
      for (var keys = Object.keys(options), i2 = 0;i2 < keys.length; ++i2)
        this.setOption(keys[i2], options[keys[i2]], ifNotSet);
    return this;
  };
  ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className, fullName = this.fullName;
    if (fullName.length)
      return className + " " + fullName;
    return className;
  };
  ReflectionObject.prototype._editionToJSON = function _editionToJSON() {
    if (!this._edition || this._edition === "proto3") {
      return;
    }
    return this._edition;
  };
  ReflectionObject._configure = function(Root_) {
    Root = Root_;
  };
});

// node_modules/protobufjs/src/enum.js
var require_enum = __commonJS((exports, module) => {
  module.exports = Enum;
  var ReflectionObject = require_object();
  ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
  var Namespace = require_namespace();
  var util = require_util();
  function Enum(name, values, options, comment, comments, valuesOptions) {
    ReflectionObject.call(this, name, options);
    if (values && typeof values !== "object")
      throw TypeError("values must be an object");
    this.valuesById = {};
    this.values = Object.create(this.valuesById);
    this.comment = comment;
    this.comments = comments || {};
    this.valuesOptions = valuesOptions;
    this._valuesFeatures = {};
    this.reserved = undefined;
    if (values) {
      for (var keys = Object.keys(values), i2 = 0;i2 < keys.length; ++i2)
        if (typeof values[keys[i2]] === "number")
          this.valuesById[this.values[keys[i2]] = values[keys[i2]]] = keys[i2];
    }
  }
  Enum.prototype._resolveFeatures = function _resolveFeatures(edition) {
    edition = this._edition || edition;
    ReflectionObject.prototype._resolveFeatures.call(this, edition);
    Object.keys(this.values).forEach((key) => {
      var parentFeaturesCopy = Object.assign({}, this._features);
      this._valuesFeatures[key] = Object.assign(parentFeaturesCopy, this.valuesOptions && this.valuesOptions[key] && this.valuesOptions[key].features);
    });
    return this;
  };
  Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    if (json.edition)
      enm._edition = json.edition;
    enm._defaultEdition = "proto3";
    return enm;
  };
  Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "edition",
      this._editionToJSON(),
      "options",
      this.options,
      "valuesOptions",
      this.valuesOptions,
      "values",
      this.values,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : undefined,
      "comment",
      keepComments ? this.comment : undefined,
      "comments",
      keepComments ? this.comments : undefined
    ]);
  };
  Enum.prototype.add = function add(name, id, comment, options) {
    if (!util.isString(name))
      throw TypeError("name must be a string");
    if (!util.isInteger(id))
      throw TypeError("id must be an integer");
    if (this.values[name] !== undefined)
      throw Error("duplicate name '" + name + "' in " + this);
    if (this.isReservedId(id))
      throw Error("id " + id + " is reserved in " + this);
    if (this.isReservedName(name))
      throw Error("name '" + name + "' is reserved in " + this);
    if (this.valuesById[id] !== undefined) {
      if (!(this.options && this.options.allow_alias))
        throw Error("duplicate id " + id + " in " + this);
      this.values[name] = id;
    } else
      this.valuesById[this.values[name] = id] = name;
    if (options) {
      if (this.valuesOptions === undefined)
        this.valuesOptions = {};
      this.valuesOptions[name] = options || null;
    }
    this.comments[name] = comment || null;
    return this;
  };
  Enum.prototype.remove = function remove(name) {
    if (!util.isString(name))
      throw TypeError("name must be a string");
    var val = this.values[name];
    if (val == null)
      throw Error("name '" + name + "' does not exist in " + this);
    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];
    if (this.valuesOptions)
      delete this.valuesOptions[name];
    return this;
  };
  Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
  };
  Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
  };
});

// node_modules/protobufjs/src/encoder.js
var require_encoder = __commonJS((exports, module) => {
  module.exports = encoder;
  var Enum = require_enum();
  var types = require_types();
  var util = require_util();
  function genTypePartial(gen, field, fieldIndex, ref) {
    return field.delimited ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
  }
  function encoder(mtype) {
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
    var i2, ref;
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    for (var i2 = 0;i2 < fields.length; ++i2) {
      var field = fields[i2].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types.basic[type];
      ref = "m" + util.safeProp(field.name);
      if (field.map) {
        gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
        if (wireType === undefined)
          gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
        else
          gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
        gen("}")("}");
      } else if (field.repeated) {
        gen("if(%s!=null&&%s.length){", ref, ref);
        if (field.packed && types.packed[type] !== undefined) {
          gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
        } else {
          gen("for(var i=0;i<%s.length;++i)", ref);
          if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
          else
            gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
        }
        gen("}");
      } else {
        if (field.optional)
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
        if (wireType === undefined)
          genTypePartial(gen, field, index, ref);
        else
          gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
      }
    }
    return gen("return w");
  }
});

// node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS((exports, module) => {
  var protobuf = module.exports = require_index_minimal();
  protobuf.build = "light";
  function load2(filename, root, callback) {
    if (typeof root === "function") {
      callback = root;
      root = new protobuf.Root;
    } else if (!root)
      root = new protobuf.Root;
    return root.load(filename, callback);
  }
  protobuf.load = load2;
  function loadSync(filename, root) {
    if (!root)
      root = new protobuf.Root;
    return root.loadSync(filename);
  }
  protobuf.loadSync = loadSync;
  protobuf.encoder = require_encoder();
  protobuf.decoder = require_decoder();
  protobuf.verifier = require_verifier();
  protobuf.converter = require_converter();
  protobuf.ReflectionObject = require_object();
  protobuf.Namespace = require_namespace();
  protobuf.Root = require_root();
  protobuf.Enum = require_enum();
  protobuf.Type = require_type();
  protobuf.Field = require_field();
  protobuf.OneOf = require_oneof();
  protobuf.MapField = require_mapfield();
  protobuf.Service = require_service2();
  protobuf.Method = require_method();
  protobuf.Message = require_message();
  protobuf.wrappers = require_wrappers();
  protobuf.types = require_types();
  protobuf.util = require_util();
  protobuf.ReflectionObject._configure(protobuf.Root);
  protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
  protobuf.Root._configure(protobuf.Type);
  protobuf.Field._configure(protobuf.Type);
});

// node_modules/protobufjs/src/tokenize.js
var require_tokenize = __commonJS((exports, module) => {
  module.exports = tokenize4;
  var delimRe = /[\s{}=;:[\],'"()<>]/g;
  var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
  var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
  var setCommentRe = /^ *[*/]+ */;
  var setCommentAltRe = /^\s*\*?\/*/;
  var setCommentSplitRe = /\n/g;
  var whitespaceRe = /\s/;
  var unescapeRe = /\\(.?)/g;
  var unescapeMap = {
    "0": "\x00",
    r: "\r",
    n: `
`,
    t: "\t"
  };
  function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
      switch ($1) {
        case "\\":
        case "":
          return $1;
        default:
          return unescapeMap[$1] || "";
      }
    });
  }
  tokenize4.unescape = unescape;
  function tokenize4(source, alternateCommentMode) {
    source = source.toString();
    var offset = 0, length = source.length, line = 1, lastCommentLine = 0, comments = {};
    var stack = [];
    var stringDelim = null;
    function illegal(subject) {
      return Error("illegal " + subject + " (line " + line + ")");
    }
    function readString() {
      var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
      re.lastIndex = offset - 1;
      var match = re.exec(source);
      if (!match)
        throw illegal("string");
      offset = re.lastIndex;
      push(stringDelim);
      stringDelim = null;
      return unescape(match[1]);
    }
    function charAt(pos) {
      return source.charAt(pos);
    }
    function setComment(start, end, isLeading) {
      var comment = {
        type: source.charAt(start++),
        lineEmpty: false,
        leading: isLeading
      };
      var lookback;
      if (alternateCommentMode) {
        lookback = 2;
      } else {
        lookback = 3;
      }
      var commentOffset = start - lookback, c3;
      do {
        if (--commentOffset < 0 || (c3 = source.charAt(commentOffset)) === `
`) {
          comment.lineEmpty = true;
          break;
        }
      } while (c3 === " " || c3 === "\t");
      var lines = source.substring(start, end).split(setCommentSplitRe);
      for (var i2 = 0;i2 < lines.length; ++i2)
        lines[i2] = lines[i2].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
      comment.text = lines.join(`
`).trim();
      comments[line] = comment;
      lastCommentLine = line;
    }
    function isDoubleSlashCommentLine(startOffset) {
      var endOffset = findEndOfLine(startOffset);
      var lineText = source.substring(startOffset, endOffset);
      var isComment = /^\s*\/\//.test(lineText);
      return isComment;
    }
    function findEndOfLine(cursor) {
      var endOffset = cursor;
      while (endOffset < length && charAt(endOffset) !== `
`) {
        endOffset++;
      }
      return endOffset;
    }
    function next() {
      if (stack.length > 0)
        return stack.shift();
      if (stringDelim)
        return readString();
      var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;
      do {
        if (offset === length)
          return null;
        repeat = false;
        while (whitespaceRe.test(curr = charAt(offset))) {
          if (curr === `
`) {
            isLeadingComment = true;
            ++line;
          }
          if (++offset === length)
            return null;
        }
        if (charAt(offset) === "/") {
          if (++offset === length) {
            throw illegal("comment");
          }
          if (charAt(offset) === "/") {
            if (!alternateCommentMode) {
              isDoc = charAt(start = offset + 1) === "/";
              while (charAt(++offset) !== `
`) {
                if (offset === length) {
                  return null;
                }
              }
              ++offset;
              if (isDoc) {
                setComment(start, offset - 1, isLeadingComment);
                isLeadingComment = true;
              }
              ++line;
              repeat = true;
            } else {
              start = offset;
              isDoc = false;
              if (isDoubleSlashCommentLine(offset - 1)) {
                isDoc = true;
                do {
                  offset = findEndOfLine(offset);
                  if (offset === length) {
                    break;
                  }
                  offset++;
                  if (!isLeadingComment) {
                    break;
                  }
                } while (isDoubleSlashCommentLine(offset));
              } else {
                offset = Math.min(length, findEndOfLine(offset) + 1);
              }
              if (isDoc) {
                setComment(start, offset, isLeadingComment);
                isLeadingComment = true;
              }
              line++;
              repeat = true;
            }
          } else if ((curr = charAt(offset)) === "*") {
            start = offset + 1;
            isDoc = alternateCommentMode || charAt(start) === "*";
            do {
              if (curr === `
`) {
                ++line;
              }
              if (++offset === length) {
                throw illegal("comment");
              }
              prev = curr;
              curr = charAt(offset);
            } while (prev !== "*" || curr !== "/");
            ++offset;
            if (isDoc) {
              setComment(start, offset - 2, isLeadingComment);
              isLeadingComment = true;
            }
            repeat = true;
          } else {
            return "/";
          }
        }
      } while (repeat);
      var end = offset;
      delimRe.lastIndex = 0;
      var delim = delimRe.test(charAt(end++));
      if (!delim)
        while (end < length && !delimRe.test(charAt(end)))
          ++end;
      var token = source.substring(offset, offset = end);
      if (token === '"' || token === "'")
        stringDelim = token;
      return token;
    }
    function push(token) {
      stack.push(token);
    }
    function peek() {
      if (!stack.length) {
        var token = next();
        if (token === null)
          return null;
        push(token);
      }
      return stack[0];
    }
    function skip(expected, optional) {
      var actual = peek(), equals = actual === expected;
      if (equals) {
        next();
        return true;
      }
      if (!optional)
        throw illegal("token '" + actual + "', '" + expected + "' expected");
      return false;
    }
    function cmnt(trailingLine) {
      var ret = null;
      var comment;
      if (trailingLine === undefined) {
        comment = comments[line - 1];
        delete comments[line - 1];
        if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
          ret = comment.leading ? comment.text : null;
        }
      } else {
        if (lastCommentLine < trailingLine) {
          peek();
        }
        comment = comments[trailingLine];
        delete comments[trailingLine];
        if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
          ret = comment.leading ? null : comment.text;
        }
      }
      return ret;
    }
    return Object.defineProperty({
      next,
      peek,
      push,
      skip,
      cmnt
    }, "line", {
      get: function() {
        return line;
      }
    });
  }
});

// node_modules/protobufjs/src/parse.js
var require_parse2 = __commonJS((exports, module) => {
  module.exports = parse;
  parse.filename = null;
  parse.defaults = { keepCase: false };
  var tokenize4 = require_tokenize();
  var Root = require_root();
  var Type = require_type();
  var Field = require_field();
  var MapField = require_mapfield();
  var OneOf = require_oneof();
  var Enum = require_enum();
  var Service = require_service2();
  var Method = require_method();
  var ReflectionObject = require_object();
  var types = require_types();
  var util = require_util();
  var base10Re = /^[1-9][0-9]*$/;
  var base10NegRe = /^-?[1-9][0-9]*$/;
  var base16Re = /^0[x][0-9a-fA-F]+$/;
  var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
  var base8Re = /^0[0-7]+$/;
  var base8NegRe = /^-?0[0-7]+$/;
  var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
  var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
  var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
  function parse(source, root, options) {
    if (!(root instanceof Root)) {
      options = root;
      root = new Root;
    }
    if (!options)
      options = parse.defaults;
    var preferTrailingComment = options.preferTrailingComment || false;
    var tn = tokenize4(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;
    var head = true, pkg, imports, weakImports, edition = "proto2";
    var ptr = root;
    var topLevelObjects = [];
    var topLevelOptions = {};
    var applyCase = options.keepCase ? function(name) {
      return name;
    } : util.camelCase;
    function resolveFileFeatures() {
      topLevelObjects.forEach((obj) => {
        obj._edition = edition;
        Object.keys(topLevelOptions).forEach((opt) => {
          if (obj.getOption(opt) !== undefined)
            return;
          obj.setOption(opt, topLevelOptions[opt], true);
        });
      });
    }
    function illegal(token2, name, insideTryCatch) {
      var filename = parse.filename;
      if (!insideTryCatch)
        parse.filename = null;
      return Error("illegal " + (name || "token") + " '" + token2 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }
    function readString() {
      var values = [], token2;
      do {
        if ((token2 = next()) !== '"' && token2 !== "'")
          throw illegal(token2);
        values.push(next());
        skip(token2);
        token2 = peek();
      } while (token2 === '"' || token2 === "'");
      return values.join("");
    }
    function readValue(acceptTypeRef) {
      var token2 = next();
      switch (token2) {
        case "'":
        case '"':
          push(token2);
          return readString();
        case "true":
        case "TRUE":
          return true;
        case "false":
        case "FALSE":
          return false;
      }
      try {
        return parseNumber2(token2, true);
      } catch (e) {
        if (acceptTypeRef && typeRefRe.test(token2))
          return token2;
        throw illegal(token2, "value");
      }
    }
    function readRanges(target, acceptStrings) {
      var token2, start;
      do {
        if (acceptStrings && ((token2 = peek()) === '"' || token2 === "'")) {
          var str = readString();
          target.push(str);
          if (edition >= 2023) {
            throw illegal(str, "id");
          }
        } else {
          try {
            target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
          } catch (err) {
            if (acceptStrings && typeRefRe.test(token2) && edition >= 2023) {
              target.push(token2);
            } else {
              throw err;
            }
          }
        }
      } while (skip(",", true));
      var dummy = { options: undefined };
      dummy.setOption = function(name, value) {
        if (this.options === undefined)
          this.options = {};
        this.options[name] = value;
      };
      ifBlock(dummy, function parseRange_block(token3) {
        if (token3 === "option") {
          parseOption(dummy, token3);
          skip(";");
        } else
          throw illegal(token3);
      }, function parseRange_line() {
        parseInlineOptions(dummy);
      });
    }
    function parseNumber2(token2, insideTryCatch) {
      var sign = 1;
      if (token2.charAt(0) === "-") {
        sign = -1;
        token2 = token2.substring(1);
      }
      switch (token2) {
        case "inf":
        case "INF":
        case "Inf":
          return sign * Infinity;
        case "nan":
        case "NAN":
        case "Nan":
        case "NaN":
          return NaN;
        case "0":
          return 0;
      }
      if (base10Re.test(token2))
        return sign * parseInt(token2, 10);
      if (base16Re.test(token2))
        return sign * parseInt(token2, 16);
      if (base8Re.test(token2))
        return sign * parseInt(token2, 8);
      if (numberRe.test(token2))
        return sign * parseFloat(token2);
      throw illegal(token2, "number", insideTryCatch);
    }
    function parseId(token2, acceptNegative) {
      switch (token2) {
        case "max":
        case "MAX":
        case "Max":
          return 536870911;
        case "0":
          return 0;
      }
      if (!acceptNegative && token2.charAt(0) === "-")
        throw illegal(token2, "id");
      if (base10NegRe.test(token2))
        return parseInt(token2, 10);
      if (base16NegRe.test(token2))
        return parseInt(token2, 16);
      if (base8NegRe.test(token2))
        return parseInt(token2, 8);
      throw illegal(token2, "id");
    }
    function parsePackage() {
      if (pkg !== undefined)
        throw illegal("package");
      pkg = next();
      if (!typeRefRe.test(pkg))
        throw illegal(pkg, "name");
      ptr = ptr.define(pkg);
      skip(";");
    }
    function parseImport() {
      var token2 = peek();
      var whichImports;
      switch (token2) {
        case "weak":
          whichImports = weakImports || (weakImports = []);
          next();
          break;
        case "public":
          next();
        default:
          whichImports = imports || (imports = []);
          break;
      }
      token2 = readString();
      skip(";");
      whichImports.push(token2);
    }
    function parseSyntax() {
      skip("=");
      edition = readString();
      if (edition < 2023)
        throw illegal(edition, "syntax");
      skip(";");
    }
    function parseEdition() {
      skip("=");
      edition = readString();
      const supportedEditions = ["2023"];
      if (!supportedEditions.includes(edition))
        throw illegal(edition, "edition");
      skip(";");
    }
    function parseCommon(parent, token2) {
      switch (token2) {
        case "option":
          parseOption(parent, token2);
          skip(";");
          return true;
        case "message":
          parseType(parent, token2);
          return true;
        case "enum":
          parseEnum(parent, token2);
          return true;
        case "service":
          parseService(parent, token2);
          return true;
        case "extend":
          parseExtension(parent, token2);
          return true;
      }
      return false;
    }
    function ifBlock(obj, fnIf, fnElse) {
      var trailingLine = tn.line;
      if (obj) {
        if (typeof obj.comment !== "string") {
          obj.comment = cmnt();
        }
        obj.filename = parse.filename;
      }
      if (skip("{", true)) {
        var token2;
        while ((token2 = next()) !== "}")
          fnIf(token2);
        skip(";", true);
      } else {
        if (fnElse)
          fnElse();
        skip(";");
        if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
          obj.comment = cmnt(trailingLine) || obj.comment;
      }
    }
    function parseType(parent, token2) {
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "type name");
      var type = new Type(token2);
      ifBlock(type, function parseType_block(token3) {
        if (parseCommon(type, token3))
          return;
        switch (token3) {
          case "map":
            parseMapField(type, token3);
            break;
          case "required":
            if (edition !== "proto2")
              throw illegal(token3);
          case "repeated":
            parseField(type, token3);
            break;
          case "optional":
            if (edition === "proto3") {
              parseField(type, "proto3_optional");
            } else if (edition !== "proto2") {
              throw illegal(token3);
            } else {
              parseField(type, "optional");
            }
            break;
          case "oneof":
            parseOneOf(type, token3);
            break;
          case "extensions":
            readRanges(type.extensions || (type.extensions = []));
            break;
          case "reserved":
            readRanges(type.reserved || (type.reserved = []), true);
            break;
          default:
            if (edition === "proto2" || !typeRefRe.test(token3)) {
              throw illegal(token3);
            }
            push(token3);
            parseField(type, "optional");
            break;
        }
      });
      parent.add(type);
      if (parent === ptr) {
        topLevelObjects.push(type);
      }
    }
    function parseField(parent, rule, extend) {
      var type = next();
      if (type === "group") {
        parseGroup(parent, rule);
        return;
      }
      while (type.endsWith(".") || peek().startsWith(".")) {
        type += next();
      }
      if (!typeRefRe.test(type))
        throw illegal(type, "type");
      var name = next();
      if (!nameRe.test(name))
        throw illegal(name, "name");
      name = applyCase(name);
      skip("=");
      var field = new Field(name, parseId(next()), type, rule, extend);
      ifBlock(field, function parseField_block(token2) {
        if (token2 === "option") {
          parseOption(field, token2);
          skip(";");
        } else
          throw illegal(token2);
      }, function parseField_line() {
        parseInlineOptions(field);
      });
      if (rule === "proto3_optional") {
        var oneof = new OneOf("_" + name);
        field.setOption("proto3_optional", true);
        oneof.add(field);
        parent.add(oneof);
      } else {
        parent.add(field);
      }
      if (parent === ptr) {
        topLevelObjects.push(field);
      }
    }
    function parseGroup(parent, rule) {
      if (edition >= 2023) {
        throw illegal("group");
      }
      var name = next();
      if (!nameRe.test(name))
        throw illegal(name, "name");
      var fieldName = util.lcFirst(name);
      if (name === fieldName)
        name = util.ucFirst(name);
      skip("=");
      var id = parseId(next());
      var type = new Type(name);
      type.group = true;
      var field = new Field(fieldName, id, name, rule);
      field.filename = parse.filename;
      ifBlock(type, function parseGroup_block(token2) {
        switch (token2) {
          case "option":
            parseOption(type, token2);
            skip(";");
            break;
          case "required":
          case "repeated":
            parseField(type, token2);
            break;
          case "optional":
            if (edition === "proto3") {
              parseField(type, "proto3_optional");
            } else {
              parseField(type, "optional");
            }
            break;
          case "message":
            parseType(type, token2);
            break;
          case "enum":
            parseEnum(type, token2);
            break;
          case "reserved":
            readRanges(type.reserved || (type.reserved = []), true);
            break;
          default:
            throw illegal(token2);
        }
      });
      parent.add(type).add(field);
    }
    function parseMapField(parent) {
      skip("<");
      var keyType = next();
      if (types.mapKey[keyType] === undefined)
        throw illegal(keyType, "type");
      skip(",");
      var valueType = next();
      if (!typeRefRe.test(valueType))
        throw illegal(valueType, "type");
      skip(">");
      var name = next();
      if (!nameRe.test(name))
        throw illegal(name, "name");
      skip("=");
      var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
      ifBlock(field, function parseMapField_block(token2) {
        if (token2 === "option") {
          parseOption(field, token2);
          skip(";");
        } else
          throw illegal(token2);
      }, function parseMapField_line() {
        parseInlineOptions(field);
      });
      parent.add(field);
    }
    function parseOneOf(parent, token2) {
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "name");
      var oneof = new OneOf(applyCase(token2));
      ifBlock(oneof, function parseOneOf_block(token3) {
        if (token3 === "option") {
          parseOption(oneof, token3);
          skip(";");
        } else {
          push(token3);
          parseField(oneof, "optional");
        }
      });
      parent.add(oneof);
    }
    function parseEnum(parent, token2) {
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "name");
      var enm = new Enum(token2);
      ifBlock(enm, function parseEnum_block(token3) {
        switch (token3) {
          case "option":
            parseOption(enm, token3);
            skip(";");
            break;
          case "reserved":
            readRanges(enm.reserved || (enm.reserved = []), true);
            if (enm.reserved === undefined)
              enm.reserved = [];
            break;
          default:
            parseEnumValue(enm, token3);
        }
      });
      parent.add(enm);
      if (parent === ptr) {
        topLevelObjects.push(enm);
      }
    }
    function parseEnumValue(parent, token2) {
      if (!nameRe.test(token2))
        throw illegal(token2, "name");
      skip("=");
      var value = parseId(next(), true), dummy = {
        options: undefined
      };
      dummy.getOption = function(name) {
        return this.options[name];
      };
      dummy.setOption = function(name, value2) {
        ReflectionObject.prototype.setOption.call(dummy, name, value2);
      };
      dummy.setParsedOption = function() {
        return;
      };
      ifBlock(dummy, function parseEnumValue_block(token3) {
        if (token3 === "option") {
          parseOption(dummy, token3);
          skip(";");
        } else
          throw illegal(token3);
      }, function parseEnumValue_line() {
        parseInlineOptions(dummy);
      });
      parent.add(token2, value, dummy.comment, dummy.parsedOptions || dummy.options);
    }
    function parseOption(parent, token2) {
      var option;
      var propName;
      var isOption = true;
      if (token2 === "option") {
        token2 = next();
      }
      while (token2 !== "=") {
        if (token2 === "(") {
          var parensValue = next();
          skip(")");
          token2 = "(" + parensValue + ")";
        }
        if (isOption) {
          isOption = false;
          if (token2.includes(".") && !token2.includes("(")) {
            var tokens = token2.split(".");
            option = tokens[0] + ".";
            token2 = tokens[1];
            continue;
          }
          option = token2;
        } else {
          propName = propName ? propName += token2 : token2;
        }
        token2 = next();
      }
      var name = propName ? option.concat(propName) : option;
      var optionValue = parseOptionValue(parent, name);
      propName = propName && propName[0] === "." ? propName.slice(1) : propName;
      option = option && option[option.length - 1] === "." ? option.slice(0, -1) : option;
      setParsedOption(parent, option, optionValue, propName);
    }
    function parseOptionValue(parent, name) {
      if (skip("{", true)) {
        var objectResult = {};
        while (!skip("}", true)) {
          if (!nameRe.test(token = next())) {
            throw illegal(token, "name");
          }
          if (token === null) {
            throw illegal(token, "end of input");
          }
          var value;
          var propName = token;
          skip(":", true);
          if (peek() === "{") {
            value = parseOptionValue(parent, name + "." + token);
          } else if (peek() === "[") {
            value = [];
            var lastValue;
            if (skip("[", true)) {
              do {
                lastValue = readValue(true);
                value.push(lastValue);
              } while (skip(",", true));
              skip("]");
              if (typeof lastValue !== "undefined") {
                setOption(parent, name + "." + token, lastValue);
              }
            }
          } else {
            value = readValue(true);
            setOption(parent, name + "." + token, value);
          }
          var prevValue = objectResult[propName];
          if (prevValue)
            value = [].concat(prevValue).concat(value);
          objectResult[propName] = value;
          skip(",", true);
          skip(";", true);
        }
        return objectResult;
      }
      var simpleValue = readValue(true);
      setOption(parent, name, simpleValue);
      return simpleValue;
    }
    function setOption(parent, name, value) {
      if (ptr === parent && /^features\./.test(name)) {
        topLevelOptions[name] = value;
        return;
      }
      if (parent.setOption)
        parent.setOption(name, value);
    }
    function setParsedOption(parent, name, value, propName) {
      if (parent.setParsedOption)
        parent.setParsedOption(name, value, propName);
    }
    function parseInlineOptions(parent) {
      if (skip("[", true)) {
        do {
          parseOption(parent, "option");
        } while (skip(",", true));
        skip("]");
      }
      return parent;
    }
    function parseService(parent, token2) {
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "service name");
      var service = new Service(token2);
      ifBlock(service, function parseService_block(token3) {
        if (parseCommon(service, token3)) {
          return;
        }
        if (token3 === "rpc")
          parseMethod(service, token3);
        else
          throw illegal(token3);
      });
      parent.add(service);
      if (parent === ptr) {
        topLevelObjects.push(service);
      }
    }
    function parseMethod(parent, token2) {
      var commentText = cmnt();
      var type = token2;
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "name");
      var name = token2, requestType, requestStream, responseType, responseStream;
      skip("(");
      if (skip("stream", true))
        requestStream = true;
      if (!typeRefRe.test(token2 = next()))
        throw illegal(token2);
      requestType = token2;
      skip(")");
      skip("returns");
      skip("(");
      if (skip("stream", true))
        responseStream = true;
      if (!typeRefRe.test(token2 = next()))
        throw illegal(token2);
      responseType = token2;
      skip(")");
      var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
      method.comment = commentText;
      ifBlock(method, function parseMethod_block(token3) {
        if (token3 === "option") {
          parseOption(method, token3);
          skip(";");
        } else
          throw illegal(token3);
      });
      parent.add(method);
    }
    function parseExtension(parent, token2) {
      if (!typeRefRe.test(token2 = next()))
        throw illegal(token2, "reference");
      var reference = token2;
      ifBlock(null, function parseExtension_block(token3) {
        switch (token3) {
          case "required":
          case "repeated":
            parseField(parent, token3, reference);
            break;
          case "optional":
            if (edition === "proto3") {
              parseField(parent, "proto3_optional", reference);
            } else {
              parseField(parent, "optional", reference);
            }
            break;
          default:
            if (edition === "proto2" || !typeRefRe.test(token3))
              throw illegal(token3);
            push(token3);
            parseField(parent, "optional", reference);
            break;
        }
      });
    }
    var token;
    while ((token = next()) !== null) {
      switch (token) {
        case "package":
          if (!head)
            throw illegal(token);
          parsePackage();
          break;
        case "import":
          if (!head)
            throw illegal(token);
          parseImport();
          break;
        case "syntax":
          if (!head)
            throw illegal(token);
          parseSyntax();
          break;
        case "edition":
          if (!head)
            throw illegal(token);
          parseEdition();
          break;
        case "option":
          parseOption(ptr, token);
          skip(";", true);
          break;
        default:
          if (parseCommon(ptr, token)) {
            head = false;
            continue;
          }
          throw illegal(token);
      }
    }
    resolveFileFeatures();
    parse.filename = null;
    return {
      package: pkg,
      imports,
      weakImports,
      root
    };
  }
});

// node_modules/protobufjs/src/common.js
var require_common = __commonJS((exports, module) => {
  module.exports = common2;
  var commonRe = /\/|\./;
  function common2(name, json) {
    if (!commonRe.test(name)) {
      name = "google/protobuf/" + name + ".proto";
      json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common2[name] = json;
  }
  common2("any", {
    Any: {
      fields: {
        type_url: {
          type: "string",
          id: 1
        },
        value: {
          type: "bytes",
          id: 2
        }
      }
    }
  });
  var timeType;
  common2("duration", {
    Duration: timeType = {
      fields: {
        seconds: {
          type: "int64",
          id: 1
        },
        nanos: {
          type: "int32",
          id: 2
        }
      }
    }
  });
  common2("timestamp", {
    Timestamp: timeType
  });
  common2("empty", {
    Empty: {
      fields: {}
    }
  });
  common2("struct", {
    Struct: {
      fields: {
        fields: {
          keyType: "string",
          type: "Value",
          id: 1
        }
      }
    },
    Value: {
      oneofs: {
        kind: {
          oneof: [
            "nullValue",
            "numberValue",
            "stringValue",
            "boolValue",
            "structValue",
            "listValue"
          ]
        }
      },
      fields: {
        nullValue: {
          type: "NullValue",
          id: 1
        },
        numberValue: {
          type: "double",
          id: 2
        },
        stringValue: {
          type: "string",
          id: 3
        },
        boolValue: {
          type: "bool",
          id: 4
        },
        structValue: {
          type: "Struct",
          id: 5
        },
        listValue: {
          type: "ListValue",
          id: 6
        }
      }
    },
    NullValue: {
      values: {
        NULL_VALUE: 0
      }
    },
    ListValue: {
      fields: {
        values: {
          rule: "repeated",
          type: "Value",
          id: 1
        }
      }
    }
  });
  common2("wrappers", {
    DoubleValue: {
      fields: {
        value: {
          type: "double",
          id: 1
        }
      }
    },
    FloatValue: {
      fields: {
        value: {
          type: "float",
          id: 1
        }
      }
    },
    Int64Value: {
      fields: {
        value: {
          type: "int64",
          id: 1
        }
      }
    },
    UInt64Value: {
      fields: {
        value: {
          type: "uint64",
          id: 1
        }
      }
    },
    Int32Value: {
      fields: {
        value: {
          type: "int32",
          id: 1
        }
      }
    },
    UInt32Value: {
      fields: {
        value: {
          type: "uint32",
          id: 1
        }
      }
    },
    BoolValue: {
      fields: {
        value: {
          type: "bool",
          id: 1
        }
      }
    },
    StringValue: {
      fields: {
        value: {
          type: "string",
          id: 1
        }
      }
    },
    BytesValue: {
      fields: {
        value: {
          type: "bytes",
          id: 1
        }
      }
    }
  });
  common2("field_mask", {
    FieldMask: {
      fields: {
        paths: {
          rule: "repeated",
          type: "string",
          id: 1
        }
      }
    }
  });
  common2.get = function get(file) {
    return common2[file] || null;
  };
});

// node_modules/protobufjs/src/index.js
var require_src = __commonJS((exports, module) => {
  var protobuf = module.exports = require_index_light();
  protobuf.build = "full";
  protobuf.tokenize = require_tokenize();
  protobuf.parse = require_parse2();
  protobuf.common = require_common();
  protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
});

// node_modules/omggif/omggif.js
var require_omggif = __commonJS((exports) => {
  function GifWriter(buf, width, height, gopts) {
    var p = 0;
    var gopts = gopts === undefined ? {} : gopts;
    var loop_count = gopts.loop === undefined ? null : gopts.loop;
    var global_palette = gopts.palette === undefined ? null : gopts.palette;
    if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
      throw new Error("Width/Height invalid.");
    function check_palette_and_num_colors(palette2) {
      var num_colors = palette2.length;
      if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
        throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
      }
      return num_colors;
    }
    buf[p++] = 71;
    buf[p++] = 73;
    buf[p++] = 70;
    buf[p++] = 56;
    buf[p++] = 57;
    buf[p++] = 97;
    var gp_num_colors_pow2 = 0;
    var background = 0;
    if (global_palette !== null) {
      var gp_num_colors = check_palette_and_num_colors(global_palette);
      while (gp_num_colors >>= 1)
        ++gp_num_colors_pow2;
      gp_num_colors = 1 << gp_num_colors_pow2;
      --gp_num_colors_pow2;
      if (gopts.background !== undefined) {
        background = gopts.background;
        if (background >= gp_num_colors)
          throw new Error("Background index out of range.");
        if (background === 0)
          throw new Error("Background index explicitly passed as 0.");
      }
    }
    buf[p++] = width & 255;
    buf[p++] = width >> 8 & 255;
    buf[p++] = height & 255;
    buf[p++] = height >> 8 & 255;
    buf[p++] = (global_palette !== null ? 128 : 0) | gp_num_colors_pow2;
    buf[p++] = background;
    buf[p++] = 0;
    if (global_palette !== null) {
      for (var i2 = 0, il = global_palette.length;i2 < il; ++i2) {
        var rgb = global_palette[i2];
        buf[p++] = rgb >> 16 & 255;
        buf[p++] = rgb >> 8 & 255;
        buf[p++] = rgb & 255;
      }
    }
    if (loop_count !== null) {
      if (loop_count < 0 || loop_count > 65535)
        throw new Error("Loop count invalid.");
      buf[p++] = 33;
      buf[p++] = 255;
      buf[p++] = 11;
      buf[p++] = 78;
      buf[p++] = 69;
      buf[p++] = 84;
      buf[p++] = 83;
      buf[p++] = 67;
      buf[p++] = 65;
      buf[p++] = 80;
      buf[p++] = 69;
      buf[p++] = 50;
      buf[p++] = 46;
      buf[p++] = 48;
      buf[p++] = 3;
      buf[p++] = 1;
      buf[p++] = loop_count & 255;
      buf[p++] = loop_count >> 8 & 255;
      buf[p++] = 0;
    }
    var ended = false;
    this.addFrame = function(x, y, w, h2, indexed_pixels, opts) {
      if (ended === true) {
        --p;
        ended = false;
      }
      opts = opts === undefined ? {} : opts;
      if (x < 0 || y < 0 || x > 65535 || y > 65535)
        throw new Error("x/y invalid.");
      if (w <= 0 || h2 <= 0 || w > 65535 || h2 > 65535)
        throw new Error("Width/Height invalid.");
      if (indexed_pixels.length < w * h2)
        throw new Error("Not enough pixels for the frame size.");
      var using_local_palette = true;
      var palette2 = opts.palette;
      if (palette2 === undefined || palette2 === null) {
        using_local_palette = false;
        palette2 = global_palette;
      }
      if (palette2 === undefined || palette2 === null)
        throw new Error("Must supply either a local or global palette.");
      var num_colors = check_palette_and_num_colors(palette2);
      var min_code_size = 0;
      while (num_colors >>= 1)
        ++min_code_size;
      num_colors = 1 << min_code_size;
      var delay = opts.delay === undefined ? 0 : opts.delay;
      var disposal = opts.disposal === undefined ? 0 : opts.disposal;
      if (disposal < 0 || disposal > 3)
        throw new Error("Disposal out of range.");
      var use_transparency = false;
      var transparent_index = 0;
      if (opts.transparent !== undefined && opts.transparent !== null) {
        use_transparency = true;
        transparent_index = opts.transparent;
        if (transparent_index < 0 || transparent_index >= num_colors)
          throw new Error("Transparent color index.");
      }
      if (disposal !== 0 || use_transparency || delay !== 0) {
        buf[p++] = 33;
        buf[p++] = 249;
        buf[p++] = 4;
        buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
        buf[p++] = delay & 255;
        buf[p++] = delay >> 8 & 255;
        buf[p++] = transparent_index;
        buf[p++] = 0;
      }
      buf[p++] = 44;
      buf[p++] = x & 255;
      buf[p++] = x >> 8 & 255;
      buf[p++] = y & 255;
      buf[p++] = y >> 8 & 255;
      buf[p++] = w & 255;
      buf[p++] = w >> 8 & 255;
      buf[p++] = h2 & 255;
      buf[p++] = h2 >> 8 & 255;
      buf[p++] = using_local_palette === true ? 128 | min_code_size - 1 : 0;
      if (using_local_palette === true) {
        for (var i3 = 0, il2 = palette2.length;i3 < il2; ++i3) {
          var rgb2 = palette2[i3];
          buf[p++] = rgb2 >> 16 & 255;
          buf[p++] = rgb2 >> 8 & 255;
          buf[p++] = rgb2 & 255;
        }
      }
      p = GifWriterOutputLZWCodeStream(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
      return p;
    };
    this.end = function() {
      if (ended === false) {
        buf[p++] = 59;
        ended = true;
      }
      return p;
    };
    this.getOutputBuffer = function() {
      return buf;
    };
    this.setOutputBuffer = function(v) {
      buf = v;
    };
    this.getOutputBufferPosition = function() {
      return p;
    };
    this.setOutputBufferPosition = function(v) {
      p = v;
    };
  }
  function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
    buf[p++] = min_code_size;
    var cur_subblock = p++;
    var clear_code = 1 << min_code_size;
    var code_mask = clear_code - 1;
    var eoi_code = clear_code + 1;
    var next_code = eoi_code + 1;
    var cur_code_size = min_code_size + 1;
    var cur_shift = 0;
    var cur = 0;
    function emit_bytes_to_buffer(bit_block_size) {
      while (cur_shift >= bit_block_size) {
        buf[p++] = cur & 255;
        cur >>= 8;
        cur_shift -= 8;
        if (p === cur_subblock + 256) {
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }
    }
    function emit_code(c3) {
      cur |= c3 << cur_shift;
      cur_shift += cur_code_size;
      emit_bytes_to_buffer(8);
    }
    var ib_code = index_stream[0] & code_mask;
    var code_table = {};
    emit_code(clear_code);
    for (var i2 = 1, il = index_stream.length;i2 < il; ++i2) {
      var k = index_stream[i2] & code_mask;
      var cur_key = ib_code << 8 | k;
      var cur_code = code_table[cur_key];
      if (cur_code === undefined) {
        cur |= ib_code << cur_shift;
        cur_shift += cur_code_size;
        while (cur_shift >= 8) {
          buf[p++] = cur & 255;
          cur >>= 8;
          cur_shift -= 8;
          if (p === cur_subblock + 256) {
            buf[cur_subblock] = 255;
            cur_subblock = p++;
          }
        }
        if (next_code === 4096) {
          emit_code(clear_code);
          next_code = eoi_code + 1;
          cur_code_size = min_code_size + 1;
          code_table = {};
        } else {
          if (next_code >= 1 << cur_code_size)
            ++cur_code_size;
          code_table[cur_key] = next_code++;
        }
        ib_code = k;
      } else {
        ib_code = cur_code;
      }
    }
    emit_code(ib_code);
    emit_code(eoi_code);
    emit_bytes_to_buffer(1);
    if (cur_subblock + 1 === p) {
      buf[cur_subblock] = 0;
    } else {
      buf[cur_subblock] = p - cur_subblock - 1;
      buf[p++] = 0;
    }
    return p;
  }
  function GifReader(buf) {
    var p = 0;
    if (buf[p++] !== 71 || buf[p++] !== 73 || buf[p++] !== 70 || buf[p++] !== 56 || (buf[p++] + 1 & 253) !== 56 || buf[p++] !== 97) {
      throw new Error("Invalid GIF 87a/89a header.");
    }
    var width = buf[p++] | buf[p++] << 8;
    var height = buf[p++] | buf[p++] << 8;
    var pf0 = buf[p++];
    var global_palette_flag = pf0 >> 7;
    var num_global_colors_pow2 = pf0 & 7;
    var num_global_colors = 1 << num_global_colors_pow2 + 1;
    var background = buf[p++];
    buf[p++];
    var global_palette_offset = null;
    var global_palette_size = null;
    if (global_palette_flag) {
      global_palette_offset = p;
      global_palette_size = num_global_colors;
      p += num_global_colors * 3;
    }
    var no_eof = true;
    var frames = [];
    var delay = 0;
    var transparent_index = null;
    var disposal = 0;
    var loop_count = null;
    this.width = width;
    this.height = height;
    while (no_eof && p < buf.length) {
      switch (buf[p++]) {
        case 33:
          switch (buf[p++]) {
            case 255:
              if (buf[p] !== 11 || buf[p + 1] == 78 && buf[p + 2] == 69 && buf[p + 3] == 84 && buf[p + 4] == 83 && buf[p + 5] == 67 && buf[p + 6] == 65 && buf[p + 7] == 80 && buf[p + 8] == 69 && buf[p + 9] == 50 && buf[p + 10] == 46 && buf[p + 11] == 48 && buf[p + 12] == 3 && buf[p + 13] == 1 && buf[p + 16] == 0) {
                p += 14;
                loop_count = buf[p++] | buf[p++] << 8;
                p++;
              } else {
                p += 12;
                while (true) {
                  var block_size = buf[p++];
                  if (!(block_size >= 0))
                    throw Error("Invalid block size");
                  if (block_size === 0)
                    break;
                  p += block_size;
                }
              }
              break;
            case 249:
              if (buf[p++] !== 4 || buf[p + 4] !== 0)
                throw new Error("Invalid graphics extension block.");
              var pf1 = buf[p++];
              delay = buf[p++] | buf[p++] << 8;
              transparent_index = buf[p++];
              if ((pf1 & 1) === 0)
                transparent_index = null;
              disposal = pf1 >> 2 & 7;
              p++;
              break;
            case 254:
              while (true) {
                var block_size = buf[p++];
                if (!(block_size >= 0))
                  throw Error("Invalid block size");
                if (block_size === 0)
                  break;
                p += block_size;
              }
              break;
            default:
              throw new Error("Unknown graphic control label: 0x" + buf[p - 1].toString(16));
          }
          break;
        case 44:
          var x = buf[p++] | buf[p++] << 8;
          var y = buf[p++] | buf[p++] << 8;
          var w = buf[p++] | buf[p++] << 8;
          var h2 = buf[p++] | buf[p++] << 8;
          var pf2 = buf[p++];
          var local_palette_flag = pf2 >> 7;
          var interlace_flag = pf2 >> 6 & 1;
          var num_local_colors_pow2 = pf2 & 7;
          var num_local_colors = 1 << num_local_colors_pow2 + 1;
          var palette_offset = global_palette_offset;
          var palette_size = global_palette_size;
          var has_local_palette = false;
          if (local_palette_flag) {
            var has_local_palette = true;
            palette_offset = p;
            palette_size = num_local_colors;
            p += num_local_colors * 3;
          }
          var data_offset = p;
          p++;
          while (true) {
            var block_size = buf[p++];
            if (!(block_size >= 0))
              throw Error("Invalid block size");
            if (block_size === 0)
              break;
            p += block_size;
          }
          frames.push({
            x,
            y,
            width: w,
            height: h2,
            has_local_palette,
            palette_offset,
            palette_size,
            data_offset,
            data_length: p - data_offset,
            transparent_index,
            interlaced: !!interlace_flag,
            delay,
            disposal
          });
          break;
        case 59:
          no_eof = false;
          break;
        default:
          throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
          break;
      }
    }
    this.numFrames = function() {
      return frames.length;
    };
    this.loopCount = function() {
      return loop_count;
    };
    this.frameInfo = function(frame_num) {
      if (frame_num < 0 || frame_num >= frames.length)
        throw new Error("Frame index out of range.");
      return frames[frame_num];
    };
    this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
      var frame = this.frameInfo(frame_num);
      var num_pixels = frame.width * frame.height;
      var index_stream = new Uint8Array(num_pixels);
      GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
      var palette_offset2 = frame.palette_offset;
      var trans = frame.transparent_index;
      if (trans === null)
        trans = 256;
      var framewidth = frame.width;
      var framestride = width - framewidth;
      var xleft = framewidth;
      var opbeg = (frame.y * width + frame.x) * 4;
      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
      var op = opbeg;
      var scanstride = framestride * 4;
      if (frame.interlaced === true) {
        scanstride += width * 4 * 7;
      }
      var interlaceskip = 8;
      for (var i2 = 0, il = index_stream.length;i2 < il; ++i2) {
        var index = index_stream[i2];
        if (xleft === 0) {
          op += scanstride;
          xleft = framewidth;
          if (op >= opend) {
            scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
            interlaceskip >>= 1;
          }
        }
        if (index === trans) {
          op += 4;
        } else {
          var r = buf[palette_offset2 + index * 3];
          var g = buf[palette_offset2 + index * 3 + 1];
          var b = buf[palette_offset2 + index * 3 + 2];
          pixels[op++] = b;
          pixels[op++] = g;
          pixels[op++] = r;
          pixels[op++] = 255;
        }
        --xleft;
      }
    };
    this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
      var frame = this.frameInfo(frame_num);
      var num_pixels = frame.width * frame.height;
      var index_stream = new Uint8Array(num_pixels);
      GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
      var palette_offset2 = frame.palette_offset;
      var trans = frame.transparent_index;
      if (trans === null)
        trans = 256;
      var framewidth = frame.width;
      var framestride = width - framewidth;
      var xleft = framewidth;
      var opbeg = (frame.y * width + frame.x) * 4;
      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
      var op = opbeg;
      var scanstride = framestride * 4;
      if (frame.interlaced === true) {
        scanstride += width * 4 * 7;
      }
      var interlaceskip = 8;
      for (var i2 = 0, il = index_stream.length;i2 < il; ++i2) {
        var index = index_stream[i2];
        if (xleft === 0) {
          op += scanstride;
          xleft = framewidth;
          if (op >= opend) {
            scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
            interlaceskip >>= 1;
          }
        }
        if (index === trans) {
          op += 4;
        } else {
          var r = buf[palette_offset2 + index * 3];
          var g = buf[palette_offset2 + index * 3 + 1];
          var b = buf[palette_offset2 + index * 3 + 2];
          pixels[op++] = r;
          pixels[op++] = g;
          pixels[op++] = b;
          pixels[op++] = 255;
        }
        --xleft;
      }
    };
  }
  function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
    var min_code_size = code_stream[p++];
    var clear_code = 1 << min_code_size;
    var eoi_code = clear_code + 1;
    var next_code = eoi_code + 1;
    var cur_code_size = min_code_size + 1;
    var code_mask = (1 << cur_code_size) - 1;
    var cur_shift = 0;
    var cur = 0;
    var op = 0;
    var subblock_size = code_stream[p++];
    var code_table = new Int32Array(4096);
    var prev_code = null;
    while (true) {
      while (cur_shift < 16) {
        if (subblock_size === 0)
          break;
        cur |= code_stream[p++] << cur_shift;
        cur_shift += 8;
        if (subblock_size === 1) {
          subblock_size = code_stream[p++];
        } else {
          --subblock_size;
        }
      }
      if (cur_shift < cur_code_size)
        break;
      var code = cur & code_mask;
      cur >>= cur_code_size;
      cur_shift -= cur_code_size;
      if (code === clear_code) {
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_mask = (1 << cur_code_size) - 1;
        prev_code = null;
        continue;
      } else if (code === eoi_code) {
        break;
      }
      var chase_code = code < next_code ? code : prev_code;
      var chase_length = 0;
      var chase = chase_code;
      while (chase > clear_code) {
        chase = code_table[chase] >> 8;
        ++chase_length;
      }
      var k = chase;
      var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
      if (op_end > output_length) {
        console.log("Warning, gif stream longer than expected.");
        return;
      }
      output[op++] = k;
      op += chase_length;
      var b = op;
      if (chase_code !== code)
        output[op++] = k;
      chase = chase_code;
      while (chase_length--) {
        chase = code_table[chase];
        output[--b] = chase & 255;
        chase >>= 8;
      }
      if (prev_code !== null && next_code < 4096) {
        code_table[next_code++] = prev_code << 8 | k;
        if (next_code >= code_mask + 1 && cur_code_size < 12) {
          ++cur_code_size;
          code_mask = code_mask << 1 | 1;
        }
      }
      prev_code = code;
    }
    if (op !== output_length) {
      console.log("Warning, gif stream shorter than expected.");
    }
    return output;
  }
  try {
    exports.GifWriter = GifWriter;
    exports.GifReader = GifReader;
  } catch (e) {}
});

// node_modules/gifwrap/src/bitmapimage.js
var require_bitmapimage = __commonJS((exports, module) => {
  class BitmapImage {
    constructor(...args) {
      if (args.length === 0) {
        throw new Error("constructor requires parameters");
      }
      const firstArg = args[0];
      if (firstArg !== null && typeof firstArg === "object") {
        if (firstArg instanceof BitmapImage) {
          const sourceBitmap = firstArg.bitmap;
          this.bitmap = {
            width: sourceBitmap.width,
            height: sourceBitmap.height,
            data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)
          };
          sourceBitmap.data.copy(this.bitmap.data);
        } else if (firstArg.width && firstArg.height && firstArg.data) {
          this.bitmap = firstArg;
        } else {
          throw new Error("unrecognized constructor parameters");
        }
      } else if (typeof firstArg === "number" && typeof args[1] === "number") {
        const width = firstArg;
        const height = args[1];
        const thirdArg = args[2];
        this.bitmap = { width, height };
        if (Buffer.isBuffer(thirdArg)) {
          this.bitmap.data = thirdArg;
        } else {
          this.bitmap.data = new Buffer(width * height * 4);
          if (typeof thirdArg === "number") {
            this.fillRGBA(thirdArg);
          }
        }
      } else {
        throw new Error("unrecognized constructor parameters");
      }
    }
    blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {
      if (fromX + fromWidth > this.bitmap.width) {
        throw new Error("copy exceeds width of source bitmap");
      }
      if (toX + fromWidth > toImage.bitmap.width) {
        throw new Error("copy exceeds width of target bitmap");
      }
      if (fromY + fromHeight > this.bitmap.height) {
        throw new Error("copy exceeds height of source bitmap");
      }
      if (toY + fromHeight > toImage.bitmap.height) {
        throw new Erro("copy exceeds height of target bitmap");
      }
      const sourceBuf = this.bitmap.data;
      const targetBuf = toImage.bitmap.data;
      const sourceByteWidth = this.bitmap.width * 4;
      const targetByteWidth = toImage.bitmap.width * 4;
      const copyByteWidth = fromWidth * 4;
      let si = fromY * sourceByteWidth + fromX * 4;
      let ti = toY * targetByteWidth + toX * 4;
      while (--fromHeight >= 0) {
        sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth);
        si += sourceByteWidth;
        ti += targetByteWidth;
      }
      return this;
    }
    fillRGBA(rgba) {
      const buf = this.bitmap.data;
      const bufByteWidth = this.bitmap.height * 4;
      let bi = 0;
      while (bi < bufByteWidth) {
        buf.writeUInt32BE(rgba, bi);
        bi += 4;
      }
      while (bi < buf.length) {
        buf.copy(buf, bi, 0, bufByteWidth);
        bi += bufByteWidth;
      }
      return this;
    }
    getRGBA(x, y) {
      const bi = (y * this.bitmap.width + x) * 4;
      return this.bitmap.data.readUInt32BE(bi);
    }
    getRGBASet() {
      const rgbaSet = new Set;
      const buf = this.bitmap.data;
      for (let bi = 0;bi < buf.length; bi += 4) {
        rgbaSet.add(buf.readUInt32BE(bi, true));
      }
      return rgbaSet;
    }
    greyscale() {
      const buf = this.bitmap.data;
      this.scan(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {
        const grey = Math.round(0.299 * buf[idx] + 0.587 * buf[idx + 1] + 0.114 * buf[idx + 2]);
        buf[idx] = grey;
        buf[idx + 1] = grey;
        buf[idx + 2] = grey;
      });
      return this;
    }
    reframe(xOffset, yOffset, width, height, fillRGBA) {
      const cropX = xOffset < 0 ? 0 : xOffset;
      const cropY = yOffset < 0 ? 0 : yOffset;
      const cropWidth = width + cropX > this.bitmap.width ? this.bitmap.width - cropX : width;
      const cropHeight = height + cropY > this.bitmap.height ? this.bitmap.height - cropY : height;
      const newX = xOffset < 0 ? -xOffset : 0;
      const newY = yOffset < 0 ? -yOffset : 0;
      let image3;
      if (fillRGBA === undefined) {
        if (cropX !== xOffset || cropY != yOffset || cropWidth !== width || cropHeight !== height) {
          throw new GifError(`fillRGBA required for this reframing`);
        }
        image3 = new BitmapImage(width, height);
      } else {
        image3 = new BitmapImage(width, height, fillRGBA);
      }
      this.blit(image3, newX, newY, cropX, cropY, cropWidth, cropHeight);
      this.bitmap = image3.bitmap;
      return this;
    }
    scale(factor) {
      if (factor === 1) {
        return;
      }
      if (!Number.isInteger(factor) || factor < 1) {
        throw new Error("the scale must be an integer >= 1");
      }
      const sourceWidth = this.bitmap.width;
      const sourceHeight = this.bitmap.height;
      const destByteWidth = sourceWidth * factor * 4;
      const sourceBuf = this.bitmap.data;
      const destBuf = new Buffer(sourceHeight * destByteWidth * factor);
      let sourceIndex = 0;
      let priorDestRowIndex;
      let destIndex = 0;
      for (let y = 0;y < sourceHeight; ++y) {
        priorDestRowIndex = destIndex;
        for (let x = 0;x < sourceWidth; ++x) {
          const color = sourceBuf.readUInt32BE(sourceIndex, true);
          for (let cx = 0;cx < factor; ++cx) {
            destBuf.writeUInt32BE(color, destIndex);
            destIndex += 4;
          }
          sourceIndex += 4;
        }
        for (let cy = 1;cy < factor; ++cy) {
          destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex);
          destIndex += destByteWidth;
          priorDestRowIndex += destByteWidth;
        }
      }
      this.bitmap = {
        width: sourceWidth * factor,
        height: sourceHeight * factor,
        data: destBuf
      };
      return this;
    }
    scanAllCoords(scanHandler) {
      const width = this.bitmap.width;
      const bufferLength = this.bitmap.data.length;
      let x = 0;
      let y = 0;
      for (let bi = 0;bi < bufferLength; bi += 4) {
        scanHandler(x, y, bi);
        if (++x === width) {
          x = 0;
          ++y;
        }
      }
    }
    scanAllIndexes(scanHandler) {
      const bufferLength = this.bitmap.data.length;
      for (let bi = 0;bi < bufferLength; bi += 4) {
        scanHandler(bi);
      }
    }
  }
  module.exports = BitmapImage;
});

// node_modules/gifwrap/src/gif.js
var require_gif = __commonJS((exports) => {
  class Gif {
    constructor(buffer, frames, spec) {
      this.width = spec.width;
      this.height = spec.height;
      this.loops = spec.loops;
      this.usesTransparency = spec.usesTransparency;
      this.colorScope = spec.colorScope;
      this.frames = frames;
      this.buffer = buffer;
    }
  }
  Gif.GlobalColorsPreferred = 0;
  Gif.GlobalColorsOnly = 1;
  Gif.LocalColorsOnly = 2;

  class GifError2 extends Error {
    constructor(messageOrError) {
      super(messageOrError);
      if (messageOrError instanceof Error) {
        this.stack = "Gif" + messageOrError.stack;
      }
    }
  }
  exports.Gif = Gif;
  exports.GifError = GifError2;
});

// node_modules/image-q/dist/cjs/image-q.cjs
var require_image_q = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module2, copyDefault, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames2(module2))
        if (!__hasOwnProp2.call(target, key) && (copyDefault || key !== "default"))
          __defProp2(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
    }
    return target;
  };
  var __toCommonJS = /* @__PURE__ */ ((cache3) => {
    return (module2, temp) => {
      return cache3 && cache3.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache3 && cache3.set(module2, temp), temp);
    };
  })(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap : 0);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var src_exports = {};
  __export2(src_exports, {
    applyPalette: () => applyPalette,
    applyPaletteSync: () => applyPaletteSync,
    buildPalette: () => buildPalette,
    buildPaletteSync: () => buildPaletteSync,
    constants: () => constants_exports,
    conversion: () => conversion_exports,
    distance: () => distance_exports,
    image: () => image_exports,
    palette: () => palette_exports,
    quality: () => quality_exports,
    utils: () => utils_exports
  });
  var constants_exports = {};
  __export2(constants_exports, {
    bt709: () => bt709_exports
  });
  var bt709_exports = {};
  __export2(bt709_exports, {
    Y: () => Y,
    x: () => x,
    y: () => y
  });
  var Y = /* @__PURE__ */ ((Y2) => {
    Y2[Y2["RED"] = 0.2126] = "RED";
    Y2[Y2["GREEN"] = 0.7152] = "GREEN";
    Y2[Y2["BLUE"] = 0.0722] = "BLUE";
    Y2[Y2["WHITE"] = 1] = "WHITE";
    return Y2;
  })(Y || {});
  var x = /* @__PURE__ */ ((x2) => {
    x2[x2["RED"] = 0.64] = "RED";
    x2[x2["GREEN"] = 0.3] = "GREEN";
    x2[x2["BLUE"] = 0.15] = "BLUE";
    x2[x2["WHITE"] = 0.3127] = "WHITE";
    return x2;
  })(x || {});
  var y = /* @__PURE__ */ ((y2) => {
    y2[y2["RED"] = 0.33] = "RED";
    y2[y2["GREEN"] = 0.6] = "GREEN";
    y2[y2["BLUE"] = 0.06] = "BLUE";
    y2[y2["WHITE"] = 0.329] = "WHITE";
    return y2;
  })(y || {});
  var conversion_exports = {};
  __export2(conversion_exports, {
    lab2rgb: () => lab2rgb,
    lab2xyz: () => lab2xyz,
    rgb2hsl: () => rgb2hsl,
    rgb2lab: () => rgb2lab,
    rgb2xyz: () => rgb2xyz,
    xyz2lab: () => xyz2lab,
    xyz2rgb: () => xyz2rgb
  });
  function correctGamma(n2) {
    return n2 > 0.04045 ? ((n2 + 0.055) / 1.055) ** 2.4 : n2 / 12.92;
  }
  function rgb2xyz(r, g, b) {
    r = correctGamma(r / 255);
    g = correctGamma(g / 255);
    b = correctGamma(b / 255);
    return {
      x: r * 0.4124 + g * 0.3576 + b * 0.1805,
      y: r * 0.2126 + g * 0.7152 + b * 0.0722,
      z: r * 0.0193 + g * 0.1192 + b * 0.9505
    };
  }
  var arithmetic_exports = {};
  __export2(arithmetic_exports, {
    degrees2radians: () => degrees2radians,
    inRange0to255: () => inRange0to255,
    inRange0to255Rounded: () => inRange0to255Rounded,
    intInRange: () => intInRange,
    max3: () => max3,
    min3: () => min3,
    stableSort: () => stableSort
  });
  function degrees2radians(n2) {
    return n2 * (Math.PI / 180);
  }
  function max3(a2, b, c3) {
    let m = a2;
    if (m < b)
      m = b;
    if (m < c3)
      m = c3;
    return m;
  }
  function min3(a2, b, c3) {
    let m = a2;
    if (m > b)
      m = b;
    if (m > c3)
      m = c3;
    return m;
  }
  function intInRange(value, low, high) {
    if (value > high)
      value = high;
    if (value < low)
      value = low;
    return value | 0;
  }
  function inRange0to255Rounded(n2) {
    n2 = Math.round(n2);
    if (n2 > 255)
      n2 = 255;
    else if (n2 < 0)
      n2 = 0;
    return n2;
  }
  function inRange0to255(n2) {
    if (n2 > 255)
      n2 = 255;
    else if (n2 < 0)
      n2 = 0;
    return n2;
  }
  function stableSort(arrayToSort, callback) {
    const type = typeof arrayToSort[0];
    let sorted;
    if (type === "number" || type === "string") {
      const ord = /* @__PURE__ */ Object.create(null);
      for (let i2 = 0, l = arrayToSort.length;i2 < l; i2++) {
        const val = arrayToSort[i2];
        if (ord[val] || ord[val] === 0)
          continue;
        ord[val] = i2;
      }
      sorted = arrayToSort.sort((a2, b) => callback(a2, b) || ord[a2] - ord[b]);
    } else {
      const ord2 = arrayToSort.slice(0);
      sorted = arrayToSort.sort((a2, b) => callback(a2, b) || ord2.indexOf(a2) - ord2.indexOf(b));
    }
    return sorted;
  }
  function rgb2hsl(r, g, b) {
    const min = min3(r, g, b);
    const max = max3(r, g, b);
    const delta = max - min;
    const l = (min + max) / 510;
    let s = 0;
    if (l > 0 && l < 1)
      s = delta / (l < 0.5 ? max + min : 510 - max - min);
    let h2 = 0;
    if (delta > 0) {
      if (max === r) {
        h2 = (g - b) / delta;
      } else if (max === g) {
        h2 = 2 + (b - r) / delta;
      } else {
        h2 = 4 + (r - g) / delta;
      }
      h2 *= 60;
      if (h2 < 0)
        h2 += 360;
    }
    return { h: h2, s, l };
  }
  var refX = 0.95047;
  var refY = 1;
  var refZ = 1.08883;
  function pivot(n2) {
    return n2 > 0.008856 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116;
  }
  function xyz2lab(x2, y2, z) {
    x2 = pivot(x2 / refX);
    y2 = pivot(y2 / refY);
    z = pivot(z / refZ);
    if (116 * y2 - 16 < 0)
      throw new Error("xxx");
    return {
      L: Math.max(0, 116 * y2 - 16),
      a: 500 * (x2 - y2),
      b: 200 * (y2 - z)
    };
  }
  function rgb2lab(r, g, b) {
    const xyz = rgb2xyz(r, g, b);
    return xyz2lab(xyz.x, xyz.y, xyz.z);
  }
  var refX2 = 0.95047;
  var refY2 = 1;
  var refZ2 = 1.08883;
  function pivot2(n2) {
    return n2 > 0.206893034 ? n2 ** 3 : (n2 - 16 / 116) / 7.787;
  }
  function lab2xyz(L, a2, b) {
    const y2 = (L + 16) / 116;
    const x2 = a2 / 500 + y2;
    const z = y2 - b / 200;
    return {
      x: refX2 * pivot2(x2),
      y: refY2 * pivot2(y2),
      z: refZ2 * pivot2(z)
    };
  }
  function correctGamma2(n2) {
    return n2 > 0.0031308 ? 1.055 * n2 ** (1 / 2.4) - 0.055 : 12.92 * n2;
  }
  function xyz2rgb(x2, y2, z) {
    const r = correctGamma2(x2 * 3.2406 + y2 * -1.5372 + z * -0.4986);
    const g = correctGamma2(x2 * -0.9689 + y2 * 1.8758 + z * 0.0415);
    const b = correctGamma2(x2 * 0.0557 + y2 * -0.204 + z * 1.057);
    return {
      r: inRange0to255Rounded(r * 255),
      g: inRange0to255Rounded(g * 255),
      b: inRange0to255Rounded(b * 255)
    };
  }
  function lab2rgb(L, a2, b) {
    const xyz = lab2xyz(L, a2, b);
    return xyz2rgb(xyz.x, xyz.y, xyz.z);
  }
  var distance_exports = {};
  __export2(distance_exports, {
    AbstractDistanceCalculator: () => AbstractDistanceCalculator,
    AbstractEuclidean: () => AbstractEuclidean,
    AbstractManhattan: () => AbstractManhattan,
    CIE94GraphicArts: () => CIE94GraphicArts,
    CIE94Textiles: () => CIE94Textiles,
    CIEDE2000: () => CIEDE2000,
    CMetric: () => CMetric,
    Euclidean: () => Euclidean,
    EuclideanBT709: () => EuclideanBT709,
    EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,
    Manhattan: () => Manhattan,
    ManhattanBT709: () => ManhattanBT709,
    ManhattanNommyde: () => ManhattanNommyde,
    PNGQuant: () => PNGQuant
  });
  var AbstractDistanceCalculator = class {
    constructor() {
      __publicField(this, "_maxDistance");
      __publicField(this, "_whitePoint");
      this._setDefaults();
      this.setWhitePoint(255, 255, 255, 255);
    }
    setWhitePoint(r, g, b, a2) {
      this._whitePoint = {
        r: r > 0 ? 255 / r : 0,
        g: g > 0 ? 255 / g : 0,
        b: b > 0 ? 255 / b : 0,
        a: a2 > 0 ? 255 / a2 : 0
      };
      this._maxDistance = this.calculateRaw(r, g, b, a2, 0, 0, 0, 0);
    }
    calculateNormalized(colorA, colorB) {
      return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
    }
  };
  var AbstractCIE94 = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
      const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
      const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
      const dL = lab1.L - lab2.L;
      const dA = lab1.a - lab2.a;
      const dB = lab1.b - lab2.b;
      const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);
      const c22 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);
      const dC = c1 - c22;
      let deltaH = dA * dA + dB * dB - dC * dC;
      deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
      const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
      return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);
    }
  };
  var CIE94Textiles = class extends AbstractCIE94 {
    _setDefaults() {
      this._Kl = 2;
      this._K1 = 0.048;
      this._K2 = 0.014;
      this._kA = 0.25 * 50 / 255;
    }
  };
  var CIE94GraphicArts = class extends AbstractCIE94 {
    _setDefaults() {
      this._Kl = 1;
      this._K1 = 0.045;
      this._K2 = 0.015;
      this._kA = 0.25 * 100 / 255;
    }
  };
  var _CIEDE2000 = class extends AbstractDistanceCalculator {
    _setDefaults() {}
    static _calculatehp(b, ap) {
      const hp = Math.atan2(b, ap);
      if (hp >= 0)
        return hp;
      return hp + _CIEDE2000._deg360InRad;
    }
    static _calculateRT(ahp, aCp) {
      const aCp_to_7 = aCp ** 7;
      const R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7));
      const delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
      return -Math.sin(2 * delta_theta) * R_C;
    }
    static _calculateT(ahp) {
      return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(ahp * 4 - _CIEDE2000._deg63InRad);
    }
    static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {
      const hpSum = h1p + h2p;
      if (C1pC2p === 0)
        return hpSum;
      if (h_bar <= _CIEDE2000._deg180InRad)
        return hpSum / 2;
      if (hpSum < _CIEDE2000._deg360InRad) {
        return (hpSum + _CIEDE2000._deg360InRad) / 2;
      }
      return (hpSum - _CIEDE2000._deg360InRad) / 2;
    }
    static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {
      let dhp;
      if (C1pC2p === 0) {
        dhp = 0;
      } else if (h_bar <= _CIEDE2000._deg180InRad) {
        dhp = h2p - h1p;
      } else if (h2p <= h1p) {
        dhp = h2p - h1p + _CIEDE2000._deg360InRad;
      } else {
        dhp = h2p - h1p - _CIEDE2000._deg360InRad;
      }
      return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
    }
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
      const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
      const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
      const dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA;
      const dE2 = this.calculateRawInLab(lab1, lab2);
      return Math.sqrt(dE2 + dA * dA);
    }
    calculateRawInLab(Lab1, Lab2) {
      const L1 = Lab1.L;
      const a1 = Lab1.a;
      const b1 = Lab1.b;
      const L2 = Lab2.L;
      const a2 = Lab2.a;
      const b2 = Lab2.b;
      const C1 = Math.sqrt(a1 * a1 + b1 * b1);
      const C2 = Math.sqrt(a2 * a2 + b2 * b2);
      const pow_a_C1_C2_to_7 = ((C1 + C2) / 2) ** 7;
      const G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7)));
      const a1p = (1 + G) * a1;
      const a2p = (1 + G) * a2;
      const C1p = Math.sqrt(a1p * a1p + b1 * b1);
      const C2p = Math.sqrt(a2p * a2p + b2 * b2);
      const C1pC2p = C1p * C2p;
      const h1p = _CIEDE2000._calculatehp(b1, a1p);
      const h2p = _CIEDE2000._calculatehp(b2, a2p);
      const h_bar = Math.abs(h1p - h2p);
      const dLp = L2 - L1;
      const dCp = C2p - C1p;
      const dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);
      const ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);
      const T = _CIEDE2000._calculateT(ahp);
      const aCp = (C1p + C2p) / 2;
      const aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2;
      const S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square);
      const S_C = 1 + 0.045 * aCp;
      const S_H = 1 + 0.015 * T * aCp;
      const R_T = _CIEDE2000._calculateRT(ahp, aCp);
      const dLpSL = dLp / S_L;
      const dCpSC = dCp / S_C;
      const dHpSH = dHp / S_H;
      return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;
    }
  };
  var CIEDE2000 = _CIEDE2000;
  __publicField(CIEDE2000, "_kA", 0.25 * 100 / 255);
  __publicField(CIEDE2000, "_pow25to7", 25 ** 7);
  __publicField(CIEDE2000, "_deg360InRad", degrees2radians(360));
  __publicField(CIEDE2000, "_deg180InRad", degrees2radians(180));
  __publicField(CIEDE2000, "_deg30InRad", degrees2radians(30));
  __publicField(CIEDE2000, "_deg6InRad", degrees2radians(6));
  __publicField(CIEDE2000, "_deg63InRad", degrees2radians(63));
  __publicField(CIEDE2000, "_deg275InRad", degrees2radians(275));
  __publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));
  var CMetric = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
      const rmean = (r1 + r2) / 2 * this._whitePoint.r;
      const r = (r1 - r2) * this._whitePoint.r;
      const g = (g1 - g2) * this._whitePoint.g;
      const b = (b1 - b2) * this._whitePoint.b;
      const dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8);
      const dA = (a2 - a1) * this._whitePoint.a;
      return Math.sqrt(dE + dA * dA);
    }
    _setDefaults() {}
  };
  var AbstractEuclidean = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
      const dR = r2 - r1;
      const dG = g2 - g1;
      const dB = b2 - b1;
      const dA = a2 - a1;
      return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
    }
  };
  var Euclidean = class extends AbstractEuclidean {
    _setDefaults() {
      this._kR = 1;
      this._kG = 1;
      this._kB = 1;
      this._kA = 1;
    }
  };
  var EuclideanBT709 = class extends AbstractEuclidean {
    _setDefaults() {
      this._kR = 0.2126;
      this._kG = 0.7152;
      this._kB = 0.0722;
      this._kA = 1;
    }
  };
  var EuclideanBT709NoAlpha = class extends AbstractEuclidean {
    _setDefaults() {
      this._kR = 0.2126;
      this._kG = 0.7152;
      this._kB = 0.0722;
      this._kA = 0;
    }
  };
  var AbstractManhattan = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
      let dR = r2 - r1;
      let dG = g2 - g1;
      let dB = b2 - b1;
      let dA = a2 - a1;
      if (dR < 0)
        dR = 0 - dR;
      if (dG < 0)
        dG = 0 - dG;
      if (dB < 0)
        dB = 0 - dB;
      if (dA < 0)
        dA = 0 - dA;
      return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
    }
  };
  var Manhattan = class extends AbstractManhattan {
    _setDefaults() {
      this._kR = 1;
      this._kG = 1;
      this._kB = 1;
      this._kA = 1;
    }
  };
  var ManhattanNommyde = class extends AbstractManhattan {
    _setDefaults() {
      this._kR = 0.4984;
      this._kG = 0.8625;
      this._kB = 0.2979;
      this._kA = 1;
    }
  };
  var ManhattanBT709 = class extends AbstractManhattan {
    _setDefaults() {
      this._kR = 0.2126;
      this._kG = 0.7152;
      this._kB = 0.0722;
      this._kA = 1;
    }
  };
  var PNGQuant = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
      const alphas = (a2 - a1) * this._whitePoint.a;
      return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
    }
    _colordifferenceCh(x2, y2, alphas) {
      const black2 = x2 - y2;
      const white2 = black2 + alphas;
      return black2 * black2 + white2 * white2;
    }
    _setDefaults() {}
  };
  var palette_exports = {};
  __export2(palette_exports, {
    AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,
    ColorHistogram: () => ColorHistogram,
    NeuQuant: () => NeuQuant,
    NeuQuantFloat: () => NeuQuantFloat,
    RGBQuant: () => RGBQuant,
    WuColorCube: () => WuColorCube,
    WuQuant: () => WuQuant
  });
  var AbstractPaletteQuantizer = class {
    quantizeSync() {
      for (const value of this.quantize()) {
        if (value.palette) {
          return value.palette;
        }
      }
      throw new Error("unreachable");
    }
  };
  var Point = class {
    constructor() {
      __publicField(this, "r");
      __publicField(this, "g");
      __publicField(this, "b");
      __publicField(this, "a");
      __publicField(this, "uint32");
      __publicField(this, "rgba");
      this.uint32 = -1 >>> 0;
      this.r = this.g = this.b = this.a = 0;
      this.rgba = new Array(4);
      this.rgba[0] = 0;
      this.rgba[1] = 0;
      this.rgba[2] = 0;
      this.rgba[3] = 0;
    }
    static createByQuadruplet(quadruplet) {
      const point = new Point;
      point.r = quadruplet[0] | 0;
      point.g = quadruplet[1] | 0;
      point.b = quadruplet[2] | 0;
      point.a = quadruplet[3] | 0;
      point._loadUINT32();
      point._loadQuadruplet();
      return point;
    }
    static createByRGBA(red2, green2, blue2, alpha) {
      const point = new Point;
      point.r = red2 | 0;
      point.g = green2 | 0;
      point.b = blue2 | 0;
      point.a = alpha | 0;
      point._loadUINT32();
      point._loadQuadruplet();
      return point;
    }
    static createByUint32(uint32) {
      const point = new Point;
      point.uint32 = uint32 >>> 0;
      point._loadRGBA();
      point._loadQuadruplet();
      return point;
    }
    from(point) {
      this.r = point.r;
      this.g = point.g;
      this.b = point.b;
      this.a = point.a;
      this.uint32 = point.uint32;
      this.rgba[0] = point.r;
      this.rgba[1] = point.g;
      this.rgba[2] = point.b;
      this.rgba[3] = point.a;
    }
    getLuminosity(useAlphaChannel) {
      let r = this.r;
      let g = this.g;
      let b = this.b;
      if (useAlphaChannel) {
        r = Math.min(255, 255 - this.a + this.a * r / 255);
        g = Math.min(255, 255 - this.a + this.a * g / 255);
        b = Math.min(255, 255 - this.a + this.a * b / 255);
      }
      return r * 0.2126 + g * 0.7152 + b * 0.0722;
    }
    _loadUINT32() {
      this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
    }
    _loadRGBA() {
      this.r = this.uint32 & 255;
      this.g = this.uint32 >>> 8 & 255;
      this.b = this.uint32 >>> 16 & 255;
      this.a = this.uint32 >>> 24 & 255;
    }
    _loadQuadruplet() {
      this.rgba[0] = this.r;
      this.rgba[1] = this.g;
      this.rgba[2] = this.b;
      this.rgba[3] = this.a;
    }
  };
  var PointContainer = class {
    constructor() {
      __publicField(this, "_pointArray");
      __publicField(this, "_width");
      __publicField(this, "_height");
      this._width = 0;
      this._height = 0;
      this._pointArray = [];
    }
    getWidth() {
      return this._width;
    }
    getHeight() {
      return this._height;
    }
    setWidth(width) {
      this._width = width;
    }
    setHeight(height) {
      this._height = height;
    }
    getPointArray() {
      return this._pointArray;
    }
    clone() {
      const clone3 = new PointContainer;
      clone3._width = this._width;
      clone3._height = this._height;
      for (let i2 = 0, l = this._pointArray.length;i2 < l; i2++) {
        clone3._pointArray[i2] = Point.createByUint32(this._pointArray[i2].uint32 | 0);
      }
      return clone3;
    }
    toUint32Array() {
      const l = this._pointArray.length;
      const uint32Array = new Uint32Array(l);
      for (let i2 = 0;i2 < l; i2++) {
        uint32Array[i2] = this._pointArray[i2].uint32;
      }
      return uint32Array;
    }
    toUint8Array() {
      return new Uint8Array(this.toUint32Array().buffer);
    }
    static fromHTMLImageElement(img) {
      const width = img.naturalWidth;
      const height = img.naturalHeight;
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
      return PointContainer.fromHTMLCanvasElement(canvas);
    }
    static fromHTMLCanvasElement(canvas) {
      const width = canvas.width;
      const height = canvas.height;
      const ctx = canvas.getContext("2d");
      const imgData = ctx.getImageData(0, 0, width, height);
      return PointContainer.fromImageData(imgData);
    }
    static fromImageData(imageData) {
      const width = imageData.width;
      const height = imageData.height;
      return PointContainer.fromUint8Array(imageData.data, width, height);
    }
    static fromUint8Array(uint8Array, width, height) {
      switch (Object.prototype.toString.call(uint8Array)) {
        case "[object Uint8ClampedArray]":
        case "[object Uint8Array]":
          break;
        default:
          uint8Array = new Uint8Array(uint8Array);
      }
      const uint32Array = new Uint32Array(uint8Array.buffer);
      return PointContainer.fromUint32Array(uint32Array, width, height);
    }
    static fromUint32Array(uint32Array, width, height) {
      const container = new PointContainer;
      container._width = width;
      container._height = height;
      for (let i2 = 0, l = uint32Array.length;i2 < l; i2++) {
        container._pointArray[i2] = Point.createByUint32(uint32Array[i2] | 0);
      }
      return container;
    }
    static fromBuffer(buffer, width, height) {
      const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);
      return PointContainer.fromUint32Array(uint32Array, width, height);
    }
  };
  var hueGroups = 10;
  function hueGroup(hue, segmentsNumber) {
    const maxHue = 360;
    const seg = maxHue / segmentsNumber;
    const half = seg / 2;
    for (let i2 = 1, mid = seg - half;i2 < segmentsNumber; i2++, mid += seg) {
      if (hue >= mid && hue < mid + seg)
        return i2;
    }
    return 0;
  }
  var Palette = class {
    constructor() {
      __publicField(this, "_pointContainer");
      __publicField(this, "_pointArray", []);
      __publicField(this, "_i32idx", {});
      this._pointContainer = new PointContainer;
      this._pointContainer.setHeight(1);
      this._pointArray = this._pointContainer.getPointArray();
    }
    add(color) {
      this._pointArray.push(color);
      this._pointContainer.setWidth(this._pointArray.length);
    }
    has(color) {
      for (let i2 = this._pointArray.length - 1;i2 >= 0; i2--) {
        if (color.uint32 === this._pointArray[i2].uint32)
          return true;
      }
      return false;
    }
    getNearestColor(colorDistanceCalculator, color) {
      return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];
    }
    getPointContainer() {
      return this._pointContainer;
    }
    _nearestPointFromCache(key) {
      return typeof this._i32idx[key] === "number" ? this._i32idx[key] : -1;
    }
    _getNearestIndex(colorDistanceCalculator, point) {
      let idx = this._nearestPointFromCache("" + point.uint32);
      if (idx >= 0)
        return idx;
      let minimalDistance = Number.MAX_VALUE;
      idx = 0;
      for (let i2 = 0, l = this._pointArray.length;i2 < l; i2++) {
        const p = this._pointArray[i2];
        const distance2 = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
        if (distance2 < minimalDistance) {
          minimalDistance = distance2;
          idx = i2;
        }
      }
      this._i32idx[point.uint32] = idx;
      return idx;
    }
    sort() {
      this._i32idx = {};
      this._pointArray.sort((a2, b) => {
        const hslA = rgb2hsl(a2.r, a2.g, a2.b);
        const hslB = rgb2hsl(b.r, b.g, b.b);
        const hueA = a2.r === a2.g && a2.g === a2.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);
        const hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);
        const hueDiff = hueB - hueA;
        if (hueDiff)
          return -hueDiff;
        const lA = a2.getLuminosity(true);
        const lB = b.getLuminosity(true);
        if (lB - lA !== 0)
          return lB - lA;
        const satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);
        if (satDiff)
          return -satDiff;
        return 0;
      });
    }
  };
  var utils_exports = {};
  __export2(utils_exports, {
    HueStatistics: () => HueStatistics,
    Palette: () => Palette,
    Point: () => Point,
    PointContainer: () => PointContainer,
    ProgressTracker: () => ProgressTracker,
    arithmetic: () => arithmetic_exports
  });
  var HueGroup = class {
    constructor() {
      __publicField(this, "num", 0);
      __publicField(this, "cols", []);
    }
  };
  var HueStatistics = class {
    constructor(numGroups, minCols) {
      __publicField(this, "_numGroups");
      __publicField(this, "_minCols");
      __publicField(this, "_stats");
      __publicField(this, "_groupsFull");
      this._numGroups = numGroups;
      this._minCols = minCols;
      this._stats = [];
      for (let i2 = 0;i2 <= numGroups; i2++) {
        this._stats[i2] = new HueGroup;
      }
      this._groupsFull = 0;
    }
    check(i32) {
      if (this._groupsFull === this._numGroups + 1) {
        this.check = () => {};
      }
      const r = i32 & 255;
      const g = i32 >>> 8 & 255;
      const b = i32 >>> 16 & 255;
      const hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);
      const gr = this._stats[hg];
      const min = this._minCols;
      gr.num++;
      if (gr.num > min) {
        return;
      }
      if (gr.num === min) {
        this._groupsFull++;
      }
      if (gr.num <= min) {
        this._stats[hg].cols.push(i32);
      }
    }
    injectIntoDictionary(histG) {
      for (let i2 = 0;i2 <= this._numGroups; i2++) {
        if (this._stats[i2].num <= this._minCols) {
          this._stats[i2].cols.forEach((col) => {
            if (!histG[col]) {
              histG[col] = 1;
            } else {
              histG[col]++;
            }
          });
        }
      }
    }
    injectIntoArray(histG) {
      for (let i2 = 0;i2 <= this._numGroups; i2++) {
        if (this._stats[i2].num <= this._minCols) {
          this._stats[i2].cols.forEach((col) => {
            if (histG.indexOf(col) === -1) {
              histG.push(col);
            }
          });
        }
      }
    }
  };
  var _ProgressTracker = class {
    constructor(valueRange, progressRange) {
      __publicField(this, "progress");
      __publicField(this, "_step");
      __publicField(this, "_range");
      __publicField(this, "_last");
      __publicField(this, "_progressRange");
      this._range = valueRange;
      this._progressRange = progressRange;
      this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0);
      this._last = -this._step;
      this.progress = 0;
    }
    shouldNotify(current) {
      if (current - this._last >= this._step) {
        this._last = current;
        this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);
        return true;
      }
      return false;
    }
  };
  var ProgressTracker = _ProgressTracker;
  __publicField(ProgressTracker, "steps", 100);
  var networkBiasShift = 3;
  var Neuron = class {
    constructor(defaultValue) {
      __publicField(this, "r");
      __publicField(this, "g");
      __publicField(this, "b");
      __publicField(this, "a");
      this.r = this.g = this.b = this.a = defaultValue;
    }
    toPoint() {
      return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
    }
    subtract(r, g, b, a2) {
      this.r -= r | 0;
      this.g -= g | 0;
      this.b -= b | 0;
      this.a -= a2 | 0;
    }
  };
  var _NeuQuant = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256) {
      super();
      __publicField(this, "_pointArray");
      __publicField(this, "_networkSize");
      __publicField(this, "_network");
      __publicField(this, "_sampleFactor");
      __publicField(this, "_radPower");
      __publicField(this, "_freq");
      __publicField(this, "_bias");
      __publicField(this, "_distance");
      this._distance = colorDistanceCalculator;
      this._pointArray = [];
      this._sampleFactor = 1;
      this._networkSize = colors;
      this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
    }
    sample(pointContainer) {
      this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
    }
    *quantize() {
      this._init();
      yield* this._learn();
      yield {
        palette: this._buildPalette(),
        progress: 100
      };
    }
    _init() {
      this._freq = [];
      this._bias = [];
      this._radPower = [];
      this._network = [];
      for (let i2 = 0;i2 < this._networkSize; i2++) {
        this._network[i2] = new Neuron((i2 << networkBiasShift + 8) / this._networkSize | 0);
        this._freq[i2] = _NeuQuant._initialBias / this._networkSize | 0;
        this._bias[i2] = 0;
      }
    }
    *_learn() {
      let sampleFactor = this._sampleFactor;
      const pointsNumber = this._pointArray.length;
      if (pointsNumber < _NeuQuant._minpicturebytes)
        sampleFactor = 1;
      const alphadec = 30 + (sampleFactor - 1) / 3 | 0;
      const pointsToSample = pointsNumber / sampleFactor | 0;
      let delta = pointsToSample / _NeuQuant._nCycles | 0;
      let alpha = _NeuQuant._initAlpha;
      let radius = (this._networkSize >> 3) * _NeuQuant._radiusBias;
      let rad = radius >> _NeuQuant._radiusBiasShift;
      if (rad <= 1)
        rad = 0;
      for (let i2 = 0;i2 < rad; i2++) {
        this._radPower[i2] = alpha * ((rad * rad - i2 * i2) * _NeuQuant._radBias / (rad * rad)) >>> 0;
      }
      let step;
      if (pointsNumber < _NeuQuant._minpicturebytes) {
        step = 1;
      } else if (pointsNumber % _NeuQuant._prime1 !== 0) {
        step = _NeuQuant._prime1;
      } else if (pointsNumber % _NeuQuant._prime2 !== 0) {
        step = _NeuQuant._prime2;
      } else if (pointsNumber % _NeuQuant._prime3 !== 0) {
        step = _NeuQuant._prime3;
      } else {
        step = _NeuQuant._prime4;
      }
      const tracker = new ProgressTracker(pointsToSample, 99);
      for (let i2 = 0, pointIndex = 0;i2 < pointsToSample; ) {
        if (tracker.shouldNotify(i2)) {
          yield {
            progress: tracker.progress
          };
        }
        const point = this._pointArray[pointIndex];
        const b = point.b << networkBiasShift;
        const g = point.g << networkBiasShift;
        const r = point.r << networkBiasShift;
        const a2 = point.a << networkBiasShift;
        const neuronIndex = this._contest(b, g, r, a2);
        this._alterSingle(alpha, neuronIndex, b, g, r, a2);
        if (rad !== 0)
          this._alterNeighbour(rad, neuronIndex, b, g, r, a2);
        pointIndex += step;
        if (pointIndex >= pointsNumber)
          pointIndex -= pointsNumber;
        i2++;
        if (delta === 0)
          delta = 1;
        if (i2 % delta === 0) {
          alpha -= alpha / alphadec | 0;
          radius -= radius / _NeuQuant._radiusDecrease | 0;
          rad = radius >> _NeuQuant._radiusBiasShift;
          if (rad <= 1)
            rad = 0;
          for (let j = 0;j < rad; j++) {
            this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;
          }
        }
      }
    }
    _buildPalette() {
      const palette2 = new Palette;
      this._network.forEach((neuron) => {
        palette2.add(neuron.toPoint());
      });
      palette2.sort();
      return palette2;
    }
    _alterNeighbour(rad, i2, b, g, r, al) {
      let lo = i2 - rad;
      if (lo < -1)
        lo = -1;
      let hi = i2 + rad;
      if (hi > this._networkSize)
        hi = this._networkSize;
      let j = i2 + 1;
      let k = i2 - 1;
      let m = 1;
      while (j < hi || k > lo) {
        const a2 = this._radPower[m++] / _NeuQuant._alphaRadBias;
        if (j < hi) {
          const p = this._network[j++];
          p.subtract(a2 * (p.r - r), a2 * (p.g - g), a2 * (p.b - b), a2 * (p.a - al));
        }
        if (k > lo) {
          const p = this._network[k--];
          p.subtract(a2 * (p.r - r), a2 * (p.g - g), a2 * (p.b - b), a2 * (p.a - al));
        }
      }
    }
    _alterSingle(alpha, i2, b, g, r, a2) {
      alpha /= _NeuQuant._initAlpha;
      const n2 = this._network[i2];
      n2.subtract(alpha * (n2.r - r), alpha * (n2.g - g), alpha * (n2.b - b), alpha * (n2.a - a2));
    }
    _contest(b, g, r, a2) {
      const multiplier = 255 * 4 << networkBiasShift;
      let bestd = ~(1 << 31);
      let bestbiasd = bestd;
      let bestpos = -1;
      let bestbiaspos = bestpos;
      for (let i2 = 0;i2 < this._networkSize; i2++) {
        const n2 = this._network[i2];
        const dist = this._distance.calculateNormalized(n2, { r, g, b, a: a2 }) * multiplier | 0;
        if (dist < bestd) {
          bestd = dist;
          bestpos = i2;
        }
        const biasdist = dist - (this._bias[i2] >> _NeuQuant._initialBiasShift - networkBiasShift);
        if (biasdist < bestbiasd) {
          bestbiasd = biasdist;
          bestbiaspos = i2;
        }
        const betafreq = this._freq[i2] >> _NeuQuant._betaShift;
        this._freq[i2] -= betafreq;
        this._bias[i2] += betafreq << _NeuQuant._gammaShift;
      }
      this._freq[bestpos] += _NeuQuant._beta;
      this._bias[bestpos] -= _NeuQuant._betaGamma;
      return bestbiaspos;
    }
  };
  var NeuQuant = _NeuQuant;
  __publicField(NeuQuant, "_prime1", 499);
  __publicField(NeuQuant, "_prime2", 491);
  __publicField(NeuQuant, "_prime3", 487);
  __publicField(NeuQuant, "_prime4", 503);
  __publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4);
  __publicField(NeuQuant, "_nCycles", 100);
  __publicField(NeuQuant, "_initialBiasShift", 16);
  __publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift);
  __publicField(NeuQuant, "_gammaShift", 10);
  __publicField(NeuQuant, "_betaShift", 10);
  __publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift);
  __publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift);
  __publicField(NeuQuant, "_radiusBiasShift", 6);
  __publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift);
  __publicField(NeuQuant, "_radiusDecrease", 30);
  __publicField(NeuQuant, "_alphaBiasShift", 10);
  __publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift);
  __publicField(NeuQuant, "_radBiasShift", 8);
  __publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift);
  __publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift);
  __publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);
  var networkBiasShift2 = 3;
  var NeuronFloat = class {
    constructor(defaultValue) {
      __publicField(this, "r");
      __publicField(this, "g");
      __publicField(this, "b");
      __publicField(this, "a");
      this.r = this.g = this.b = this.a = defaultValue;
    }
    toPoint() {
      return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
    }
    subtract(r, g, b, a2) {
      this.r -= r;
      this.g -= g;
      this.b -= b;
      this.a -= a2;
    }
  };
  var _NeuQuantFloat = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256) {
      super();
      __publicField(this, "_pointArray");
      __publicField(this, "_networkSize");
      __publicField(this, "_network");
      __publicField(this, "_sampleFactor");
      __publicField(this, "_radPower");
      __publicField(this, "_freq");
      __publicField(this, "_bias");
      __publicField(this, "_distance");
      this._distance = colorDistanceCalculator;
      this._pointArray = [];
      this._sampleFactor = 1;
      this._networkSize = colors;
      this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
    }
    sample(pointContainer) {
      this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
    }
    *quantize() {
      this._init();
      yield* this._learn();
      yield {
        palette: this._buildPalette(),
        progress: 100
      };
    }
    _init() {
      this._freq = [];
      this._bias = [];
      this._radPower = [];
      this._network = [];
      for (let i2 = 0;i2 < this._networkSize; i2++) {
        this._network[i2] = new NeuronFloat((i2 << networkBiasShift2 + 8) / this._networkSize);
        this._freq[i2] = _NeuQuantFloat._initialBias / this._networkSize;
        this._bias[i2] = 0;
      }
    }
    *_learn() {
      let sampleFactor = this._sampleFactor;
      const pointsNumber = this._pointArray.length;
      if (pointsNumber < _NeuQuantFloat._minpicturebytes)
        sampleFactor = 1;
      const alphadec = 30 + (sampleFactor - 1) / 3;
      const pointsToSample = pointsNumber / sampleFactor;
      let delta = pointsToSample / _NeuQuantFloat._nCycles | 0;
      let alpha = _NeuQuantFloat._initAlpha;
      let radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias;
      let rad = radius >> _NeuQuantFloat._radiusBiasShift;
      if (rad <= 1)
        rad = 0;
      for (let i2 = 0;i2 < rad; i2++) {
        this._radPower[i2] = alpha * ((rad * rad - i2 * i2) * _NeuQuantFloat._radBias / (rad * rad));
      }
      let step;
      if (pointsNumber < _NeuQuantFloat._minpicturebytes) {
        step = 1;
      } else if (pointsNumber % _NeuQuantFloat._prime1 !== 0) {
        step = _NeuQuantFloat._prime1;
      } else if (pointsNumber % _NeuQuantFloat._prime2 !== 0) {
        step = _NeuQuantFloat._prime2;
      } else if (pointsNumber % _NeuQuantFloat._prime3 !== 0) {
        step = _NeuQuantFloat._prime3;
      } else {
        step = _NeuQuantFloat._prime4;
      }
      const tracker = new ProgressTracker(pointsToSample, 99);
      for (let i2 = 0, pointIndex = 0;i2 < pointsToSample; ) {
        if (tracker.shouldNotify(i2)) {
          yield {
            progress: tracker.progress
          };
        }
        const point = this._pointArray[pointIndex];
        const b = point.b << networkBiasShift2;
        const g = point.g << networkBiasShift2;
        const r = point.r << networkBiasShift2;
        const a2 = point.a << networkBiasShift2;
        const neuronIndex = this._contest(b, g, r, a2);
        this._alterSingle(alpha, neuronIndex, b, g, r, a2);
        if (rad !== 0)
          this._alterNeighbour(rad, neuronIndex, b, g, r, a2);
        pointIndex += step;
        if (pointIndex >= pointsNumber)
          pointIndex -= pointsNumber;
        i2++;
        if (delta === 0)
          delta = 1;
        if (i2 % delta === 0) {
          alpha -= alpha / alphadec;
          radius -= radius / _NeuQuantFloat._radiusDecrease;
          rad = radius >> _NeuQuantFloat._radiusBiasShift;
          if (rad <= 1)
            rad = 0;
          for (let j = 0;j < rad; j++) {
            this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));
          }
        }
      }
    }
    _buildPalette() {
      const palette2 = new Palette;
      this._network.forEach((neuron) => {
        palette2.add(neuron.toPoint());
      });
      palette2.sort();
      return palette2;
    }
    _alterNeighbour(rad, i2, b, g, r, al) {
      let lo = i2 - rad;
      if (lo < -1)
        lo = -1;
      let hi = i2 + rad;
      if (hi > this._networkSize)
        hi = this._networkSize;
      let j = i2 + 1;
      let k = i2 - 1;
      let m = 1;
      while (j < hi || k > lo) {
        const a2 = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;
        if (j < hi) {
          const p = this._network[j++];
          p.subtract(a2 * (p.r - r), a2 * (p.g - g), a2 * (p.b - b), a2 * (p.a - al));
        }
        if (k > lo) {
          const p = this._network[k--];
          p.subtract(a2 * (p.r - r), a2 * (p.g - g), a2 * (p.b - b), a2 * (p.a - al));
        }
      }
    }
    _alterSingle(alpha, i2, b, g, r, a2) {
      alpha /= _NeuQuantFloat._initAlpha;
      const n2 = this._network[i2];
      n2.subtract(alpha * (n2.r - r), alpha * (n2.g - g), alpha * (n2.b - b), alpha * (n2.a - a2));
    }
    _contest(b, g, r, al) {
      const multiplier = 255 * 4 << networkBiasShift2;
      let bestd = ~(1 << 31);
      let bestbiasd = bestd;
      let bestpos = -1;
      let bestbiaspos = bestpos;
      for (let i2 = 0;i2 < this._networkSize; i2++) {
        const n2 = this._network[i2];
        const dist = this._distance.calculateNormalized(n2, { r, g, b, a: al }) * multiplier;
        if (dist < bestd) {
          bestd = dist;
          bestpos = i2;
        }
        const biasdist = dist - (this._bias[i2] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
        if (biasdist < bestbiasd) {
          bestbiasd = biasdist;
          bestbiaspos = i2;
        }
        const betafreq = this._freq[i2] >> _NeuQuantFloat._betaShift;
        this._freq[i2] -= betafreq;
        this._bias[i2] += betafreq << _NeuQuantFloat._gammaShift;
      }
      this._freq[bestpos] += _NeuQuantFloat._beta;
      this._bias[bestpos] -= _NeuQuantFloat._betaGamma;
      return bestbiaspos;
    }
  };
  var NeuQuantFloat = _NeuQuantFloat;
  __publicField(NeuQuantFloat, "_prime1", 499);
  __publicField(NeuQuantFloat, "_prime2", 491);
  __publicField(NeuQuantFloat, "_prime3", 487);
  __publicField(NeuQuantFloat, "_prime4", 503);
  __publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4);
  __publicField(NeuQuantFloat, "_nCycles", 100);
  __publicField(NeuQuantFloat, "_initialBiasShift", 16);
  __publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift);
  __publicField(NeuQuantFloat, "_gammaShift", 10);
  __publicField(NeuQuantFloat, "_betaShift", 10);
  __publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift);
  __publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift);
  __publicField(NeuQuantFloat, "_radiusBiasShift", 6);
  __publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift);
  __publicField(NeuQuantFloat, "_radiusDecrease", 30);
  __publicField(NeuQuantFloat, "_alphaBiasShift", 10);
  __publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift);
  __publicField(NeuQuantFloat, "_radBiasShift", 8);
  __publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift);
  __publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift);
  __publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);
  var _ColorHistogram = class {
    constructor(method, colors) {
      __publicField(this, "_method");
      __publicField(this, "_hueStats");
      __publicField(this, "_histogram");
      __publicField(this, "_initColors");
      __publicField(this, "_minHueCols");
      this._method = method;
      this._minHueCols = colors << 2;
      this._initColors = colors << 2;
      this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols);
      this._histogram = /* @__PURE__ */ Object.create(null);
    }
    sample(pointContainer) {
      switch (this._method) {
        case 1:
          this._colorStats1D(pointContainer);
          break;
        case 2:
          this._colorStats2D(pointContainer);
          break;
      }
    }
    getImportanceSortedColorsIDXI32() {
      const sorted = stableSort(Object.keys(this._histogram), (a2, b) => this._histogram[b] - this._histogram[a2]);
      if (sorted.length === 0) {
        return [];
      }
      let idxi32;
      switch (this._method) {
        case 1:
          const initialColorsLimit = Math.min(sorted.length, this._initColors);
          const last = sorted[initialColorsLimit - 1];
          const freq = this._histogram[last];
          idxi32 = sorted.slice(0, initialColorsLimit);
          let pos = initialColorsLimit;
          const len = sorted.length;
          while (pos < len && this._histogram[sorted[pos]] === freq) {
            idxi32.push(sorted[pos++]);
          }
          this._hueStats.injectIntoArray(idxi32);
          break;
        case 2:
          idxi32 = sorted;
          break;
        default:
          throw new Error("Incorrect method");
      }
      return idxi32.map((v) => +v);
    }
    _colorStats1D(pointContainer) {
      const histG = this._histogram;
      const pointArray = pointContainer.getPointArray();
      const len = pointArray.length;
      for (let i2 = 0;i2 < len; i2++) {
        const col = pointArray[i2].uint32;
        this._hueStats.check(col);
        if (col in histG) {
          histG[col]++;
        } else {
          histG[col] = 1;
        }
      }
    }
    _colorStats2D(pointContainer) {
      const width = pointContainer.getWidth();
      const height = pointContainer.getHeight();
      const pointArray = pointContainer.getPointArray();
      const boxW = _ColorHistogram._boxSize[0];
      const boxH = _ColorHistogram._boxSize[1];
      const area = boxW * boxH;
      const boxes = this._makeBoxes(width, height, boxW, boxH);
      const histG = this._histogram;
      boxes.forEach((box) => {
        let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;
        if (effc < 2)
          effc = 2;
        const histL = {};
        this._iterateBox(box, width, (i2) => {
          const col = pointArray[i2].uint32;
          this._hueStats.check(col);
          if (col in histG) {
            histG[col]++;
          } else if (col in histL) {
            if (++histL[col] >= effc) {
              histG[col] = histL[col];
            }
          } else {
            histL[col] = 1;
          }
        });
      });
      this._hueStats.injectIntoDictionary(histG);
    }
    _iterateBox(bbox, wid, fn) {
      const b = bbox;
      const i0 = b.y * wid + b.x;
      const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);
      const incr = wid - b.w + 1;
      let cnt = 0;
      let i2 = i0;
      do {
        fn.call(this, i2);
        i2 += ++cnt % b.w === 0 ? incr : 1;
      } while (i2 <= i1);
    }
    _makeBoxes(width, height, stepX, stepY) {
      const wrem = width % stepX;
      const hrem = height % stepY;
      const xend = width - wrem;
      const yend = height - hrem;
      const boxesArray = [];
      for (let y2 = 0;y2 < height; y2 += stepY) {
        for (let x2 = 0;x2 < width; x2 += stepX) {
          boxesArray.push({
            x: x2,
            y: y2,
            w: x2 === xend ? wrem : stepX,
            h: y2 === yend ? hrem : stepY
          });
        }
      }
      return boxesArray;
    }
  };
  var ColorHistogram = _ColorHistogram;
  __publicField(ColorHistogram, "_boxSize", [64, 64]);
  __publicField(ColorHistogram, "_boxPixels", 2);
  __publicField(ColorHistogram, "_hueGroups", 10);
  var RemovedColor = class {
    constructor(index, color, distance2) {
      __publicField(this, "index");
      __publicField(this, "color");
      __publicField(this, "distance");
      this.index = index;
      this.color = color;
      this.distance = distance2;
    }
  };
  var RGBQuant = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256, method = 2) {
      super();
      __publicField(this, "_colors");
      __publicField(this, "_initialDistance");
      __publicField(this, "_distanceIncrement");
      __publicField(this, "_histogram");
      __publicField(this, "_distance");
      this._distance = colorDistanceCalculator;
      this._colors = colors;
      this._histogram = new ColorHistogram(method, colors);
      this._initialDistance = 0.01;
      this._distanceIncrement = 0.005;
    }
    sample(image3) {
      this._histogram.sample(image3);
    }
    *quantize() {
      const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
      if (idxi32.length === 0) {
        throw new Error("No colors in image");
      }
      yield* this._buildPalette(idxi32);
    }
    *_buildPalette(idxi32) {
      const palette2 = new Palette;
      const colorArray = palette2.getPointContainer().getPointArray();
      const usageArray = new Array(idxi32.length);
      for (let i2 = 0;i2 < idxi32.length; i2++) {
        colorArray.push(Point.createByUint32(idxi32[i2]));
        usageArray[i2] = 1;
      }
      const len = colorArray.length;
      const memDist = [];
      let palLen = len;
      let thold = this._initialDistance;
      const tracker = new ProgressTracker(palLen - this._colors, 99);
      while (palLen > this._colors) {
        memDist.length = 0;
        for (let i2 = 0;i2 < len; i2++) {
          if (tracker.shouldNotify(len - palLen)) {
            yield {
              progress: tracker.progress
            };
          }
          if (usageArray[i2] === 0)
            continue;
          const pxi = colorArray[i2];
          for (let j = i2 + 1;j < len; j++) {
            if (usageArray[j] === 0)
              continue;
            const pxj = colorArray[j];
            const dist = this._distance.calculateNormalized(pxi, pxj);
            if (dist < thold) {
              memDist.push(new RemovedColor(j, pxj, dist));
              usageArray[j] = 0;
              palLen--;
            }
          }
        }
        thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
      }
      if (palLen < this._colors) {
        stableSort(memDist, (a2, b) => b.distance - a2.distance);
        let k = 0;
        while (palLen < this._colors && k < memDist.length) {
          const removedColor = memDist[k];
          usageArray[removedColor.index] = 1;
          palLen++;
          k++;
        }
      }
      let colors = colorArray.length;
      for (let colorIndex = colors - 1;colorIndex >= 0; colorIndex--) {
        if (usageArray[colorIndex] === 0) {
          if (colorIndex !== colors - 1) {
            colorArray[colorIndex] = colorArray[colors - 1];
          }
          --colors;
        }
      }
      colorArray.length = colors;
      palette2.sort();
      yield {
        palette: palette2,
        progress: 100
      };
    }
  };
  function createArray1D(dimension1) {
    const a2 = [];
    for (let k = 0;k < dimension1; k++) {
      a2[k] = 0;
    }
    return a2;
  }
  function createArray4D(dimension1, dimension2, dimension3, dimension4) {
    const a2 = new Array(dimension1);
    for (let i2 = 0;i2 < dimension1; i2++) {
      a2[i2] = new Array(dimension2);
      for (let j = 0;j < dimension2; j++) {
        a2[i2][j] = new Array(dimension3);
        for (let k = 0;k < dimension3; k++) {
          a2[i2][j][k] = new Array(dimension4);
          for (let l = 0;l < dimension4; l++) {
            a2[i2][j][k][l] = 0;
          }
        }
      }
    }
    return a2;
  }
  function createArray3D(dimension1, dimension2, dimension3) {
    const a2 = new Array(dimension1);
    for (let i2 = 0;i2 < dimension1; i2++) {
      a2[i2] = new Array(dimension2);
      for (let j = 0;j < dimension2; j++) {
        a2[i2][j] = new Array(dimension3);
        for (let k = 0;k < dimension3; k++) {
          a2[i2][j][k] = 0;
        }
      }
    }
    return a2;
  }
  function fillArray3D(a2, dimension1, dimension2, dimension3, value) {
    for (let i2 = 0;i2 < dimension1; i2++) {
      a2[i2] = [];
      for (let j = 0;j < dimension2; j++) {
        a2[i2][j] = [];
        for (let k = 0;k < dimension3; k++) {
          a2[i2][j][k] = value;
        }
      }
    }
  }
  function fillArray1D(a2, dimension1, value) {
    for (let i2 = 0;i2 < dimension1; i2++) {
      a2[i2] = value;
    }
  }
  var WuColorCube = class {
    constructor() {
      __publicField(this, "redMinimum");
      __publicField(this, "redMaximum");
      __publicField(this, "greenMinimum");
      __publicField(this, "greenMaximum");
      __publicField(this, "blueMinimum");
      __publicField(this, "blueMaximum");
      __publicField(this, "volume");
      __publicField(this, "alphaMinimum");
      __publicField(this, "alphaMaximum");
    }
  };
  var _WuQuant = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {
      super();
      __publicField(this, "_reds");
      __publicField(this, "_greens");
      __publicField(this, "_blues");
      __publicField(this, "_alphas");
      __publicField(this, "_sums");
      __publicField(this, "_weights");
      __publicField(this, "_momentsRed");
      __publicField(this, "_momentsGreen");
      __publicField(this, "_momentsBlue");
      __publicField(this, "_momentsAlpha");
      __publicField(this, "_moments");
      __publicField(this, "_table");
      __publicField(this, "_pixels");
      __publicField(this, "_cubes");
      __publicField(this, "_colors");
      __publicField(this, "_significantBitsPerChannel");
      __publicField(this, "_maxSideIndex");
      __publicField(this, "_alphaMaxSideIndex");
      __publicField(this, "_sideSize");
      __publicField(this, "_alphaSideSize");
      __publicField(this, "_distance");
      this._distance = colorDistanceCalculator;
      this._setQuality(significantBitsPerChannel);
      this._initialize(colors);
    }
    sample(image3) {
      const pointArray = image3.getPointArray();
      for (let i2 = 0, l = pointArray.length;i2 < l; i2++) {
        this._addColor(pointArray[i2]);
      }
      this._pixels = this._pixels.concat(pointArray);
    }
    *quantize() {
      yield* this._preparePalette();
      const palette2 = new Palette;
      for (let paletteIndex = 0;paletteIndex < this._colors; paletteIndex++) {
        if (this._sums[paletteIndex] > 0) {
          const sum = this._sums[paletteIndex];
          const r = this._reds[paletteIndex] / sum;
          const g = this._greens[paletteIndex] / sum;
          const b = this._blues[paletteIndex] / sum;
          const a2 = this._alphas[paletteIndex] / sum;
          const color = Point.createByRGBA(r | 0, g | 0, b | 0, a2 | 0);
          palette2.add(color);
        }
      }
      palette2.sort();
      yield {
        palette: palette2,
        progress: 100
      };
    }
    *_preparePalette() {
      yield* this._calculateMoments();
      let next = 0;
      const volumeVariance = createArray1D(this._colors);
      for (let cubeIndex = 1;cubeIndex < this._colors; ++cubeIndex) {
        if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
          volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;
          volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;
        } else {
          volumeVariance[next] = 0;
          cubeIndex--;
        }
        next = 0;
        let temp = volumeVariance[0];
        for (let index = 1;index <= cubeIndex; ++index) {
          if (volumeVariance[index] > temp) {
            temp = volumeVariance[index];
            next = index;
          }
        }
        if (temp <= 0) {
          this._colors = cubeIndex + 1;
          break;
        }
      }
      const lookupRed = [];
      const lookupGreen = [];
      const lookupBlue = [];
      const lookupAlpha = [];
      for (let k = 0;k < this._colors; ++k) {
        const weight = _WuQuant._volume(this._cubes[k], this._weights);
        if (weight > 0) {
          lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0;
          lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0;
          lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0;
          lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0;
        } else {
          lookupRed[k] = 0;
          lookupGreen[k] = 0;
          lookupBlue[k] = 0;
          lookupAlpha[k] = 0;
        }
      }
      this._reds = createArray1D(this._colors + 1);
      this._greens = createArray1D(this._colors + 1);
      this._blues = createArray1D(this._colors + 1);
      this._alphas = createArray1D(this._colors + 1);
      this._sums = createArray1D(this._colors + 1);
      for (let index = 0, l = this._pixels.length;index < l; index++) {
        const color = this._pixels[index];
        const match = -1;
        let bestMatch = match;
        let bestDistance = Number.MAX_VALUE;
        for (let lookup = 0;lookup < this._colors; lookup++) {
          const foundRed = lookupRed[lookup];
          const foundGreen = lookupGreen[lookup];
          const foundBlue = lookupBlue[lookup];
          const foundAlpha = lookupAlpha[lookup];
          const distance2 = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
          if (distance2 < bestDistance) {
            bestDistance = distance2;
            bestMatch = lookup;
          }
        }
        this._reds[bestMatch] += color.r;
        this._greens[bestMatch] += color.g;
        this._blues[bestMatch] += color.b;
        this._alphas[bestMatch] += color.a;
        this._sums[bestMatch]++;
      }
    }
    _addColor(color) {
      const bitsToRemove = 8 - this._significantBitsPerChannel;
      const indexRed = (color.r >> bitsToRemove) + 1;
      const indexGreen = (color.g >> bitsToRemove) + 1;
      const indexBlue = (color.b >> bitsToRemove) + 1;
      const indexAlpha = (color.a >> bitsToRemove) + 1;
      this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
      this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
      this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
      this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
      this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
      this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
    }
    *_calculateMoments() {
      const area = [];
      const areaRed = [];
      const areaGreen = [];
      const areaBlue = [];
      const areaAlpha = [];
      const area2 = [];
      const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);
      const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);
      const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);
      const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);
      const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);
      const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
      let trackerProgress = 0;
      const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
      for (let alphaIndex = 1;alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
        fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
        fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
        fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
        fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
        fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
        fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
        for (let redIndex = 1;redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {
          if (tracker.shouldNotify(trackerProgress)) {
            yield {
              progress: tracker.progress
            };
          }
          fillArray1D(area, this._sideSize, 0);
          fillArray1D(areaRed, this._sideSize, 0);
          fillArray1D(areaGreen, this._sideSize, 0);
          fillArray1D(areaBlue, this._sideSize, 0);
          fillArray1D(areaAlpha, this._sideSize, 0);
          fillArray1D(area2, this._sideSize, 0);
          for (let greenIndex = 1;greenIndex <= this._maxSideIndex; ++greenIndex) {
            let line = 0;
            let lineRed = 0;
            let lineGreen = 0;
            let lineBlue = 0;
            let lineAlpha = 0;
            let line2 = 0;
            for (let blueIndex = 1;blueIndex <= this._maxSideIndex; ++blueIndex) {
              line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
              lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
              lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
              lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
              lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
              line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
              area[blueIndex] += line;
              areaRed[blueIndex] += lineRed;
              areaGreen[blueIndex] += lineGreen;
              areaBlue[blueIndex] += lineBlue;
              areaAlpha[blueIndex] += lineAlpha;
              area2[blueIndex] += line2;
              xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
              xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
              xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
              xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
              xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
              xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
              this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
              this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
              this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
              this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
              this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
              this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
            }
          }
        }
      }
    }
    static _volumeFloat(cube, moment) {
      return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
    }
    static _volume(cube, moment) {
      return _WuQuant._volumeFloat(cube, moment) | 0;
    }
    static _top(cube, direction, position, moment) {
      let result;
      switch (direction) {
        case _WuQuant._alpha:
          result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
          break;
        case _WuQuant._red:
          result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
          break;
        case _WuQuant._green:
          result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
          break;
        case _WuQuant._blue:
          result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
          break;
        default:
          throw new Error("impossible");
      }
      return result | 0;
    }
    static _bottom(cube, direction, moment) {
      switch (direction) {
        case _WuQuant._alpha:
          return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
        case _WuQuant._red:
          return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
        case _WuQuant._green:
          return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
        case _WuQuant._blue:
          return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
        default:
          return 0;
      }
    }
    _calculateVariance(cube) {
      const volumeRed = _WuQuant._volume(cube, this._momentsRed);
      const volumeGreen = _WuQuant._volume(cube, this._momentsGreen);
      const volumeBlue = _WuQuant._volume(cube, this._momentsBlue);
      const volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);
      const volumeMoment = _WuQuant._volumeFloat(cube, this._moments);
      const volumeWeight = _WuQuant._volume(cube, this._weights);
      const distance2 = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
      return volumeMoment - distance2 / volumeWeight;
    }
    _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
      const bottomRed = _WuQuant._bottom(cube, direction, this._momentsRed) | 0;
      const bottomGreen = _WuQuant._bottom(cube, direction, this._momentsGreen) | 0;
      const bottomBlue = _WuQuant._bottom(cube, direction, this._momentsBlue) | 0;
      const bottomAlpha = _WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;
      const bottomWeight = _WuQuant._bottom(cube, direction, this._weights) | 0;
      let result = 0;
      let cutPosition = -1;
      for (let position = first;position < last; ++position) {
        let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed);
        let halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen);
        let halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue);
        let halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha);
        let halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);
        if (halfWeight !== 0) {
          let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
          let temp = halfDistance / halfWeight;
          halfRed = wholeRed - halfRed;
          halfGreen = wholeGreen - halfGreen;
          halfBlue = wholeBlue - halfBlue;
          halfAlpha = wholeAlpha - halfAlpha;
          halfWeight = wholeWeight - halfWeight;
          if (halfWeight !== 0) {
            halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
            temp += halfDistance / halfWeight;
            if (temp > result) {
              result = temp;
              cutPosition = position;
            }
          }
        }
      }
      return { max: result, position: cutPosition };
    }
    _cut(first, second) {
      let direction;
      const wholeRed = _WuQuant._volume(first, this._momentsRed);
      const wholeGreen = _WuQuant._volume(first, this._momentsGreen);
      const wholeBlue = _WuQuant._volume(first, this._momentsBlue);
      const wholeAlpha = _WuQuant._volume(first, this._momentsAlpha);
      const wholeWeight = _WuQuant._volume(first, this._weights);
      const red2 = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
      const green2 = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
      const blue2 = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
      const alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
      if (alpha.max >= red2.max && alpha.max >= green2.max && alpha.max >= blue2.max) {
        direction = _WuQuant._alpha;
        if (alpha.position < 0)
          return false;
      } else if (red2.max >= alpha.max && red2.max >= green2.max && red2.max >= blue2.max) {
        direction = _WuQuant._red;
      } else if (green2.max >= alpha.max && green2.max >= red2.max && green2.max >= blue2.max) {
        direction = _WuQuant._green;
      } else {
        direction = _WuQuant._blue;
      }
      second.redMaximum = first.redMaximum;
      second.greenMaximum = first.greenMaximum;
      second.blueMaximum = first.blueMaximum;
      second.alphaMaximum = first.alphaMaximum;
      switch (direction) {
        case _WuQuant._red:
          second.redMinimum = first.redMaximum = red2.position;
          second.greenMinimum = first.greenMinimum;
          second.blueMinimum = first.blueMinimum;
          second.alphaMinimum = first.alphaMinimum;
          break;
        case _WuQuant._green:
          second.greenMinimum = first.greenMaximum = green2.position;
          second.redMinimum = first.redMinimum;
          second.blueMinimum = first.blueMinimum;
          second.alphaMinimum = first.alphaMinimum;
          break;
        case _WuQuant._blue:
          second.blueMinimum = first.blueMaximum = blue2.position;
          second.redMinimum = first.redMinimum;
          second.greenMinimum = first.greenMinimum;
          second.alphaMinimum = first.alphaMinimum;
          break;
        case _WuQuant._alpha:
          second.alphaMinimum = first.alphaMaximum = alpha.position;
          second.blueMinimum = first.blueMinimum;
          second.redMinimum = first.redMinimum;
          second.greenMinimum = first.greenMinimum;
          break;
      }
      first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
      second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
      return true;
    }
    _initialize(colors) {
      this._colors = colors;
      this._cubes = [];
      for (let cubeIndex = 0;cubeIndex < colors; cubeIndex++) {
        this._cubes[cubeIndex] = new WuColorCube;
      }
      this._cubes[0].redMinimum = 0;
      this._cubes[0].greenMinimum = 0;
      this._cubes[0].blueMinimum = 0;
      this._cubes[0].alphaMinimum = 0;
      this._cubes[0].redMaximum = this._maxSideIndex;
      this._cubes[0].greenMaximum = this._maxSideIndex;
      this._cubes[0].blueMaximum = this._maxSideIndex;
      this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
      this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
      this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
      this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
      this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
      this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
      this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
      this._table = [];
      for (let tableIndex = 0;tableIndex < 256; ++tableIndex) {
        this._table[tableIndex] = tableIndex * tableIndex;
      }
      this._pixels = [];
    }
    _setQuality(significantBitsPerChannel = 5) {
      this._significantBitsPerChannel = significantBitsPerChannel;
      this._maxSideIndex = 1 << this._significantBitsPerChannel;
      this._alphaMaxSideIndex = this._maxSideIndex;
      this._sideSize = this._maxSideIndex + 1;
      this._alphaSideSize = this._alphaMaxSideIndex + 1;
    }
  };
  var WuQuant = _WuQuant;
  __publicField(WuQuant, "_alpha", 3);
  __publicField(WuQuant, "_red", 2);
  __publicField(WuQuant, "_green", 1);
  __publicField(WuQuant, "_blue", 0);
  var image_exports = {};
  __export2(image_exports, {
    AbstractImageQuantizer: () => AbstractImageQuantizer,
    ErrorDiffusionArray: () => ErrorDiffusionArray,
    ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,
    ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,
    NearestColor: () => NearestColor
  });
  var AbstractImageQuantizer = class {
    quantizeSync(pointContainer, palette2) {
      for (const value of this.quantize(pointContainer, palette2)) {
        if (value.pointContainer) {
          return value.pointContainer;
        }
      }
      throw new Error("unreachable");
    }
  };
  var NearestColor = class extends AbstractImageQuantizer {
    constructor(colorDistanceCalculator) {
      super();
      __publicField(this, "_distance");
      this._distance = colorDistanceCalculator;
    }
    *quantize(pointContainer, palette2) {
      const pointArray = pointContainer.getPointArray();
      const width = pointContainer.getWidth();
      const height = pointContainer.getHeight();
      const tracker = new ProgressTracker(height, 99);
      for (let y2 = 0;y2 < height; y2++) {
        if (tracker.shouldNotify(y2)) {
          yield {
            progress: tracker.progress
          };
        }
        for (let x2 = 0, idx = y2 * width;x2 < width; x2++, idx++) {
          const point = pointArray[idx];
          point.from(palette2.getNearestColor(this._distance, point));
        }
      }
      yield {
        pointContainer,
        progress: 100
      };
    }
  };
  var ErrorDiffusionArrayKernel = /* @__PURE__ */ ((ErrorDiffusionArrayKernel2) => {
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FloydSteinberg"] = 0] = "FloydSteinberg";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Stucki"] = 2] = "Stucki";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Atkinson"] = 3] = "Atkinson";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Jarvis"] = 4] = "Jarvis";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Burkes"] = 5] = "Burkes";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Sierra"] = 6] = "Sierra";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["TwoSierra"] = 7] = "TwoSierra";
    ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["SierraLite"] = 8] = "SierraLite";
    return ErrorDiffusionArrayKernel2;
  })(ErrorDiffusionArrayKernel || {});
  var ErrorDiffusionArray = class extends AbstractImageQuantizer {
    constructor(colorDistanceCalculator, kernel, serpentine = true, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = false) {
      super();
      __publicField(this, "_minColorDistance");
      __publicField(this, "_serpentine");
      __publicField(this, "_kernel");
      __publicField(this, "_calculateErrorLikeGIMP");
      __publicField(this, "_distance");
      this._setKernel(kernel);
      this._distance = colorDistanceCalculator;
      this._minColorDistance = minimumColorDistanceToDither;
      this._serpentine = serpentine;
      this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
    }
    *quantize(pointContainer, palette2) {
      const pointArray = pointContainer.getPointArray();
      const originalPoint = new Point;
      const width = pointContainer.getWidth();
      const height = pointContainer.getHeight();
      const errorLines = [];
      let dir = 1;
      let maxErrorLines = 1;
      for (const kernel of this._kernel) {
        const kernelErrorLines = kernel[2] + 1;
        if (maxErrorLines < kernelErrorLines)
          maxErrorLines = kernelErrorLines;
      }
      for (let i2 = 0;i2 < maxErrorLines; i2++) {
        this._fillErrorLine(errorLines[i2] = [], width);
      }
      const tracker = new ProgressTracker(height, 99);
      for (let y2 = 0;y2 < height; y2++) {
        if (tracker.shouldNotify(y2)) {
          yield {
            progress: tracker.progress
          };
        }
        if (this._serpentine)
          dir *= -1;
        const lni = y2 * width;
        const xStart = dir === 1 ? 0 : width - 1;
        const xEnd = dir === 1 ? width : -1;
        this._fillErrorLine(errorLines[0], width);
        errorLines.push(errorLines.shift());
        const errorLine = errorLines[0];
        for (let x2 = xStart, idx = lni + xStart;x2 !== xEnd; x2 += dir, idx += dir) {
          const point = pointArray[idx];
          const error = errorLine[x2];
          originalPoint.from(point);
          const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3]));
          const palettePoint = palette2.getNearestColor(this._distance, correctedPoint);
          point.from(palettePoint);
          if (this._minColorDistance) {
            const dist = this._distance.calculateNormalized(originalPoint, palettePoint);
            if (dist < this._minColorDistance)
              continue;
          }
          let er;
          let eg;
          let eb;
          let ea;
          if (this._calculateErrorLikeGIMP) {
            er = correctedPoint.r - palettePoint.r;
            eg = correctedPoint.g - palettePoint.g;
            eb = correctedPoint.b - palettePoint.b;
            ea = correctedPoint.a - palettePoint.a;
          } else {
            er = originalPoint.r - palettePoint.r;
            eg = originalPoint.g - palettePoint.g;
            eb = originalPoint.b - palettePoint.b;
            ea = originalPoint.a - palettePoint.a;
          }
          const dStart = dir === 1 ? 0 : this._kernel.length - 1;
          const dEnd = dir === 1 ? this._kernel.length : -1;
          for (let i2 = dStart;i2 !== dEnd; i2 += dir) {
            const x1 = this._kernel[i2][1] * dir;
            const y1 = this._kernel[i2][2];
            if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {
              const d = this._kernel[i2][0];
              const e = errorLines[y1][x1 + x2];
              e[0] += er * d;
              e[1] += eg * d;
              e[2] += eb * d;
              e[3] += ea * d;
            }
          }
        }
      }
      yield {
        pointContainer,
        progress: 100
      };
    }
    _fillErrorLine(errorLine, width) {
      if (errorLine.length > width) {
        errorLine.length = width;
      }
      const l = errorLine.length;
      for (let i2 = 0;i2 < l; i2++) {
        const error = errorLine[i2];
        error[0] = error[1] = error[2] = error[3] = 0;
      }
      for (let i2 = l;i2 < width; i2++) {
        errorLine[i2] = [0, 0, 0, 0];
      }
    }
    _setKernel(kernel) {
      switch (kernel) {
        case 0:
          this._kernel = [
            [7 / 16, 1, 0],
            [3 / 16, -1, 1],
            [5 / 16, 0, 1],
            [1 / 16, 1, 1]
          ];
          break;
        case 1:
          this._kernel = [
            [3 / 8, 1, 0],
            [3 / 8, 0, 1],
            [2 / 8, 1, 1]
          ];
          break;
        case 2:
          this._kernel = [
            [8 / 42, 1, 0],
            [4 / 42, 2, 0],
            [2 / 42, -2, 1],
            [4 / 42, -1, 1],
            [8 / 42, 0, 1],
            [4 / 42, 1, 1],
            [2 / 42, 2, 1],
            [1 / 42, -2, 2],
            [2 / 42, -1, 2],
            [4 / 42, 0, 2],
            [2 / 42, 1, 2],
            [1 / 42, 2, 2]
          ];
          break;
        case 3:
          this._kernel = [
            [1 / 8, 1, 0],
            [1 / 8, 2, 0],
            [1 / 8, -1, 1],
            [1 / 8, 0, 1],
            [1 / 8, 1, 1],
            [1 / 8, 0, 2]
          ];
          break;
        case 4:
          this._kernel = [
            [7 / 48, 1, 0],
            [5 / 48, 2, 0],
            [3 / 48, -2, 1],
            [5 / 48, -1, 1],
            [7 / 48, 0, 1],
            [5 / 48, 1, 1],
            [3 / 48, 2, 1],
            [1 / 48, -2, 2],
            [3 / 48, -1, 2],
            [5 / 48, 0, 2],
            [3 / 48, 1, 2],
            [1 / 48, 2, 2]
          ];
          break;
        case 5:
          this._kernel = [
            [8 / 32, 1, 0],
            [4 / 32, 2, 0],
            [2 / 32, -2, 1],
            [4 / 32, -1, 1],
            [8 / 32, 0, 1],
            [4 / 32, 1, 1],
            [2 / 32, 2, 1]
          ];
          break;
        case 6:
          this._kernel = [
            [5 / 32, 1, 0],
            [3 / 32, 2, 0],
            [2 / 32, -2, 1],
            [4 / 32, -1, 1],
            [5 / 32, 0, 1],
            [4 / 32, 1, 1],
            [2 / 32, 2, 1],
            [2 / 32, -1, 2],
            [3 / 32, 0, 2],
            [2 / 32, 1, 2]
          ];
          break;
        case 7:
          this._kernel = [
            [4 / 16, 1, 0],
            [3 / 16, 2, 0],
            [1 / 16, -2, 1],
            [2 / 16, -1, 1],
            [3 / 16, 0, 1],
            [2 / 16, 1, 1],
            [1 / 16, 2, 1]
          ];
          break;
        case 8:
          this._kernel = [
            [2 / 4, 1, 0],
            [1 / 4, -1, 1],
            [1 / 4, 0, 1]
          ];
          break;
        default:
          throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);
      }
    }
  };
  function* hilbertCurve(width, height, callback) {
    const maxBound = Math.max(width, height);
    const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);
    const tracker = new ProgressTracker(width * height, 99);
    const data = {
      width,
      height,
      level,
      callback,
      tracker,
      index: 0,
      x: 0,
      y: 0
    };
    yield* walkHilbert(data, 1);
    visit(data, 0);
  }
  function* walkHilbert(data, direction) {
    if (data.level < 1)
      return;
    if (data.tracker.shouldNotify(data.index)) {
      yield { progress: data.tracker.progress };
    }
    data.level--;
    switch (direction) {
      case 2:
        yield* walkHilbert(data, 1);
        visit(data, 3);
        yield* walkHilbert(data, 2);
        visit(data, 4);
        yield* walkHilbert(data, 2);
        visit(data, 2);
        yield* walkHilbert(data, 4);
        break;
      case 3:
        yield* walkHilbert(data, 4);
        visit(data, 2);
        yield* walkHilbert(data, 3);
        visit(data, 1);
        yield* walkHilbert(data, 3);
        visit(data, 3);
        yield* walkHilbert(data, 1);
        break;
      case 1:
        yield* walkHilbert(data, 2);
        visit(data, 4);
        yield* walkHilbert(data, 1);
        visit(data, 3);
        yield* walkHilbert(data, 1);
        visit(data, 1);
        yield* walkHilbert(data, 3);
        break;
      case 4:
        yield* walkHilbert(data, 3);
        visit(data, 1);
        yield* walkHilbert(data, 4);
        visit(data, 2);
        yield* walkHilbert(data, 4);
        visit(data, 4);
        yield* walkHilbert(data, 2);
        break;
      default:
        break;
    }
    data.level++;
  }
  function visit(data, direction) {
    if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {
      data.callback(data.x, data.y);
      data.index++;
    }
    switch (direction) {
      case 2:
        data.x--;
        break;
      case 3:
        data.x++;
        break;
      case 1:
        data.y--;
        break;
      case 4:
        data.y++;
        break;
    }
  }
  var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
    constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {
      super();
      __publicField(this, "_distance");
      __publicField(this, "_weights");
      __publicField(this, "_errorQueueSize");
      this._distance = colorDistanceCalculator;
      this._errorQueueSize = errorQueueSize;
      this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);
    }
    *quantize(pointContainer, palette2) {
      const pointArray = pointContainer.getPointArray();
      const width = pointContainer.getWidth();
      const height = pointContainer.getHeight();
      const errorQueue = [];
      let head = 0;
      for (let i2 = 0;i2 < this._errorQueueSize; i2++) {
        errorQueue[i2] = { r: 0, g: 0, b: 0, a: 0 };
      }
      yield* hilbertCurve(width, height, (x2, y2) => {
        const p = pointArray[x2 + y2 * width];
        let { r, g, b, a: a2 } = p;
        for (let i2 = 0;i2 < this._errorQueueSize; i2++) {
          const weight = this._weights[i2];
          const e = errorQueue[(i2 + head) % this._errorQueueSize];
          r += e.r * weight;
          g += e.g * weight;
          b += e.b * weight;
          a2 += e.a * weight;
        }
        const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a2));
        const quantizedPoint = palette2.getNearestColor(this._distance, correctedPoint);
        head = (head + 1) % this._errorQueueSize;
        const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;
        errorQueue[tail].r = p.r - quantizedPoint.r;
        errorQueue[tail].g = p.g - quantizedPoint.g;
        errorQueue[tail].b = p.b - quantizedPoint.b;
        errorQueue[tail].a = p.a - quantizedPoint.a;
        p.from(quantizedPoint);
      });
      yield {
        pointContainer,
        progress: 100
      };
    }
    static _createWeights(errorPropagation, errorQueueSize) {
      const weights = [];
      const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));
      for (let i2 = 0, next = 1;i2 < errorQueueSize; i2++) {
        weights[i2] = (next + 0.5 | 0) / errorQueueSize * errorPropagation;
        next *= multiplier;
      }
      return weights;
    }
  };
  var quality_exports = {};
  __export2(quality_exports, {
    ssim: () => ssim
  });
  var K1 = 0.01;
  var K2 = 0.03;
  function ssim(image1, image22) {
    if (image1.getHeight() !== image22.getHeight() || image1.getWidth() !== image22.getWidth()) {
      throw new Error("Images have different sizes!");
    }
    const bitsPerComponent = 8;
    const L = (1 << bitsPerComponent) - 1;
    const c1 = (K1 * L) ** 2;
    const c22 = (K2 * L) ** 2;
    let numWindows = 0;
    let mssim = 0;
    iterate(image1, image22, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {
      let sigxy = 0;
      let sigsqx = 0;
      let sigsqy = 0;
      for (let i2 = 0;i2 < lumaValues1.length; i2++) {
        sigsqx += (lumaValues1[i2] - averageLumaValue1) ** 2;
        sigsqy += (lumaValues2[i2] - averageLumaValue2) ** 2;
        sigxy += (lumaValues1[i2] - averageLumaValue1) * (lumaValues2[i2] - averageLumaValue2);
      }
      const numPixelsInWin = lumaValues1.length - 1;
      sigsqx /= numPixelsInWin;
      sigsqy /= numPixelsInWin;
      sigxy /= numPixelsInWin;
      const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c22);
      const denominator = (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c22);
      const ssim2 = numerator / denominator;
      mssim += ssim2;
      numWindows++;
    });
    return mssim / numWindows;
  }
  function iterate(image1, image22, callback) {
    const windowSize = 8;
    const width = image1.getWidth();
    const height = image1.getHeight();
    for (let y2 = 0;y2 < height; y2 += windowSize) {
      for (let x2 = 0;x2 < width; x2 += windowSize) {
        const windowWidth = Math.min(windowSize, width - x2);
        const windowHeight = Math.min(windowSize, height - y2);
        const lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight);
        const lumaValues2 = calculateLumaValuesForWindow(image22, x2, y2, windowWidth, windowHeight);
        const averageLuma1 = calculateAverageLuma(lumaValues1);
        const averageLuma2 = calculateAverageLuma(lumaValues2);
        callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
      }
    }
  }
  function calculateLumaValuesForWindow(image3, x2, y2, width, height) {
    const pointArray = image3.getPointArray();
    const lumaValues = [];
    let counter = 0;
    for (let j = y2;j < y2 + height; j++) {
      const offset = j * image3.getWidth();
      for (let i2 = x2;i2 < x2 + width; i2++) {
        const point = pointArray[offset + i2];
        lumaValues[counter] = point.r * 0.2126 + point.g * 0.7152 + point.b * 0.0722;
        counter++;
      }
    }
    return lumaValues;
  }
  function calculateAverageLuma(lumaValues) {
    let sumLuma = 0;
    for (const luma of lumaValues) {
      sumLuma += luma;
    }
    return sumLuma / lumaValues.length;
  }
  var setImmediateImpl = typeof setImmediate === "function" ? setImmediate : typeof process !== "undefined" && typeof (process == null ? undefined : process.nextTick) === "function" ? (callback) => process.nextTick(callback) : (callback) => setTimeout(callback, 0);
  function buildPaletteSync(images, {
    colorDistanceFormula,
    paletteQuantization,
    colors
  } = {}) {
    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
    images.forEach((image3) => paletteQuantizer.sample(image3));
    return paletteQuantizer.quantizeSync();
  }
  async function buildPalette(images, {
    colorDistanceFormula,
    paletteQuantization,
    colors,
    onProgress
  } = {}) {
    return new Promise((resolve2, reject2) => {
      const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
      const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
      images.forEach((image3) => paletteQuantizer.sample(image3));
      let palette2;
      const iterator = paletteQuantizer.quantize();
      const next = () => {
        try {
          const result = iterator.next();
          if (result.done) {
            resolve2(palette2);
          } else {
            if (result.value.palette)
              palette2 = result.value.palette;
            if (onProgress)
              onProgress(result.value.progress);
            setImmediateImpl(next);
          }
        } catch (error) {
          reject2(error);
        }
      };
      setImmediateImpl(next);
    });
  }
  function applyPaletteSync(image3, palette2, { colorDistanceFormula, imageQuantization } = {}) {
    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
    const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
    return imageQuantizer.quantizeSync(image3, palette2);
  }
  async function applyPalette(image3, palette2, {
    colorDistanceFormula,
    imageQuantization,
    onProgress
  } = {}) {
    return new Promise((resolve2, reject2) => {
      const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
      const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
      let outPointContainer;
      const iterator = imageQuantizer.quantize(image3, palette2);
      const next = () => {
        try {
          const result = iterator.next();
          if (result.done) {
            resolve2(outPointContainer);
          } else {
            if (result.value.pointContainer) {
              outPointContainer = result.value.pointContainer;
            }
            if (onProgress)
              onProgress(result.value.progress);
            setImmediateImpl(next);
          }
        } catch (error) {
          reject2(error);
        }
      };
      setImmediateImpl(next);
    });
  }
  function colorDistanceFormulaToColorDistance(colorDistanceFormula = "euclidean-bt709") {
    switch (colorDistanceFormula) {
      case "cie94-graphic-arts":
        return new CIE94GraphicArts;
      case "cie94-textiles":
        return new CIE94Textiles;
      case "ciede2000":
        return new CIEDE2000;
      case "color-metric":
        return new CMetric;
      case "euclidean":
        return new Euclidean;
      case "euclidean-bt709":
        return new EuclideanBT709;
      case "euclidean-bt709-noalpha":
        return new EuclideanBT709NoAlpha;
      case "manhattan":
        return new Manhattan;
      case "manhattan-bt709":
        return new ManhattanBT709;
      case "manhattan-nommyde":
        return new ManhattanNommyde;
      case "pngquant":
        return new PNGQuant;
      default:
        throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);
    }
  }
  function imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = "floyd-steinberg") {
    switch (imageQuantization) {
      case "nearest":
        return new NearestColor(distanceCalculator);
      case "riemersma":
        return new ErrorDiffusionRiemersma(distanceCalculator);
      case "floyd-steinberg":
        return new ErrorDiffusionArray(distanceCalculator, 0);
      case "false-floyd-steinberg":
        return new ErrorDiffusionArray(distanceCalculator, 1);
      case "stucki":
        return new ErrorDiffusionArray(distanceCalculator, 2);
      case "atkinson":
        return new ErrorDiffusionArray(distanceCalculator, 3);
      case "jarvis":
        return new ErrorDiffusionArray(distanceCalculator, 4);
      case "burkes":
        return new ErrorDiffusionArray(distanceCalculator, 5);
      case "sierra":
        return new ErrorDiffusionArray(distanceCalculator, 6);
      case "two-sierra":
        return new ErrorDiffusionArray(distanceCalculator, 7);
      case "sierra-lite":
        return new ErrorDiffusionArray(distanceCalculator, 8);
      default:
        throw new Error(`Unknown imageQuantization ${imageQuantization}`);
    }
  }
  function paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = "wuquant", colors = 256) {
    switch (paletteQuantization) {
      case "neuquant":
        return new NeuQuant(distanceCalculator, colors);
      case "rgbquant":
        return new RGBQuant(distanceCalculator, colors);
      case "wuquant":
        return new WuQuant(distanceCalculator, colors);
      case "neuquant-float":
        return new NeuQuantFloat(distanceCalculator, colors);
      default:
        throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);
    }
  }
  module.exports = __toCommonJS(src_exports);
});

// node_modules/gifwrap/src/gifframe.js
var require_gifframe = __commonJS((exports) => {
  var BitmapImage = require_bitmapimage();
  var { GifError: GifError2 } = require_gif();

  class GifFrame extends BitmapImage {
    constructor(...args) {
      super(...args);
      if (args[0] instanceof GifFrame) {
        const source = args[0];
        this.xOffset = source.xOffset;
        this.yOffset = source.yOffset;
        this.disposalMethod = source.disposalMethod;
        this.delayCentisecs = source.delayCentisecs;
        this.interlaced = source.interlaced;
      } else {
        const lastArg = args[args.length - 1];
        let options = {};
        if (typeof lastArg === "object" && !(lastArg instanceof BitmapImage)) {
          options = lastArg;
        }
        this.xOffset = options.xOffset || 0;
        this.yOffset = options.yOffset || 0;
        this.disposalMethod = options.disposalMethod !== undefined ? options.disposalMethod : GifFrame.DisposeToBackgroundColor;
        this.delayCentisecs = options.delayCentisecs || 8;
        this.interlaced = options.interlaced || false;
      }
    }
    getPalette() {
      const colorSet = new Set;
      const buf = this.bitmap.data;
      let i2 = 0;
      let usesTransparency = false;
      while (i2 < buf.length) {
        if (buf[i2 + 3] === 0) {
          usesTransparency = true;
        } else {
          const color = buf.readUInt32BE(i2, true) >> 8 & 16777215;
          colorSet.add(color);
        }
        i2 += 4;
      }
      const colors = new Array(colorSet.size);
      const iter = colorSet.values();
      for (i2 = 0;i2 < colors.length; ++i2) {
        colors[i2] = iter.next().value;
      }
      colors.sort((a2, b) => a2 - b);
      let indexCount = colors.length;
      if (usesTransparency) {
        ++indexCount;
      }
      return { colors, usesTransparency, indexCount };
    }
  }
  GifFrame.DisposeToAnything = 0;
  GifFrame.DisposeNothing = 1;
  GifFrame.DisposeToBackgroundColor = 2;
  GifFrame.DisposeToPrevious = 3;
  exports.GifFrame = GifFrame;
});

// node_modules/gifwrap/src/gifutil.js
var require_gifutil = __commonJS((exports) => {
  var fs5 = __require("fs");
  var ImageQ = require_image_q();
  var BitmapImage = require_bitmapimage();
  var { GifFrame } = require_gifframe();
  var { GifError: GifError2 } = require_gif();
  var { GifCodec } = require_gifcodec();
  var INVALID_SUFFIXES = [".jpg", ".jpeg", ".png", ".bmp"];
  var defaultCodec = new GifCodec;
  exports.cloneFrames = function(frames) {
    let clones = [];
    frames.forEach((frame) => {
      clones.push(new GifFrame(frame));
    });
    return clones;
  };
  exports.getColorInfo = function(frames, maxGlobalIndex) {
    let usesTransparency = false;
    const palettes = [];
    for (let i2 = 0;i2 < frames.length; ++i2) {
      let palette2 = frames[i2].getPalette();
      if (palette2.usesTransparency) {
        usesTransparency = true;
      }
      if (palette2.indexCount > 256) {
        throw new GifError2(`Frame ${i2} uses more than 256 color indexes`);
      }
      palettes.push(palette2);
    }
    if (maxGlobalIndex === 0) {
      return { usesTransparency, palettes };
    }
    const globalColorSet = new Set;
    palettes.forEach((palette2) => {
      palette2.colors.forEach((color) => {
        globalColorSet.add(color);
      });
    });
    let indexCount = globalColorSet.size;
    if (usesTransparency) {
      ++indexCount;
    }
    if (maxGlobalIndex && indexCount > maxGlobalIndex) {
      return { usesTransparency, palettes };
    }
    const colors = new Array(globalColorSet.size);
    const iter = globalColorSet.values();
    for (let i2 = 0;i2 < colors.length; ++i2) {
      colors[i2] = iter.next().value;
    }
    colors.sort((a2, b) => a2 - b);
    return { colors, indexCount, usesTransparency, palettes };
  };
  exports.copyAsJimp = function(jimp, bitmapImageToCopy) {
    return exports.shareAsJimp(jimp, new BitmapImage(bitmapImageToCopy));
  };
  exports.getMaxDimensions = function(frames) {
    let maxWidth = 0, maxHeight = 0;
    frames.forEach((frame) => {
      const width = frame.xOffset + frame.bitmap.width;
      if (width > maxWidth) {
        maxWidth = width;
      }
      const height = frame.yOffset + frame.bitmap.height;
      if (height > maxHeight) {
        maxHeight = height;
      }
    });
    return { maxWidth, maxHeight };
  };
  exports.quantizeDekker = function(imageOrImages, maxColorIndexes, dither) {
    maxColorIndexes = maxColorIndexes || 256;
    _quantize(imageOrImages, "NeuQuantFloat", maxColorIndexes, 0, dither);
  };
  exports.quantizeSorokin = function(imageOrImages, maxColorIndexes, histogram, dither) {
    maxColorIndexes = maxColorIndexes || 256;
    histogram = histogram || "min-pop";
    let histogramID;
    switch (histogram) {
      case "min-pop":
        histogramID = 2;
        break;
      case "top-pop":
        histogramID = 1;
        break;
      default:
        throw new Error(`Invalid quantizeSorokin histogram '${histogram}'`);
    }
    _quantize(imageOrImages, "RGBQuant", maxColorIndexes, histogramID, dither);
  };
  exports.quantizeWu = function(imageOrImages, maxColorIndexes, significantBits, dither) {
    maxColorIndexes = maxColorIndexes || 256;
    significantBits = significantBits || 5;
    if (significantBits < 1 || significantBits > 8) {
      throw new Error("Invalid quantization quality");
    }
    _quantize(imageOrImages, "WuQuant", maxColorIndexes, significantBits, dither);
  };
  exports.read = function(source, decoder) {
    decoder = decoder || defaultCodec;
    if (Buffer.isBuffer(source)) {
      return decoder.decodeGif(source);
    }
    return _readBinary(source).then((buffer) => {
      return decoder.decodeGif(buffer);
    });
  };
  exports.shareAsJimp = function(jimp, bitmapImageToShare) {
    const jimpImage = new jimp(bitmapImageToShare.bitmap.width, bitmapImageToShare.bitmap.height, 0);
    jimpImage.bitmap.data = bitmapImageToShare.bitmap.data;
    return jimpImage;
  };
  exports.write = function(path8, frames, spec, encoder) {
    encoder = encoder || defaultCodec;
    const matches = path8.match(/\.[a-zA-Z]+$/);
    if (matches !== null && INVALID_SUFFIXES.includes(matches[0].toLowerCase())) {
      throw new Error(`GIF '${path8}' has an unexpected suffix`);
    }
    return encoder.encodeGif(frames, spec).then((gif) => {
      return _writeBinary(path8, gif.buffer).then(() => {
        return gif;
      });
    });
  };
  function _quantize(imageOrImages, method, maxColorIndexes, modifier, dither) {
    const images = Array.isArray(imageOrImages) ? imageOrImages : [imageOrImages];
    const ditherAlgs = [
      "FloydSteinberg",
      "FalseFloydSteinberg",
      "Stucki",
      "Atkinson",
      "Jarvis",
      "Burkes",
      "Sierra",
      "TwoSierra",
      "SierraLite"
    ];
    if (dither) {
      if (ditherAlgs.indexOf(dither.ditherAlgorithm) < 0) {
        throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);
      }
      if (dither.serpentine === undefined) {
        dither.serpentine = true;
      }
      if (dither.minimumColorDistanceToDither === undefined) {
        dither.minimumColorDistanceToDither = 0;
      }
      if (dither.calculateErrorLikeGIMP === undefined) {
        dither.calculateErrorLikeGIMP = false;
      }
    }
    const distCalculator = new ImageQ.distance.Euclidean;
    const quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);
    let imageMaker;
    if (dither) {
      imageMaker = new ImageQ.image.ErrorDiffusionArray(distCalculator, ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm], dither.serpentine, dither.minimumColorDistanceToDither, dither.calculateErrorLikeGIMP);
    } else {
      imageMaker = new ImageQ.image.NearestColor(distCalculator);
    }
    const inputContainers = [];
    images.forEach((image3) => {
      const imageBuf = image3.bitmap.data;
      const inputBuf = new ArrayBuffer(imageBuf.length);
      const inputArray = new Uint32Array(inputBuf);
      for (let bi = 0, ai = 0;bi < imageBuf.length; bi += 4, ++ai) {
        inputArray[ai] = imageBuf.readUInt32LE(bi, true);
      }
      const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(inputArray, image3.bitmap.width, image3.bitmap.height);
      quantizer.sample(inputContainer);
      inputContainers.push(inputContainer);
    });
    const limitedPalette = quantizer.quantizeSync();
    for (let i2 = 0;i2 < images.length; ++i2) {
      const imageBuf = images[i2].bitmap.data;
      const outputContainer = imageMaker.quantizeSync(inputContainers[i2], limitedPalette);
      const outputArray = outputContainer.toUint32Array();
      for (let bi = 0, ai = 0;bi < imageBuf.length; bi += 4, ++ai) {
        imageBuf.writeUInt32LE(outputArray[ai], bi);
      }
    }
  }
  function _readBinary(path8) {
    return new Promise((resolve2, reject2) => {
      fs5.readFile(path8, (err, buffer) => {
        if (err) {
          return reject2(err);
        }
        return resolve2(buffer);
      });
    });
  }
  function _writeBinary(path8, buffer) {
    return new Promise((resolve2, reject2) => {
      fs5.writeFile(path8, buffer, (err) => {
        if (err) {
          return reject2(err);
        }
        return resolve2();
      });
    });
  }
});

// node_modules/gifwrap/src/gifcodec.js
var require_gifcodec = __commonJS((exports) => {
  var Omggif = require_omggif();
  var { Gif, GifError: GifError2 } = require_gif();
  function GifUtil() {
    const data = require_gifutil();
    GifUtil = function() {
      return data;
    };
    return data;
  }
  var { GifFrame } = require_gifframe();
  var PER_GIF_OVERHEAD = 200;
  var PER_FRAME_OVERHEAD = 100;

  class GifCodec {
    constructor(options = {}) {
      this._transparentRGB = null;
      if (typeof options.transparentRGB === "number" && options.transparentRGB !== 0) {
        this._transparentRGBA = options.transparentRGB * 256;
      }
      this._testInitialBufferSize = 0;
    }
    decodeGif(buffer) {
      try {
        let reader;
        try {
          reader = new Omggif.GifReader(buffer);
        } catch (err) {
          throw new GifError2(err);
        }
        const frameCount = reader.numFrames();
        const frames = [];
        const spec = {
          width: reader.width,
          height: reader.height,
          loops: reader.loopCount()
        };
        spec.usesTransparency = false;
        for (let i2 = 0;i2 < frameCount; ++i2) {
          const frameInfo = this._decodeFrame(reader, i2, spec.usesTransparency);
          frames.push(frameInfo.frame);
          if (frameInfo.usesTransparency) {
            spec.usesTransparency = true;
          }
        }
        return Promise.resolve(new Gif(buffer, frames, spec));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    encodeGif(frames, spec = {}) {
      try {
        if (frames === null || frames.length === 0) {
          throw new GifError2("there are no frames");
        }
        const dims = GifUtil().getMaxDimensions(frames);
        spec = Object.assign({}, spec);
        spec.width = dims.maxWidth;
        spec.height = dims.maxHeight;
        if (spec.loops === undefined) {
          spec.loops = 0;
        }
        spec.colorScope = spec.colorScope || Gif.GlobalColorsPreferred;
        return Promise.resolve(this._encodeGif(frames, spec));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {
      let info, buffer;
      try {
        info = reader.frameInfo(frameIndex);
        buffer = new Buffer(reader.width * reader.height * 4);
        reader.decodeAndBlitFrameRGBA(frameIndex, buffer);
        if (info.width !== reader.width || info.height !== reader.height) {
          if (info.y) {
            buffer = buffer.slice(info.y * reader.width * 4);
          }
          if (reader.width > info.width) {
            for (let ii = 0;ii < info.height; ++ii) {
              buffer.copy(buffer, ii * info.width * 4, (info.x + ii * reader.width) * 4, (info.x + ii * reader.width) * 4 + info.width * 4);
            }
          }
          buffer = buffer.slice(0, info.width * info.height * 4);
        }
      } catch (err) {
        throw new GifError2(err);
      }
      let usesTransparency = false;
      if (this._transparentRGBA === null) {
        if (!alreadyUsedTransparency) {
          for (let i2 = 3;i2 < buffer.length; i2 += 4) {
            if (buffer[i2] === 0) {
              usesTransparency = true;
              i2 = buffer.length;
            }
          }
        }
      } else {
        for (let i2 = 3;i2 < buffer.length; i2 += 4) {
          if (buffer[i2] === 0) {
            buffer.writeUInt32BE(this._transparentRGBA, i2 - 3);
            usesTransparency = true;
          }
        }
      }
      const frame = new GifFrame(info.width, info.height, buffer, {
        xOffset: info.x,
        yOffset: info.y,
        disposalMethod: info.disposal,
        interlaced: info.interlaced,
        delayCentisecs: info.delay
      });
      return { frame, usesTransparency };
    }
    _encodeGif(frames, spec) {
      let colorInfo;
      if (spec.colorScope === Gif.LocalColorsOnly) {
        colorInfo = GifUtil().getColorInfo(frames, 0);
      } else {
        colorInfo = GifUtil().getColorInfo(frames, 256);
        if (!colorInfo.colors) {
          if (spec.colorScope === Gif.GlobalColorsOnly) {
            throw new GifError2("Too many color indexes for global color table");
          }
          spec.colorScope = Gif.LocalColorsOnly;
        }
      }
      spec.usesTransparency = colorInfo.usesTransparency;
      const localPalettes = colorInfo.palettes;
      if (spec.colorScope === Gif.LocalColorsOnly) {
        const localSizeEst = 2000;
        return _encodeLocal(frames, spec, localSizeEst, localPalettes);
      }
      const globalSizeEst = 2000;
      return _encodeGlobal(frames, spec, globalSizeEst, colorInfo);
    }
    _getSizeEstimateGlobal(globalPalette, frames) {
      if (this._testInitialBufferSize > 0) {
        return this._testInitialBufferSize;
      }
      let sizeEst = PER_GIF_OVERHEAD + 3 * 256;
      const pixelBitWidth = _getPixelBitWidth(globalPalette);
      frames.forEach((frame) => {
        sizeEst += _getFrameSizeEst(frame, pixelBitWidth);
      });
      return sizeEst;
    }
    _getSizeEstimateLocal(palettes, frames) {
      if (this._testInitialBufferSize > 0) {
        return this._testInitialBufferSize;
      }
      let sizeEst = PER_GIF_OVERHEAD;
      for (let i2 = 0;i2 < frames.length; ++i2) {
        const palette2 = palettes[i2];
        const pixelBitWidth = _getPixelBitWidth(palette2);
        sizeEst += _getFrameSizeEst(frames[i2], pixelBitWidth);
      }
      return sizeEst;
    }
  }
  exports.GifCodec = GifCodec;
  function _colorLookupLinear(colors, color) {
    const index = colors.indexOf(color);
    return index === -1 ? null : index;
  }
  function _colorLookupBinary(colors, color) {
    var lo = 0, hi = colors.length - 1, mid;
    while (lo <= hi) {
      mid = Math.floor((lo + hi) / 2);
      if (colors[mid] > color)
        hi = mid - 1;
      else if (colors[mid] < color)
        lo = mid + 1;
      else
        return mid;
    }
    return null;
  }
  function _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {
    const extendedGlobalPalette = {
      colors: globalPalette.colors.slice(),
      usesTransparency: globalPalette.usesTransparency
    };
    _extendPaletteToPowerOf2(extendedGlobalPalette);
    const options = {
      palette: extendedGlobalPalette.colors,
      loop: spec.loops
    };
    let buffer = new Buffer(bufferSizeEst);
    let gifWriter;
    try {
      gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
    } catch (err) {
      throw new GifError2(err);
    }
    for (let i2 = 0;i2 < frames.length; ++i2) {
      buffer = _writeFrame(gifWriter, i2, frames[i2], globalPalette, false);
    }
    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
  }
  function _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {
    const options = {
      loop: spec.loops
    };
    let buffer = new Buffer(bufferSizeEst);
    let gifWriter;
    try {
      gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
    } catch (err) {
      throw new GifError2(err);
    }
    for (let i2 = 0;i2 < frames.length; ++i2) {
      buffer = _writeFrame(gifWriter, i2, frames[i2], localPalettes[i2], true);
    }
    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
  }
  function _extendPaletteToPowerOf2(palette2) {
    const colors = palette2.colors;
    if (palette2.usesTransparency) {
      colors.push(0);
    }
    const colorCount = colors.length;
    let powerOf2 = 2;
    while (colorCount > powerOf2) {
      powerOf2 <<= 1;
    }
    colors.length = powerOf2;
    colors.fill(0, colorCount);
  }
  function _getFrameSizeEst(frame, pixelBitWidth) {
    let byteLength = frame.bitmap.width * frame.bitmap.height;
    byteLength = Math.ceil(byteLength * pixelBitWidth / 8);
    byteLength += Math.ceil(byteLength / 255);
    return PER_FRAME_OVERHEAD + byteLength + 3 * 256;
  }
  function _getIndexedImage(frameIndex, frame, palette2) {
    const colors = palette2.colors;
    const colorToIndexFunc = colors.length <= 8 ? _colorLookupLinear : _colorLookupBinary;
    const colorBuffer = frame.bitmap.data;
    const indexBuffer = new Buffer(colorBuffer.length / 4);
    let transparentIndex = colors.length;
    let i2 = 0, j = 0;
    while (i2 < colorBuffer.length) {
      if (colorBuffer[i2 + 3] !== 0) {
        const color = colorBuffer.readUInt32BE(i2, true) >> 8 & 16777215;
        indexBuffer[j] = colorToIndexFunc(colors, color);
      } else {
        indexBuffer[j] = transparentIndex;
      }
      i2 += 4;
      ++j;
    }
    if (palette2.usesTransparency) {
      if (transparentIndex === 256) {
        throw new GifError2(`Frame ${frameIndex} already has 256 colors` + `and so can't use transparency`);
      }
    } else {
      transparentIndex = null;
    }
    return { buffer: indexBuffer, transparentIndex };
  }
  function _getPixelBitWidth(palette2) {
    let indexCount = palette2.indexCount;
    let pixelBitWidth = 0;
    --indexCount;
    while (indexCount) {
      ++pixelBitWidth;
      indexCount >>= 1;
    }
    return pixelBitWidth > 0 ? pixelBitWidth : 1;
  }
  function _writeFrame(gifWriter, frameIndex, frame, palette2, isLocalPalette) {
    if (frame.interlaced) {
      throw new GifError2("writing interlaced GIFs is not supported");
    }
    const frameInfo = _getIndexedImage(frameIndex, frame, palette2);
    const options = {
      delay: frame.delayCentisecs,
      disposal: frame.disposalMethod,
      transparent: frameInfo.transparentIndex
    };
    if (isLocalPalette) {
      _extendPaletteToPowerOf2(palette2);
      options.palette = palette2.colors;
    }
    try {
      let buffer = gifWriter.getOutputBuffer();
      let startOfFrame = gifWriter.getOutputBufferPosition();
      let endOfFrame;
      let tryAgain = true;
      while (tryAgain) {
        endOfFrame = gifWriter.addFrame(frame.xOffset, frame.yOffset, frame.bitmap.width, frame.bitmap.height, frameInfo.buffer, options);
        tryAgain = false;
        if (endOfFrame >= buffer.length - 1) {
          const biggerBuffer = new Buffer(buffer.length * 1.5);
          buffer.copy(biggerBuffer);
          gifWriter.setOutputBuffer(biggerBuffer);
          gifWriter.setOutputBufferPosition(startOfFrame);
          buffer = biggerBuffer;
          tryAgain = true;
        }
      }
      return buffer;
    } catch (err) {
      throw new GifError2(err);
    }
  }
});

// node_modules/gifwrap/src/index.js
var require_src2 = __commonJS((exports, module) => {
  var BitmapImage = require_bitmapimage();
  var { Gif, GifError: GifError2 } = require_gif();
  var { GifCodec } = require_gifcodec();
  var { GifFrame } = require_gifframe();
  var GifUtil = require_gifutil();
  module.exports = {
    BitmapImage,
    Gif,
    GifCodec,
    GifFrame,
    GifUtil,
    GifError: GifError2
  };
});

// node_modules/jpeg-js/lib/encoder.js
var require_encoder2 = __commonJS((exports, module) => {
  var btoa = btoa || function(buf) {
    return Buffer.from(buf).toString("base64");
  };
  function JPEGEncoder(quality2) {
    var self2 = this;
    var fround = Math.round;
    var ffloor = Math.floor;
    var YTable = new Array(64);
    var UVTable = new Array(64);
    var fdtbl_Y = new Array(64);
    var fdtbl_UV = new Array(64);
    var YDC_HT;
    var UVDC_HT;
    var YAC_HT;
    var UVAC_HT;
    var bitcode = new Array(65535);
    var category = new Array(65535);
    var outputfDCTQuant = new Array(64);
    var DU = new Array(64);
    var byteout = [];
    var bytenew = 0;
    var bytepos = 7;
    var YDU = new Array(64);
    var UDU = new Array(64);
    var VDU = new Array(64);
    var clt = new Array(256);
    var RGB_YUV_TABLE = new Array(2048);
    var currentQuality;
    var ZigZag = [
      0,
      1,
      5,
      6,
      14,
      15,
      27,
      28,
      2,
      4,
      7,
      13,
      16,
      26,
      29,
      42,
      3,
      8,
      12,
      17,
      25,
      30,
      41,
      43,
      9,
      11,
      18,
      24,
      31,
      40,
      44,
      53,
      10,
      19,
      23,
      32,
      39,
      45,
      52,
      54,
      20,
      22,
      33,
      38,
      46,
      51,
      55,
      60,
      21,
      34,
      37,
      47,
      50,
      56,
      59,
      61,
      35,
      36,
      48,
      49,
      57,
      58,
      62,
      63
    ];
    var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
    var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
    var std_ac_luminance_values = [
      1,
      2,
      3,
      0,
      4,
      17,
      5,
      18,
      33,
      49,
      65,
      6,
      19,
      81,
      97,
      7,
      34,
      113,
      20,
      50,
      129,
      145,
      161,
      8,
      35,
      66,
      177,
      193,
      21,
      82,
      209,
      240,
      36,
      51,
      98,
      114,
      130,
      9,
      10,
      22,
      23,
      24,
      25,
      26,
      37,
      38,
      39,
      40,
      41,
      42,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      131,
      132,
      133,
      134,
      135,
      136,
      137,
      138,
      146,
      147,
      148,
      149,
      150,
      151,
      152,
      153,
      154,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250
    ];
    var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
    var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
    var std_ac_chrominance_values = [
      0,
      1,
      2,
      3,
      17,
      4,
      5,
      33,
      49,
      6,
      18,
      65,
      81,
      7,
      97,
      113,
      19,
      34,
      50,
      129,
      8,
      20,
      66,
      145,
      161,
      177,
      193,
      9,
      35,
      51,
      82,
      240,
      21,
      98,
      114,
      209,
      10,
      22,
      36,
      52,
      225,
      37,
      241,
      23,
      24,
      25,
      26,
      38,
      39,
      40,
      41,
      42,
      53,
      54,
      55,
      56,
      57,
      58,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      130,
      131,
      132,
      133,
      134,
      135,
      136,
      137,
      138,
      146,
      147,
      148,
      149,
      150,
      151,
      152,
      153,
      154,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250
    ];
    function initQuantTables(sf) {
      var YQT = [
        16,
        11,
        10,
        16,
        24,
        40,
        51,
        61,
        12,
        12,
        14,
        19,
        26,
        58,
        60,
        55,
        14,
        13,
        16,
        24,
        40,
        57,
        69,
        56,
        14,
        17,
        22,
        29,
        51,
        87,
        80,
        62,
        18,
        22,
        37,
        56,
        68,
        109,
        103,
        77,
        24,
        35,
        55,
        64,
        81,
        104,
        113,
        92,
        49,
        64,
        78,
        87,
        103,
        121,
        120,
        101,
        72,
        92,
        95,
        98,
        112,
        100,
        103,
        99
      ];
      for (var i2 = 0;i2 < 64; i2++) {
        var t = ffloor((YQT[i2] * sf + 50) / 100);
        if (t < 1) {
          t = 1;
        } else if (t > 255) {
          t = 255;
        }
        YTable[ZigZag[i2]] = t;
      }
      var UVQT = [
        17,
        18,
        24,
        47,
        99,
        99,
        99,
        99,
        18,
        21,
        26,
        66,
        99,
        99,
        99,
        99,
        24,
        26,
        56,
        99,
        99,
        99,
        99,
        99,
        47,
        66,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99,
        99
      ];
      for (var j = 0;j < 64; j++) {
        var u2 = ffloor((UVQT[j] * sf + 50) / 100);
        if (u2 < 1) {
          u2 = 1;
        } else if (u2 > 255) {
          u2 = 255;
        }
        UVTable[ZigZag[j]] = u2;
      }
      var aasf = [
        1,
        1.387039845,
        1.306562965,
        1.175875602,
        1,
        0.785694958,
        0.5411961,
        0.275899379
      ];
      var k = 0;
      for (var row = 0;row < 8; row++) {
        for (var col = 0;col < 8; col++) {
          fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
          fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
          k++;
        }
      }
    }
    function computeHuffmanTbl(nrcodes, std_table) {
      var codevalue = 0;
      var pos_in_table = 0;
      var HT = new Array;
      for (var k = 1;k <= 16; k++) {
        for (var j = 1;j <= nrcodes[k]; j++) {
          HT[std_table[pos_in_table]] = [];
          HT[std_table[pos_in_table]][0] = codevalue;
          HT[std_table[pos_in_table]][1] = k;
          pos_in_table++;
          codevalue++;
        }
        codevalue *= 2;
      }
      return HT;
    }
    function initHuffmanTbl() {
      YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
      UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
      YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
      UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
    }
    function initCategoryNumber() {
      var nrlower = 1;
      var nrupper = 2;
      for (var cat = 1;cat <= 15; cat++) {
        for (var nr = nrlower;nr < nrupper; nr++) {
          category[32767 + nr] = cat;
          bitcode[32767 + nr] = [];
          bitcode[32767 + nr][1] = cat;
          bitcode[32767 + nr][0] = nr;
        }
        for (var nrneg = -(nrupper - 1);nrneg <= -nrlower; nrneg++) {
          category[32767 + nrneg] = cat;
          bitcode[32767 + nrneg] = [];
          bitcode[32767 + nrneg][1] = cat;
          bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
        }
        nrlower <<= 1;
        nrupper <<= 1;
      }
    }
    function initRGBYUVTable() {
      for (var i2 = 0;i2 < 256; i2++) {
        RGB_YUV_TABLE[i2] = 19595 * i2;
        RGB_YUV_TABLE[i2 + 256 >> 0] = 38470 * i2;
        RGB_YUV_TABLE[i2 + 512 >> 0] = 7471 * i2 + 32768;
        RGB_YUV_TABLE[i2 + 768 >> 0] = -11059 * i2;
        RGB_YUV_TABLE[i2 + 1024 >> 0] = -21709 * i2;
        RGB_YUV_TABLE[i2 + 1280 >> 0] = 32768 * i2 + 8421375;
        RGB_YUV_TABLE[i2 + 1536 >> 0] = -27439 * i2;
        RGB_YUV_TABLE[i2 + 1792 >> 0] = -5329 * i2;
      }
    }
    function writeBits(bs) {
      var value = bs[0];
      var posval = bs[1] - 1;
      while (posval >= 0) {
        if (value & 1 << posval) {
          bytenew |= 1 << bytepos;
        }
        posval--;
        bytepos--;
        if (bytepos < 0) {
          if (bytenew == 255) {
            writeByte(255);
            writeByte(0);
          } else {
            writeByte(bytenew);
          }
          bytepos = 7;
          bytenew = 0;
        }
      }
    }
    function writeByte(value) {
      byteout.push(value);
    }
    function writeWord(value) {
      writeByte(value >> 8 & 255);
      writeByte(value & 255);
    }
    function fDCTQuant(data, fdtbl) {
      var d0, d1, d2, d3, d4, d5, d6, d7;
      var dataOff = 0;
      var i2;
      var I8 = 8;
      var I64 = 64;
      for (i2 = 0;i2 < I8; ++i2) {
        d0 = data[dataOff];
        d1 = data[dataOff + 1];
        d2 = data[dataOff + 2];
        d3 = data[dataOff + 3];
        d4 = data[dataOff + 4];
        d5 = data[dataOff + 5];
        d6 = data[dataOff + 6];
        d7 = data[dataOff + 7];
        var tmp0 = d0 + d7;
        var tmp7 = d0 - d7;
        var tmp1 = d1 + d6;
        var tmp6 = d1 - d6;
        var tmp2 = d2 + d5;
        var tmp5 = d2 - d5;
        var tmp3 = d3 + d4;
        var tmp4 = d3 - d4;
        var tmp10 = tmp0 + tmp3;
        var tmp13 = tmp0 - tmp3;
        var tmp11 = tmp1 + tmp2;
        var tmp12 = tmp1 - tmp2;
        data[dataOff] = tmp10 + tmp11;
        data[dataOff + 4] = tmp10 - tmp11;
        var z1 = (tmp12 + tmp13) * 0.707106781;
        data[dataOff + 2] = tmp13 + z1;
        data[dataOff + 6] = tmp13 - z1;
        tmp10 = tmp4 + tmp5;
        tmp11 = tmp5 + tmp6;
        tmp12 = tmp6 + tmp7;
        var z5 = (tmp10 - tmp12) * 0.382683433;
        var z2 = 0.5411961 * tmp10 + z5;
        var z4 = 1.306562965 * tmp12 + z5;
        var z3 = tmp11 * 0.707106781;
        var z11 = tmp7 + z3;
        var z13 = tmp7 - z3;
        data[dataOff + 5] = z13 + z2;
        data[dataOff + 3] = z13 - z2;
        data[dataOff + 1] = z11 + z4;
        data[dataOff + 7] = z11 - z4;
        dataOff += 8;
      }
      dataOff = 0;
      for (i2 = 0;i2 < I8; ++i2) {
        d0 = data[dataOff];
        d1 = data[dataOff + 8];
        d2 = data[dataOff + 16];
        d3 = data[dataOff + 24];
        d4 = data[dataOff + 32];
        d5 = data[dataOff + 40];
        d6 = data[dataOff + 48];
        d7 = data[dataOff + 56];
        var tmp0p2 = d0 + d7;
        var tmp7p2 = d0 - d7;
        var tmp1p2 = d1 + d6;
        var tmp6p2 = d1 - d6;
        var tmp2p2 = d2 + d5;
        var tmp5p2 = d2 - d5;
        var tmp3p2 = d3 + d4;
        var tmp4p2 = d3 - d4;
        var tmp10p2 = tmp0p2 + tmp3p2;
        var tmp13p2 = tmp0p2 - tmp3p2;
        var tmp11p2 = tmp1p2 + tmp2p2;
        var tmp12p2 = tmp1p2 - tmp2p2;
        data[dataOff] = tmp10p2 + tmp11p2;
        data[dataOff + 32] = tmp10p2 - tmp11p2;
        var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
        data[dataOff + 16] = tmp13p2 + z1p2;
        data[dataOff + 48] = tmp13p2 - z1p2;
        tmp10p2 = tmp4p2 + tmp5p2;
        tmp11p2 = tmp5p2 + tmp6p2;
        tmp12p2 = tmp6p2 + tmp7p2;
        var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
        var z2p2 = 0.5411961 * tmp10p2 + z5p2;
        var z4p2 = 1.306562965 * tmp12p2 + z5p2;
        var z3p2 = tmp11p2 * 0.707106781;
        var z11p2 = tmp7p2 + z3p2;
        var z13p2 = tmp7p2 - z3p2;
        data[dataOff + 40] = z13p2 + z2p2;
        data[dataOff + 24] = z13p2 - z2p2;
        data[dataOff + 8] = z11p2 + z4p2;
        data[dataOff + 56] = z11p2 - z4p2;
        dataOff++;
      }
      var fDCTQuant2;
      for (i2 = 0;i2 < I64; ++i2) {
        fDCTQuant2 = data[i2] * fdtbl[i2];
        outputfDCTQuant[i2] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
      }
      return outputfDCTQuant;
    }
    function writeAPP0() {
      writeWord(65504);
      writeWord(16);
      writeByte(74);
      writeByte(70);
      writeByte(73);
      writeByte(70);
      writeByte(0);
      writeByte(1);
      writeByte(1);
      writeByte(0);
      writeWord(1);
      writeWord(1);
      writeByte(0);
      writeByte(0);
    }
    function writeAPP1(exifBuffer) {
      if (!exifBuffer)
        return;
      writeWord(65505);
      if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
        writeWord(exifBuffer.length + 2);
      } else {
        writeWord(exifBuffer.length + 5 + 2);
        writeByte(69);
        writeByte(120);
        writeByte(105);
        writeByte(102);
        writeByte(0);
      }
      for (var i2 = 0;i2 < exifBuffer.length; i2++) {
        writeByte(exifBuffer[i2]);
      }
    }
    function writeSOF0(width, height) {
      writeWord(65472);
      writeWord(17);
      writeByte(8);
      writeWord(height);
      writeWord(width);
      writeByte(3);
      writeByte(1);
      writeByte(17);
      writeByte(0);
      writeByte(2);
      writeByte(17);
      writeByte(1);
      writeByte(3);
      writeByte(17);
      writeByte(1);
    }
    function writeDQT() {
      writeWord(65499);
      writeWord(132);
      writeByte(0);
      for (var i2 = 0;i2 < 64; i2++) {
        writeByte(YTable[i2]);
      }
      writeByte(1);
      for (var j = 0;j < 64; j++) {
        writeByte(UVTable[j]);
      }
    }
    function writeDHT() {
      writeWord(65476);
      writeWord(418);
      writeByte(0);
      for (var i2 = 0;i2 < 16; i2++) {
        writeByte(std_dc_luminance_nrcodes[i2 + 1]);
      }
      for (var j = 0;j <= 11; j++) {
        writeByte(std_dc_luminance_values[j]);
      }
      writeByte(16);
      for (var k = 0;k < 16; k++) {
        writeByte(std_ac_luminance_nrcodes[k + 1]);
      }
      for (var l = 0;l <= 161; l++) {
        writeByte(std_ac_luminance_values[l]);
      }
      writeByte(1);
      for (var m = 0;m < 16; m++) {
        writeByte(std_dc_chrominance_nrcodes[m + 1]);
      }
      for (var n2 = 0;n2 <= 11; n2++) {
        writeByte(std_dc_chrominance_values[n2]);
      }
      writeByte(17);
      for (var o2 = 0;o2 < 16; o2++) {
        writeByte(std_ac_chrominance_nrcodes[o2 + 1]);
      }
      for (var p = 0;p <= 161; p++) {
        writeByte(std_ac_chrominance_values[p]);
      }
    }
    function writeCOM(comments) {
      if (typeof comments === "undefined" || comments.constructor !== Array)
        return;
      comments.forEach((e) => {
        if (typeof e !== "string")
          return;
        writeWord(65534);
        var l = e.length;
        writeWord(l + 2);
        var i2;
        for (i2 = 0;i2 < l; i2++)
          writeByte(e.charCodeAt(i2));
      });
    }
    function writeSOS() {
      writeWord(65498);
      writeWord(12);
      writeByte(3);
      writeByte(1);
      writeByte(0);
      writeByte(2);
      writeByte(17);
      writeByte(3);
      writeByte(17);
      writeByte(0);
      writeByte(63);
      writeByte(0);
    }
    function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
      var EOB = HTAC[0];
      var M16zeroes = HTAC[240];
      var pos;
      var I16 = 16;
      var I63 = 63;
      var I64 = 64;
      var DU_DCT = fDCTQuant(CDU, fdtbl);
      for (var j = 0;j < I64; ++j) {
        DU[ZigZag[j]] = DU_DCT[j];
      }
      var Diff = DU[0] - DC;
      DC = DU[0];
      if (Diff == 0) {
        writeBits(HTDC[0]);
      } else {
        pos = 32767 + Diff;
        writeBits(HTDC[category[pos]]);
        writeBits(bitcode[pos]);
      }
      var end0pos = 63;
      for (;end0pos > 0 && DU[end0pos] == 0; end0pos--) {}
      if (end0pos == 0) {
        writeBits(EOB);
        return DC;
      }
      var i2 = 1;
      var lng;
      while (i2 <= end0pos) {
        var startpos = i2;
        for (;DU[i2] == 0 && i2 <= end0pos; ++i2) {}
        var nrzeroes = i2 - startpos;
        if (nrzeroes >= I16) {
          lng = nrzeroes >> 4;
          for (var nrmarker = 1;nrmarker <= lng; ++nrmarker)
            writeBits(M16zeroes);
          nrzeroes = nrzeroes & 15;
        }
        pos = 32767 + DU[i2];
        writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
        writeBits(bitcode[pos]);
        i2++;
      }
      if (end0pos != I63) {
        writeBits(EOB);
      }
      return DC;
    }
    function initCharLookupTable() {
      var sfcc = String.fromCharCode;
      for (var i2 = 0;i2 < 256; i2++) {
        clt[i2] = sfcc(i2);
      }
    }
    this.encode = function(image3, quality3) {
      var time_start = new Date().getTime();
      if (quality3)
        setQuality(quality3);
      byteout = new Array;
      bytenew = 0;
      bytepos = 7;
      writeWord(65496);
      writeAPP0();
      writeCOM(image3.comments);
      writeAPP1(image3.exifBuffer);
      writeDQT();
      writeSOF0(image3.width, image3.height);
      writeDHT();
      writeSOS();
      var DCY = 0;
      var DCU = 0;
      var DCV = 0;
      bytenew = 0;
      bytepos = 7;
      this.encode.displayName = "_encode_";
      var imageData = image3.data;
      var width = image3.width;
      var height = image3.height;
      var quadWidth = width * 4;
      var tripleWidth = width * 3;
      var x, y = 0;
      var r, g, b;
      var start, p, col, row, pos;
      while (y < height) {
        x = 0;
        while (x < quadWidth) {
          start = quadWidth * y + x;
          p = start;
          col = -1;
          row = 0;
          for (pos = 0;pos < 64; pos++) {
            row = pos >> 3;
            col = (pos & 7) * 4;
            p = start + row * quadWidth + col;
            if (y + row >= height) {
              p -= quadWidth * (y + 1 + row - height);
            }
            if (x + col >= quadWidth) {
              p -= x + col - quadWidth + 4;
            }
            r = imageData[p++];
            g = imageData[p++];
            b = imageData[p++];
            YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
            UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
            VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
          }
          DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
          DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
          DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
          x += 32;
        }
        y += 8;
      }
      if (bytepos >= 0) {
        var fillbits = [];
        fillbits[1] = bytepos + 1;
        fillbits[0] = (1 << bytepos + 1) - 1;
        writeBits(fillbits);
      }
      writeWord(65497);
      if (typeof module === "undefined")
        return new Uint8Array(byteout);
      return Buffer.from(byteout);
      var jpegDataUri = "data:image/jpeg;base64," + btoa(byteout.join(""));
      byteout = [];
      var duration = new Date().getTime() - time_start;
      return jpegDataUri;
    };
    function setQuality(quality3) {
      if (quality3 <= 0) {
        quality3 = 1;
      }
      if (quality3 > 100) {
        quality3 = 100;
      }
      if (currentQuality == quality3)
        return;
      var sf = 0;
      if (quality3 < 50) {
        sf = Math.floor(5000 / quality3);
      } else {
        sf = Math.floor(200 - quality3 * 2);
      }
      initQuantTables(sf);
      currentQuality = quality3;
    }
    function init() {
      var time_start = new Date().getTime();
      if (!quality2)
        quality2 = 50;
      initCharLookupTable();
      initHuffmanTbl();
      initCategoryNumber();
      initRGBYUVTable();
      setQuality(quality2);
      var duration = new Date().getTime() - time_start;
    }
    init();
  }
  if (typeof module !== "undefined") {
    module.exports = encode3;
  } else if (typeof window !== "undefined") {
    window["jpeg-js"] = window["jpeg-js"] || {};
    window["jpeg-js"].encode = encode3;
  }
  function encode3(imgData, qu) {
    if (typeof qu === "undefined")
      qu = 50;
    var encoder = new JPEGEncoder(qu);
    var data = encoder.encode(imgData, qu);
    return {
      data,
      width: imgData.width,
      height: imgData.height
    };
  }
});

// node_modules/jpeg-js/lib/decoder.js
var require_decoder2 = __commonJS((exports, module) => {
  var JpegImage = function jpegImage() {
    var dctZigZag = new Int32Array([
      0,
      1,
      8,
      16,
      9,
      2,
      3,
      10,
      17,
      24,
      32,
      25,
      18,
      11,
      4,
      5,
      12,
      19,
      26,
      33,
      40,
      48,
      41,
      34,
      27,
      20,
      13,
      6,
      7,
      14,
      21,
      28,
      35,
      42,
      49,
      56,
      57,
      50,
      43,
      36,
      29,
      22,
      15,
      23,
      30,
      37,
      44,
      51,
      58,
      59,
      52,
      45,
      38,
      31,
      39,
      46,
      53,
      60,
      61,
      54,
      47,
      55,
      62,
      63
    ]);
    var dctCos1 = 4017;
    var dctSin1 = 799;
    var dctCos3 = 3406;
    var dctSin3 = 2276;
    var dctCos6 = 1567;
    var dctSin6 = 3784;
    var dctSqrt2 = 5793;
    var dctSqrt1d2 = 2896;
    function constructor() {}
    function buildHuffmanTable(codeLengths, values) {
      var k = 0, code = [], i2, j, length = 16;
      while (length > 0 && !codeLengths[length - 1])
        length--;
      code.push({ children: [], index: 0 });
      var p = code[0], q;
      for (i2 = 0;i2 < length; i2++) {
        for (j = 0;j < codeLengths[i2]; j++) {
          p = code.pop();
          p.children[p.index] = values[k];
          while (p.index > 0) {
            if (code.length === 0)
              throw new Error("Could not recreate Huffman Table");
            p = code.pop();
          }
          p.index++;
          code.push(p);
          while (code.length <= i2) {
            code.push(q = { children: [], index: 0 });
            p.children[p.index] = q.children;
            p = q;
          }
          k++;
        }
        if (i2 + 1 < length) {
          code.push(q = { children: [], index: 0 });
          p.children[p.index] = q.children;
          p = q;
        }
      }
      return code[0].children;
    }
    function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
      var precision = frame.precision;
      var samplesPerLine = frame.samplesPerLine;
      var scanLines = frame.scanLines;
      var mcusPerLine = frame.mcusPerLine;
      var progressive = frame.progressive;
      var { maxH, maxV } = frame;
      var startOffset = offset, bitsData = 0, bitsCount = 0;
      function readBit() {
        if (bitsCount > 0) {
          bitsCount--;
          return bitsData >> bitsCount & 1;
        }
        bitsData = data[offset++];
        if (bitsData == 255) {
          var nextByte = data[offset++];
          if (nextByte) {
            throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
          }
        }
        bitsCount = 7;
        return bitsData >>> 7;
      }
      function decodeHuffman(tree) {
        var node = tree, bit;
        while ((bit = readBit()) !== null) {
          node = node[bit];
          if (typeof node === "number")
            return node;
          if (typeof node !== "object")
            throw new Error("invalid huffman sequence");
        }
        return null;
      }
      function receive(length) {
        var n3 = 0;
        while (length > 0) {
          var bit = readBit();
          if (bit === null)
            return;
          n3 = n3 << 1 | bit;
          length--;
        }
        return n3;
      }
      function receiveAndExtend(length) {
        var n3 = receive(length);
        if (n3 >= 1 << length - 1)
          return n3;
        return n3 + (-1 << length) + 1;
      }
      function decodeBaseline(component2, zz) {
        var t = decodeHuffman(component2.huffmanTableDC);
        var diff2 = t === 0 ? 0 : receiveAndExtend(t);
        zz[0] = component2.pred += diff2;
        var k2 = 1;
        while (k2 < 64) {
          var rs = decodeHuffman(component2.huffmanTableAC);
          var s = rs & 15, r = rs >> 4;
          if (s === 0) {
            if (r < 15)
              break;
            k2 += 16;
            continue;
          }
          k2 += r;
          var z = dctZigZag[k2];
          zz[z] = receiveAndExtend(s);
          k2++;
        }
      }
      function decodeDCFirst(component2, zz) {
        var t = decodeHuffman(component2.huffmanTableDC);
        var diff2 = t === 0 ? 0 : receiveAndExtend(t) << successive;
        zz[0] = component2.pred += diff2;
      }
      function decodeDCSuccessive(component2, zz) {
        zz[0] |= readBit() << successive;
      }
      var eobrun = 0;
      function decodeACFirst(component2, zz) {
        if (eobrun > 0) {
          eobrun--;
          return;
        }
        var k2 = spectralStart, e = spectralEnd;
        while (k2 <= e) {
          var rs = decodeHuffman(component2.huffmanTableAC);
          var s = rs & 15, r = rs >> 4;
          if (s === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r) - 1;
              break;
            }
            k2 += 16;
            continue;
          }
          k2 += r;
          var z = dctZigZag[k2];
          zz[z] = receiveAndExtend(s) * (1 << successive);
          k2++;
        }
      }
      var successiveACState = 0, successiveACNextValue;
      function decodeACSuccessive(component2, zz) {
        var k2 = spectralStart, e = spectralEnd, r = 0;
        while (k2 <= e) {
          var z = dctZigZag[k2];
          var direction = zz[z] < 0 ? -1 : 1;
          switch (successiveACState) {
            case 0:
              var rs = decodeHuffman(component2.huffmanTableAC);
              var s = rs & 15, r = rs >> 4;
              if (s === 0) {
                if (r < 15) {
                  eobrun = receive(r) + (1 << r);
                  successiveACState = 4;
                } else {
                  r = 16;
                  successiveACState = 1;
                }
              } else {
                if (s !== 1)
                  throw new Error("invalid ACn encoding");
                successiveACNextValue = receiveAndExtend(s);
                successiveACState = r ? 2 : 3;
              }
              continue;
            case 1:
            case 2:
              if (zz[z])
                zz[z] += (readBit() << successive) * direction;
              else {
                r--;
                if (r === 0)
                  successiveACState = successiveACState == 2 ? 3 : 0;
              }
              break;
            case 3:
              if (zz[z])
                zz[z] += (readBit() << successive) * direction;
              else {
                zz[z] = successiveACNextValue << successive;
                successiveACState = 0;
              }
              break;
            case 4:
              if (zz[z])
                zz[z] += (readBit() << successive) * direction;
              break;
          }
          k2++;
        }
        if (successiveACState === 4) {
          eobrun--;
          if (eobrun === 0)
            successiveACState = 0;
        }
      }
      function decodeMcu(component2, decode4, mcu2, row, col) {
        var mcuRow = mcu2 / mcusPerLine | 0;
        var mcuCol = mcu2 % mcusPerLine;
        var blockRow = mcuRow * component2.v + row;
        var blockCol = mcuCol * component2.h + col;
        if (component2.blocks[blockRow] === undefined && opts.tolerantDecoding)
          return;
        decode4(component2, component2.blocks[blockRow][blockCol]);
      }
      function decodeBlock(component2, decode4, mcu2) {
        var blockRow = mcu2 / component2.blocksPerLine | 0;
        var blockCol = mcu2 % component2.blocksPerLine;
        if (component2.blocks[blockRow] === undefined && opts.tolerantDecoding)
          return;
        decode4(component2, component2.blocks[blockRow][blockCol]);
      }
      var componentsLength = components.length;
      var component, i2, j, k, n2;
      var decodeFn;
      if (progressive) {
        if (spectralStart === 0)
          decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
        else
          decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
      } else {
        decodeFn = decodeBaseline;
      }
      var mcu = 0, marker;
      var mcuExpected;
      if (componentsLength == 1) {
        mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
      } else {
        mcuExpected = mcusPerLine * frame.mcusPerColumn;
      }
      if (!resetInterval)
        resetInterval = mcuExpected;
      var h2, v;
      while (mcu < mcuExpected) {
        for (i2 = 0;i2 < componentsLength; i2++)
          components[i2].pred = 0;
        eobrun = 0;
        if (componentsLength == 1) {
          component = components[0];
          for (n2 = 0;n2 < resetInterval; n2++) {
            decodeBlock(component, decodeFn, mcu);
            mcu++;
          }
        } else {
          for (n2 = 0;n2 < resetInterval; n2++) {
            for (i2 = 0;i2 < componentsLength; i2++) {
              component = components[i2];
              h2 = component.h;
              v = component.v;
              for (j = 0;j < v; j++) {
                for (k = 0;k < h2; k++) {
                  decodeMcu(component, decodeFn, mcu, j, k);
                }
              }
            }
            mcu++;
            if (mcu === mcuExpected)
              break;
          }
        }
        if (mcu === mcuExpected) {
          do {
            if (data[offset] === 255) {
              if (data[offset + 1] !== 0) {
                break;
              }
            }
            offset += 1;
          } while (offset < data.length - 2);
        }
        bitsCount = 0;
        marker = data[offset] << 8 | data[offset + 1];
        if (marker < 65280) {
          throw new Error("marker was not found");
        }
        if (marker >= 65488 && marker <= 65495) {
          offset += 2;
        } else
          break;
      }
      return offset - startOffset;
    }
    function buildComponentData(frame, component) {
      var lines = [];
      var blocksPerLine = component.blocksPerLine;
      var blocksPerColumn = component.blocksPerColumn;
      var samplesPerLine = blocksPerLine << 3;
      var R = new Int32Array(64), r = new Uint8Array(64);
      function quantizeAndInverse(zz, dataOut, dataIn) {
        var qt = component.quantizationTable;
        var v0, v1, v2, v3, v4, v5, v6, v7, t;
        var p = dataIn;
        var i3;
        for (i3 = 0;i3 < 64; i3++)
          p[i3] = zz[i3] * qt[i3];
        for (i3 = 0;i3 < 8; ++i3) {
          var row = 8 * i3;
          if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
            t = dctSqrt2 * p[0 + row] + 512 >> 10;
            p[0 + row] = t;
            p[1 + row] = t;
            p[2 + row] = t;
            p[3 + row] = t;
            p[4 + row] = t;
            p[5 + row] = t;
            p[6 + row] = t;
            p[7 + row] = t;
            continue;
          }
          v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
          v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
          v2 = p[2 + row];
          v3 = p[6 + row];
          v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
          v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
          v5 = p[3 + row] << 4;
          v6 = p[5 + row] << 4;
          t = v0 - v1 + 1 >> 1;
          v0 = v0 + v1 + 1 >> 1;
          v1 = t;
          t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
          v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
          v3 = t;
          t = v4 - v6 + 1 >> 1;
          v4 = v4 + v6 + 1 >> 1;
          v6 = t;
          t = v7 + v5 + 1 >> 1;
          v5 = v7 - v5 + 1 >> 1;
          v7 = t;
          t = v0 - v3 + 1 >> 1;
          v0 = v0 + v3 + 1 >> 1;
          v3 = t;
          t = v1 - v2 + 1 >> 1;
          v1 = v1 + v2 + 1 >> 1;
          v2 = t;
          t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
          v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
          v7 = t;
          t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
          v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
          v6 = t;
          p[0 + row] = v0 + v7;
          p[7 + row] = v0 - v7;
          p[1 + row] = v1 + v6;
          p[6 + row] = v1 - v6;
          p[2 + row] = v2 + v5;
          p[5 + row] = v2 - v5;
          p[3 + row] = v3 + v4;
          p[4 + row] = v3 - v4;
        }
        for (i3 = 0;i3 < 8; ++i3) {
          var col = i3;
          if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
            t = dctSqrt2 * dataIn[i3 + 0] + 8192 >> 14;
            p[0 * 8 + col] = t;
            p[1 * 8 + col] = t;
            p[2 * 8 + col] = t;
            p[3 * 8 + col] = t;
            p[4 * 8 + col] = t;
            p[5 * 8 + col] = t;
            p[6 * 8 + col] = t;
            p[7 * 8 + col] = t;
            continue;
          }
          v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
          v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
          v2 = p[2 * 8 + col];
          v3 = p[6 * 8 + col];
          v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
          v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
          v5 = p[3 * 8 + col];
          v6 = p[5 * 8 + col];
          t = v0 - v1 + 1 >> 1;
          v0 = v0 + v1 + 1 >> 1;
          v1 = t;
          t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
          v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
          v3 = t;
          t = v4 - v6 + 1 >> 1;
          v4 = v4 + v6 + 1 >> 1;
          v6 = t;
          t = v7 + v5 + 1 >> 1;
          v5 = v7 - v5 + 1 >> 1;
          v7 = t;
          t = v0 - v3 + 1 >> 1;
          v0 = v0 + v3 + 1 >> 1;
          v3 = t;
          t = v1 - v2 + 1 >> 1;
          v1 = v1 + v2 + 1 >> 1;
          v2 = t;
          t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
          v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
          v7 = t;
          t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
          v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
          v6 = t;
          p[0 * 8 + col] = v0 + v7;
          p[7 * 8 + col] = v0 - v7;
          p[1 * 8 + col] = v1 + v6;
          p[6 * 8 + col] = v1 - v6;
          p[2 * 8 + col] = v2 + v5;
          p[5 * 8 + col] = v2 - v5;
          p[3 * 8 + col] = v3 + v4;
          p[4 * 8 + col] = v3 - v4;
        }
        for (i3 = 0;i3 < 64; ++i3) {
          var sample2 = 128 + (p[i3] + 8 >> 4);
          dataOut[i3] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
        }
      }
      requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
      var i2, j;
      for (var blockRow = 0;blockRow < blocksPerColumn; blockRow++) {
        var scanLine = blockRow << 3;
        for (i2 = 0;i2 < 8; i2++)
          lines.push(new Uint8Array(samplesPerLine));
        for (var blockCol = 0;blockCol < blocksPerLine; blockCol++) {
          quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
          var offset = 0, sample = blockCol << 3;
          for (j = 0;j < 8; j++) {
            var line = lines[scanLine + j];
            for (i2 = 0;i2 < 8; i2++)
              line[sample + i2] = r[offset++];
          }
        }
      }
      return lines;
    }
    function clampTo8bit(a2) {
      return a2 < 0 ? 0 : a2 > 255 ? 255 : a2;
    }
    constructor.prototype = {
      load: function load(path8) {
        var xhr = new XMLHttpRequest;
        xhr.open("GET", path8, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function() {
          var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
          this.parse(data);
          if (this.onload)
            this.onload();
        }.bind(this);
        xhr.send(null);
      },
      parse: function parse(data) {
        var maxResolutionInPixels = this.opts.maxResolutionInMP * 1000 * 1000;
        var offset = 0, length = data.length;
        function readUint16() {
          var value = data[offset] << 8 | data[offset + 1];
          offset += 2;
          return value;
        }
        function readDataBlock() {
          var length2 = readUint16();
          var array = data.subarray(offset, offset + length2 - 2);
          offset += array.length;
          return array;
        }
        function prepareComponents(frame2) {
          var maxH2 = 1, maxV2 = 1;
          var component2, componentId2;
          for (componentId2 in frame2.components) {
            if (frame2.components.hasOwnProperty(componentId2)) {
              component2 = frame2.components[componentId2];
              if (maxH2 < component2.h)
                maxH2 = component2.h;
              if (maxV2 < component2.v)
                maxV2 = component2.v;
            }
          }
          var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
          var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
          for (componentId2 in frame2.components) {
            if (frame2.components.hasOwnProperty(componentId2)) {
              component2 = frame2.components[componentId2];
              var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
              var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
              var blocksPerLineForMcu = mcusPerLine * component2.h;
              var blocksPerColumnForMcu = mcusPerColumn * component2.v;
              var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
              var blocks = [];
              requestMemoryAllocation(blocksToAllocate * 256);
              for (var i3 = 0;i3 < blocksPerColumnForMcu; i3++) {
                var row = [];
                for (var j2 = 0;j2 < blocksPerLineForMcu; j2++)
                  row.push(new Int32Array(64));
                blocks.push(row);
              }
              component2.blocksPerLine = blocksPerLine;
              component2.blocksPerColumn = blocksPerColumn;
              component2.blocks = blocks;
            }
          }
          frame2.maxH = maxH2;
          frame2.maxV = maxV2;
          frame2.mcusPerLine = mcusPerLine;
          frame2.mcusPerColumn = mcusPerColumn;
        }
        var jfif = null;
        var adobe = null;
        var pixels = null;
        var frame, resetInterval;
        var quantizationTables = [], frames = [];
        var huffmanTablesAC = [], huffmanTablesDC = [];
        var fileMarker = readUint16();
        var malformedDataOffset = -1;
        this.comments = [];
        if (fileMarker != 65496) {
          throw new Error("SOI not found");
        }
        fileMarker = readUint16();
        while (fileMarker != 65497) {
          var i2, j, l;
          switch (fileMarker) {
            case 65280:
              break;
            case 65504:
            case 65505:
            case 65506:
            case 65507:
            case 65508:
            case 65509:
            case 65510:
            case 65511:
            case 65512:
            case 65513:
            case 65514:
            case 65515:
            case 65516:
            case 65517:
            case 65518:
            case 65519:
            case 65534:
              var appData = readDataBlock();
              if (fileMarker === 65534) {
                var comment = String.fromCharCode.apply(null, appData);
                this.comments.push(comment);
              }
              if (fileMarker === 65504) {
                if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                  jfif = {
                    version: { major: appData[5], minor: appData[6] },
                    densityUnits: appData[7],
                    xDensity: appData[8] << 8 | appData[9],
                    yDensity: appData[10] << 8 | appData[11],
                    thumbWidth: appData[12],
                    thumbHeight: appData[13],
                    thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                  };
                }
              }
              if (fileMarker === 65505) {
                if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                  this.exifBuffer = appData.subarray(5, appData.length);
                }
              }
              if (fileMarker === 65518) {
                if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                  adobe = {
                    version: appData[6],
                    flags0: appData[7] << 8 | appData[8],
                    flags1: appData[9] << 8 | appData[10],
                    transformCode: appData[11]
                  };
                }
              }
              break;
            case 65499:
              var quantizationTablesLength = readUint16();
              var quantizationTablesEnd = quantizationTablesLength + offset - 2;
              while (offset < quantizationTablesEnd) {
                var quantizationTableSpec = data[offset++];
                requestMemoryAllocation(64 * 4);
                var tableData = new Int32Array(64);
                if (quantizationTableSpec >> 4 === 0) {
                  for (j = 0;j < 64; j++) {
                    var z = dctZigZag[j];
                    tableData[z] = data[offset++];
                  }
                } else if (quantizationTableSpec >> 4 === 1) {
                  for (j = 0;j < 64; j++) {
                    var z = dctZigZag[j];
                    tableData[z] = readUint16();
                  }
                } else
                  throw new Error("DQT: invalid table spec");
                quantizationTables[quantizationTableSpec & 15] = tableData;
              }
              break;
            case 65472:
            case 65473:
            case 65474:
              readUint16();
              frame = {};
              frame.extended = fileMarker === 65473;
              frame.progressive = fileMarker === 65474;
              frame.precision = data[offset++];
              frame.scanLines = readUint16();
              frame.samplesPerLine = readUint16();
              frame.components = {};
              frame.componentsOrder = [];
              var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
              if (pixelsInFrame > maxResolutionInPixels) {
                var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
              }
              var componentsCount = data[offset++], componentId;
              var maxH = 0, maxV = 0;
              for (i2 = 0;i2 < componentsCount; i2++) {
                componentId = data[offset];
                var h2 = data[offset + 1] >> 4;
                var v = data[offset + 1] & 15;
                var qId = data[offset + 2];
                if (h2 <= 0 || v <= 0) {
                  throw new Error("Invalid sampling factor, expected values above 0");
                }
                frame.componentsOrder.push(componentId);
                frame.components[componentId] = {
                  h: h2,
                  v,
                  quantizationIdx: qId
                };
                offset += 3;
              }
              prepareComponents(frame);
              frames.push(frame);
              break;
            case 65476:
              var huffmanLength = readUint16();
              for (i2 = 2;i2 < huffmanLength; ) {
                var huffmanTableSpec = data[offset++];
                var codeLengths = new Uint8Array(16);
                var codeLengthSum = 0;
                for (j = 0;j < 16; j++, offset++) {
                  codeLengthSum += codeLengths[j] = data[offset];
                }
                requestMemoryAllocation(16 + codeLengthSum);
                var huffmanValues = new Uint8Array(codeLengthSum);
                for (j = 0;j < codeLengthSum; j++, offset++)
                  huffmanValues[j] = data[offset];
                i2 += 17 + codeLengthSum;
                (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
              }
              break;
            case 65501:
              readUint16();
              resetInterval = readUint16();
              break;
            case 65500:
              readUint16();
              readUint16();
              break;
            case 65498:
              var scanLength = readUint16();
              var selectorsCount = data[offset++];
              var components = [], component;
              for (i2 = 0;i2 < selectorsCount; i2++) {
                component = frame.components[data[offset++]];
                var tableSpec = data[offset++];
                component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                components.push(component);
              }
              var spectralStart = data[offset++];
              var spectralEnd = data[offset++];
              var successiveApproximation = data[offset++];
              var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, this.opts);
              offset += processed;
              break;
            case 65535:
              if (data[offset] !== 255) {
                offset--;
              }
              break;
            default:
              if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                offset -= 3;
                break;
              } else if (fileMarker === 224 || fileMarker == 225) {
                if (malformedDataOffset !== -1) {
                  throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                }
                malformedDataOffset = offset - 1;
                const nextOffset = readUint16();
                if (data[offset + nextOffset - 2] === 255) {
                  offset += nextOffset - 2;
                  break;
                }
              }
              throw new Error("unknown JPEG marker " + fileMarker.toString(16));
          }
          fileMarker = readUint16();
        }
        if (frames.length != 1)
          throw new Error("only single frame JPEGs supported");
        for (var i2 = 0;i2 < frames.length; i2++) {
          var cp = frames[i2].components;
          for (var j in cp) {
            cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
            delete cp[j].quantizationIdx;
          }
        }
        this.width = frame.samplesPerLine;
        this.height = frame.scanLines;
        this.jfif = jfif;
        this.adobe = adobe;
        this.components = [];
        for (var i2 = 0;i2 < frame.componentsOrder.length; i2++) {
          var component = frame.components[frame.componentsOrder[i2]];
          this.components.push({
            lines: buildComponentData(frame, component),
            scaleX: component.h / frame.maxH,
            scaleY: component.v / frame.maxV
          });
        }
      },
      getData: function getData(width, height) {
        var scaleX = this.width / width, scaleY = this.height / height;
        var component1, component2, component3, component4;
        var component1Line, component2Line, component3Line, component4Line;
        var x, y;
        var offset = 0;
        var Y, Cb, Cr, K, C, M, Ye, R, G, B;
        var colorTransform;
        var dataLength = width * height * this.components.length;
        requestMemoryAllocation(dataLength);
        var data = new Uint8Array(dataLength);
        switch (this.components.length) {
          case 1:
            component1 = this.components[0];
            for (y = 0;y < height; y++) {
              component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
              for (x = 0;x < width; x++) {
                Y = component1Line[0 | x * component1.scaleX * scaleX];
                data[offset++] = Y;
              }
            }
            break;
          case 2:
            component1 = this.components[0];
            component2 = this.components[1];
            for (y = 0;y < height; y++) {
              component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
              component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
              for (x = 0;x < width; x++) {
                Y = component1Line[0 | x * component1.scaleX * scaleX];
                data[offset++] = Y;
                Y = component2Line[0 | x * component2.scaleX * scaleX];
                data[offset++] = Y;
              }
            }
            break;
          case 3:
            colorTransform = true;
            if (this.adobe && this.adobe.transformCode)
              colorTransform = true;
            else if (typeof this.opts.colorTransform !== "undefined")
              colorTransform = !!this.opts.colorTransform;
            component1 = this.components[0];
            component2 = this.components[1];
            component3 = this.components[2];
            for (y = 0;y < height; y++) {
              component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
              component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
              component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
              for (x = 0;x < width; x++) {
                if (!colorTransform) {
                  R = component1Line[0 | x * component1.scaleX * scaleX];
                  G = component2Line[0 | x * component2.scaleX * scaleX];
                  B = component3Line[0 | x * component3.scaleX * scaleX];
                } else {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  Cb = component2Line[0 | x * component2.scaleX * scaleX];
                  Cr = component3Line[0 | x * component3.scaleX * scaleX];
                  R = clampTo8bit(Y + 1.402 * (Cr - 128));
                  G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                  B = clampTo8bit(Y + 1.772 * (Cb - 128));
                }
                data[offset++] = R;
                data[offset++] = G;
                data[offset++] = B;
              }
            }
            break;
          case 4:
            if (!this.adobe)
              throw new Error("Unsupported color mode (4 components)");
            colorTransform = false;
            if (this.adobe && this.adobe.transformCode)
              colorTransform = true;
            else if (typeof this.opts.colorTransform !== "undefined")
              colorTransform = !!this.opts.colorTransform;
            component1 = this.components[0];
            component2 = this.components[1];
            component3 = this.components[2];
            component4 = this.components[3];
            for (y = 0;y < height; y++) {
              component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
              component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
              component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
              component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
              for (x = 0;x < width; x++) {
                if (!colorTransform) {
                  C = component1Line[0 | x * component1.scaleX * scaleX];
                  M = component2Line[0 | x * component2.scaleX * scaleX];
                  Ye = component3Line[0 | x * component3.scaleX * scaleX];
                  K = component4Line[0 | x * component4.scaleX * scaleX];
                } else {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  Cb = component2Line[0 | x * component2.scaleX * scaleX];
                  Cr = component3Line[0 | x * component3.scaleX * scaleX];
                  K = component4Line[0 | x * component4.scaleX * scaleX];
                  C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                  M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                  Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                }
                data[offset++] = 255 - C;
                data[offset++] = 255 - M;
                data[offset++] = 255 - Ye;
                data[offset++] = 255 - K;
              }
            }
            break;
          default:
            throw new Error("Unsupported color mode");
        }
        return data;
      },
      copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
        var { width, height } = imageData;
        var imageDataArray = imageData.data;
        var data = this.getData(width, height);
        var i2 = 0, j = 0, x, y;
        var Y, K, C, M, R, G, B;
        switch (this.components.length) {
          case 1:
            for (y = 0;y < height; y++) {
              for (x = 0;x < width; x++) {
                Y = data[i2++];
                imageDataArray[j++] = Y;
                imageDataArray[j++] = Y;
                imageDataArray[j++] = Y;
                if (formatAsRGBA) {
                  imageDataArray[j++] = 255;
                }
              }
            }
            break;
          case 3:
            for (y = 0;y < height; y++) {
              for (x = 0;x < width; x++) {
                R = data[i2++];
                G = data[i2++];
                B = data[i2++];
                imageDataArray[j++] = R;
                imageDataArray[j++] = G;
                imageDataArray[j++] = B;
                if (formatAsRGBA) {
                  imageDataArray[j++] = 255;
                }
              }
            }
            break;
          case 4:
            for (y = 0;y < height; y++) {
              for (x = 0;x < width; x++) {
                C = data[i2++];
                M = data[i2++];
                Y = data[i2++];
                K = data[i2++];
                R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                imageDataArray[j++] = R;
                imageDataArray[j++] = G;
                imageDataArray[j++] = B;
                if (formatAsRGBA) {
                  imageDataArray[j++] = 255;
                }
              }
            }
            break;
          default:
            throw new Error("Unsupported color mode");
        }
      }
    };
    var totalBytesAllocated = 0;
    var maxMemoryUsageBytes = 0;
    function requestMemoryAllocation(increaseAmount = 0) {
      var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
      if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
        var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
        throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
      }
      totalBytesAllocated = totalMemoryImpactBytes;
    }
    constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
      totalBytesAllocated = 0;
      maxMemoryUsageBytes = maxMemoryUsageBytes_;
    };
    constructor.getBytesAllocated = function() {
      return totalBytesAllocated;
    };
    constructor.requestMemoryAllocation = requestMemoryAllocation;
    return constructor;
  }();
  if (typeof module !== "undefined") {
    module.exports = decode3;
  } else if (typeof window !== "undefined") {
    window["jpeg-js"] = window["jpeg-js"] || {};
    window["jpeg-js"].decode = decode3;
  }
  function decode3(jpegData, userOpts = {}) {
    var defaultOpts = {
      colorTransform: undefined,
      useTArray: false,
      formatAsRGBA: true,
      tolerantDecoding: true,
      maxResolutionInMP: 100,
      maxMemoryUsageInMB: 512
    };
    var opts = { ...defaultOpts, ...userOpts };
    var arr = new Uint8Array(jpegData);
    var decoder = new JpegImage;
    decoder.opts = opts;
    JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
    decoder.parse(arr);
    var channels = opts.formatAsRGBA ? 4 : 3;
    var bytesNeeded = decoder.width * decoder.height * channels;
    try {
      JpegImage.requestMemoryAllocation(bytesNeeded);
      var image3 = {
        width: decoder.width,
        height: decoder.height,
        exifBuffer: decoder.exifBuffer,
        data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
      };
      if (decoder.comments.length > 0) {
        image3["comments"] = decoder.comments;
      }
    } catch (err) {
      if (err instanceof RangeError) {
        throw new Error("Could not allocate enough memory for the image. " + "Required: " + bytesNeeded);
      }
      if (err instanceof ReferenceError) {
        if (err.message === "Buffer is not defined") {
          throw new Error("Buffer is not globally defined in this environment. " + "Consider setting useTArray to true");
        }
      }
      throw err;
    }
    decoder.copyToImageData(image3, opts.formatAsRGBA);
    return image3;
  }
});

// node_modules/jpeg-js/index.js
var require_jpeg_js = __commonJS((exports, module) => {
  var encode3 = require_encoder2();
  var decode3 = require_decoder2();
  module.exports = {
    encode: encode3,
    decode: decode3
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS((exports, module) => {
  var util = __require("util");
  var Stream2 = __require("stream");
  var ChunkStream = module.exports = function() {
    Stream2.call(this);
    this._buffers = [];
    this._buffered = 0;
    this._reads = [];
    this._paused = false;
    this._encoding = "utf8";
    this.writable = true;
  };
  util.inherits(ChunkStream, Stream2);
  ChunkStream.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      allowLess: length < 0,
      func: callback
    });
    process.nextTick(function() {
      this._process();
      if (this._paused && this._reads && this._reads.length > 0) {
        this._paused = false;
        this.emit("drain");
      }
    }.bind(this));
  };
  ChunkStream.prototype.write = function(data, encoding) {
    if (!this.writable) {
      this.emit("error", new Error("Stream not writable"));
      return false;
    }
    let dataBuffer;
    if (Buffer.isBuffer(data)) {
      dataBuffer = data;
    } else {
      dataBuffer = Buffer.from(data, encoding || this._encoding);
    }
    this._buffers.push(dataBuffer);
    this._buffered += dataBuffer.length;
    this._process();
    if (this._reads && this._reads.length === 0) {
      this._paused = true;
    }
    return this.writable && !this._paused;
  };
  ChunkStream.prototype.end = function(data, encoding) {
    if (data) {
      this.write(data, encoding);
    }
    this.writable = false;
    if (!this._buffers) {
      return;
    }
    if (this._buffers.length === 0) {
      this._end();
    } else {
      this._buffers.push(null);
      this._process();
    }
  };
  ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
  ChunkStream.prototype._end = function() {
    if (this._reads.length > 0) {
      this.emit("error", new Error("Unexpected end of input"));
    }
    this.destroy();
  };
  ChunkStream.prototype.destroy = function() {
    if (!this._buffers) {
      return;
    }
    this.writable = false;
    this._reads = null;
    this._buffers = null;
    this.emit("close");
  };
  ChunkStream.prototype._processReadAllowingLess = function(read) {
    this._reads.shift();
    let smallerBuf = this._buffers[0];
    if (smallerBuf.length > read.length) {
      this._buffered -= read.length;
      this._buffers[0] = smallerBuf.slice(read.length);
      read.func.call(this, smallerBuf.slice(0, read.length));
    } else {
      this._buffered -= smallerBuf.length;
      this._buffers.shift();
      read.func.call(this, smallerBuf);
    }
  };
  ChunkStream.prototype._processRead = function(read) {
    this._reads.shift();
    let pos = 0;
    let count2 = 0;
    let data = Buffer.alloc(read.length);
    while (pos < read.length) {
      let buf = this._buffers[count2++];
      let len = Math.min(buf.length, read.length - pos);
      buf.copy(data, pos, 0, len);
      pos += len;
      if (len !== buf.length) {
        this._buffers[--count2] = buf.slice(len);
      }
    }
    if (count2 > 0) {
      this._buffers.splice(0, count2);
    }
    this._buffered -= read.length;
    read.func.call(this, data);
  };
  ChunkStream.prototype._process = function() {
    try {
      while (this._buffered > 0 && this._reads && this._reads.length > 0) {
        let read = this._reads[0];
        if (read.allowLess) {
          this._processReadAllowingLess(read);
        } else if (this._buffered >= read.length) {
          this._processRead(read);
        } else {
          break;
        }
      }
      if (this._buffers && !this.writable) {
        this._end();
      }
    } catch (ex) {
      this.emit("error", ex);
    }
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS((exports) => {
  var imagePasses = [
    {
      x: [0],
      y: [0]
    },
    {
      x: [4],
      y: [0]
    },
    {
      x: [0, 4],
      y: [4]
    },
    {
      x: [2, 6],
      y: [0, 4]
    },
    {
      x: [0, 2, 4, 6],
      y: [2, 6]
    },
    {
      x: [1, 3, 5, 7],
      y: [0, 2, 4, 6]
    },
    {
      x: [0, 1, 2, 3, 4, 5, 6, 7],
      y: [1, 3, 5, 7]
    }
  ];
  exports.getImagePasses = function(width, height) {
    let images = [];
    let xLeftOver = width % 8;
    let yLeftOver = height % 8;
    let xRepeats = (width - xLeftOver) / 8;
    let yRepeats = (height - yLeftOver) / 8;
    for (let i2 = 0;i2 < imagePasses.length; i2++) {
      let pass = imagePasses[i2];
      let passWidth = xRepeats * pass.x.length;
      let passHeight = yRepeats * pass.y.length;
      for (let j = 0;j < pass.x.length; j++) {
        if (pass.x[j] < xLeftOver) {
          passWidth++;
        } else {
          break;
        }
      }
      for (let j = 0;j < pass.y.length; j++) {
        if (pass.y[j] < yLeftOver) {
          passHeight++;
        } else {
          break;
        }
      }
      if (passWidth > 0 && passHeight > 0) {
        images.push({ width: passWidth, height: passHeight, index: i2 });
      }
    }
    return images;
  };
  exports.getInterlaceIterator = function(width) {
    return function(x, y, pass) {
      let outerXLeftOver = x % imagePasses[pass].x.length;
      let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
      let outerYLeftOver = y % imagePasses[pass].y.length;
      let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
      return outerX * 4 + outerY * width * 4;
    };
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS((exports, module) => {
  module.exports = function paethPredictor(left, above, upLeft) {
    let paeth = left + above - upLeft;
    let pLeft = Math.abs(paeth - left);
    let pAbove = Math.abs(paeth - above);
    let pUpLeft = Math.abs(paeth - upLeft);
    if (pLeft <= pAbove && pLeft <= pUpLeft) {
      return left;
    }
    if (pAbove <= pUpLeft) {
      return above;
    }
    return upLeft;
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS((exports, module) => {
  var interlaceUtils = require_interlace();
  var paethPredictor = require_paeth_predictor();
  function getByteWidth(width, bpp, depth) {
    let byteWidth = width * bpp;
    if (depth !== 8) {
      byteWidth = Math.ceil(byteWidth / (8 / depth));
    }
    return byteWidth;
  }
  var Filter = module.exports = function(bitmapInfo, dependencies) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let interlace = bitmapInfo.interlace;
    let bpp = bitmapInfo.bpp;
    let depth = bitmapInfo.depth;
    this.read = dependencies.read;
    this.write = dependencies.write;
    this.complete = dependencies.complete;
    this._imageIndex = 0;
    this._images = [];
    if (interlace) {
      let passes = interlaceUtils.getImagePasses(width, height);
      for (let i2 = 0;i2 < passes.length; i2++) {
        this._images.push({
          byteWidth: getByteWidth(passes[i2].width, bpp, depth),
          height: passes[i2].height,
          lineIndex: 0
        });
      }
    } else {
      this._images.push({
        byteWidth: getByteWidth(width, bpp, depth),
        height,
        lineIndex: 0
      });
    }
    if (depth === 8) {
      this._xComparison = bpp;
    } else if (depth === 16) {
      this._xComparison = bpp * 2;
    } else {
      this._xComparison = 1;
    }
  };
  Filter.prototype.start = function() {
    this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
  };
  Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      unfilteredLine[x] = rawByte + f1Left;
    }
  };
  Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
    let lastLine = this._lastLine;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f2Up = lastLine ? lastLine[x] : 0;
      unfilteredLine[x] = rawByte + f2Up;
    }
  };
  Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f3Up = lastLine ? lastLine[x] : 0;
      let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f3Add = Math.floor((f3Left + f3Up) / 2);
      unfilteredLine[x] = rawByte + f3Add;
    }
  };
  Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f4Up = lastLine ? lastLine[x] : 0;
      let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
      let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
      unfilteredLine[x] = rawByte + f4Add;
    }
  };
  Filter.prototype._reverseFilterLine = function(rawData) {
    let filter = rawData[0];
    let unfilteredLine;
    let currentImage = this._images[this._imageIndex];
    let byteWidth = currentImage.byteWidth;
    if (filter === 0) {
      unfilteredLine = rawData.slice(1, byteWidth + 1);
    } else {
      unfilteredLine = Buffer.alloc(byteWidth);
      switch (filter) {
        case 1:
          this._unFilterType1(rawData, unfilteredLine, byteWidth);
          break;
        case 2:
          this._unFilterType2(rawData, unfilteredLine, byteWidth);
          break;
        case 3:
          this._unFilterType3(rawData, unfilteredLine, byteWidth);
          break;
        case 4:
          this._unFilterType4(rawData, unfilteredLine, byteWidth);
          break;
        default:
          throw new Error("Unrecognised filter type - " + filter);
      }
    }
    this.write(unfilteredLine);
    currentImage.lineIndex++;
    if (currentImage.lineIndex >= currentImage.height) {
      this._lastLine = null;
      this._imageIndex++;
      currentImage = this._images[this._imageIndex];
    } else {
      this._lastLine = unfilteredLine;
    }
    if (currentImage) {
      this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
    } else {
      this._lastLine = null;
      this.complete();
    }
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS((exports, module) => {
  var util = __require("util");
  var ChunkStream = require_chunkstream();
  var Filter = require_filter_parse();
  var FilterAsync = module.exports = function(bitmapInfo) {
    ChunkStream.call(this);
    let buffers = [];
    let that = this;
    this._filter = new Filter(bitmapInfo, {
      read: this.read.bind(this),
      write: function(buffer) {
        buffers.push(buffer);
      },
      complete: function() {
        that.emit("complete", Buffer.concat(buffers));
      }
    });
    this._filter.start();
  };
  util.inherits(FilterAsync, ChunkStream);
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/constants.js
var require_constants3 = __commonJS((exports, module) => {
  module.exports = {
    PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
    TYPE_IHDR: 1229472850,
    TYPE_IEND: 1229278788,
    TYPE_IDAT: 1229209940,
    TYPE_PLTE: 1347179589,
    TYPE_tRNS: 1951551059,
    TYPE_gAMA: 1732332865,
    COLORTYPE_GRAYSCALE: 0,
    COLORTYPE_PALETTE: 1,
    COLORTYPE_COLOR: 2,
    COLORTYPE_ALPHA: 4,
    COLORTYPE_PALETTE_COLOR: 3,
    COLORTYPE_COLOR_ALPHA: 6,
    COLORTYPE_TO_BPP_MAP: {
      0: 1,
      2: 3,
      3: 1,
      4: 2,
      6: 4
    },
    GAMMA_DIVISION: 1e5
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/crc.js
var require_crc = __commonJS((exports, module) => {
  var crcTable = [];
  (function() {
    for (let i2 = 0;i2 < 256; i2++) {
      let currentCrc = i2;
      for (let j = 0;j < 8; j++) {
        if (currentCrc & 1) {
          currentCrc = 3988292384 ^ currentCrc >>> 1;
        } else {
          currentCrc = currentCrc >>> 1;
        }
      }
      crcTable[i2] = currentCrc;
    }
  })();
  var CrcCalculator = module.exports = function() {
    this._crc = -1;
  };
  CrcCalculator.prototype.write = function(data) {
    for (let i2 = 0;i2 < data.length; i2++) {
      this._crc = crcTable[(this._crc ^ data[i2]) & 255] ^ this._crc >>> 8;
    }
    return true;
  };
  CrcCalculator.prototype.crc32 = function() {
    return this._crc ^ -1;
  };
  CrcCalculator.crc32 = function(buf) {
    let crc = -1;
    for (let i2 = 0;i2 < buf.length; i2++) {
      crc = crcTable[(crc ^ buf[i2]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/parser.js
var require_parser = __commonJS((exports, module) => {
  var constants6 = require_constants3();
  var CrcCalculator = require_crc();
  var Parser = module.exports = function(options, dependencies) {
    this._options = options;
    options.checkCRC = options.checkCRC !== false;
    this._hasIHDR = false;
    this._hasIEND = false;
    this._emittedHeadersFinished = false;
    this._palette = [];
    this._colorType = 0;
    this._chunks = {};
    this._chunks[constants6.TYPE_IHDR] = this._handleIHDR.bind(this);
    this._chunks[constants6.TYPE_IEND] = this._handleIEND.bind(this);
    this._chunks[constants6.TYPE_IDAT] = this._handleIDAT.bind(this);
    this._chunks[constants6.TYPE_PLTE] = this._handlePLTE.bind(this);
    this._chunks[constants6.TYPE_tRNS] = this._handleTRNS.bind(this);
    this._chunks[constants6.TYPE_gAMA] = this._handleGAMA.bind(this);
    this.read = dependencies.read;
    this.error = dependencies.error;
    this.metadata = dependencies.metadata;
    this.gamma = dependencies.gamma;
    this.transColor = dependencies.transColor;
    this.palette = dependencies.palette;
    this.parsed = dependencies.parsed;
    this.inflateData = dependencies.inflateData;
    this.finished = dependencies.finished;
    this.simpleTransparency = dependencies.simpleTransparency;
    this.headersFinished = dependencies.headersFinished || function() {};
  };
  Parser.prototype.start = function() {
    this.read(constants6.PNG_SIGNATURE.length, this._parseSignature.bind(this));
  };
  Parser.prototype._parseSignature = function(data) {
    let signature = constants6.PNG_SIGNATURE;
    for (let i2 = 0;i2 < signature.length; i2++) {
      if (data[i2] !== signature[i2]) {
        this.error(new Error("Invalid file signature"));
        return;
      }
    }
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._parseChunkBegin = function(data) {
    let length = data.readUInt32BE(0);
    let type = data.readUInt32BE(4);
    let name = "";
    for (let i2 = 4;i2 < 8; i2++) {
      name += String.fromCharCode(data[i2]);
    }
    let ancillary = Boolean(data[4] & 32);
    if (!this._hasIHDR && type !== constants6.TYPE_IHDR) {
      this.error(new Error("Expected IHDR on beggining"));
      return;
    }
    this._crc = new CrcCalculator;
    this._crc.write(Buffer.from(name));
    if (this._chunks[type]) {
      return this._chunks[type](length);
    }
    if (!ancillary) {
      this.error(new Error("Unsupported critical chunk type " + name));
      return;
    }
    this.read(length + 4, this._skipChunk.bind(this));
  };
  Parser.prototype._skipChunk = function() {
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._handleChunkEnd = function() {
    this.read(4, this._parseChunkEnd.bind(this));
  };
  Parser.prototype._parseChunkEnd = function(data) {
    let fileCrc = data.readInt32BE(0);
    let calcCrc = this._crc.crc32();
    if (this._options.checkCRC && calcCrc !== fileCrc) {
      this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
      return;
    }
    if (!this._hasIEND) {
      this.read(8, this._parseChunkBegin.bind(this));
    }
  };
  Parser.prototype._handleIHDR = function(length) {
    this.read(length, this._parseIHDR.bind(this));
  };
  Parser.prototype._parseIHDR = function(data) {
    this._crc.write(data);
    let width = data.readUInt32BE(0);
    let height = data.readUInt32BE(4);
    let depth = data[8];
    let colorType = data[9];
    let compr = data[10];
    let filter = data[11];
    let interlace = data[12];
    if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
      this.error(new Error("Unsupported bit depth " + depth));
      return;
    }
    if (!(colorType in constants6.COLORTYPE_TO_BPP_MAP)) {
      this.error(new Error("Unsupported color type"));
      return;
    }
    if (compr !== 0) {
      this.error(new Error("Unsupported compression method"));
      return;
    }
    if (filter !== 0) {
      this.error(new Error("Unsupported filter method"));
      return;
    }
    if (interlace !== 0 && interlace !== 1) {
      this.error(new Error("Unsupported interlace method"));
      return;
    }
    this._colorType = colorType;
    let bpp = constants6.COLORTYPE_TO_BPP_MAP[this._colorType];
    this._hasIHDR = true;
    this.metadata({
      width,
      height,
      depth,
      interlace: Boolean(interlace),
      palette: Boolean(colorType & constants6.COLORTYPE_PALETTE),
      color: Boolean(colorType & constants6.COLORTYPE_COLOR),
      alpha: Boolean(colorType & constants6.COLORTYPE_ALPHA),
      bpp,
      colorType
    });
    this._handleChunkEnd();
  };
  Parser.prototype._handlePLTE = function(length) {
    this.read(length, this._parsePLTE.bind(this));
  };
  Parser.prototype._parsePLTE = function(data) {
    this._crc.write(data);
    let entries = Math.floor(data.length / 3);
    for (let i2 = 0;i2 < entries; i2++) {
      this._palette.push([data[i2 * 3], data[i2 * 3 + 1], data[i2 * 3 + 2], 255]);
    }
    this.palette(this._palette);
    this._handleChunkEnd();
  };
  Parser.prototype._handleTRNS = function(length) {
    this.simpleTransparency();
    this.read(length, this._parseTRNS.bind(this));
  };
  Parser.prototype._parseTRNS = function(data) {
    this._crc.write(data);
    if (this._colorType === constants6.COLORTYPE_PALETTE_COLOR) {
      if (this._palette.length === 0) {
        this.error(new Error("Transparency chunk must be after palette"));
        return;
      }
      if (data.length > this._palette.length) {
        this.error(new Error("More transparent colors than palette size"));
        return;
      }
      for (let i2 = 0;i2 < data.length; i2++) {
        this._palette[i2][3] = data[i2];
      }
      this.palette(this._palette);
    }
    if (this._colorType === constants6.COLORTYPE_GRAYSCALE) {
      this.transColor([data.readUInt16BE(0)]);
    }
    if (this._colorType === constants6.COLORTYPE_COLOR) {
      this.transColor([
        data.readUInt16BE(0),
        data.readUInt16BE(2),
        data.readUInt16BE(4)
      ]);
    }
    this._handleChunkEnd();
  };
  Parser.prototype._handleGAMA = function(length) {
    this.read(length, this._parseGAMA.bind(this));
  };
  Parser.prototype._parseGAMA = function(data) {
    this._crc.write(data);
    this.gamma(data.readUInt32BE(0) / constants6.GAMMA_DIVISION);
    this._handleChunkEnd();
  };
  Parser.prototype._handleIDAT = function(length) {
    if (!this._emittedHeadersFinished) {
      this._emittedHeadersFinished = true;
      this.headersFinished();
    }
    this.read(-length, this._parseIDAT.bind(this, length));
  };
  Parser.prototype._parseIDAT = function(length, data) {
    this._crc.write(data);
    if (this._colorType === constants6.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
      throw new Error("Expected palette not found");
    }
    this.inflateData(data);
    let leftOverLength = length - data.length;
    if (leftOverLength > 0) {
      this._handleIDAT(leftOverLength);
    } else {
      this._handleChunkEnd();
    }
  };
  Parser.prototype._handleIEND = function(length) {
    this.read(length, this._parseIEND.bind(this));
  };
  Parser.prototype._parseIEND = function(data) {
    this._crc.write(data);
    this._hasIEND = true;
    this._handleChunkEnd();
    if (this.finished) {
      this.finished();
    }
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS((exports) => {
  var interlaceUtils = require_interlace();
  var pixelBppMapper = [
    function() {},
    function(pxData, data, pxPos, rawPos) {
      if (rawPos === data.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = 255;
    },
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 1 >= data.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = data[rawPos + 1];
    },
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 2 >= data.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data[rawPos];
      pxData[pxPos + 1] = data[rawPos + 1];
      pxData[pxPos + 2] = data[rawPos + 2];
      pxData[pxPos + 3] = 255;
    },
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 3 >= data.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data[rawPos];
      pxData[pxPos + 1] = data[rawPos + 1];
      pxData[pxPos + 2] = data[rawPos + 2];
      pxData[pxPos + 3] = data[rawPos + 3];
    }
  ];
  var pixelBppCustomMapper = [
    function() {},
    function(pxData, pixelData, pxPos, maxBit) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = maxBit;
    },
    function(pxData, pixelData, pxPos) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = pixelData[1];
    },
    function(pxData, pixelData, pxPos, maxBit) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = maxBit;
    },
    function(pxData, pixelData, pxPos) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = pixelData[3];
    }
  ];
  function bitRetriever(data, depth) {
    let leftOver = [];
    let i2 = 0;
    function split() {
      if (i2 === data.length) {
        throw new Error("Ran out of data");
      }
      let byte = data[i2];
      i2++;
      let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
      switch (depth) {
        default:
          throw new Error("unrecognised depth");
        case 16:
          byte2 = data[i2];
          i2++;
          leftOver.push((byte << 8) + byte2);
          break;
        case 4:
          byte2 = byte & 15;
          byte1 = byte >> 4;
          leftOver.push(byte1, byte2);
          break;
        case 2:
          byte4 = byte & 3;
          byte3 = byte >> 2 & 3;
          byte2 = byte >> 4 & 3;
          byte1 = byte >> 6 & 3;
          leftOver.push(byte1, byte2, byte3, byte4);
          break;
        case 1:
          byte8 = byte & 1;
          byte7 = byte >> 1 & 1;
          byte6 = byte >> 2 & 1;
          byte5 = byte >> 3 & 1;
          byte4 = byte >> 4 & 1;
          byte3 = byte >> 5 & 1;
          byte2 = byte >> 6 & 1;
          byte1 = byte >> 7 & 1;
          leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
          break;
      }
    }
    return {
      get: function(count2) {
        while (leftOver.length < count2) {
          split();
        }
        let returner = leftOver.slice(0, count2);
        leftOver = leftOver.slice(count2);
        return returner;
      },
      resetAfterLine: function() {
        leftOver.length = 0;
      },
      end: function() {
        if (i2 !== data.length) {
          throw new Error("extra data found");
        }
      }
    };
  }
  function mapImage8Bit(image3, pxData, getPxPos, bpp, data, rawPos) {
    let imageWidth = image3.width;
    let imageHeight = image3.height;
    let imagePass = image3.index;
    for (let y = 0;y < imageHeight; y++) {
      for (let x = 0;x < imageWidth; x++) {
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
        rawPos += bpp;
      }
    }
    return rawPos;
  }
  function mapImageCustomBit(image3, pxData, getPxPos, bpp, bits, maxBit) {
    let imageWidth = image3.width;
    let imageHeight = image3.height;
    let imagePass = image3.index;
    for (let y = 0;y < imageHeight; y++) {
      for (let x = 0;x < imageWidth; x++) {
        let pixelData = bits.get(bpp);
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
      }
      bits.resetAfterLine();
    }
  }
  exports.dataToBitMap = function(data, bitmapInfo) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let depth = bitmapInfo.depth;
    let bpp = bitmapInfo.bpp;
    let interlace = bitmapInfo.interlace;
    let bits;
    if (depth !== 8) {
      bits = bitRetriever(data, depth);
    }
    let pxData;
    if (depth <= 8) {
      pxData = Buffer.alloc(width * height * 4);
    } else {
      pxData = new Uint16Array(width * height * 4);
    }
    let maxBit = Math.pow(2, depth) - 1;
    let rawPos = 0;
    let images;
    let getPxPos;
    if (interlace) {
      images = interlaceUtils.getImagePasses(width, height);
      getPxPos = interlaceUtils.getInterlaceIterator(width, height);
    } else {
      let nonInterlacedPxPos = 0;
      getPxPos = function() {
        let returner = nonInterlacedPxPos;
        nonInterlacedPxPos += 4;
        return returner;
      };
      images = [{ width, height }];
    }
    for (let imageIndex = 0;imageIndex < images.length; imageIndex++) {
      if (depth === 8) {
        rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
      } else {
        mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
      }
    }
    if (depth === 8) {
      if (rawPos !== data.length) {
        throw new Error("extra data found");
      }
    } else {
      bits.end();
    }
    return pxData;
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS((exports, module) => {
  function dePalette(indata, outdata, width, height, palette2) {
    let pxPos = 0;
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        let color = palette2[indata[pxPos]];
        if (!color) {
          throw new Error("index " + indata[pxPos] + " not in palette");
        }
        for (let i2 = 0;i2 < 4; i2++) {
          outdata[pxPos + i2] = color[i2];
        }
        pxPos += 4;
      }
    }
  }
  function replaceTransparentColor(indata, outdata, width, height, transColor) {
    let pxPos = 0;
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        let makeTrans = false;
        if (transColor.length === 1) {
          if (transColor[0] === indata[pxPos]) {
            makeTrans = true;
          }
        } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
          makeTrans = true;
        }
        if (makeTrans) {
          for (let i2 = 0;i2 < 4; i2++) {
            outdata[pxPos + i2] = 0;
          }
        }
        pxPos += 4;
      }
    }
  }
  function scaleDepth(indata, outdata, width, height, depth) {
    let maxOutSample = 255;
    let maxInSample = Math.pow(2, depth) - 1;
    let pxPos = 0;
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        for (let i2 = 0;i2 < 4; i2++) {
          outdata[pxPos + i2] = Math.floor(indata[pxPos + i2] * maxOutSample / maxInSample + 0.5);
        }
        pxPos += 4;
      }
    }
  }
  module.exports = function(indata, imageData, skipRescale = false) {
    let depth = imageData.depth;
    let width = imageData.width;
    let height = imageData.height;
    let colorType = imageData.colorType;
    let transColor = imageData.transColor;
    let palette2 = imageData.palette;
    let outdata = indata;
    if (colorType === 3) {
      dePalette(indata, outdata, width, height, palette2);
    } else {
      if (transColor) {
        replaceTransparentColor(indata, outdata, width, height, transColor);
      }
      if (depth !== 8 && !skipRescale) {
        if (depth === 16) {
          outdata = Buffer.alloc(width * height * 4);
        }
        scaleDepth(indata, outdata, width, height, depth);
      }
    }
    return outdata;
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS((exports, module) => {
  var util = __require("util");
  var zlib = __require("zlib");
  var ChunkStream = require_chunkstream();
  var FilterAsync = require_filter_parse_async();
  var Parser = require_parser();
  var bitmapper = require_bitmapper();
  var formatNormaliser = require_format_normaliser();
  var ParserAsync = module.exports = function(options) {
    ChunkStream.call(this);
    this._parser = new Parser(options, {
      read: this.read.bind(this),
      error: this._handleError.bind(this),
      metadata: this._handleMetaData.bind(this),
      gamma: this.emit.bind(this, "gamma"),
      palette: this._handlePalette.bind(this),
      transColor: this._handleTransColor.bind(this),
      finished: this._finished.bind(this),
      inflateData: this._inflateData.bind(this),
      simpleTransparency: this._simpleTransparency.bind(this),
      headersFinished: this._headersFinished.bind(this)
    });
    this._options = options;
    this.writable = true;
    this._parser.start();
  };
  util.inherits(ParserAsync, ChunkStream);
  ParserAsync.prototype._handleError = function(err) {
    this.emit("error", err);
    this.writable = false;
    this.destroy();
    if (this._inflate && this._inflate.destroy) {
      this._inflate.destroy();
    }
    if (this._filter) {
      this._filter.destroy();
      this._filter.on("error", function() {});
    }
    this.errord = true;
  };
  ParserAsync.prototype._inflateData = function(data) {
    if (!this._inflate) {
      if (this._bitmapInfo.interlace) {
        this._inflate = zlib.createInflate();
        this._inflate.on("error", this.emit.bind(this, "error"));
        this._filter.on("complete", this._complete.bind(this));
        this._inflate.pipe(this._filter);
      } else {
        let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
        let imageSize = rowSize * this._bitmapInfo.height;
        let chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
        this._inflate = zlib.createInflate({ chunkSize });
        let leftToInflate = imageSize;
        let emitError = this.emit.bind(this, "error");
        this._inflate.on("error", function(err) {
          if (!leftToInflate) {
            return;
          }
          emitError(err);
        });
        this._filter.on("complete", this._complete.bind(this));
        let filterWrite = this._filter.write.bind(this._filter);
        this._inflate.on("data", function(chunk) {
          if (!leftToInflate) {
            return;
          }
          if (chunk.length > leftToInflate) {
            chunk = chunk.slice(0, leftToInflate);
          }
          leftToInflate -= chunk.length;
          filterWrite(chunk);
        });
        this._inflate.on("end", this._filter.end.bind(this._filter));
      }
    }
    this._inflate.write(data);
  };
  ParserAsync.prototype._handleMetaData = function(metaData) {
    this._metaData = metaData;
    this._bitmapInfo = Object.create(metaData);
    this._filter = new FilterAsync(this._bitmapInfo);
  };
  ParserAsync.prototype._handleTransColor = function(transColor) {
    this._bitmapInfo.transColor = transColor;
  };
  ParserAsync.prototype._handlePalette = function(palette2) {
    this._bitmapInfo.palette = palette2;
  };
  ParserAsync.prototype._simpleTransparency = function() {
    this._metaData.alpha = true;
  };
  ParserAsync.prototype._headersFinished = function() {
    this.emit("metadata", this._metaData);
  };
  ParserAsync.prototype._finished = function() {
    if (this.errord) {
      return;
    }
    if (!this._inflate) {
      this.emit("error", "No Inflate block");
    } else {
      this._inflate.end();
    }
  };
  ParserAsync.prototype._complete = function(filteredData) {
    if (this.errord) {
      return;
    }
    let normalisedBitmapData;
    try {
      let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
      normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo, this._options.skipRescale);
      bitmapData = null;
    } catch (ex) {
      this._handleError(ex);
      return;
    }
    this.emit("parsed", normalisedBitmapData);
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS((exports, module) => {
  var constants6 = require_constants3();
  module.exports = function(dataIn, width, height, options) {
    let outHasAlpha = [constants6.COLORTYPE_COLOR_ALPHA, constants6.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
    if (options.colorType === options.inputColorType) {
      let bigEndian = function() {
        let buffer = new ArrayBuffer(2);
        new DataView(buffer).setInt16(0, 256, true);
        return new Int16Array(buffer)[0] !== 256;
      }();
      if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
        return dataIn;
      }
    }
    let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
    let maxValue = 255;
    let inBpp = constants6.COLORTYPE_TO_BPP_MAP[options.inputColorType];
    if (inBpp === 4 && !options.inputHasAlpha) {
      inBpp = 3;
    }
    let outBpp = constants6.COLORTYPE_TO_BPP_MAP[options.colorType];
    if (options.bitDepth === 16) {
      maxValue = 65535;
      outBpp *= 2;
    }
    let outData = Buffer.alloc(width * height * outBpp);
    let inIndex = 0;
    let outIndex = 0;
    let bgColor = options.bgColor || {};
    if (bgColor.red === undefined) {
      bgColor.red = maxValue;
    }
    if (bgColor.green === undefined) {
      bgColor.green = maxValue;
    }
    if (bgColor.blue === undefined) {
      bgColor.blue = maxValue;
    }
    function getRGBA() {
      let red2;
      let green2;
      let blue2;
      let alpha = maxValue;
      switch (options.inputColorType) {
        case constants6.COLORTYPE_COLOR_ALPHA:
          alpha = data[inIndex + 3];
          red2 = data[inIndex];
          green2 = data[inIndex + 1];
          blue2 = data[inIndex + 2];
          break;
        case constants6.COLORTYPE_COLOR:
          red2 = data[inIndex];
          green2 = data[inIndex + 1];
          blue2 = data[inIndex + 2];
          break;
        case constants6.COLORTYPE_ALPHA:
          alpha = data[inIndex + 1];
          red2 = data[inIndex];
          green2 = red2;
          blue2 = red2;
          break;
        case constants6.COLORTYPE_GRAYSCALE:
          red2 = data[inIndex];
          green2 = red2;
          blue2 = red2;
          break;
        default:
          throw new Error("input color type:" + options.inputColorType + " is not supported at present");
      }
      if (options.inputHasAlpha) {
        if (!outHasAlpha) {
          alpha /= maxValue;
          red2 = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red2), 0), maxValue);
          green2 = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green2), 0), maxValue);
          blue2 = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue2), 0), maxValue);
        }
      }
      return { red: red2, green: green2, blue: blue2, alpha };
    }
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        let rgba = getRGBA(data, inIndex);
        switch (options.colorType) {
          case constants6.COLORTYPE_COLOR_ALPHA:
          case constants6.COLORTYPE_COLOR:
            if (options.bitDepth === 8) {
              outData[outIndex] = rgba.red;
              outData[outIndex + 1] = rgba.green;
              outData[outIndex + 2] = rgba.blue;
              if (outHasAlpha) {
                outData[outIndex + 3] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(rgba.red, outIndex);
              outData.writeUInt16BE(rgba.green, outIndex + 2);
              outData.writeUInt16BE(rgba.blue, outIndex + 4);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 6);
              }
            }
            break;
          case constants6.COLORTYPE_ALPHA:
          case constants6.COLORTYPE_GRAYSCALE: {
            let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
            if (options.bitDepth === 8) {
              outData[outIndex] = grayscale;
              if (outHasAlpha) {
                outData[outIndex + 1] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(grayscale, outIndex);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 2);
              }
            }
            break;
          }
          default:
            throw new Error("unrecognised color Type " + options.colorType);
        }
        inIndex += inBpp;
        outIndex += outBpp;
      }
    }
    return outData;
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS((exports, module) => {
  var paethPredictor = require_paeth_predictor();
  function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0;x < byteWidth; x++) {
      rawData[rawPos + x] = pxData[pxPos + x];
    }
  }
  function filterSumNone(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let i2 = pxPos;i2 < length; i2++) {
      sum += Math.abs(pxData[i2]);
    }
    return sum;
  }
  function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      rawData[rawPos + x] = val;
    }
  }
  function filterSumSub(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0;x < byteWidth; x++) {
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - up;
      rawData[rawPos + x] = val;
    }
  }
  function filterSumUp(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let x = pxPos;x < length; x++) {
      let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
      let val = pxData[x] - up;
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      rawData[rawPos + x] = val;
    }
  }
  function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
      rawData[rawPos + x] = val;
    }
  }
  function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
      sum += Math.abs(val);
    }
    return sum;
  }
  var filters = {
    0: filterNone,
    1: filterSub,
    2: filterUp,
    3: filterAvg,
    4: filterPaeth
  };
  var filterSums = {
    0: filterSumNone,
    1: filterSumSub,
    2: filterSumUp,
    3: filterSumAvg,
    4: filterSumPaeth
  };
  module.exports = function(pxData, width, height, options, bpp) {
    let filterTypes;
    if (!("filterType" in options) || options.filterType === -1) {
      filterTypes = [0, 1, 2, 3, 4];
    } else if (typeof options.filterType === "number") {
      filterTypes = [options.filterType];
    } else {
      throw new Error("unrecognised filter types");
    }
    if (options.bitDepth === 16) {
      bpp *= 2;
    }
    let byteWidth = width * bpp;
    let rawPos = 0;
    let pxPos = 0;
    let rawData = Buffer.alloc((byteWidth + 1) * height);
    let sel = filterTypes[0];
    for (let y = 0;y < height; y++) {
      if (filterTypes.length > 1) {
        let min = Infinity;
        for (let i2 = 0;i2 < filterTypes.length; i2++) {
          let sum = filterSums[filterTypes[i2]](pxData, pxPos, byteWidth, bpp);
          if (sum < min) {
            sel = filterTypes[i2];
            min = sum;
          }
        }
      }
      rawData[rawPos] = sel;
      rawPos++;
      filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
      rawPos += byteWidth;
      pxPos += byteWidth;
    }
    return rawData;
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/packer.js
var require_packer = __commonJS((exports, module) => {
  var constants6 = require_constants3();
  var CrcStream = require_crc();
  var bitPacker = require_bitpacker();
  var filter = require_filter_pack();
  var zlib = __require("zlib");
  var Packer = module.exports = function(options) {
    this._options = options;
    options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
    options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
    options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
    options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
    options.deflateFactory = options.deflateFactory || zlib.createDeflate;
    options.bitDepth = options.bitDepth || 8;
    options.colorType = typeof options.colorType === "number" ? options.colorType : constants6.COLORTYPE_COLOR_ALPHA;
    options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants6.COLORTYPE_COLOR_ALPHA;
    if ([
      constants6.COLORTYPE_GRAYSCALE,
      constants6.COLORTYPE_COLOR,
      constants6.COLORTYPE_COLOR_ALPHA,
      constants6.COLORTYPE_ALPHA
    ].indexOf(options.colorType) === -1) {
      throw new Error("option color type:" + options.colorType + " is not supported at present");
    }
    if ([
      constants6.COLORTYPE_GRAYSCALE,
      constants6.COLORTYPE_COLOR,
      constants6.COLORTYPE_COLOR_ALPHA,
      constants6.COLORTYPE_ALPHA
    ].indexOf(options.inputColorType) === -1) {
      throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
    }
    if (options.bitDepth !== 8 && options.bitDepth !== 16) {
      throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
    }
  };
  Packer.prototype.getDeflateOptions = function() {
    return {
      chunkSize: this._options.deflateChunkSize,
      level: this._options.deflateLevel,
      strategy: this._options.deflateStrategy
    };
  };
  Packer.prototype.createDeflate = function() {
    return this._options.deflateFactory(this.getDeflateOptions());
  };
  Packer.prototype.filterData = function(data, width, height) {
    let packedData = bitPacker(data, width, height, this._options);
    let bpp = constants6.COLORTYPE_TO_BPP_MAP[this._options.colorType];
    let filteredData = filter(packedData, width, height, this._options, bpp);
    return filteredData;
  };
  Packer.prototype._packChunk = function(type, data) {
    let len = data ? data.length : 0;
    let buf = Buffer.alloc(len + 12);
    buf.writeUInt32BE(len, 0);
    buf.writeUInt32BE(type, 4);
    if (data) {
      data.copy(buf, 8);
    }
    buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
    return buf;
  };
  Packer.prototype.packGAMA = function(gamma) {
    let buf = Buffer.alloc(4);
    buf.writeUInt32BE(Math.floor(gamma * constants6.GAMMA_DIVISION), 0);
    return this._packChunk(constants6.TYPE_gAMA, buf);
  };
  Packer.prototype.packIHDR = function(width, height) {
    let buf = Buffer.alloc(13);
    buf.writeUInt32BE(width, 0);
    buf.writeUInt32BE(height, 4);
    buf[8] = this._options.bitDepth;
    buf[9] = this._options.colorType;
    buf[10] = 0;
    buf[11] = 0;
    buf[12] = 0;
    return this._packChunk(constants6.TYPE_IHDR, buf);
  };
  Packer.prototype.packIDAT = function(data) {
    return this._packChunk(constants6.TYPE_IDAT, data);
  };
  Packer.prototype.packIEND = function() {
    return this._packChunk(constants6.TYPE_IEND, null);
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS((exports, module) => {
  var util = __require("util");
  var Stream2 = __require("stream");
  var constants6 = require_constants3();
  var Packer = require_packer();
  var PackerAsync = module.exports = function(opt) {
    Stream2.call(this);
    let options = opt || {};
    this._packer = new Packer(options);
    this._deflate = this._packer.createDeflate();
    this.readable = true;
  };
  util.inherits(PackerAsync, Stream2);
  PackerAsync.prototype.pack = function(data, width, height, gamma) {
    this.emit("data", Buffer.from(constants6.PNG_SIGNATURE));
    this.emit("data", this._packer.packIHDR(width, height));
    if (gamma) {
      this.emit("data", this._packer.packGAMA(gamma));
    }
    let filteredData = this._packer.filterData(data, width, height);
    this._deflate.on("error", this.emit.bind(this, "error"));
    this._deflate.on("data", function(compressedData) {
      this.emit("data", this._packer.packIDAT(compressedData));
    }.bind(this));
    this._deflate.on("end", function() {
      this.emit("data", this._packer.packIEND());
      this.emit("end");
    }.bind(this));
    this._deflate.end(filteredData);
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS((exports, module) => {
  var assert = __require("assert").ok;
  var zlib = __require("zlib");
  var util = __require("util");
  var kMaxLength = __require("buffer").kMaxLength;
  function Inflate(opts) {
    if (!(this instanceof Inflate)) {
      return new Inflate(opts);
    }
    if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
      opts.chunkSize = zlib.Z_MIN_CHUNK;
    }
    zlib.Inflate.call(this, opts);
    this._offset = this._offset === undefined ? this._outOffset : this._offset;
    this._buffer = this._buffer || this._outBuffer;
    if (opts && opts.maxLength != null) {
      this._maxLength = opts.maxLength;
    }
  }
  function createInflate(opts) {
    return new Inflate(opts);
  }
  function _close(engine, callback) {
    if (callback) {
      process.nextTick(callback);
    }
    if (!engine._handle) {
      return;
    }
    engine._handle.close();
    engine._handle = null;
  }
  Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
    if (typeof asyncCb === "function") {
      return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
    }
    let self2 = this;
    let availInBefore = chunk && chunk.length;
    let availOutBefore = this._chunkSize - this._offset;
    let leftToInflate = this._maxLength;
    let inOff = 0;
    let buffers = [];
    let nread = 0;
    let error;
    this.on("error", function(err) {
      error = err;
    });
    function handleChunk(availInAfter, availOutAfter) {
      if (self2._hadError) {
        return;
      }
      let have = availOutBefore - availOutAfter;
      assert(have >= 0, "have should not go down");
      if (have > 0) {
        let out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (out.length > leftToInflate) {
          out = out.slice(0, leftToInflate);
        }
        buffers.push(out);
        nread += out.length;
        leftToInflate -= out.length;
        if (leftToInflate === 0) {
          return false;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        return true;
      }
      return false;
    }
    assert(this._handle, "zlib binding closed");
    let res;
    do {
      res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
      res = res || this._writeState;
    } while (!this._hadError && handleChunk(res[0], res[1]));
    if (this._hadError) {
      throw error;
    }
    if (nread >= kMaxLength) {
      _close(this);
      throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
    }
    let buf = Buffer.concat(buffers, nread);
    _close(this);
    return buf;
  };
  util.inherits(Inflate, zlib.Inflate);
  function zlibBufferSync(engine, buffer) {
    if (typeof buffer === "string") {
      buffer = Buffer.from(buffer);
    }
    if (!(buffer instanceof Buffer)) {
      throw new TypeError("Not a string or buffer");
    }
    let flushFlag = engine._finishFlushFlag;
    if (flushFlag == null) {
      flushFlag = zlib.Z_FINISH;
    }
    return engine._processChunk(buffer, flushFlag);
  }
  function inflateSync(buffer, opts) {
    return zlibBufferSync(new Inflate(opts), buffer);
  }
  module.exports = exports = inflateSync;
  exports.Inflate = Inflate;
  exports.createInflate = createInflate;
  exports.inflateSync = inflateSync;
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS((exports, module) => {
  var SyncReader = module.exports = function(buffer) {
    this._buffer = buffer;
    this._reads = [];
  };
  SyncReader.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      allowLess: length < 0,
      func: callback
    });
  };
  SyncReader.prototype.process = function() {
    while (this._reads.length > 0 && this._buffer.length) {
      let read = this._reads[0];
      if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
        this._reads.shift();
        let buf = this._buffer;
        this._buffer = buf.slice(read.length);
        read.func.call(this, buf.slice(0, read.length));
      } else {
        break;
      }
    }
    if (this._reads.length > 0) {
      throw new Error("There are some read requests waitng on finished stream");
    }
    if (this._buffer.length > 0) {
      throw new Error("unrecognised content at end of stream");
    }
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS((exports) => {
  var SyncReader = require_sync_reader();
  var Filter = require_filter_parse();
  exports.process = function(inBuffer, bitmapInfo) {
    let outBuffers = [];
    let reader = new SyncReader(inBuffer);
    let filter = new Filter(bitmapInfo, {
      read: reader.read.bind(reader),
      write: function(bufferPart) {
        outBuffers.push(bufferPart);
      },
      complete: function() {}
    });
    filter.start();
    reader.process();
    return Buffer.concat(outBuffers);
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS((exports, module) => {
  var hasSyncZlib = true;
  var zlib = __require("zlib");
  var inflateSync = require_sync_inflate();
  if (!zlib.deflateSync) {
    hasSyncZlib = false;
  }
  var SyncReader = require_sync_reader();
  var FilterSync = require_filter_parse_sync();
  var Parser = require_parser();
  var bitmapper = require_bitmapper();
  var formatNormaliser = require_format_normaliser();
  module.exports = function(buffer, options) {
    if (!hasSyncZlib) {
      throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
    }
    let err;
    function handleError(_err_) {
      err = _err_;
    }
    let metaData;
    function handleMetaData(_metaData_) {
      metaData = _metaData_;
    }
    function handleTransColor(transColor) {
      metaData.transColor = transColor;
    }
    function handlePalette(palette2) {
      metaData.palette = palette2;
    }
    function handleSimpleTransparency() {
      metaData.alpha = true;
    }
    let gamma;
    function handleGamma(_gamma_) {
      gamma = _gamma_;
    }
    let inflateDataList = [];
    function handleInflateData(inflatedData2) {
      inflateDataList.push(inflatedData2);
    }
    let reader = new SyncReader(buffer);
    let parser = new Parser(options, {
      read: reader.read.bind(reader),
      error: handleError,
      metadata: handleMetaData,
      gamma: handleGamma,
      palette: handlePalette,
      transColor: handleTransColor,
      inflateData: handleInflateData,
      simpleTransparency: handleSimpleTransparency
    });
    parser.start();
    reader.process();
    if (err) {
      throw err;
    }
    let inflateData = Buffer.concat(inflateDataList);
    inflateDataList.length = 0;
    let inflatedData;
    if (metaData.interlace) {
      inflatedData = zlib.inflateSync(inflateData);
    } else {
      let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
      let imageSize = rowSize * metaData.height;
      inflatedData = inflateSync(inflateData, {
        chunkSize: imageSize,
        maxLength: imageSize
      });
    }
    inflateData = null;
    if (!inflatedData || !inflatedData.length) {
      throw new Error("bad png - invalid inflate data response");
    }
    let unfilteredData = FilterSync.process(inflatedData, metaData);
    inflateData = null;
    let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
    unfilteredData = null;
    let normalisedBitmapData = formatNormaliser(bitmapData, metaData, options.skipRescale);
    metaData.data = normalisedBitmapData;
    metaData.gamma = gamma || 0;
    return metaData;
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS((exports, module) => {
  var hasSyncZlib = true;
  var zlib = __require("zlib");
  if (!zlib.deflateSync) {
    hasSyncZlib = false;
  }
  var constants6 = require_constants3();
  var Packer = require_packer();
  module.exports = function(metaData, opt) {
    if (!hasSyncZlib) {
      throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
    }
    let options = opt || {};
    let packer = new Packer(options);
    let chunks = [];
    chunks.push(Buffer.from(constants6.PNG_SIGNATURE));
    chunks.push(packer.packIHDR(metaData.width, metaData.height));
    if (metaData.gamma) {
      chunks.push(packer.packGAMA(metaData.gamma));
    }
    let filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
    let compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
    filteredData = null;
    if (!compressedData || !compressedData.length) {
      throw new Error("bad png - invalid compressed data response");
    }
    chunks.push(packer.packIDAT(compressedData));
    chunks.push(packer.packIEND());
    return Buffer.concat(chunks);
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS((exports) => {
  var parse = require_parser_sync();
  var pack = require_packer_sync();
  exports.read = function(buffer, options) {
    return parse(buffer, options || {});
  };
  exports.write = function(png, options) {
    return pack(png, options);
  };
});

// node_modules/@jimp/js-png/node_modules/pngjs/lib/png.js
var require_png = __commonJS((exports) => {
  var util = __require("util");
  var Stream2 = __require("stream");
  var Parser = require_parser_async();
  var Packer = require_packer_async();
  var PNGSync = require_png_sync();
  var PNG = exports.PNG = function(options) {
    Stream2.call(this);
    options = options || {};
    this.width = options.width | 0;
    this.height = options.height | 0;
    this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
    if (options.fill && this.data) {
      this.data.fill(0);
    }
    this.gamma = 0;
    this.readable = this.writable = true;
    this._parser = new Parser(options);
    this._parser.on("error", this.emit.bind(this, "error"));
    this._parser.on("close", this._handleClose.bind(this));
    this._parser.on("metadata", this._metadata.bind(this));
    this._parser.on("gamma", this._gamma.bind(this));
    this._parser.on("parsed", function(data) {
      this.data = data;
      this.emit("parsed", data);
    }.bind(this));
    this._packer = new Packer(options);
    this._packer.on("data", this.emit.bind(this, "data"));
    this._packer.on("end", this.emit.bind(this, "end"));
    this._parser.on("close", this._handleClose.bind(this));
    this._packer.on("error", this.emit.bind(this, "error"));
  };
  util.inherits(PNG, Stream2);
  PNG.sync = PNGSync;
  PNG.prototype.pack = function() {
    if (!this.data || !this.data.length) {
      this.emit("error", "No data provided");
      return this;
    }
    process.nextTick(function() {
      this._packer.pack(this.data, this.width, this.height, this.gamma);
    }.bind(this));
    return this;
  };
  PNG.prototype.parse = function(data, callback) {
    if (callback) {
      let onParsed, onError;
      onParsed = function(parsedData) {
        this.removeListener("error", onError);
        this.data = parsedData;
        callback(null, this);
      }.bind(this);
      onError = function(err) {
        this.removeListener("parsed", onParsed);
        callback(err, null);
      }.bind(this);
      this.once("parsed", onParsed);
      this.once("error", onError);
    }
    this.end(data);
    return this;
  };
  PNG.prototype.write = function(data) {
    this._parser.write(data);
    return true;
  };
  PNG.prototype.end = function(data) {
    this._parser.end(data);
  };
  PNG.prototype._metadata = function(metadata) {
    this.width = metadata.width;
    this.height = metadata.height;
    this.emit("metadata", metadata);
  };
  PNG.prototype._gamma = function(gamma) {
    this.gamma = gamma;
  };
  PNG.prototype._handleClose = function() {
    if (!this._parser.writable && !this._packer.readable) {
      this.emit("close");
    }
  };
  PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
    srcX |= 0;
    srcY |= 0;
    width |= 0;
    height |= 0;
    deltaX |= 0;
    deltaY |= 0;
    if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
      throw new Error("bitblt reading outside image");
    }
    if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
      throw new Error("bitblt writing outside image");
    }
    for (let y = 0;y < height; y++) {
      src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
    }
  };
  PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
    PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
    return this;
  };
  PNG.adjustGamma = function(src) {
    if (src.gamma) {
      for (let y = 0;y < src.height; y++) {
        for (let x = 0;x < src.width; x++) {
          let idx = src.width * y + x << 2;
          for (let i2 = 0;i2 < 3; i2++) {
            let sample = src.data[idx + i2] / 255;
            sample = Math.pow(sample, 1 / 2.2 / src.gamma);
            src.data[idx + i2] = Math.round(sample * 255);
          }
        }
      }
      src.gamma = 0;
    }
  };
  PNG.prototype.adjustGamma = function() {
    PNG.adjustGamma(this);
  };
});

// node_modules/pako/lib/utils/common.js
var require_common2 = __commonJS((exports) => {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i2 = 0;i2 < len; i2++) {
        dest[dest_offs + i2] = src[src_offs + i2];
      }
    },
    flattenChunks: function(chunks) {
      var i2, l, len, pos, chunk, result;
      len = 0;
      for (i2 = 0, l = chunks.length;i2 < l; i2++) {
        len += chunks[i2].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i2 = 0, l = chunks.length;i2 < l; i2++) {
        chunk = chunks[i2];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i2 = 0;i2 < len; i2++) {
        dest[dest_offs + i2] = src[src_offs + i2];
      }
    },
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on6) {
    if (on6) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS((exports) => {
  var utils2 = require_common2();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
  var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
  var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  }
  function put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  function send_bits(s, value, length) {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 65535;
      s.bi_valid += length;
    }
  }
  function send_code(s, c3, tree) {
    send_bits(s, tree[c3 * 2], tree[c3 * 2 + 1]);
  }
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush(s) {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  function gen_bitlen(s, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base2 = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h2;
    var n2, m;
    var bits;
    var xbits;
    var f;
    var overflow = 0;
    for (bits = 0;bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h2 = s.heap_max + 1;h2 < HEAP_SIZE; h2++) {
      n2 = s.heap[h2];
      bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n2 * 2 + 1] = bits;
      if (n2 > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n2 >= base2) {
        xbits = extra[n2 - base2];
      }
      f = tree[n2 * 2];
      s.opt_len += f * (bits + xbits);
      if (has_stree) {
        s.static_len += f * (stree[n2 * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length;bits !== 0; bits--) {
      n2 = s.bl_count[bits];
      while (n2 !== 0) {
        m = s.heap[--h2];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n2--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n2;
    for (bits = 1;bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n2 = 0;n2 <= max_code; n2++) {
      var len = tree[n2 * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n2 * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  function tr_static_init() {
    var n2;
    var bits;
    var length;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0;code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n2 = 0;n2 < 1 << extra_lbits[code]; n2++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for (code = 0;code < 16; code++) {
      base_dist[code] = dist;
      for (n2 = 0;n2 < 1 << extra_dbits[code]; n2++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (;code < D_CODES; code++) {
      base_dist[code] = dist << 7;
      for (n2 = 0;n2 < 1 << extra_dbits[code] - 7; n2++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0;bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n2 = 0;
    while (n2 <= 143) {
      static_ltree[n2 * 2 + 1] = 8;
      n2++;
      bl_count[8]++;
    }
    while (n2 <= 255) {
      static_ltree[n2 * 2 + 1] = 9;
      n2++;
      bl_count[9]++;
    }
    while (n2 <= 279) {
      static_ltree[n2 * 2 + 1] = 7;
      n2++;
      bl_count[7]++;
    }
    while (n2 <= 287) {
      static_ltree[n2 * 2 + 1] = 8;
      n2++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n2 = 0;n2 < D_CODES; n2++) {
      static_dtree[n2 * 2 + 1] = 5;
      static_dtree[n2 * 2] = bi_reverse(n2, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s) {
    var n2;
    for (n2 = 0;n2 < L_CODES; n2++) {
      s.dyn_ltree[n2 * 2] = 0;
    }
    for (n2 = 0;n2 < D_CODES; n2++) {
      s.dyn_dtree[n2 * 2] = 0;
    }
    for (n2 = 0;n2 < BL_CODES; n2++) {
      s.bl_tree[n2 * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  function bi_windup(s) {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  function copy_block(s, buf, len, header) {
    bi_windup(s);
    if (header) {
      put_short(s, len);
      put_short(s, ~len);
    }
    utils2.arraySet(s.pending_buf, s.window, buf, len, s.pending);
    s.pending += len;
  }
  function smaller(tree, n2, m, depth) {
    var _n2 = n2 * 2;
    var _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m];
  }
  function pqdownheap(s, tree, k) {
    var v = s.heap[k];
    var j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  function compress_block(s, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    send_code(s, END_BLOCK, ltree);
  }
  function build_tree(s, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n2, m;
    var max_code = -1;
    var node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n2 = 0;n2 < elems; n2++) {
      if (tree[n2 * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n2;
        s.depth[n2] = 0;
      } else {
        tree[n2 * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n2 = s.heap_len >> 1;n2 >= 1; n2--) {
      pqdownheap(s, tree, n2);
    }
    node = elems;
    do {
      n2 = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n2;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n2 * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n2] >= s.depth[m] ? s.depth[n2] : s.depth[m]) + 1;
      tree[n2 * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  }
  function scan_tree(s, tree, max_code) {
    var n2;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count2 = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n2 = 0;n2 <= max_code; n2++) {
      curlen = nextlen;
      nextlen = tree[(n2 + 1) * 2 + 1];
      if (++count2 < max_count && curlen === nextlen) {
        continue;
      } else if (count2 < min_count) {
        s.bl_tree[curlen * 2] += count2;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count2 <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count2 = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s, tree, max_code) {
    var n2;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count2 = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n2 = 0;n2 <= max_code; n2++) {
      curlen = nextlen;
      nextlen = tree[(n2 + 1) * 2 + 1];
      if (++count2 < max_count && curlen === nextlen) {
        continue;
      } else if (count2 < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count2 !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count2--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count2 - 3, 2);
      } else if (count2 <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count2 - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count2 - 11, 7);
      }
      count2 = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s) {
    var max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES - 1;max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank = 0;rank < blcodes; rank++) {
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s) {
    var black_mask = 4093624447;
    var n2;
    for (n2 = 0;n2 <= 31; n2++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n2 * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n2 = 32;n2 < LITERALS; n2++) {
      if (s.dyn_ltree[n2 * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  }
  var static_init_done = false;
  function _tr_init(s) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  }
  function _tr_stored_block(s, buf, stored_len, last) {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s, buf, stored_len, true);
  }
  function _tr_align(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  }
  function _tr_flush_block(s, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
      bi_windup(s);
    }
  }
  function _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s.dyn_dtree[d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
  exports._tr_init = _tr_init;
  exports._tr_stored_block = _tr_stored_block;
  exports._tr_flush_block = _tr_flush_block;
  exports._tr_tally = _tr_tally;
  exports._tr_align = _tr_align;
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS((exports, module) => {
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
    while (len !== 0) {
      n2 = len > 2000 ? 2000 : len;
      len -= n2;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n2);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  module.exports = adler32;
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS((exports, module) => {
  function makeTable() {
    var c3, table = [];
    for (var n2 = 0;n2 < 256; n2++) {
      c3 = n2;
      for (var k = 0;k < 8; k++) {
        c3 = c3 & 1 ? 3988292384 ^ c3 >>> 1 : c3 >>> 1;
      }
      table[n2] = c3;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc ^= -1;
    for (var i2 = pos;i2 < end; i2++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i2]) & 255];
    }
    return crc ^ -1;
  }
  module.exports = crc32;
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS((exports, module) => {
  module.exports = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
  };
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS((exports) => {
  var utils2 = require_common2();
  var trees = require_trees();
  var adler32 = require_adler32();
  var crc32 = require_crc32();
  var msg = require_messages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending(strm) {
    var s = strm.state;
    var len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils2.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  function flush_block_only(s, last) {
    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  }
  function put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  function putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils2.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match(s, cur_match) {
    var chain_length = s.max_chain_length;
    var scan2 = s.strstart;
    var match;
    var len;
    var best_len = s.prev_length;
    var nice_match = s.nice_match;
    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s.window;
    var wmask = s.w_mask;
    var prev = s.prev;
    var strend = s.strstart + MAX_MATCH;
    var scan_end1 = _win[scan2 + best_len - 1];
    var scan_end = _win[scan2 + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan2] || _win[++match] !== _win[scan2 + 1]) {
        continue;
      }
      scan2 += 2;
      match++;
      do {} while (_win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && scan2 < strend);
      len = MAX_MATCH - (strend - scan2);
      scan2 = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan2 + best_len - 1];
        scan_end = _win[scan2 + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  function fill_window(s) {
    var _w_size = s.w_size;
    var p, n2, m, more, str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils2.arraySet(s.window, s.window, _w_size, _w_size, 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n2 = s.hash_size;
        p = n2;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n2);
        n2 = _w_size;
        p = n2;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n2);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n2 = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n2;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
        while (s.insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  function deflate_stored(s, flush) {
    var max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (;; ) {
      if (s.lookahead <= 1) {
        fill_window(s);
        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      var max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s, flush) {
    var hash_head;
    var bflush;
    for (;; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
        }
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (;; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s, flush) {
    var bflush;
    var prev;
    var scan2, strend;
    var _win = s.window;
    for (;; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan2 = s.strstart - 1;
        prev = _win[scan2];
        if (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2]) {
          strend = s.strstart + MAX_MATCH;
          do {} while (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && scan2 < strend);
          s.match_length = MAX_MATCH - (strend - scan2);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s, flush) {
    var bflush;
    for (;; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table;
  configuration_table = [
    new Config(0, 0, 0, 0, deflate_stored),
    new Config(4, 4, 8, 4, deflate_fast),
    new Config(4, 5, 16, 8, deflate_fast),
    new Config(4, 6, 32, 32, deflate_fast),
    new Config(4, 4, 16, 16, deflate_slow),
    new Config(8, 16, 32, 32, deflate_slow),
    new Config(8, 16, 128, 128, deflate_slow),
    new Config(8, 32, 128, 256, deflate_slow),
    new Config(32, 128, 258, 1024, deflate_slow),
    new Config(32, 258, 258, 4096, deflate_slow)
  ];
  function lm_init(s) {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils2.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils2.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils2.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils2.Buf16(MAX_BITS + 1);
    this.heap = new utils2.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils2.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH;
    trees._tr_init(s);
    return Z_OK;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  }
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s = new DeflateState;
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new utils2.Buf8(s.w_size * 2);
    s.head = new utils2.Buf16(s.hash_size);
    s.prev = new utils2.Buf16(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new utils2.Buf8(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  }
  function deflate(strm, flush) {
    var old_flush, s;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s.strm = strm;
    old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
        s.status = NAME_STATE;
      }
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
        s.status = COMMENT_STATE;
      }
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
        s.status = HCRC_STATE;
      }
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees._tr_align(s);
        } else if (flush !== Z_BLOCK) {
          trees._tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s;
    var str, n2;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s = strm.state;
    wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      tmpDict = new utils2.Buf8(s.w_size);
      utils2.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      str = s.strstart;
      n2 = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n2);
      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
  }
  exports.deflateInit = deflateInit;
  exports.deflateInit2 = deflateInit2;
  exports.deflateReset = deflateReset;
  exports.deflateResetKeep = deflateResetKeep;
  exports.deflateSetHeader = deflateSetHeader;
  exports.deflate = deflate;
  exports.deflateEnd = deflateEnd;
  exports.deflateSetDictionary = deflateSetDictionary;
  exports.deflateInfo = "pako deflate (from Nodeca project)";
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS((exports) => {
  var utils2 = require_common2();
  var STR_APPLY_OK = true;
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (__) {
    STR_APPLY_OK = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new utils2.Buf8(256);
  for (q = 0;q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  var q;
  _utf8len[254] = _utf8len[254] = 1;
  exports.string2buf = function(str) {
    var buf, c3, c22, m_pos, i2, str_len = str.length, buf_len = 0;
    for (m_pos = 0;m_pos < str_len; m_pos++) {
      c3 = str.charCodeAt(m_pos);
      if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      buf_len += c3 < 128 ? 1 : c3 < 2048 ? 2 : c3 < 65536 ? 3 : 4;
    }
    buf = new utils2.Buf8(buf_len);
    for (i2 = 0, m_pos = 0;i2 < buf_len; m_pos++) {
      c3 = str.charCodeAt(m_pos);
      if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      if (c3 < 128) {
        buf[i2++] = c3;
      } else if (c3 < 2048) {
        buf[i2++] = 192 | c3 >>> 6;
        buf[i2++] = 128 | c3 & 63;
      } else if (c3 < 65536) {
        buf[i2++] = 224 | c3 >>> 12;
        buf[i2++] = 128 | c3 >>> 6 & 63;
        buf[i2++] = 128 | c3 & 63;
      } else {
        buf[i2++] = 240 | c3 >>> 18;
        buf[i2++] = 128 | c3 >>> 12 & 63;
        buf[i2++] = 128 | c3 >>> 6 & 63;
        buf[i2++] = 128 | c3 & 63;
      }
    }
    return buf;
  };
  function buf2binstring(buf, len) {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
        return String.fromCharCode.apply(null, utils2.shrinkBuf(buf, len));
      }
    }
    var result = "";
    for (var i2 = 0;i2 < len; i2++) {
      result += String.fromCharCode(buf[i2]);
    }
    return result;
  }
  exports.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
  };
  exports.binstring2buf = function(str) {
    var buf = new utils2.Buf8(str.length);
    for (var i2 = 0, len = buf.length;i2 < len; i2++) {
      buf[i2] = str.charCodeAt(i2);
    }
    return buf;
  };
  exports.buf2string = function(buf, max) {
    var i2, out, c3, c_len;
    var len = max || buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i2 = 0;i2 < len; ) {
      c3 = buf[i2++];
      if (c3 < 128) {
        utf16buf[out++] = c3;
        continue;
      }
      c_len = _utf8len[c3];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i2 += c_len - 1;
        continue;
      }
      c3 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i2 < len) {
        c3 = c3 << 6 | buf[i2++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c3 < 65536) {
        utf16buf[out++] = c3;
      } else {
        c3 -= 65536;
        utf16buf[out++] = 55296 | c3 >> 10 & 1023;
        utf16buf[out++] = 56320 | c3 & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  exports.utf8border = function(buf, max) {
    var pos;
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS((exports, module) => {
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  module.exports = ZStream;
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS((exports) => {
  var zlib_deflate = require_deflate();
  var utils2 = require_common2();
  var strings = require_strings();
  var msg = require_messages();
  var ZStream = require_zstream();
  var toString3 = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  function Deflate(options) {
    if (!(this instanceof Deflate))
      return new Deflate(options);
    this.options = utils2.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === "string") {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString3.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.string2buf(data);
    } else if (toString3.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils2.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          this.onData(strings.buf2binstring(utils2.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils2.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils2.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate(input, options);
  }
  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate(input, options);
  }
  exports.Deflate = Deflate;
  exports.deflate = deflate;
  exports.deflateRaw = deflateRaw;
  exports.gzip = gzip;
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS((exports, module) => {
  var BAD = 30;
  var TYPE = 12;
  module.exports = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (;; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (;; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS((exports, module) => {
  var utils2 = require_common2();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min = 0, max = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base2 = null;
    var base_index = 0;
    var end;
    var count2 = new utils2.Buf16(MAXBITS + 1);
    var offs = new utils2.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0;len <= MAXBITS; len++) {
      count2[len] = 0;
    }
    for (sym = 0;sym < codes; sym++) {
      count2[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS;max >= 1; max--) {
      if (count2[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1;min < max; min++) {
      if (count2[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1;len <= MAXBITS; len++) {
      left <<= 1;
      left -= count2[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1;len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count2[len];
    }
    for (sym = 0;sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES) {
      base2 = extra = work;
      end = 19;
    } else if (type === LENS) {
      base2 = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base2 = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (;; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base2[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count2[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count2[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS((exports) => {
  var utils2 = require_common2();
  var adler32 = require_adler32();
  var crc32 = require_crc32();
  var inflate_fast = require_inffast();
  var inflate_table = require_inftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils2.Buf16(320);
    this.work = new utils2.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils2.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils2.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  }
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state = new InflateState;
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix;
  var distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils2.Buf32(512);
      distfix = new utils2.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  function updatewindow(strm, src, end, copy) {
    var dist;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils2.Buf8(state.wsize);
    }
    if (copy >= state.wsize) {
      utils2.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      utils2.arraySet(state.window, src, end - copy, dist, state.wnext);
      copy -= dist;
      if (copy) {
        utils2.arraySet(state.window, src, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  function inflate(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils2.Buf8(4);
    var opts;
    var n2;
    var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (;; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils2.arraySet(state.head.extra, input, next, copy, len);
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils2.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (;; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n2 = here_bits + 2;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n2 = here_bits + 3;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n2 = here_bits + 7;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (;; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n2 = state.extra;
              while (bits < n2) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (;; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n2 = state.extra;
              while (bits < n2) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK;
  }
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return Z_OK;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK;
  }
  exports.inflateReset = inflateReset;
  exports.inflateReset2 = inflateReset2;
  exports.inflateResetKeep = inflateResetKeep;
  exports.inflateInit = inflateInit;
  exports.inflateInit2 = inflateInit2;
  exports.inflate = inflate;
  exports.inflateEnd = inflateEnd;
  exports.inflateGetHeader = inflateGetHeader;
  exports.inflateSetDictionary = inflateSetDictionary;
  exports.inflateInfo = "pako inflate (from Nodeca project)";
});

// node_modules/pako/lib/zlib/constants.js
var require_constants4 = __commonJS((exports, module) => {
  module.exports = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS((exports, module) => {
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  module.exports = GZheader;
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS((exports) => {
  var zlib_inflate = require_inflate();
  var utils2 = require_common2();
  var strings = require_strings();
  var c3 = require_constants4();
  var msg = require_messages();
  var ZStream = require_zstream();
  var GZheader = require_gzheader();
  var toString3 = Object.prototype.toString;
  function Inflate(options) {
    if (!(this instanceof Inflate))
      return new Inflate(options);
    this.options = utils2.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream;
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== c3.Z_OK) {
      throw new Error(msg[status]);
    }
    this.header = new GZheader;
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString3.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== c3.Z_OK) {
          throw new Error(msg[status]);
        }
      }
    }
  }
  Inflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;
    var status, _mode;
    var next_out_utf8, tail, utf8str;
    var allowBufError = false;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? c3.Z_FINISH : c3.Z_NO_FLUSH;
    if (typeof data === "string") {
      strm.input = strings.binstring2buf(data);
    } else if (toString3.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils2.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, c3.Z_NO_FLUSH);
      if (status === c3.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
      }
      if (status === c3.Z_BUF_ERROR && allowBufError === true) {
        status = c3.Z_OK;
        allowBufError = false;
      }
      if (status !== c3.Z_STREAM_END && status !== c3.Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === c3.Z_STREAM_END || strm.avail_in === 0 && (_mode === c3.Z_FINISH || _mode === c3.Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            tail = strm.next_out - next_out_utf8;
            utf8str = strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) {
              utils2.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
            }
            this.onData(utf8str);
          } else {
            this.onData(utils2.shrinkBuf(strm.output, strm.next_out));
          }
        }
      }
      if (strm.avail_in === 0 && strm.avail_out === 0) {
        allowBufError = true;
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c3.Z_STREAM_END);
    if (status === c3.Z_STREAM_END) {
      _mode = c3.Z_FINISH;
    }
    if (_mode === c3.Z_FINISH) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === c3.Z_OK;
    }
    if (_mode === c3.Z_SYNC_FLUSH) {
      this.onEnd(c3.Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate.prototype.onEnd = function(status) {
    if (status === c3.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils2.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate(input, options) {
    var inflator = new Inflate(options);
    inflator.push(input, true);
    if (inflator.err) {
      throw inflator.msg || msg[inflator.err];
    }
    return inflator.result;
  }
  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate(input, options);
  }
  exports.Inflate = Inflate;
  exports.inflate = inflate;
  exports.inflateRaw = inflateRaw;
  exports.ungzip = inflate;
});

// node_modules/pako/index.js
var require_pako = __commonJS((exports, module) => {
  var assign = require_common2().assign;
  var deflate = require_deflate2();
  var inflate = require_inflate2();
  var constants7 = require_constants4();
  var pako = {};
  assign(pako, deflate, inflate, constants7);
  module.exports = pako;
});

// node_modules/utif2/UTIF.js
var require_UTIF = __commonJS((exports, module) => {
  (function() {
    var UTIF = {};
    if (typeof module == "object") {
      module.exports = UTIF;
    } else {
      self.UTIF = UTIF;
    }
    var pako = require_pako();
    function log() {
      if (typeof process == "undefined" || true)
        console.log.apply(console, arguments);
    }
    (function(UTIF2, pako2) {
      (function() {
        var W = function a1() {
          function W2(p) {
            this.message = "JPEG error: " + p;
          }
          W2.prototype = new Error;
          W2.prototype.name = "JpegError";
          W2.constructor = W2;
          return W2;
        }(), ak = function ag() {
          var p = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), t = 4017, ac = 799, ah = 3406, ao = 2276, ar = 1567, ai = 3784, s = 5793, ad = 2896;
          function ak2(Q) {
            if (Q == null)
              Q = {};
            if (Q.w == null)
              Q.w = -1;
            this.V = Q.n;
            this.N = Q.w;
          }
          function a5(Q, h2) {
            var f = 0, G = [], n2, E, a3 = 16, F;
            while (a3 > 0 && !Q[a3 - 1]) {
              a3--;
            }
            G.push({ children: [], index: 0 });
            var C = G[0];
            for (n2 = 0;n2 < a3; n2++) {
              for (E = 0;E < Q[n2]; E++) {
                C = G.pop();
                C.children[C.index] = h2[f];
                while (C.index > 0) {
                  C = G.pop();
                }
                C.index++;
                G.push(C);
                while (G.length <= n2) {
                  G.push(F = { children: [], index: 0 });
                  C.children[C.index] = F.children;
                  C = F;
                }
                f++;
              }
              if (n2 + 1 < a3) {
                G.push(F = { children: [], index: 0 });
                C.children[C.index] = F.children;
                C = F;
              }
            }
            return G[0].children;
          }
          function a2(Q, h2, f) {
            return 64 * ((Q.P + 1) * h2 + f);
          }
          function a7(Q, h2, f, G, n2, E, a3, C, F, d) {
            if (d == null)
              d = false;
            var { m: T, Z: U } = f, z = h2, J = 0, V = 0, r = 0, D = 0, a8, q = 0, X, O, _, N, e, K, x = 0, k, g, R, c3;
            function Y() {
              if (V > 0) {
                V--;
                return J >> V & 1;
              }
              J = Q[h2++];
              if (J === 255) {
                var I = Q[h2++];
                if (I) {
                  if (I === 220 && d) {
                    h2 += 2;
                    var l = Z(Q, h2);
                    h2 += 2;
                    if (l > 0 && l !== f.s) {
                      throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", l);
                    }
                  } else if (I === 217) {
                    if (d) {
                      var M = q * 8;
                      if (M > 0 && M < f.s / 10) {
                        throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, " + "possibly caused by incorrect `scanLines` parameter", M);
                      }
                    }
                    throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                  }
                  throw new W("unexpected marker");
                }
              }
              V = 7;
              return J >>> 7;
            }
            function u2(I) {
              var l = I;
              while (true) {
                l = l[Y()];
                switch (typeof l) {
                  case "number":
                    return l;
                  case "object":
                    continue;
                }
                throw new W("invalid huffman sequence");
              }
            }
            function m(I) {
              var e2 = 0;
              while (I > 0) {
                e2 = e2 << 1 | Y();
                I--;
              }
              return e2;
            }
            function j(I) {
              if (I === 1) {
                return Y() === 1 ? 1 : -1;
              }
              var e2 = m(I);
              if (e2 >= 1 << I - 1) {
                return e2;
              }
              return e2 + (-1 << I) + 1;
            }
            function v(X2, I) {
              var l = u2(X2.J), M = l === 0 ? 0 : j(l), N2 = 1;
              X2.D[I] = X2.Q += M;
              while (N2 < 64) {
                var S = u2(X2.i), i2 = S & 15, A = S >> 4;
                if (i2 === 0) {
                  if (A < 15) {
                    break;
                  }
                  N2 += 16;
                  continue;
                }
                N2 += A;
                var o2 = p[N2];
                X2.D[I + o2] = j(i2);
                N2++;
              }
            }
            function $2(X2, I) {
              var l = u2(X2.J), M = l === 0 ? 0 : j(l) << F;
              X2.D[I] = X2.Q += M;
            }
            function b(X2, I) {
              X2.D[I] |= Y() << F;
            }
            function P(X2, I) {
              if (r > 0) {
                r--;
                return;
              }
              var N2 = E, l = a3;
              while (N2 <= l) {
                var M = u2(X2.i), S = M & 15, i2 = M >> 4;
                if (S === 0) {
                  if (i2 < 15) {
                    r = m(i2) + (1 << i2) - 1;
                    break;
                  }
                  N2 += 16;
                  continue;
                }
                N2 += i2;
                var A = p[N2];
                X2.D[I + A] = j(S) * (1 << F);
                N2++;
              }
            }
            function a4(X2, I) {
              var N2 = E, l = a3, M = 0, S, i2;
              while (N2 <= l) {
                var A = I + p[N2], o2 = X2.D[A] < 0 ? -1 : 1;
                switch (D) {
                  case 0:
                    i2 = u2(X2.i);
                    S = i2 & 15;
                    M = i2 >> 4;
                    if (S === 0) {
                      if (M < 15) {
                        r = m(M) + (1 << M);
                        D = 4;
                      } else {
                        M = 16;
                        D = 1;
                      }
                    } else {
                      if (S !== 1) {
                        throw new W("invalid ACn encoding");
                      }
                      a8 = j(S);
                      D = M ? 2 : 3;
                    }
                    continue;
                  case 1:
                  case 2:
                    if (X2.D[A]) {
                      X2.D[A] += o2 * (Y() << F);
                    } else {
                      M--;
                      if (M === 0) {
                        D = D === 2 ? 3 : 0;
                      }
                    }
                    break;
                  case 3:
                    if (X2.D[A]) {
                      X2.D[A] += o2 * (Y() << F);
                    } else {
                      X2.D[A] = a8 << F;
                      D = 0;
                    }
                    break;
                  case 4:
                    if (X2.D[A]) {
                      X2.D[A] += o2 * (Y() << F);
                    }
                    break;
                }
                N2++;
              }
              if (D === 4) {
                r--;
                if (r === 0) {
                  D = 0;
                }
              }
            }
            function H(X2, I, x2, l, M) {
              var S = x2 / T | 0, i2 = x2 % T;
              q = S * X2.A + l;
              var A = i2 * X2.h + M, o2 = a2(X2, q, A);
              I(X2, o2);
            }
            function w(X2, I, x2) {
              q = x2 / X2.P | 0;
              var l = x2 % X2.P, M = a2(X2, q, l);
              I(X2, M);
            }
            var y = G.length;
            if (U) {
              if (E === 0) {
                K = C === 0 ? $2 : b;
              } else {
                K = C === 0 ? P : a4;
              }
            } else {
              K = v;
            }
            if (y === 1) {
              g = G[0].P * G[0].c;
            } else {
              g = T * f.R;
            }
            while (x <= g) {
              var L = n2 ? Math.min(g - x, n2) : g;
              if (L > 0) {
                for (O = 0;O < y; O++) {
                  G[O].Q = 0;
                }
                r = 0;
                if (y === 1) {
                  X = G[0];
                  for (e = 0;e < L; e++) {
                    w(X, K, x);
                    x++;
                  }
                } else {
                  for (e = 0;e < L; e++) {
                    for (O = 0;O < y; O++) {
                      X = G[O];
                      R = X.h;
                      c3 = X.A;
                      for (_ = 0;_ < c3; _++) {
                        for (N = 0;N < R; N++) {
                          H(X, K, x, _, N);
                        }
                      }
                    }
                    x++;
                  }
                }
              }
              V = 0;
              k = an(Q, h2);
              if (!k) {
                break;
              }
              if (k.u) {
                var a6 = L > 0 ? "unexpected" : "excessive";
                h2 = k.offset;
              }
              if (k.M >= 65488 && k.M <= 65495) {
                h2 += 2;
              } else {
                break;
              }
            }
            return h2 - z;
          }
          function al(Q, h2, f) {
            var { $: G, D: n2 } = Q, E, a3, C, F, d, T, U, z, J, V, Y, u2, m, j, v, $2, b;
            if (!G) {
              throw new W("missing required Quantization Table.");
            }
            for (var r = 0;r < 64; r += 8) {
              J = n2[h2 + r];
              V = n2[h2 + r + 1];
              Y = n2[h2 + r + 2];
              u2 = n2[h2 + r + 3];
              m = n2[h2 + r + 4];
              j = n2[h2 + r + 5];
              v = n2[h2 + r + 6];
              $2 = n2[h2 + r + 7];
              J *= G[r];
              if ((V | Y | u2 | m | j | v | $2) === 0) {
                b = s * J + 512 >> 10;
                f[r] = b;
                f[r + 1] = b;
                f[r + 2] = b;
                f[r + 3] = b;
                f[r + 4] = b;
                f[r + 5] = b;
                f[r + 6] = b;
                f[r + 7] = b;
                continue;
              }
              V *= G[r + 1];
              Y *= G[r + 2];
              u2 *= G[r + 3];
              m *= G[r + 4];
              j *= G[r + 5];
              v *= G[r + 6];
              $2 *= G[r + 7];
              E = s * J + 128 >> 8;
              a3 = s * m + 128 >> 8;
              C = Y;
              F = v;
              d = ad * (V - $2) + 128 >> 8;
              z = ad * (V + $2) + 128 >> 8;
              T = u2 << 4;
              U = j << 4;
              E = E + a3 + 1 >> 1;
              a3 = E - a3;
              b = C * ai + F * ar + 128 >> 8;
              C = C * ar - F * ai + 128 >> 8;
              F = b;
              d = d + U + 1 >> 1;
              U = d - U;
              z = z + T + 1 >> 1;
              T = z - T;
              E = E + F + 1 >> 1;
              F = E - F;
              a3 = a3 + C + 1 >> 1;
              C = a3 - C;
              b = d * ao + z * ah + 2048 >> 12;
              d = d * ah - z * ao + 2048 >> 12;
              z = b;
              b = T * ac + U * t + 2048 >> 12;
              T = T * t - U * ac + 2048 >> 12;
              U = b;
              f[r] = E + z;
              f[r + 7] = E - z;
              f[r + 1] = a3 + U;
              f[r + 6] = a3 - U;
              f[r + 2] = C + T;
              f[r + 5] = C - T;
              f[r + 3] = F + d;
              f[r + 4] = F - d;
            }
            for (var P = 0;P < 8; ++P) {
              J = f[P];
              V = f[P + 8];
              Y = f[P + 16];
              u2 = f[P + 24];
              m = f[P + 32];
              j = f[P + 40];
              v = f[P + 48];
              $2 = f[P + 56];
              if ((V | Y | u2 | m | j | v | $2) === 0) {
                b = s * J + 8192 >> 14;
                if (b < -2040) {
                  b = 0;
                } else if (b >= 2024) {
                  b = 255;
                } else {
                  b = b + 2056 >> 4;
                }
                n2[h2 + P] = b;
                n2[h2 + P + 8] = b;
                n2[h2 + P + 16] = b;
                n2[h2 + P + 24] = b;
                n2[h2 + P + 32] = b;
                n2[h2 + P + 40] = b;
                n2[h2 + P + 48] = b;
                n2[h2 + P + 56] = b;
                continue;
              }
              E = s * J + 2048 >> 12;
              a3 = s * m + 2048 >> 12;
              C = Y;
              F = v;
              d = ad * (V - $2) + 2048 >> 12;
              z = ad * (V + $2) + 2048 >> 12;
              T = u2;
              U = j;
              E = (E + a3 + 1 >> 1) + 4112;
              a3 = E - a3;
              b = C * ai + F * ar + 2048 >> 12;
              C = C * ar - F * ai + 2048 >> 12;
              F = b;
              d = d + U + 1 >> 1;
              U = d - U;
              z = z + T + 1 >> 1;
              T = z - T;
              E = E + F + 1 >> 1;
              F = E - F;
              a3 = a3 + C + 1 >> 1;
              C = a3 - C;
              b = d * ao + z * ah + 2048 >> 12;
              d = d * ah - z * ao + 2048 >> 12;
              z = b;
              b = T * ac + U * t + 2048 >> 12;
              T = T * t - U * ac + 2048 >> 12;
              U = b;
              J = E + z;
              $2 = E - z;
              V = a3 + U;
              v = a3 - U;
              Y = C + T;
              j = C - T;
              u2 = F + d;
              m = F - d;
              if (J < 16) {
                J = 0;
              } else if (J >= 4080) {
                J = 255;
              } else {
                J >>= 4;
              }
              if (V < 16) {
                V = 0;
              } else if (V >= 4080) {
                V = 255;
              } else {
                V >>= 4;
              }
              if (Y < 16) {
                Y = 0;
              } else if (Y >= 4080) {
                Y = 255;
              } else {
                Y >>= 4;
              }
              if (u2 < 16) {
                u2 = 0;
              } else if (u2 >= 4080) {
                u2 = 255;
              } else {
                u2 >>= 4;
              }
              if (m < 16) {
                m = 0;
              } else if (m >= 4080) {
                m = 255;
              } else {
                m >>= 4;
              }
              if (j < 16) {
                j = 0;
              } else if (j >= 4080) {
                j = 255;
              } else {
                j >>= 4;
              }
              if (v < 16) {
                v = 0;
              } else if (v >= 4080) {
                v = 255;
              } else {
                v >>= 4;
              }
              if ($2 < 16) {
                $2 = 0;
              } else if ($2 >= 4080) {
                $2 = 255;
              } else {
                $2 >>= 4;
              }
              n2[h2 + P] = J;
              n2[h2 + P + 8] = V;
              n2[h2 + P + 16] = Y;
              n2[h2 + P + 24] = u2;
              n2[h2 + P + 32] = m;
              n2[h2 + P + 40] = j;
              n2[h2 + P + 48] = v;
              n2[h2 + P + 56] = $2;
            }
          }
          function a0(Q, h2) {
            var { P: f, c: G } = h2, n2 = new Int16Array(64);
            for (var E = 0;E < G; E++) {
              for (var a3 = 0;a3 < f; a3++) {
                var C = a2(h2, E, a3);
                al(h2, C, n2);
              }
            }
            return h2.D;
          }
          function an(Q, h2, f) {
            if (f == null)
              f = h2;
            var G = Q.length - 1, n2 = f < h2 ? f : h2;
            if (h2 >= G) {
              return null;
            }
            var E = Z(Q, h2);
            if (E >= 65472 && E <= 65534) {
              return { u: null, M: E, offset: h2 };
            }
            var a3 = Z(Q, n2);
            while (!(a3 >= 65472 && a3 <= 65534)) {
              if (++n2 >= G) {
                return null;
              }
              a3 = Z(Q, n2);
            }
            return { u: E.toString(16), M: a3, offset: n2 };
          }
          ak2.prototype = { parse(Q, h2) {
            if (h2 == null)
              h2 = {};
            var f = h2.F, E = 0, a3 = null, C = null, F, d, T = 0;
            function G() {
              var o2 = Z(Q, E);
              E += 2;
              var B = E + o2 - 2, V2 = an(Q, B, E);
              if (V2 && V2.u) {
                B = V2.offset;
              }
              var ab = Q.subarray(E, B);
              E += ab.length;
              return ab;
            }
            function n2(F2) {
              var o2 = Math.ceil(F2.o / 8 / F2.X), B = Math.ceil(F2.s / 8 / F2.B);
              for (var Y2 = 0;Y2 < F2.W.length; Y2++) {
                R = F2.W[Y2];
                var ab = Math.ceil(Math.ceil(F2.o / 8) * R.h / F2.X), af = Math.ceil(Math.ceil(F2.s / 8) * R.A / F2.B), ap = o2 * R.h, aq = B * R.A, ae = 64 * aq * (ap + 1);
                R.D = new Int16Array(ae);
                R.P = ab;
                R.c = af;
              }
              F2.m = o2;
              F2.R = B;
            }
            var U = [], z = [], J = [], V = Z(Q, E);
            E += 2;
            if (V !== 65496) {
              throw new W("SOI not found");
            }
            V = Z(Q, E);
            E += 2;
            markerLoop:
              while (V !== 65497) {
                var Y, u2, m;
                switch (V) {
                  case 65504:
                  case 65505:
                  case 65506:
                  case 65507:
                  case 65508:
                  case 65509:
                  case 65510:
                  case 65511:
                  case 65512:
                  case 65513:
                  case 65514:
                  case 65515:
                  case 65516:
                  case 65517:
                  case 65518:
                  case 65519:
                  case 65534:
                    var j = G();
                    if (V === 65504) {
                      if (j[0] === 74 && j[1] === 70 && j[2] === 73 && j[3] === 70 && j[4] === 0) {
                        a3 = { version: { d: j[5], T: j[6] }, K: j[7], j: j[8] << 8 | j[9], H: j[10] << 8 | j[11], S: j[12], I: j[13], C: j.subarray(14, 14 + 3 * j[12] * j[13]) };
                      }
                    }
                    if (V === 65518) {
                      if (j[0] === 65 && j[1] === 100 && j[2] === 111 && j[3] === 98 && j[4] === 101) {
                        C = { version: j[5] << 8 | j[6], k: j[7] << 8 | j[8], q: j[9] << 8 | j[10], a: j[11] };
                      }
                    }
                    break;
                  case 65499:
                    var v = Z(Q, E), b;
                    E += 2;
                    var $2 = v + E - 2;
                    while (E < $2) {
                      var r = Q[E++], P = new Uint16Array(64);
                      if (r >> 4 === 0) {
                        for (u2 = 0;u2 < 64; u2++) {
                          b = p[u2];
                          P[b] = Q[E++];
                        }
                      } else if (r >> 4 === 1) {
                        for (u2 = 0;u2 < 64; u2++) {
                          b = p[u2];
                          P[b] = Z(Q, E);
                          E += 2;
                        }
                      } else {
                        throw new W("DQT - invalid table spec");
                      }
                      U[r & 15] = P;
                    }
                    break;
                  case 65472:
                  case 65473:
                  case 65474:
                    if (F) {
                      throw new W("Only single frame JPEGs supported");
                    }
                    E += 2;
                    F = {};
                    F.G = V === 65473;
                    F.Z = V === 65474;
                    F.precision = Q[E++];
                    var D = Z(Q, E), a4, q = 0, H = 0;
                    E += 2;
                    F.s = f || D;
                    F.o = Z(Q, E);
                    E += 2;
                    F.W = [];
                    F._ = {};
                    var a8 = Q[E++];
                    for (Y = 0;Y < a8; Y++) {
                      a4 = Q[E];
                      var w = Q[E + 1] >> 4, y = Q[E + 1] & 15;
                      if (q < w) {
                        q = w;
                      }
                      if (H < y) {
                        H = y;
                      }
                      var X = Q[E + 2];
                      m = F.W.push({ h: w, A: y, L: X, $: null });
                      F._[a4] = m - 1;
                      E += 3;
                    }
                    F.X = q;
                    F.B = H;
                    n2(F);
                    break;
                  case 65476:
                    var O = Z(Q, E);
                    E += 2;
                    for (Y = 2;Y < O; ) {
                      var _ = Q[E++], N = new Uint8Array(16), e = 0;
                      for (u2 = 0;u2 < 16; u2++, E++) {
                        e += N[u2] = Q[E];
                      }
                      var K = new Uint8Array(e);
                      for (u2 = 0;u2 < e; u2++, E++) {
                        K[u2] = Q[E];
                      }
                      Y += 17 + e;
                      (_ >> 4 === 0 ? J : z)[_ & 15] = a5(N, K);
                    }
                    break;
                  case 65501:
                    E += 2;
                    d = Z(Q, E);
                    E += 2;
                    break;
                  case 65498:
                    var x = ++T === 1 && !f, R;
                    E += 2;
                    var k = Q[E++], g = [];
                    for (Y = 0;Y < k; Y++) {
                      var c3 = Q[E++], L = F._[c3];
                      R = F.W[L];
                      R.index = c3;
                      var a6 = Q[E++];
                      R.J = J[a6 >> 4];
                      R.i = z[a6 & 15];
                      g.push(R);
                    }
                    var I = Q[E++], l = Q[E++], M = Q[E++];
                    try {
                      var S = a7(Q, E, F, g, d, I, l, M >> 4, M & 15, x);
                      E += S;
                    } catch (ex) {
                      if (ex instanceof DNLMarkerError) {
                        return this.parse(Q, { F: ex.s });
                      } else if (ex instanceof EOIMarkerError) {
                        break markerLoop;
                      }
                      throw ex;
                    }
                    break;
                  case 65500:
                    E += 4;
                    break;
                  case 65535:
                    if (Q[E] !== 255) {
                      E--;
                    }
                    break;
                  default:
                    var i2 = an(Q, E - 2, E - 3);
                    if (i2 && i2.u) {
                      E = i2.offset;
                      break;
                    }
                    if (E >= Q.length - 1) {
                      break markerLoop;
                    }
                    throw new W("JpegImage.parse - unknown marker: " + V.toString(16));
                }
                V = Z(Q, E);
                E += 2;
              }
            this.width = F.o;
            this.height = F.s;
            this.g = a3;
            this.b = C;
            this.W = [];
            for (Y = 0;Y < F.W.length; Y++) {
              R = F.W[Y];
              var A = U[R.L];
              if (A) {
                R.$ = A;
              }
              this.W.push({ index: R.index, e: a0(F, R), l: R.h / F.X, t: R.A / F.B, P: R.P, c: R.c });
            }
            this.p = this.W.length;
            return;
          }, Y(Q, h2, f) {
            if (f == null)
              f = false;
            var G = this.width / Q, n2 = this.height / h2, E, a3, C, F, d, T, U, z, J, V, Y = 0, u2, m = this.W.length, j = Q * h2 * m, v = new Uint8ClampedArray(j), $2 = new Uint32Array(Q), b = 4294967288, r;
            for (U = 0;U < m; U++) {
              E = this.W[U];
              a3 = E.l * G;
              C = E.t * n2;
              Y = U;
              u2 = E.e;
              F = E.P + 1 << 3;
              if (a3 !== r) {
                for (d = 0;d < Q; d++) {
                  z = 0 | d * a3;
                  $2[d] = (z & b) << 3 | z & 7;
                }
                r = a3;
              }
              for (T = 0;T < h2; T++) {
                z = 0 | T * C;
                V = F * (z & b) | (z & 7) << 3;
                for (d = 0;d < Q; d++) {
                  v[Y] = u2[V + $2[d]];
                  Y += m;
                }
              }
            }
            var P = this.V;
            if (!f && m === 4 && !P) {
              P = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
            }
            if (P) {
              for (U = 0;U < j; ) {
                for (z = 0, J = 0;z < m; z++, U++, J += 2) {
                  v[U] = (v[U] * P[J] >> 8) + P[J + 1];
                }
              }
            }
            return v;
          }, get f() {
            if (this.b) {
              return !!this.b.a;
            }
            if (this.p === 3) {
              if (this.N === 0) {
                return false;
              } else if (this.W[0].index === 82 && this.W[1].index === 71 && this.W[2].index === 66) {
                return false;
              }
              return true;
            }
            if (this.N === 1) {
              return true;
            }
            return false;
          }, z: function aj(Q) {
            var h2, f, G;
            for (var n2 = 0, E = Q.length;n2 < E; n2 += 3) {
              h2 = Q[n2];
              f = Q[n2 + 1];
              G = Q[n2 + 2];
              Q[n2] = h2 - 179.456 + 1.402 * G;
              Q[n2 + 1] = h2 + 135.459 - 0.344 * f - 0.714 * G;
              Q[n2 + 2] = h2 - 226.816 + 1.772 * f;
            }
            return Q;
          }, O: function aa(Q) {
            var h2, f, G, n2, E = 0;
            for (var a3 = 0, C = Q.length;a3 < C; a3 += 4) {
              h2 = Q[a3];
              f = Q[a3 + 1];
              G = Q[a3 + 2];
              n2 = Q[a3 + 3];
              Q[E++] = -122.67195406894 + f * (-0.0000660635669420364 * f + 0.000437130475926232 * G - 0.000054080610064599 * h2 + 0.00048449797120281 * n2 - 0.154362151871126) + G * (-0.000957964378445773 * G + 0.000817076911346625 * h2 - 0.00477271405408747 * n2 + 1.53380253221734) + h2 * (0.000961250184130688 * h2 - 0.00266257332283933 * n2 + 0.48357088451265) + n2 * (-0.000336197177618394 * n2 + 0.484791561490776);
              Q[E++] = 107.268039397724 + f * (0.0000219927104525741 * f - 0.000640992018297945 * G + 0.000659397001245577 * h2 + 0.000426105652938837 * n2 - 0.176491792462875) + G * (-0.000778269941513683 * G + 0.00130872261408275 * h2 + 0.000770482631801132 * n2 - 0.151051492775562) + h2 * (0.00126935368114843 * h2 - 0.00265090189010898 * n2 + 0.25802910206845) + n2 * (-0.000318913117588328 * n2 - 0.213742400323665);
              Q[E++] = -20.810012546947 + f * (-0.000570115196973677 * f - 0.0000263409051004589 * G + 0.0020741088115012 * h2 - 0.00288260236853442 * n2 + 0.814272968359295) + G * (-0.0000153496057440975 * G - 0.000132689043961446 * h2 + 0.000560833691242812 * n2 - 0.195152027534049) + h2 * (0.00174418132927582 * h2 - 0.00255243321439347 * n2 + 0.116935020465145) + n2 * (-0.000343531996510555 * n2 + 0.24165260232407);
            }
            return Q.subarray(0, E);
          }, r: function a3(Q) {
            var h2, f, G;
            for (var n2 = 0, E = Q.length;n2 < E; n2 += 4) {
              h2 = Q[n2];
              f = Q[n2 + 1];
              G = Q[n2 + 2];
              Q[n2] = 434.456 - h2 - 1.402 * G;
              Q[n2 + 1] = 119.541 - h2 + 0.344 * f + 0.714 * G;
              Q[n2 + 2] = 481.816 - h2 - 1.772 * f;
            }
            return Q;
          }, U: function as(Q) {
            var h2, f, G, n2, E = 0;
            for (var a3 = 0, C = Q.length;a3 < C; a3 += 4) {
              h2 = Q[a3];
              f = Q[a3 + 1];
              G = Q[a3 + 2];
              n2 = Q[a3 + 3];
              Q[E++] = 255 + h2 * (-0.00006747147073602441 * h2 + 0.0008379262121013727 * f + 0.0002894718188643294 * G + 0.003264231057537806 * n2 - 1.1185611867203937) + f * (0.000026374107616089405 * f - 0.00008626949158638572 * G - 0.0002748769067499491 * n2 - 0.02155688794978967) + G * (-0.00003878099212869363 * G - 0.0003267808279485286 * n2 + 0.0686742238595345) - n2 * (0.0003361971776183937 * n2 + 0.7430659151342254);
              Q[E++] = 255 + h2 * (0.00013596372813588848 * h2 + 0.000924537132573585 * f + 0.00010567359618683593 * G + 0.0004791864687436512 * n2 - 0.3109689587515875) + f * (-0.00023545346108370344 * f + 0.0002702845253534714 * G + 0.0020200308977307156 * n2 - 0.7488052167015494) + G * (0.00006834815998235662 * G + 0.00015168452363460973 * n2 - 0.09751927774728933) - n2 * (0.0003189131175883281 * n2 + 0.7364883807733168);
              Q[E++] = 255 + h2 * (0.000013598650411385307 * h2 + 0.00012423956175490851 * f + 0.0004751985097583589 * G - 0.0000036729317476630422 * n2 - 0.05562186980264034) + f * (0.00016141380598724676 * f + 0.0009692239130725186 * G + 0.0007782692450036253 * n2 - 0.44015232367526463) + G * (0.0000005068882914068769 * G + 0.0017778369011375071 * n2 - 0.7591454649749609) - n2 * (0.0003435319965105553 * n2 + 0.7063770186160144);
            }
            return Q.subarray(0, E);
          }, getData: function(Q) {
            var { width: h2, height: f, forceRGB: G, isSourcePDF: n2 } = Q;
            if (this.p > 4) {
              throw new W("Unsupported color mode");
            }
            var E = this.Y(h2, f, n2);
            if (this.p === 1 && G) {
              var a3 = E.length, C = new Uint8ClampedArray(a3 * 3), F = 0;
              for (var d = 0;d < a3; d++) {
                var T = E[d];
                C[F++] = T;
                C[F++] = T;
                C[F++] = T;
              }
              return C;
            } else if (this.p === 3 && this.f) {
              return this.z(E);
            } else if (this.p === 4) {
              if (this.f) {
                if (G) {
                  return this.O(E);
                }
                return this.r(E);
              } else if (G) {
                return this.U(E);
              }
            }
            return E;
          } };
          return ak2;
        }();
        function a9(p, t) {
          return p[t] << 24 >> 24;
        }
        function Z(p, t) {
          return p[t] << 8 | p[t + 1];
        }
        function am(p, t) {
          return (p[t] << 24 | p[t + 1] << 16 | p[t + 2] << 8 | p[t + 3]) >>> 0;
        }
        UTIF2.JpegDecoder = ak;
      })();
      UTIF2.encodeImage = function(rgba, w, h2, metadata) {
        var idf = {
          t256: [w],
          t257: [h2],
          t258: [8, 8, 8, 8],
          t259: [1],
          t262: [2],
          t273: [1000],
          t277: [4],
          t278: [h2],
          t279: [w * h2 * 4],
          t282: [[72, 1]],
          t283: [[72, 1]],
          t284: [1],
          t286: [[0, 1]],
          t287: [[0, 1]],
          t296: [1],
          t305: ["Photopea (UTIF.js)"],
          t338: [1]
        };
        if (metadata)
          for (var i2 in metadata)
            idf[i2] = metadata[i2];
        var prfx = new Uint8Array(UTIF2.encode([idf]));
        var img = new Uint8Array(rgba);
        var data = new Uint8Array(1000 + w * h2 * 4);
        for (var i2 = 0;i2 < prfx.length; i2++)
          data[i2] = prfx[i2];
        for (var i2 = 0;i2 < img.length; i2++)
          data[1000 + i2] = img[i2];
        return data.buffer;
      };
      UTIF2.encode = function(ifds) {
        var LE = false;
        var data = new Uint8Array(20000), offset = 4, bin = LE ? UTIF2._binLE : UTIF2._binBE;
        data[0] = data[1] = LE ? 73 : 77;
        bin.writeUshort(data, 2, 42);
        var ifdo = 8;
        bin.writeUint(data, offset, ifdo);
        offset += 4;
        for (var i2 = 0;i2 < ifds.length; i2++) {
          var noffs = UTIF2._writeIFD(bin, UTIF2._types.basic, data, ifdo, ifds[i2]);
          ifdo = noffs[1];
          if (i2 < ifds.length - 1) {
            if ((ifdo & 3) != 0)
              ifdo += 4 - (ifdo & 3);
            bin.writeUint(data, noffs[0], ifdo);
          }
        }
        return data.slice(0, ifdo).buffer;
      };
      UTIF2.decode = function(buff, prm) {
        if (prm == null)
          prm = { parseMN: true, debug: false };
        var data = new Uint8Array(buff), offset = 0;
        var id = UTIF2._binBE.readASCII(data, offset, 2);
        offset += 2;
        var bin = id == "II" ? UTIF2._binLE : UTIF2._binBE;
        var num = bin.readUshort(data, offset);
        offset += 2;
        var ifdo = bin.readUint(data, offset);
        offset += 4;
        var ifds = [];
        while (true) {
          var cnt = bin.readUshort(data, ifdo), typ = bin.readUshort(data, ifdo + 4);
          if (cnt != 0) {
            if (typ < 1 || 13 < typ) {
              log("error in TIFF");
              break;
            }
          }
          UTIF2._readIFD(bin, data, ifdo, ifds, 0, prm);
          ifdo = bin.readUint(data, ifdo + 2 + cnt * 12);
          if (ifdo == 0)
            break;
        }
        return ifds;
      };
      UTIF2.decodeImage = function(buff, img, ifds) {
        if (img.data)
          return;
        var data = new Uint8Array(buff);
        var id = UTIF2._binBE.readASCII(data, 0, 2);
        if (img["t256"] == null)
          return;
        img.isLE = id == "II";
        img.width = img["t256"][0];
        img.height = img["t257"][0];
        var cmpr = img["t259"] ? img["t259"][0] : 1;
        var fo = img["t266"] ? img["t266"][0] : 1;
        if (img["t284"] && img["t284"][0] == 2)
          log("PlanarConfiguration 2 should not be used!");
        if (cmpr == 7 && img["t258"] && img["t258"].length > 3)
          img["t258"] = img["t258"].slice(0, 3);
        var spp = img["t277"] ? img["t277"][0] : 1;
        var bps = img["t258"] ? img["t258"][0] : 1;
        var bipp = bps * spp;
        if (cmpr == 1 && img["t279"] != null && img["t278"] && img["t262"][0] == 32803) {
          bipp = Math.round(img["t279"][0] * 8 / (img.width * img["t278"][0]));
        }
        if (img["t50885"] && img["t50885"][0] == 4)
          bipp = img["t258"][0] * 3;
        var bipl = Math.ceil(img.width * bipp / 8) * 8;
        var soff = img["t273"];
        if (soff == null || img["t322"])
          soff = img["t324"];
        var bcnt = img["t279"];
        if (cmpr == 1 && soff.length == 1)
          bcnt = [img.height * (bipl >>> 3)];
        if (bcnt == null || img["t322"])
          bcnt = img["t325"];
        var bytes = new Uint8Array(img.height * (bipl >>> 3)), bilen = 0;
        if (img["t322"] != null) {
          var tw = img["t322"][0], th = img["t323"][0];
          var tx = Math.floor((img.width + tw - 1) / tw);
          var ty = Math.floor((img.height + th - 1) / th);
          var tbuff = new Uint8Array(Math.ceil(tw * th * bipp / 8) | 0);
          console.log("====", tx, ty);
          for (var y = 0;y < ty; y++)
            for (var x = 0;x < tx; x++) {
              var i2 = y * tx + x;
              tbuff.fill(0);
              UTIF2.decode._decompress(img, ifds, data, soff[i2], bcnt[i2], cmpr, tbuff, 0, fo, tw, th);
              if (cmpr == 6)
                bytes = tbuff;
              else
                UTIF2._copyTile(tbuff, Math.ceil(tw * bipp / 8) | 0, th, bytes, Math.ceil(img.width * bipp / 8) | 0, img.height, Math.ceil(x * tw * bipp / 8) | 0, y * th);
            }
          bilen = bytes.length * 8;
        } else {
          if (soff == null)
            return;
          var rps = img["t278"] ? img["t278"][0] : img.height;
          rps = Math.min(rps, img.height);
          for (var i2 = 0;i2 < soff.length; i2++) {
            UTIF2.decode._decompress(img, ifds, data, soff[i2], bcnt[i2], cmpr, bytes, Math.ceil(bilen / 8) | 0, fo, img.width, rps);
            bilen += bipl * rps;
          }
          bilen = Math.min(bilen, bytes.length * 8);
        }
        img.data = new Uint8Array(bytes.buffer, 0, Math.ceil(bilen / 8) | 0);
      };
      UTIF2.decode._decompress = function(img, ifds, data, off, len, cmpr, tgt, toff, fo, w, h2) {
        if (img["t271"] && img["t271"][0] == "Panasonic" && img["t45"] && img["t45"][0] == 6)
          cmpr = 34316;
        if (false) {} else if (cmpr == 1)
          for (var j = 0;j < len; j++)
            tgt[toff + j] = data[off + j];
        else if (cmpr == 2)
          UTIF2.decode._decodeG2(data, off, len, tgt, toff, w, fo);
        else if (cmpr == 3)
          UTIF2.decode._decodeG3(data, off, len, tgt, toff, w, fo, img["t292"] ? (img["t292"][0] & 1) == 1 : false);
        else if (cmpr == 4)
          UTIF2.decode._decodeG4(data, off, len, tgt, toff, w, fo);
        else if (cmpr == 5)
          UTIF2.decode._decodeLZW(data, off, len, tgt, toff, 8);
        else if (cmpr == 6)
          UTIF2.decode._decodeOldJPEG(img, data, off, len, tgt, toff);
        else if (cmpr == 7 || cmpr == 34892)
          UTIF2.decode._decodeNewJPEG(img, data, off, len, tgt, toff);
        else if (cmpr == 8 || cmpr == 32946) {
          var src = new Uint8Array(data.buffer, off + 2, len - 6);
          var bin = pako2["inflateRaw"](src);
          if (toff + bin.length <= tgt.length)
            tgt.set(bin, toff);
        } else if (cmpr == 9)
          UTIF2.decode._decodeVC5(data, off, len, tgt, toff, img["t33422"]);
        else if (cmpr == 32767)
          UTIF2.decode._decodeARW(img, data, off, len, tgt, toff);
        else if (cmpr == 32773)
          UTIF2.decode._decodePackBits(data, off, len, tgt, toff);
        else if (cmpr == 32809)
          UTIF2.decode._decodeThunder(data, off, len, tgt, toff);
        else if (cmpr == 34316)
          UTIF2.decode._decodePanasonic(img, data, off, len, tgt, toff);
        else if (cmpr == 34713)
          UTIF2.decode._decodeNikon(img, ifds, data, off, len, tgt, toff);
        else if (cmpr == 34676)
          UTIF2.decode._decodeLogLuv32(img, data, off, len, tgt, toff);
        else
          log("Unknown compression", cmpr);
        var bps = img["t258"] ? Math.min(32, img["t258"][0]) : 1;
        var noc = img["t277"] ? img["t277"][0] : 1, bpp = bps * noc >>> 3, bpl = Math.ceil(bps * noc * w / 8);
        if (bps == 16 && !img.isLE && img["t33422"] == null)
          for (var y = 0;y < h2; y++) {
            var roff = toff + y * bpl;
            for (var x = 1;x < bpl; x += 2) {
              var t = tgt[roff + x];
              tgt[roff + x] = tgt[roff + x - 1];
              tgt[roff + x - 1] = t;
            }
          }
        if (img["t317"] && img["t317"][0] == 2) {
          for (var y = 0;y < h2; y++) {
            var ntoff = toff + y * bpl;
            if (bps == 16)
              for (var j = bpp;j < bpl; j += 2) {
                var nv = (tgt[ntoff + j + 1] << 8 | tgt[ntoff + j]) + (tgt[ntoff + j - bpp + 1] << 8 | tgt[ntoff + j - bpp]);
                tgt[ntoff + j] = nv & 255;
                tgt[ntoff + j + 1] = nv >>> 8 & 255;
              }
            else if (noc == 3)
              for (var j = 3;j < bpl; j += 3) {
                tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - 3] & 255;
                tgt[ntoff + j + 1] = tgt[ntoff + j + 1] + tgt[ntoff + j - 2] & 255;
                tgt[ntoff + j + 2] = tgt[ntoff + j + 2] + tgt[ntoff + j - 1] & 255;
              }
            else
              for (var j = bpp;j < bpl; j++)
                tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - bpp] & 255;
          }
        }
      };
      UTIF2.decode._decodePanasonic = function(img, data, off, len, tgt, toff) {
        var img_buffer = data.buffer;
        var rawWidth = img["t2"][0];
        var rawHeight = img["t3"][0];
        var bitsPerSample = img["t10"][0];
        var RW2_Format = img["t45"][0];
        var bidx = 0;
        var imageIndex = 0;
        var vpos = 0;
        var byte = 0;
        var arr_a, arr_b;
        var bytes = RW2_Format == 6 ? new Uint32Array(18) : new Uint8Array(16);
        var i2, j, sh, pred = [0, 0], nonz = [0, 0], isOdd, idx = 0, pixel_base;
        var row, col, crow;
        var buffer = new Uint8Array(16384);
        var result = new Uint16Array(tgt.buffer);
        function getDataRaw(bits) {
          if (vpos == 0) {
            var arr_a2 = new Uint8Array(img_buffer, off + imageIndex + 8184, 16384 - 8184);
            var arr_b2 = new Uint8Array(img_buffer, off + imageIndex, 8184);
            buffer.set(arr_a2);
            buffer.set(arr_b2, arr_a2.length);
            imageIndex += 16384;
          }
          if (RW2_Format == 5) {
            for (i2 = 0;i2 < 16; i2++) {
              bytes[i2] = buffer[vpos++];
              vpos &= 16383;
            }
          } else {
            vpos = vpos - bits & 131071;
            byte = vpos >> 3 ^ 16368;
            return (buffer[byte] | buffer[byte + 1] << 8) >> (vpos & 7) & ~(-1 << bits);
          }
        }
        function getBufferDataRW6(i3) {
          return buffer[vpos + 15 - i3];
        }
        function readPageRW6() {
          bytes[0] = getBufferDataRW6(0) << 6 | getBufferDataRW6(1) >> 2;
          bytes[1] = ((getBufferDataRW6(1) & 3) << 12 | getBufferDataRW6(2) << 4 | getBufferDataRW6(3) >> 4) & 16383;
          bytes[2] = getBufferDataRW6(3) >> 2 & 3;
          bytes[3] = (getBufferDataRW6(3) & 3) << 8 | getBufferDataRW6(4);
          bytes[4] = getBufferDataRW6(5) << 2 | getBufferDataRW6(6) >> 6;
          bytes[5] = (getBufferDataRW6(6) & 63) << 4 | getBufferDataRW6(7) >> 4;
          bytes[6] = getBufferDataRW6(7) >> 2 & 3;
          bytes[7] = (getBufferDataRW6(7) & 3) << 8 | getBufferDataRW6(8);
          bytes[8] = getBufferDataRW6(9) << 2 & 1020 | getBufferDataRW6(10) >> 6;
          bytes[9] = (getBufferDataRW6(10) << 4 | getBufferDataRW6(11) >> 4) & 1023;
          bytes[10] = getBufferDataRW6(11) >> 2 & 3;
          bytes[11] = (getBufferDataRW6(11) & 3) << 8 | getBufferDataRW6(12);
          bytes[12] = (getBufferDataRW6(13) << 2 & 1020 | getBufferDataRW6(14) >> 6) & 1023;
          bytes[13] = (getBufferDataRW6(14) << 4 | getBufferDataRW6(15) >> 4) & 1023;
          vpos += 16;
          byte = 0;
        }
        function readPageRw6_bps12() {
          bytes[0] = getBufferDataRW6(0) << 4 | getBufferDataRW6(1) >> 4;
          bytes[1] = ((getBufferDataRW6(1) & 15) << 8 | getBufferDataRW6(2)) & 4095;
          bytes[2] = getBufferDataRW6(3) >> 6 & 3;
          bytes[3] = (getBufferDataRW6(3) & 63) << 2 | getBufferDataRW6(4) >> 6;
          bytes[4] = (getBufferDataRW6(4) & 63) << 2 | getBufferDataRW6(5) >> 6;
          bytes[5] = (getBufferDataRW6(5) & 63) << 2 | getBufferDataRW6(6) >> 6;
          bytes[6] = getBufferDataRW6(6) >> 4 & 3;
          bytes[7] = (getBufferDataRW6(6) & 15) << 4 | getBufferDataRW6(7) >> 4;
          bytes[8] = (getBufferDataRW6(7) & 15) << 4 | getBufferDataRW6(8) >> 4;
          bytes[9] = (getBufferDataRW6(8) & 15) << 4 | getBufferDataRW6(9) >> 4;
          bytes[10] = getBufferDataRW6(9) >> 2 & 3;
          bytes[11] = (getBufferDataRW6(9) & 3) << 6 | getBufferDataRW6(10) >> 2;
          bytes[12] = (getBufferDataRW6(10) & 3) << 6 | getBufferDataRW6(11) >> 2;
          bytes[13] = (getBufferDataRW6(11) & 3) << 6 | getBufferDataRW6(12) >> 2;
          bytes[14] = getBufferDataRW6(12) & 3;
          bytes[15] = getBufferDataRW6(13);
          bytes[16] = getBufferDataRW6(14);
          bytes[17] = getBufferDataRW6(15);
          vpos += 16;
          byte = 0;
        }
        function resetPredNonzeros() {
          pred[0] = 0;
          pred[1] = 0;
          nonz[0] = 0;
          nonz[1] = 0;
        }
        if (RW2_Format == 7) {
          throw RW2_Format;
        } else if (RW2_Format == 6) {
          var is12bit = bitsPerSample == 12, readPageRw6Fn = is12bit ? readPageRw6_bps12 : readPageRW6, pixelsPerBlock = is12bit ? 14 : 11, pixelbase0 = is12bit ? 128 : 512, pixelbase_compare = is12bit ? 2048 : 8192, spix_compare = is12bit ? 16383 : 65535, pixel_mask = is12bit ? 4095 : 16383, blocksperrow = rawWidth / pixelsPerBlock, rowbytes = blocksperrow * 16, bufferSize = is12bit ? 18 : 14;
          for (row = 0;row < rawHeight - 15; row += 16) {
            var rowstoread = Math.min(16, rawHeight - row);
            var readlen = rowbytes * rowstoread;
            buffer = new Uint8Array(img_buffer, off + bidx, readlen);
            vpos = 0;
            bidx += readlen;
            for (crow = 0, col = 0;crow < rowstoread; crow++, col = 0) {
              idx = (row + crow) * rawWidth;
              for (var rblock = 0;rblock < blocksperrow; rblock++) {
                readPageRw6Fn();
                resetPredNonzeros();
                sh = 0;
                pixel_base = 0;
                for (i2 = 0;i2 < pixelsPerBlock; i2++) {
                  isOdd = i2 & 1;
                  if (i2 % 3 == 2) {
                    var base2 = byte < bufferSize ? bytes[byte++] : 0;
                    if (base2 == 3)
                      base2 = 4;
                    pixel_base = pixelbase0 << base2;
                    sh = 1 << base2;
                  }
                  var epixel = byte < bufferSize ? bytes[byte++] : 0;
                  if (pred[isOdd]) {
                    epixel *= sh;
                    if (pixel_base < pixelbase_compare && nonz[isOdd] > pixel_base)
                      epixel += nonz[isOdd] - pixel_base;
                    nonz[isOdd] = epixel;
                  } else {
                    pred[isOdd] = epixel;
                    if (epixel)
                      nonz[isOdd] = epixel;
                    else
                      epixel = nonz[isOdd];
                  }
                  result[idx + col++] = epixel - 15 <= spix_compare ? epixel - 15 & spix_compare : epixel + 2147483633 >> 31 & pixel_mask;
                }
              }
            }
          }
        } else if (RW2_Format == 5) {
          var blockSize = bitsPerSample == 12 ? 10 : 9;
          for (row = 0;row < rawHeight; row++) {
            for (col = 0;col < rawWidth; col += blockSize) {
              getDataRaw(0);
              if (bitsPerSample == 12) {
                result[idx++] = ((bytes[1] & 15) << 8) + bytes[0];
                result[idx++] = 16 * bytes[2] + (bytes[1] >> 4);
                result[idx++] = ((bytes[4] & 15) << 8) + bytes[3];
                result[idx++] = 16 * bytes[5] + (bytes[4] >> 4);
                result[idx++] = ((bytes[7] & 15) << 8) + bytes[6];
                result[idx++] = 16 * bytes[8] + (bytes[7] >> 4);
                result[idx++] = ((bytes[10] & 15) << 8) + bytes[9];
                result[idx++] = 16 * bytes[11] + (bytes[10] >> 4);
                result[idx++] = ((bytes[13] & 15) << 8) + bytes[12];
                result[idx++] = 16 * bytes[14] + (bytes[13] >> 4);
              } else if (bitsPerSample == 14) {
                result[idx++] = bytes[0] + ((bytes[1] & 63) << 8);
                result[idx++] = (bytes[1] >> 6) + 4 * bytes[2] + ((bytes[3] & 15) << 10);
                result[idx++] = (bytes[3] >> 4) + 16 * bytes[4] + ((bytes[5] & 3) << 12);
                result[idx++] = ((bytes[5] & 252) >> 2) + (bytes[6] << 6);
                result[idx++] = bytes[7] + ((bytes[8] & 63) << 8);
                result[idx++] = (bytes[8] >> 6) + 4 * bytes[9] + ((bytes[10] & 15) << 10);
                result[idx++] = (bytes[10] >> 4) + 16 * bytes[11] + ((bytes[12] & 3) << 12);
                result[idx++] = ((bytes[12] & 252) >> 2) + (bytes[13] << 6);
                result[idx++] = bytes[14] + ((bytes[15] & 63) << 8);
              }
            }
          }
        } else if (RW2_Format == 4) {
          for (row = 0;row < rawHeight; row++) {
            for (col = 0;col < rawWidth; col++) {
              i2 = col % 14;
              isOdd = i2 & 1;
              if (i2 == 0)
                resetPredNonzeros();
              if (i2 % 3 == 2)
                sh = 4 >> 3 - getDataRaw(2);
              if (nonz[isOdd]) {
                j = getDataRaw(8);
                if (j != 0) {
                  pred[isOdd] -= 128 << sh;
                  if (pred[isOdd] < 0 || sh == 4)
                    pred[isOdd] &= ~(-1 << sh);
                  pred[isOdd] += j << sh;
                }
              } else {
                nonz[isOdd] = getDataRaw(8);
                if (nonz[isOdd] || i2 > 11)
                  pred[isOdd] = nonz[isOdd] << 4 | getDataRaw(4);
              }
              result[idx++] = pred[col & 1];
            }
          }
        } else
          throw RW2_Format;
      };
      UTIF2.decode._decodeVC5 = function() {
        var x = [1, 0, 1, 0, 2, 2, 1, 1, 3, 7, 1, 2, 5, 25, 1, 3, 6, 48, 1, 4, 6, 54, 1, 5, 7, 111, 1, 8, 7, 99, 1, 6, 7, 105, 12, 0, 7, 107, 1, 7, 8, 209, 20, 0, 8, 212, 1, 9, 8, 220, 1, 10, 9, 393, 1, 11, 9, 394, 32, 0, 9, 416, 1, 12, 9, 427, 1, 13, 10, 887, 1, 18, 10, 784, 1, 14, 10, 790, 1, 15, 10, 835, 60, 0, 10, 852, 1, 16, 10, 885, 1, 17, 11, 1571, 1, 19, 11, 1668, 1, 20, 11, 1669, 100, 0, 11, 1707, 1, 21, 11, 1772, 1, 22, 12, 3547, 1, 29, 12, 3164, 1, 24, 12, 3166, 1, 25, 12, 3140, 1, 23, 12, 3413, 1, 26, 12, 3537, 1, 27, 12, 3539, 1, 28, 13, 7093, 1, 35, 13, 6283, 1, 30, 13, 6331, 1, 31, 13, 6335, 180, 0, 13, 6824, 1, 32, 13, 7072, 1, 33, 13, 7077, 320, 0, 13, 7076, 1, 34, 14, 12565, 1, 36, 14, 12661, 1, 37, 14, 12669, 1, 38, 14, 13651, 1, 39, 14, 14184, 1, 40, 15, 28295, 1, 46, 15, 28371, 1, 47, 15, 25320, 1, 42, 15, 25336, 1, 43, 15, 25128, 1, 41, 15, 27300, 1, 44, 15, 28293, 1, 45, 16, 50259, 1, 48, 16, 50643, 1, 49, 16, 50675, 1, 50, 16, 56740, 1, 53, 16, 56584, 1, 51, 16, 56588, 1, 52, 17, 113483, 1, 61, 17, 113482, 1, 60, 17, 101285, 1, 55, 17, 101349, 1, 56, 17, 109205, 1, 57, 17, 109207, 1, 58, 17, 100516, 1, 54, 17, 113171, 1, 59, 18, 202568, 1, 62, 18, 202696, 1, 63, 18, 218408, 1, 64, 18, 218412, 1, 65, 18, 226340, 1, 66, 18, 226356, 1, 67, 18, 226358, 1, 68, 19, 402068, 1, 69, 19, 405138, 1, 70, 19, 405394, 1, 71, 19, 436818, 1, 72, 19, 436826, 1, 73, 19, 452714, 1, 75, 19, 452718, 1, 76, 19, 452682, 1, 74, 20, 804138, 1, 77, 20, 810279, 1, 78, 20, 810790, 1, 79, 20, 873638, 1, 80, 20, 873654, 1, 81, 20, 905366, 1, 82, 20, 905430, 1, 83, 20, 905438, 1, 84, 21, 1608278, 1, 85, 21, 1620557, 1, 86, 21, 1621582, 1, 87, 21, 1621583, 1, 88, 21, 1747310, 1, 89, 21, 1810734, 1, 90, 21, 1810735, 1, 91, 21, 1810863, 1, 92, 21, 1810879, 1, 93, 22, 3621725, 1, 99, 22, 3621757, 1, 100, 22, 3241112, 1, 94, 22, 3494556, 1, 95, 22, 3494557, 1, 96, 22, 3494622, 1, 97, 22, 3494623, 1, 98, 23, 6482227, 1, 102, 23, 6433117, 1, 101, 23, 6989117, 1, 103, 23, 6989119, 1, 105, 23, 6989118, 1, 104, 23, 7243449, 1, 106, 23, 7243512, 1, 107, 24, 13978233, 1, 111, 24, 12964453, 1, 109, 24, 12866232, 1, 108, 24, 14486897, 1, 113, 24, 13978232, 1, 110, 24, 14486896, 1, 112, 24, 14487026, 1, 114, 24, 14487027, 1, 115, 25, 25732598, 1, 225, 25, 25732597, 1, 189, 25, 25732596, 1, 188, 25, 25732595, 1, 203, 25, 25732594, 1, 202, 25, 25732593, 1, 197, 25, 25732592, 1, 207, 25, 25732591, 1, 169, 25, 25732590, 1, 223, 25, 25732589, 1, 159, 25, 25732522, 1, 235, 25, 25732579, 1, 152, 25, 25732575, 1, 192, 25, 25732489, 1, 179, 25, 25732573, 1, 201, 25, 25732472, 1, 172, 25, 25732576, 1, 149, 25, 25732488, 1, 178, 25, 25732566, 1, 120, 25, 25732571, 1, 219, 25, 25732577, 1, 150, 25, 25732487, 1, 127, 25, 25732506, 1, 211, 25, 25732548, 1, 125, 25, 25732588, 1, 158, 25, 25732486, 1, 247, 25, 25732467, 1, 238, 25, 25732508, 1, 163, 25, 25732552, 1, 228, 25, 25732603, 1, 183, 25, 25732513, 1, 217, 25, 25732587, 1, 168, 25, 25732520, 1, 122, 25, 25732484, 1, 128, 25, 25732562, 1, 249, 25, 25732505, 1, 187, 25, 25732504, 1, 186, 25, 25732483, 1, 136, 25, 25928905, 1, 181, 25, 25732560, 1, 255, 25, 25732500, 1, 230, 25, 25732482, 1, 135, 25, 25732555, 1, 233, 25, 25732568, 1, 222, 25, 25732583, 1, 145, 25, 25732481, 1, 134, 25, 25732586, 1, 167, 25, 25732521, 1, 248, 25, 25732518, 1, 209, 25, 25732480, 1, 243, 25, 25732512, 1, 216, 25, 25732509, 1, 164, 25, 25732547, 1, 140, 25, 25732479, 1, 157, 25, 25732544, 1, 239, 25, 25732574, 1, 191, 25, 25732564, 1, 251, 25, 25732478, 1, 156, 25, 25732546, 1, 139, 25, 25732498, 1, 242, 25, 25732557, 1, 133, 25, 25732477, 1, 162, 25, 25732515, 1, 213, 25, 25732584, 1, 165, 25, 25732514, 1, 212, 25, 25732476, 1, 227, 25, 25732494, 1, 198, 25, 25732531, 1, 236, 25, 25732530, 1, 234, 25, 25732529, 1, 117, 25, 25732528, 1, 215, 25, 25732527, 1, 124, 25, 25732526, 1, 123, 25, 25732525, 1, 254, 25, 25732524, 1, 253, 25, 25732523, 1, 148, 25, 25732570, 1, 218, 25, 25732580, 1, 146, 25, 25732581, 1, 147, 25, 25732569, 1, 224, 25, 25732533, 1, 143, 25, 25732540, 1, 184, 25, 25732541, 1, 185, 25, 25732585, 1, 166, 25, 25732556, 1, 132, 25, 25732485, 1, 129, 25, 25732563, 1, 250, 25, 25732578, 1, 151, 25, 25732501, 1, 119, 25, 25732502, 1, 193, 25, 25732536, 1, 176, 25, 25732496, 1, 245, 25, 25732553, 1, 229, 25, 25732516, 1, 206, 25, 25732582, 1, 144, 25, 25732517, 1, 208, 25, 25732558, 1, 137, 25, 25732543, 1, 241, 25, 25732466, 1, 237, 25, 25732507, 1, 190, 25, 25732542, 1, 240, 25, 25732551, 1, 131, 25, 25732554, 1, 232, 25, 25732565, 1, 252, 25, 25732475, 1, 171, 25, 25732493, 1, 205, 25, 25732492, 1, 204, 25, 25732491, 1, 118, 25, 25732490, 1, 214, 25, 25928904, 1, 180, 25, 25732549, 1, 126, 25, 25732602, 1, 182, 25, 25732539, 1, 175, 25, 25732545, 1, 141, 25, 25732559, 1, 138, 25, 25732537, 1, 177, 25, 25732534, 1, 153, 25, 25732503, 1, 194, 25, 25732606, 1, 160, 25, 25732567, 1, 121, 25, 25732538, 1, 174, 25, 25732497, 1, 246, 25, 25732550, 1, 130, 25, 25732572, 1, 200, 25, 25732474, 1, 170, 25, 25732511, 1, 221, 25, 25732601, 1, 196, 25, 25732532, 1, 142, 25, 25732519, 1, 210, 25, 25732495, 1, 199, 25, 25732605, 1, 155, 25, 25732535, 1, 154, 25, 25732499, 1, 244, 25, 25732510, 1, 220, 25, 25732600, 1, 195, 25, 25732607, 1, 161, 25, 25732604, 1, 231, 25, 25732473, 1, 173, 25, 25732599, 1, 226, 26, 51465122, 1, 116, 26, 51465123, 0, 1], o2, C, k, P = [3, 3, 3, 3, 2, 2, 2, 1, 1, 1], V = 24576, ar = 16384, H = 8192, az = ar | H;
        function d(t) {
          var E = t[1], h2 = t[0][E >>> 3] >>> 7 - (E & 7) & 1;
          t[1]++;
          return h2;
        }
        function ag(t, E) {
          if (o2 == null) {
            o2 = {};
            for (var h2 = 0;h2 < x.length; h2 += 4)
              o2[x[h2 + 1]] = x.slice(h2, h2 + 4);
          }
          var L = d(t), g = o2[L];
          while (g == null) {
            L = L << 1 | d(t);
            g = o2[L];
          }
          var n2 = g[3];
          if (n2 != 0)
            n2 = d(t) == 0 ? n2 : -n2;
          E[0] = g[2];
          E[1] = n2;
        }
        function m(t, E) {
          for (var h2 = 0;h2 < E; h2++) {
            if ((t & 1) == 1)
              t++;
            t = t >>> 1;
          }
          return t;
        }
        function A(t, E) {
          return t >> E;
        }
        function O(t, E, h2, L, g, n2) {
          E[h2] = A(A(11 * t[g] - 4 * t[g + n2] + t[g + n2 + n2] + 4, 3) + t[L], 1);
          E[h2 + n2] = A(A(5 * t[g] + 4 * t[g + n2] - t[g + n2 + n2] + 4, 3) - t[L], 1);
        }
        function J(t, E, h2, L, g, n2) {
          var W = t[g - n2] - t[g + n2], j = t[g], $2 = t[L];
          E[h2] = A(A(W + 4, 3) + j + $2, 1);
          E[h2 + n2] = A(A(-W + 4, 3) + j - $2, 1);
        }
        function y(t, E, h2, L, g, n2) {
          E[h2] = A(A(5 * t[g] + 4 * t[g - n2] - t[g - n2 - n2] + 4, 3) + t[L], 1);
          E[h2 + n2] = A(A(11 * t[g] - 4 * t[g - n2] + t[g - n2 - n2] + 4, 3) - t[L], 1);
        }
        function q(t) {
          t = t < 0 ? 0 : t > 4095 ? 4095 : t;
          t = k[t] >>> 2;
          return t;
        }
        function av(t, E, h2, L, g, n2) {
          L = new Uint16Array(L.buffer);
          var W = Date.now(), j = UTIF2._binBE, $2 = E + h2, r, u2, X, I, ax, a3, R, ai, aa, ap, ah, ae, aD, al, i2, aE, T, B;
          E += 4;
          var a5 = n2[0] == 1;
          while (E < $2) {
            var S = j.readShort(t, E), s = j.readUshort(t, E + 2);
            E += 4;
            if (S == 12)
              r = s;
            else if (S == 20)
              u2 = s;
            else if (S == 21)
              X = s;
            else if (S == 48)
              I = s;
            else if (S == 53)
              ax = s;
            else if (S == 35)
              a3 = s;
            else if (S == 62)
              R = s;
            else if (S == 101)
              ai = s;
            else if (S == 109)
              aa = s;
            else if (S == 84)
              ap = s;
            else if (S == 106)
              ah = s;
            else if (S == 107)
              ae = s;
            else if (S == 108)
              aD = s;
            else if (S == 102)
              al = s;
            else if (S == 104)
              i2 = s;
            else if (S == 105)
              aE = s;
            else {
              var F = S < 0 ? -S : S, D = F & 65280, _ = 0;
              if (F & az) {
                if (F & H) {
                  _ = s & 65535;
                  _ += (F & 255) << 16;
                } else {
                  _ = s & 65535;
                }
              }
              if ((F & V) == V) {
                if (T == null) {
                  T = [];
                  for (var M = 0;M < 4; M++)
                    T[M] = new Int16Array((u2 >>> 1) * (X >>> 1));
                  B = new Int16Array((u2 >>> 1) * (X >>> 1));
                  C = new Int16Array(1024);
                  for (var M = 0;M < 1024; M++) {
                    var aG = M - 512, p = Math.abs(aG), r = Math.floor(768 * p * p * p / (255 * 255 * 255)) + p;
                    C[M] = Math.sign(aG) * r;
                  }
                  k = new Uint16Array(4096);
                  var aA = (1 << 16) - 1;
                  for (var M = 0;M < 4096; M++) {
                    var at = M, a1 = aA * (Math.pow(113, at / 4095) - 1) / 112;
                    k[M] = Math.min(a1, aA);
                  }
                }
                var w = T[R], v = m(u2, 1 + P[I]), N = m(X, 1 + P[I]);
                if (I == 0) {
                  for (var b = 0;b < N; b++)
                    for (var G = 0;G < v; G++) {
                      var c3 = E + (b * v + G) * 2;
                      w[b * (u2 >>> 1) + G] = t[c3] << 8 | t[c3 + 1];
                    }
                } else {
                  var a7 = [t, E * 8], a4 = [], ay = 0, aw = v * N, f = [0, 0], Q = 0, s = 0;
                  while (ay < aw) {
                    ag(a7, f);
                    Q = f[0];
                    s = f[1];
                    while (Q > 0) {
                      a4[ay++] = s;
                      Q--;
                    }
                  }
                  var l = (I - 1) % 3, aF = l != 1 ? v : 0, a2 = l != 0 ? N : 0;
                  for (var b = 0;b < N; b++) {
                    var af = (b + a2) * (u2 >>> 1) + aF, au = b * v;
                    for (var G = 0;G < v; G++)
                      w[af + G] = C[a4[au + G] + 512] * ax;
                  }
                  if (l == 2) {
                    var i2 = u2 >>> 1, an = v * 2, a9 = N * 2;
                    for (var b = 0;b < N; b++) {
                      for (var G = 0;G < an; G++) {
                        var M = b * 2 * i2 + G, a6 = b * i2 + G, e = N * i2 + a6;
                        if (b == 0)
                          O(w, B, M, e, a6, i2);
                        else if (b == N - 1)
                          y(w, B, M, e, a6, i2);
                        else
                          J(w, B, M, e, a6, i2);
                      }
                    }
                    var Z = w;
                    w = B;
                    B = Z;
                    for (var b = 0;b < a9; b++) {
                      for (var G = 0;G < v; G++) {
                        var M = b * i2 + 2 * G, a6 = b * i2 + G, e = v + a6;
                        if (G == 0)
                          O(w, B, M, e, a6, 1);
                        else if (G == v - 1)
                          y(w, B, M, e, a6, 1);
                        else
                          J(w, B, M, e, a6, 1);
                      }
                    }
                    var Z = w;
                    w = B;
                    B = Z;
                    var aC = [], aB = 2 - ~~((I - 1) / 3);
                    for (var K = 0;K < 3; K++)
                      aC[K] = aa >> 14 - K * 2 & 3;
                    var a62 = aC[aB];
                    if (a62 != 0)
                      for (var b = 0;b < a9; b++)
                        for (var G = 0;G < an; G++) {
                          var M = b * i2 + G;
                          w[M] = w[M] << a62;
                        }
                  }
                }
                if (I == 9 && R == 3) {
                  var a8 = T[0], ab = T[1], aq = T[2], as = T[3];
                  for (var b = 0;b < X; b += 2)
                    for (var G = 0;G < u2; G += 2) {
                      var U = b * u2 + G, c3 = (b >>> 1) * (u2 >>> 1) + (G >>> 1), z = a8[c3], ao = ab[c3] - 2048, ak = aq[c3] - 2048, ad = as[c3] - 2048, aj = (ao << 1) + z, a0 = (ak << 1) + z, aH = z + ad, am = z - ad;
                      if (a5) {
                        L[U] = q(aH);
                        L[U + 1] = q(a0);
                        L[U + u2] = q(aj);
                        L[U + u2 + 1] = q(am);
                      } else {
                        L[U] = q(aj);
                        L[U + 1] = q(aH);
                        L[U + u2] = q(am);
                        L[U + u2 + 1] = q(a0);
                      }
                    }
                }
                E += _ * 4;
              } else if (F == 16388) {
                E += _ * 4;
              } else if (D == 8192 || D == 8448 || D == 9216) {} else
                throw F.toString(16);
            }
          }
          console.log(Date.now() - W);
        }
        return av;
      }();
      UTIF2.decode._decodeLogLuv32 = function(img, data, off, len, tgt, toff) {
        var w = img.width, qw = w * 4;
        var io = 0, out = new Uint8Array(qw);
        while (io < len) {
          var oo = 0;
          while (oo < qw) {
            var c3 = data[off + io];
            io++;
            if (c3 < 128) {
              for (var j = 0;j < c3; j++)
                out[oo + j] = data[off + io + j];
              oo += c3;
              io += c3;
            } else {
              c3 = c3 - 126;
              for (var j = 0;j < c3; j++)
                out[oo + j] = data[off + io];
              oo += c3;
              io++;
            }
          }
          for (var x = 0;x < w; x++) {
            tgt[toff + 0] = out[x];
            tgt[toff + 1] = out[x + w];
            tgt[toff + 2] = out[x + w * 2];
            tgt[toff + 4] = out[x + w * 3];
            toff += 6;
          }
        }
      };
      UTIF2.decode._ljpeg_diff = function(data, prm, huff) {
        var getbithuff = UTIF2.decode._getbithuff;
        var len, diff2;
        len = getbithuff(data, prm, huff[0], huff);
        diff2 = getbithuff(data, prm, len, 0);
        if ((diff2 & 1 << len - 1) == 0)
          diff2 -= (1 << len) - 1;
        return diff2;
      };
      UTIF2.decode._decodeARW = function(img, inp, off, src_length, tgt, toff) {
        var raw_width = img["t256"][0], height = img["t257"][0], tiff_bps = img["t258"][0];
        var bin = img.isLE ? UTIF2._binLE : UTIF2._binBE;
        var arw2 = raw_width * height == src_length || raw_width * height * 1.5 == src_length;
        if (!arw2) {
          height += 8;
          var prm = [off, 0, 0, 0];
          var huff = new Uint16Array(32770);
          var tab2 = [
            3857,
            3856,
            3599,
            3342,
            3085,
            2828,
            2571,
            2314,
            2057,
            1800,
            1543,
            1286,
            1029,
            772,
            771,
            768,
            514,
            513
          ];
          var i2, c3, n2, col, row, sum = 0;
          var ljpeg_diff = UTIF2.decode._ljpeg_diff;
          huff[0] = 15;
          for (n2 = i2 = 0;i2 < 18; i2++) {
            var lim = 32768 >>> (tab2[i2] >>> 8);
            for (var c3 = 0;c3 < lim; c3++)
              huff[++n2] = tab2[i2];
          }
          for (col = raw_width;col--; )
            for (row = 0;row < height + 1; row += 2) {
              if (row == height)
                row = 1;
              sum += ljpeg_diff(inp, prm, huff);
              if (row < height) {
                var clr = sum & 4095;
                UTIF2.decode._putsF(tgt, (row * raw_width + col) * tiff_bps, clr << 16 - tiff_bps);
              }
            }
          return;
        }
        if (raw_width * height * 1.5 == src_length) {
          for (var i2 = 0;i2 < src_length; i2 += 3) {
            var b0 = inp[off + i2 + 0], b1 = inp[off + i2 + 1], b2 = inp[off + i2 + 2];
            tgt[toff + i2] = b1 << 4 | b0 >>> 4;
            tgt[toff + i2 + 1] = b0 << 4 | b2 >>> 4;
            tgt[toff + i2 + 2] = b2 << 4 | b1 >>> 4;
          }
          return;
        }
        var pix = new Uint16Array(16);
        var row, col, val, max, min, imax, imin, sh, bit, i2, dp;
        var data = new Uint8Array(raw_width + 1);
        for (row = 0;row < height; row++) {
          for (var j = 0;j < raw_width; j++)
            data[j] = inp[off++];
          for (dp = 0, col = 0;col < raw_width - 30; dp += 16) {
            max = 2047 & (val = bin.readUint(data, dp));
            min = 2047 & val >>> 11;
            imax = 15 & val >>> 22;
            imin = 15 & val >>> 26;
            for (sh = 0;sh < 4 && 128 << sh <= max - min; sh++)
              ;
            for (bit = 30, i2 = 0;i2 < 16; i2++)
              if (i2 == imax)
                pix[i2] = max;
              else if (i2 == imin)
                pix[i2] = min;
              else {
                pix[i2] = ((bin.readUshort(data, dp + (bit >> 3)) >>> (bit & 7) & 127) << sh) + min;
                if (pix[i2] > 2047)
                  pix[i2] = 2047;
                bit += 7;
              }
            for (i2 = 0;i2 < 16; i2++, col += 2) {
              var clr = pix[i2] << 1;
              UTIF2.decode._putsF(tgt, (row * raw_width + col) * tiff_bps, clr << 16 - tiff_bps);
            }
            col -= col & 1 ? 1 : 31;
          }
        }
      };
      UTIF2.decode._decodeNikon = function(img, imgs, data, off, src_length, tgt, toff) {
        var nikon_tree = [
          [
            0,
            0,
            1,
            5,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            5,
            4,
            3,
            6,
            2,
            7,
            1,
            0,
            8,
            9,
            11,
            10,
            12
          ],
          [
            0,
            0,
            1,
            5,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            57,
            90,
            56,
            39,
            22,
            5,
            4,
            3,
            2,
            1,
            0,
            11,
            12,
            12
          ],
          [
            0,
            0,
            1,
            4,
            2,
            3,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            5,
            4,
            6,
            3,
            7,
            2,
            8,
            1,
            9,
            0,
            10,
            11,
            12
          ],
          [
            0,
            0,
            1,
            4,
            3,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            5,
            6,
            4,
            7,
            8,
            3,
            9,
            2,
            1,
            0,
            10,
            11,
            12,
            13,
            14
          ],
          [
            0,
            0,
            1,
            5,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            8,
            92,
            75,
            58,
            41,
            7,
            6,
            5,
            4,
            3,
            2,
            1,
            0,
            13,
            14
          ],
          [
            0,
            0,
            1,
            4,
            2,
            2,
            3,
            1,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            7,
            6,
            8,
            5,
            9,
            4,
            10,
            3,
            11,
            12,
            2,
            0,
            1,
            13,
            14
          ]
        ];
        var raw_width = img["t256"][0], height = img["t257"][0], tiff_bps = img["t258"][0];
        var tree = 0, split = 0;
        var make_decoder = UTIF2.decode._make_decoder;
        var getbithuff = UTIF2.decode._getbithuff;
        var mn = imgs[0].exifIFD.makerNote, md = mn["t150"] ? mn["t150"] : mn["t140"], mdo = 0;
        var ver0 = md[mdo++], ver1 = md[mdo++];
        if (ver0 == 73 || ver1 == 88)
          mdo += 2110;
        if (ver0 == 70)
          tree = 2;
        if (tiff_bps == 14)
          tree += 3;
        var vpred = [[0, 0], [0, 0]], bin = img.isLE ? UTIF2._binLE : UTIF2._binBE;
        for (var i2 = 0;i2 < 2; i2++)
          for (var j = 0;j < 2; j++) {
            vpred[i2][j] = bin.readShort(md, mdo);
            mdo += 2;
          }
        var max = 1 << tiff_bps & 32767, step = 0;
        var csize = bin.readShort(md, mdo);
        mdo += 2;
        if (csize > 1)
          step = Math.floor(max / (csize - 1));
        if (ver0 == 68 && ver1 == 32 && step > 0)
          split = bin.readShort(md, 562);
        var i2;
        var row, col;
        var len, shl, diff2;
        var min_v = 0;
        var hpred = [0, 0];
        var huff = make_decoder(nikon_tree[tree]);
        var prm = [off, 0, 0, 0];
        for (min_v = row = 0;row < height; row++) {
          if (split && row == split) {
            huff = make_decoder(nikon_tree[tree + 1]);
          }
          for (col = 0;col < raw_width; col++) {
            i2 = getbithuff(data, prm, huff[0], huff);
            len = i2 & 15;
            shl = i2 >>> 4;
            diff2 = (getbithuff(data, prm, len - shl, 0) << 1) + 1 << shl >>> 1;
            if ((diff2 & 1 << len - 1) == 0)
              diff2 -= (1 << len) - (shl == 0 ? 1 : 0);
            if (col < 2)
              hpred[col] = vpred[row & 1][col] += diff2;
            else
              hpred[col & 1] += diff2;
            var clr = Math.min(Math.max(hpred[col & 1], 0), (1 << tiff_bps) - 1);
            var bti = (row * raw_width + col) * tiff_bps;
            UTIF2.decode._putsF(tgt, bti, clr << 16 - tiff_bps);
          }
        }
      };
      UTIF2.decode._putsF = function(dt, pos, val) {
        val = val << 8 - (pos & 7);
        var o2 = pos >>> 3;
        dt[o2] |= val >>> 16;
        dt[o2 + 1] |= val >>> 8;
        dt[o2 + 2] |= val;
      };
      UTIF2.decode._getbithuff = function(data, prm, nbits, huff) {
        var zero_after_ff = 0;
        var get_byte = UTIF2.decode._get_byte;
        var c3;
        var off = prm[0], bitbuf = prm[1], vbits = prm[2], reset2 = prm[3];
        if (nbits == 0 || vbits < 0)
          return 0;
        while (!reset2 && vbits < nbits && (c3 = data[off++]) != -1 && !(reset2 = zero_after_ff && c3 == 255 && data[off++])) {
          bitbuf = (bitbuf << 8) + c3;
          vbits += 8;
        }
        c3 = bitbuf << 32 - vbits >>> 32 - nbits;
        if (huff) {
          vbits -= huff[c3 + 1] >>> 8;
          c3 = huff[c3 + 1] & 255;
        } else
          vbits -= nbits;
        if (vbits < 0)
          throw "e";
        prm[0] = off;
        prm[1] = bitbuf;
        prm[2] = vbits;
        prm[3] = reset2;
        return c3;
      };
      UTIF2.decode._make_decoder = function(source) {
        var max, len, h2, i2, j;
        var huff = [];
        for (max = 16;max != 0 && !source[max]; max--)
          ;
        var si = 17;
        huff[0] = max;
        for (h2 = len = 1;len <= max; len++)
          for (i2 = 0;i2 < source[len]; i2++, ++si)
            for (j = 0;j < 1 << max - len; j++)
              if (h2 <= 1 << max)
                huff[h2++] = len << 8 | source[si];
        return huff;
      };
      UTIF2.decode._decodeNewJPEG = function(img, data, off, len, tgt, toff) {
        len = Math.min(len, data.length - off);
        var tables = img["t347"], tlen = tables ? tables.length : 0, buff = new Uint8Array(tlen + len);
        if (tables) {
          var SOI = 216, EOI2 = 217, boff = 0;
          for (var i2 = 0;i2 < tlen - 1; i2++) {
            if (tables[i2] == 255 && tables[i2 + 1] == EOI2)
              break;
            buff[boff++] = tables[i2];
          }
          var byte1 = data[off], byte2 = data[off + 1];
          if (byte1 != 255 || byte2 != SOI) {
            buff[boff++] = byte1;
            buff[boff++] = byte2;
          }
          for (var i2 = 2;i2 < len; i2++)
            buff[boff++] = data[off + i2];
        } else
          for (var i2 = 0;i2 < len; i2++)
            buff[i2] = data[off + i2];
        if (img["t262"][0] == 32803 || img["t259"][0] == 7 && img["t262"][0] == 34892) {
          var bps = img["t258"][0];
          var out = UTIF2.LosslessJpegDecode(buff), olen = out.length;
          if (false) {} else if (bps == 16) {
            if (img.isLE)
              for (var i2 = 0;i2 < olen; i2++) {
                tgt[toff + (i2 << 1)] = out[i2] & 255;
                tgt[toff + (i2 << 1) + 1] = out[i2] >>> 8;
              }
            else
              for (var i2 = 0;i2 < olen; i2++) {
                tgt[toff + (i2 << 1)] = out[i2] >>> 8;
                tgt[toff + (i2 << 1) + 1] = out[i2] & 255;
              }
          } else if (bps == 14 || bps == 12 || bps == 10) {
            var rst = 16 - bps;
            for (var i2 = 0;i2 < olen; i2++)
              UTIF2.decode._putsF(tgt, i2 * bps, out[i2] << rst);
          } else if (bps == 8) {
            for (var i2 = 0;i2 < olen; i2++)
              tgt[toff + i2] = out[i2];
          } else
            throw new Error("unsupported bit depth " + bps);
        } else {
          var parser = new UTIF2.JpegDecoder;
          parser.parse(buff);
          var decoded = parser.getData({ width: parser.width, height: parser.height, forceRGB: true, isSourcePDF: false });
          for (var i2 = 0;i2 < decoded.length; i2++)
            tgt[toff + i2] = decoded[i2];
        }
        if (img["t262"][0] == 6)
          img["t262"][0] = 2;
      };
      UTIF2.decode._decodeOldJPEGInit = function(img, data, off, len) {
        var SOI = 216, EOI2 = 217, DQT = 219, DHT = 196, DRI = 221, SOF0 = 192, SOS2 = 218;
        var joff = 0, soff = 0, tables, sosMarker2, isTiled = false, i2, j, k;
        var jpgIchgFmt = img["t513"], jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0;
        var jpgIchgFmtLen = img["t514"], jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0;
        var soffTag = img["t324"] || img["t273"] || jpgIchgFmt;
        var ycbcrss = img["t530"], ssx = 0, ssy = 0;
        var spp = img["t277"] ? img["t277"][0] : 1;
        var jpgresint = img["t515"];
        if (soffTag) {
          soff = soffTag[0];
          isTiled = soffTag.length > 1;
        }
        if (!isTiled) {
          if (data[off] == 255 && data[off + 1] == SOI)
            return { jpegOffset: off };
          if (jpgIchgFmt != null) {
            if (data[off + jifoff] == 255 && data[off + jifoff + 1] == SOI)
              joff = off + jifoff;
            else
              log("JPEGInterchangeFormat does not point to SOI");
            if (jpgIchgFmtLen == null)
              log("JPEGInterchangeFormatLength field is missing");
            else if (jifoff >= soff || jifoff + jiflen <= soff)
              log("JPEGInterchangeFormatLength field value is invalid");
            if (joff != null)
              return { jpegOffset: joff };
          }
        }
        if (ycbcrss != null) {
          ssx = ycbcrss[0];
          ssy = ycbcrss[1];
        }
        if (jpgIchgFmt != null) {
          if (jpgIchgFmtLen != null)
            if (jiflen >= 2 && jifoff + jiflen <= soff) {
              if (data[off + jifoff + jiflen - 2] == 255 && data[off + jifoff + jiflen - 1] == SOI)
                tables = new Uint8Array(jiflen - 2);
              else
                tables = new Uint8Array(jiflen);
              for (i2 = 0;i2 < tables.length; i2++)
                tables[i2] = data[off + jifoff + i2];
              log("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
            } else
              log("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
        }
        if (tables == null) {
          var ooff = 0, out = [];
          out[ooff++] = 255;
          out[ooff++] = SOI;
          var qtables = img["t519"];
          if (qtables == null)
            throw new Error("JPEGQTables tag is missing");
          for (i2 = 0;i2 < qtables.length; i2++) {
            out[ooff++] = 255;
            out[ooff++] = DQT;
            out[ooff++] = 0;
            out[ooff++] = 67;
            out[ooff++] = i2;
            for (j = 0;j < 64; j++)
              out[ooff++] = data[off + qtables[i2] + j];
          }
          for (k = 0;k < 2; k++) {
            var htables = img[k == 0 ? "t520" : "t521"];
            if (htables == null)
              throw new Error((k == 0 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
            for (i2 = 0;i2 < htables.length; i2++) {
              out[ooff++] = 255;
              out[ooff++] = DHT;
              var nc = 19;
              for (j = 0;j < 16; j++)
                nc += data[off + htables[i2] + j];
              out[ooff++] = nc >>> 8;
              out[ooff++] = nc & 255;
              out[ooff++] = i2 | k << 4;
              for (j = 0;j < 16; j++)
                out[ooff++] = data[off + htables[i2] + j];
              for (j = 0;j < nc; j++)
                out[ooff++] = data[off + htables[i2] + 16 + j];
            }
          }
          out[ooff++] = 255;
          out[ooff++] = SOF0;
          out[ooff++] = 0;
          out[ooff++] = 8 + 3 * spp;
          out[ooff++] = 8;
          out[ooff++] = img.height >>> 8 & 255;
          out[ooff++] = img.height & 255;
          out[ooff++] = img.width >>> 8 & 255;
          out[ooff++] = img.width & 255;
          out[ooff++] = spp;
          if (spp == 1) {
            out[ooff++] = 1;
            out[ooff++] = 17;
            out[ooff++] = 0;
          } else
            for (i2 = 0;i2 < 3; i2++) {
              out[ooff++] = i2 + 1;
              out[ooff++] = i2 != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
              out[ooff++] = i2;
            }
          if (jpgresint != null && jpgresint[0] != 0) {
            out[ooff++] = 255;
            out[ooff++] = DRI;
            out[ooff++] = 0;
            out[ooff++] = 4;
            out[ooff++] = jpgresint[0] >>> 8 & 255;
            out[ooff++] = jpgresint[0] & 255;
          }
          tables = new Uint8Array(out);
        }
        var sofpos = -1;
        i2 = 0;
        while (i2 < tables.length - 1) {
          if (tables[i2] == 255 && tables[i2 + 1] == SOF0) {
            sofpos = i2;
            break;
          }
          i2++;
        }
        if (sofpos == -1) {
          var tmptab = new Uint8Array(tables.length + 10 + 3 * spp);
          tmptab.set(tables);
          var tmpoff = tables.length;
          sofpos = tables.length;
          tables = tmptab;
          tables[tmpoff++] = 255;
          tables[tmpoff++] = SOF0;
          tables[tmpoff++] = 0;
          tables[tmpoff++] = 8 + 3 * spp;
          tables[tmpoff++] = 8;
          tables[tmpoff++] = img.height >>> 8 & 255;
          tables[tmpoff++] = img.height & 255;
          tables[tmpoff++] = img.width >>> 8 & 255;
          tables[tmpoff++] = img.width & 255;
          tables[tmpoff++] = spp;
          if (spp == 1) {
            tables[tmpoff++] = 1;
            tables[tmpoff++] = 17;
            tables[tmpoff++] = 0;
          } else
            for (i2 = 0;i2 < 3; i2++) {
              tables[tmpoff++] = i2 + 1;
              tables[tmpoff++] = i2 != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
              tables[tmpoff++] = i2;
            }
        }
        if (data[soff] == 255 && data[soff + 1] == SOS2) {
          var soslen = data[soff + 2] << 8 | data[soff + 3];
          sosMarker2 = new Uint8Array(soslen + 2);
          sosMarker2[0] = data[soff];
          sosMarker2[1] = data[soff + 1];
          sosMarker2[2] = data[soff + 2];
          sosMarker2[3] = data[soff + 3];
          for (i2 = 0;i2 < soslen - 2; i2++)
            sosMarker2[i2 + 4] = data[soff + i2 + 4];
        } else {
          sosMarker2 = new Uint8Array(2 + 6 + 2 * spp);
          var sosoff = 0;
          sosMarker2[sosoff++] = 255;
          sosMarker2[sosoff++] = SOS2;
          sosMarker2[sosoff++] = 0;
          sosMarker2[sosoff++] = 6 + 2 * spp;
          sosMarker2[sosoff++] = spp;
          if (spp == 1) {
            sosMarker2[sosoff++] = 1;
            sosMarker2[sosoff++] = 0;
          } else
            for (i2 = 0;i2 < 3; i2++) {
              sosMarker2[sosoff++] = i2 + 1;
              sosMarker2[sosoff++] = i2 << 4 | i2;
            }
          sosMarker2[sosoff++] = 0;
          sosMarker2[sosoff++] = 63;
          sosMarker2[sosoff++] = 0;
        }
        return { jpegOffset: off, tables, sosMarker: sosMarker2, sofPosition: sofpos };
      };
      UTIF2.decode._decodeOldJPEG = function(img, data, off, len, tgt, toff) {
        var i2, dlen, tlen, buff, buffoff;
        var jpegData = UTIF2.decode._decodeOldJPEGInit(img, data, off, len);
        if (jpegData.jpegOffset != null) {
          dlen = off + len - jpegData.jpegOffset;
          buff = new Uint8Array(dlen);
          for (i2 = 0;i2 < dlen; i2++)
            buff[i2] = data[jpegData.jpegOffset + i2];
        } else {
          tlen = jpegData.tables.length;
          buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2);
          buff.set(jpegData.tables);
          buffoff = tlen;
          buff[jpegData.sofPosition + 5] = img.height >>> 8 & 255;
          buff[jpegData.sofPosition + 6] = img.height & 255;
          buff[jpegData.sofPosition + 7] = img.width >>> 8 & 255;
          buff[jpegData.sofPosition + 8] = img.width & 255;
          if (data[off] != 255 || data[off + 1] != SOS) {
            buff.set(jpegData.sosMarker, buffoff);
            buffoff += sosMarker.length;
          }
          for (i2 = 0;i2 < len; i2++)
            buff[buffoff++] = data[off + i2];
          buff[buffoff++] = 255;
          buff[buffoff++] = EOI;
        }
        var parser = new UTIF2.JpegDecoder;
        parser.parse(buff);
        var decoded = parser.getData({ width: parser.width, height: parser.height, forceRGB: true, isSourcePDF: false });
        for (var i2 = 0;i2 < decoded.length; i2++)
          tgt[toff + i2] = decoded[i2];
        if (img["t262"] && img["t262"][0] == 6)
          img["t262"][0] = 2;
      };
      UTIF2.decode._decodePackBits = function(data, off, len, tgt, toff) {
        var sa = new Int8Array(data.buffer), ta = new Int8Array(tgt.buffer), lim = off + len;
        while (off < lim) {
          var n2 = sa[off];
          off++;
          if (n2 >= 0 && n2 < 128)
            for (var i2 = 0;i2 < n2 + 1; i2++) {
              ta[toff] = sa[off];
              toff++;
              off++;
            }
          if (n2 >= -127 && n2 < 0) {
            for (var i2 = 0;i2 < -n2 + 1; i2++) {
              ta[toff] = sa[off];
              toff++;
            }
            off++;
          }
        }
        return toff;
      };
      UTIF2.decode._decodeThunder = function(data, off, len, tgt, toff) {
        var d2 = [0, 1, 0, -1], d3 = [0, 1, 2, 3, 0, -3, -2, -1];
        var lim = off + len, qoff = toff * 2, px = 0;
        while (off < lim) {
          var b = data[off], msk = b >>> 6, n2 = b & 63;
          off++;
          if (msk == 3) {
            px = n2 & 15;
            tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
            qoff++;
          }
          if (msk == 0)
            for (var i2 = 0;i2 < n2; i2++) {
              tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
              qoff++;
            }
          if (msk == 2)
            for (var i2 = 0;i2 < 2; i2++) {
              var d = n2 >>> 3 * (1 - i2) & 7;
              if (d != 4) {
                px += d3[d];
                tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
                qoff++;
              }
            }
          if (msk == 1)
            for (var i2 = 0;i2 < 3; i2++) {
              var d = n2 >>> 2 * (2 - i2) & 3;
              if (d != 2) {
                px += d2[d];
                tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
                qoff++;
              }
            }
        }
      };
      UTIF2.decode._dmap = { "1": 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 };
      UTIF2.decode._lens = function() {
        var addKeys = function(lens, arr, i0, inc) {
          for (var i2 = 0;i2 < arr.length; i2++)
            lens[arr[i2]] = i0 + i2 * inc;
        };
        var termW = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101," + "101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010," + "00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010," + "00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100";
        var termB = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000," + "0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001," + "000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111," + "000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111";
        var makeW = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110," + "011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011";
        var makeB = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100," + "0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010," + "0000001011011,0000001100100,0000001100101";
        var makeA = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
        termW = termW.split(",");
        termB = termB.split(",");
        makeW = makeW.split(",");
        makeB = makeB.split(",");
        makeA = makeA.split(",");
        var lensW = {}, lensB = {};
        addKeys(lensW, termW, 0, 1);
        addKeys(lensW, makeW, 64, 64);
        addKeys(lensW, makeA, 1792, 64);
        addKeys(lensB, termB, 0, 1);
        addKeys(lensB, makeB, 64, 64);
        addKeys(lensB, makeA, 1792, 64);
        return [lensW, lensB];
      }();
      UTIF2.decode._decodeG4 = function(data, off, slen, tgt, toff, w, fo) {
        var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
        var line = [], pline = [];
        for (var i2 = 0;i2 < w; i2++)
          pline.push(0);
        pline = U._makeDiff(pline);
        var a0 = 0, a1 = 0, a2 = 0, b1 = 0, b2 = 0, clr = 0;
        var y = 0, mode = "", toRead = 0;
        var bipl = Math.ceil(w / 8) * 8;
        while (boff >>> 3 < off + slen) {
          b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
          var bit = 0;
          if (fo == 1)
            bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
          if (fo == 2)
            bit = data[boff >>> 3] >>> (boff & 7) & 1;
          boff++;
          wrd += bit;
          if (mode == "H") {
            if (U._lens[clr][wrd] != null) {
              var dl = U._lens[clr][wrd];
              wrd = "";
              len += dl;
              if (dl < 64) {
                U._addNtimes(line, len, clr);
                a0 += len;
                clr = 1 - clr;
                len = 0;
                toRead--;
                if (toRead == 0)
                  mode = "";
              }
            }
          } else {
            if (wrd == "0001") {
              wrd = "";
              U._addNtimes(line, b2 - a0, clr);
              a0 = b2;
            }
            if (wrd == "001") {
              wrd = "";
              mode = "H";
              toRead = 2;
            }
            if (U._dmap[wrd] != null) {
              a1 = b1 + U._dmap[wrd];
              U._addNtimes(line, a1 - a0, clr);
              a0 = a1;
              wrd = "";
              clr = 1 - clr;
            }
          }
          if (line.length == w && mode == "") {
            U._writeBits(line, tgt, toff * 8 + y * bipl);
            clr = 0;
            y++;
            a0 = 0;
            pline = U._makeDiff(line);
            line = [];
          }
        }
      };
      UTIF2.decode._findDiff = function(line, x, clr) {
        for (var i2 = 0;i2 < line.length; i2 += 2)
          if (line[i2] >= x && line[i2 + 1] == clr)
            return line[i2];
      };
      UTIF2.decode._makeDiff = function(line) {
        var out = [];
        if (line[0] == 1)
          out.push(0, 1);
        for (var i2 = 1;i2 < line.length; i2++)
          if (line[i2 - 1] != line[i2])
            out.push(i2, line[i2]);
        out.push(line.length, 0, line.length, 1);
        return out;
      };
      UTIF2.decode._decodeG2 = function(data, off, slen, tgt, toff, w, fo) {
        var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
        var line = [];
        var clr = 0;
        var y = 0;
        var bipl = Math.ceil(w / 8) * 8;
        while (boff >>> 3 < off + slen) {
          var bit = 0;
          if (fo == 1)
            bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
          if (fo == 2)
            bit = data[boff >>> 3] >>> (boff & 7) & 1;
          boff++;
          wrd += bit;
          len = U._lens[clr][wrd];
          if (len != null) {
            U._addNtimes(line, len, clr);
            wrd = "";
            if (len < 64)
              clr = 1 - clr;
            if (line.length == w) {
              U._writeBits(line, tgt, toff * 8 + y * bipl);
              line = [];
              y++;
              clr = 0;
              if ((boff & 7) != 0)
                boff += 8 - (boff & 7);
              if (len >= 64)
                boff += 8;
            }
          }
        }
      };
      UTIF2.decode._decodeG3 = function(data, off, slen, tgt, toff, w, fo, twoDim) {
        var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
        var line = [], pline = [];
        for (var i2 = 0;i2 < w; i2++)
          line.push(0);
        var a0 = 0, a1 = 0, a2 = 0, b1 = 0, b2 = 0, clr = 0;
        var y = -1, mode = "", toRead = 0, is1D = true;
        var bipl = Math.ceil(w / 8) * 8;
        while (boff >>> 3 < off + slen) {
          b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
          var bit = 0;
          if (fo == 1)
            bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
          if (fo == 2)
            bit = data[boff >>> 3] >>> (boff & 7) & 1;
          boff++;
          wrd += bit;
          if (is1D) {
            if (U._lens[clr][wrd] != null) {
              var dl = U._lens[clr][wrd];
              wrd = "";
              len += dl;
              if (dl < 64) {
                U._addNtimes(line, len, clr);
                clr = 1 - clr;
                len = 0;
              }
            }
          } else {
            if (mode == "H") {
              if (U._lens[clr][wrd] != null) {
                var dl = U._lens[clr][wrd];
                wrd = "";
                len += dl;
                if (dl < 64) {
                  U._addNtimes(line, len, clr);
                  a0 += len;
                  clr = 1 - clr;
                  len = 0;
                  toRead--;
                  if (toRead == 0)
                    mode = "";
                }
              }
            } else {
              if (wrd == "0001") {
                wrd = "";
                U._addNtimes(line, b2 - a0, clr);
                a0 = b2;
              }
              if (wrd == "001") {
                wrd = "";
                mode = "H";
                toRead = 2;
              }
              if (U._dmap[wrd] != null) {
                a1 = b1 + U._dmap[wrd];
                U._addNtimes(line, a1 - a0, clr);
                a0 = a1;
                wrd = "";
                clr = 1 - clr;
              }
            }
          }
          if (wrd.endsWith("000000000001")) {
            if (y >= 0)
              U._writeBits(line, tgt, toff * 8 + y * bipl);
            if (twoDim) {
              if (fo == 1)
                is1D = (data[boff >>> 3] >>> 7 - (boff & 7) & 1) == 1;
              if (fo == 2)
                is1D = (data[boff >>> 3] >>> (boff & 7) & 1) == 1;
              boff++;
            }
            wrd = "";
            clr = 0;
            y++;
            a0 = 0;
            pline = U._makeDiff(line);
            line = [];
          }
        }
        if (line.length == w)
          U._writeBits(line, tgt, toff * 8 + y * bipl);
      };
      UTIF2.decode._addNtimes = function(arr, n2, val) {
        for (var i2 = 0;i2 < n2; i2++)
          arr.push(val);
      };
      UTIF2.decode._writeBits = function(bits, tgt, boff) {
        for (var i2 = 0;i2 < bits.length; i2++)
          tgt[boff + i2 >>> 3] |= bits[i2] << 7 - (boff + i2 & 7);
      };
      UTIF2.decode._decodeLZW = UTIF2.decode._decodeLZW = function() {
        var e, U, Z, u2, K = 0, V = 0, g = 0, N = 0, O = function() {
          var S = e >>> 3, A = U[S] << 16 | U[S + 1] << 8 | U[S + 2], j = A >>> 24 - (e & 7) - V & (1 << V) - 1;
          e += V;
          return j;
        }, h2 = new Uint32Array(4096 * 4), w = 0, m = function(S) {
          if (S == w)
            return;
          w = S;
          g = 1 << S;
          N = g + 1;
          for (var A = 0;A < N + 1; A++) {
            h2[4 * A] = h2[4 * A + 3] = A;
            h2[4 * A + 1] = 65535;
            h2[4 * A + 2] = 1;
          }
        }, i2 = function(S) {
          V = S + 1;
          K = N + 1;
        }, D = function(S) {
          var A = S << 2, j = h2[A + 2], a2 = u2 + j - 1;
          while (A != 65535) {
            Z[a2--] = h2[A];
            A = h2[A + 1];
          }
          u2 += j;
        }, L = function(S, A) {
          var j = K << 2, a2 = S << 2;
          h2[j] = h2[(A << 2) + 3];
          h2[j + 1] = a2;
          h2[j + 2] = h2[a2 + 2] + 1;
          h2[j + 3] = h2[a2 + 3];
          K++;
          if (K + 1 == 1 << V && V != 12)
            V++;
        }, T = function(S, A, j, a2, n2, q) {
          e = A << 3;
          U = S;
          Z = a2;
          u2 = n2;
          var B = A + j << 3, _ = 0, t = 0;
          m(q);
          i2(q);
          while (e < B && (_ = O()) != N) {
            if (_ == g) {
              i2(q);
              _ = O();
              if (_ == N)
                break;
              D(_);
            } else {
              if (_ < K) {
                D(_);
                L(t, _);
              } else {
                L(t, t);
                D(K - 1);
              }
            }
            t = _;
          }
          return u2;
        };
        return T;
      }();
      UTIF2.tags = {};
      UTIF2._types = function() {
        var main = new Array(250);
        main.fill(0);
        main = main.concat([0, 0, 0, 0, 4, 3, 3, 3, 3, 3, 0, 0, 3, 0, 0, 0, 3, 0, 0, 2, 2, 2, 2, 4, 3, 0, 0, 3, 4, 4, 3, 3, 5, 5, 3, 2, 5, 5, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 5, 5, 3, 0, 3, 3, 4, 4, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        var rest = { 33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7 };
        return {
          basic: {
            main,
            rest
          },
          gps: {
            main: [1, 2, 5, 2, 5, 1, 5, 5, 0, 9],
            rest: { 18: 2, 29: 2 }
          }
        };
      }();
      UTIF2._readIFD = function(bin, data, offset, ifds, depth, prm) {
        var cnt = bin.readUshort(data, offset);
        offset += 2;
        var ifd = {};
        if (prm.debug)
          log("   ".repeat(depth), ifds.length - 1, ">>>----------------");
        for (var i2 = 0;i2 < cnt; i2++) {
          var tag = bin.readUshort(data, offset);
          offset += 2;
          var type = bin.readUshort(data, offset);
          offset += 2;
          var num = bin.readUint(data, offset);
          offset += 4;
          var voff = bin.readUint(data, offset);
          offset += 4;
          var arr = [];
          if (type == 1 || type == 7) {
            var no = num < 5 ? offset - 4 : voff;
            if (no + num > data.buffer.byteLength)
              num = data.buffer.byteLength - no;
            arr = new Uint8Array(data.buffer, no, num);
          }
          if (type == 2) {
            var o0 = num < 5 ? offset - 4 : voff, c3 = data[o0], len = Math.max(0, Math.min(num - 1, data.length - o0));
            if (c3 < 128 || len == 0)
              arr.push(bin.readASCII(data, o0, len));
            else
              arr = new Uint8Array(data.buffer, o0, len);
          }
          if (type == 3) {
            for (var j = 0;j < num; j++)
              arr.push(bin.readUshort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
          }
          if (type == 4 || type == 13) {
            for (var j = 0;j < num; j++)
              arr.push(bin.readUint(data, (num < 2 ? offset - 4 : voff) + 4 * j));
          }
          if (type == 5 || type == 10) {
            var ri = type == 5 ? bin.readUint : bin.readInt;
            for (var j = 0;j < num; j++)
              arr.push([ri(data, voff + j * 8), ri(data, voff + j * 8 + 4)]);
          }
          if (type == 8) {
            for (var j = 0;j < num; j++)
              arr.push(bin.readShort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
          }
          if (type == 9) {
            for (var j = 0;j < num; j++)
              arr.push(bin.readInt(data, (num < 2 ? offset - 4 : voff) + 4 * j));
          }
          if (type == 11) {
            for (var j = 0;j < num; j++)
              arr.push(bin.readFloat(data, voff + j * 4));
          }
          if (type == 12) {
            for (var j = 0;j < num; j++)
              arr.push(bin.readDouble(data, voff + j * 8));
          }
          if (num != 0 && arr.length == 0) {
            log(tag, "unknown TIFF tag type: ", type, "num:", num);
            if (i2 == 0)
              return;
            continue;
          }
          if (prm.debug)
            log("   ".repeat(depth), tag, type, UTIF2.tags[tag], arr);
          ifd["t" + tag] = arr;
          if (tag == 330 && ifd["t272"] && ifd["t272"][0] == "DSLR-A100") {} else if (tag == 330 || tag == 34665 || tag == 34853 || tag == 50740 && bin.readUshort(data, bin.readUint(arr, 0)) < 300 || tag == 61440) {
            var oarr = tag == 50740 ? [bin.readUint(arr, 0)] : arr;
            var subfd = [];
            for (var j = 0;j < oarr.length; j++)
              UTIF2._readIFD(bin, data, oarr[j], subfd, depth + 1, prm);
            if (tag == 330)
              ifd.subIFD = subfd;
            if (tag == 34665)
              ifd.exifIFD = subfd[0];
            if (tag == 34853)
              ifd.gpsiIFD = subfd[0];
            if (tag == 50740)
              ifd.dngPrvt = subfd[0];
            if (tag == 61440)
              ifd.fujiIFD = subfd[0];
          }
          if (tag == 37500 && prm.parseMN) {
            var mn = arr;
            if (bin.readASCII(mn, 0, 5) == "Nikon")
              ifd.makerNote = UTIF2["decode"](mn.slice(10).buffer)[0];
            else if (bin.readASCII(mn, 0, 5) == "OLYMP" || bin.readASCII(mn, 0, 9) == "OM SYSTEM") {
              var inds = [8208, 8224, 8240, 8256, 8272];
              var subsub = [];
              UTIF2._readIFD(bin, mn, mn[1] == 77 ? 16 : mn[5] == 85 ? 12 : 8, subsub, depth + 1, prm);
              var obj = ifd.makerNote = subsub.pop();
              for (var j = 0;j < inds.length; j++) {
                var k = "t" + inds[j];
                if (obj[k] == null)
                  continue;
                UTIF2._readIFD(bin, mn, obj[k][0], subsub, depth + 1, prm);
                obj[k] = subsub.pop();
              }
              if (obj["t12288"]) {
                UTIF2._readIFD(bin, obj["t12288"], 0, subsub, depth + 1, prm);
                obj["t12288"] = subsub.pop();
              }
            } else if (bin.readUshort(data, voff) < 300 && bin.readUshort(data, voff + 4) <= 12) {
              var subsub = [];
              UTIF2._readIFD(bin, data, voff, subsub, depth + 1, prm);
              ifd.makerNote = subsub[0];
            }
          }
        }
        ifds.push(ifd);
        if (prm.debug)
          log("   ".repeat(depth), "<<<---------------");
        return offset;
      };
      UTIF2._writeIFD = function(bin, types2, data, offset, ifd) {
        var keys = Object.keys(ifd), knum = keys.length;
        if (ifd["exifIFD"])
          knum--;
        if (ifd["gpsiIFD"])
          knum--;
        bin.writeUshort(data, offset, knum);
        offset += 2;
        var eoff = offset + knum * 12 + 4;
        for (var ki = 0;ki < keys.length; ki++) {
          var key = keys[ki];
          if (key == "t34665" || key == "t34853")
            continue;
          if (key == "exifIFD")
            key = "t34665";
          if (key == "gpsiIFD")
            key = "t34853";
          var tag = parseInt(key.slice(1)), type = types2.main[tag];
          if (type == null)
            type = types2.rest[tag];
          if (type == null || type == 0)
            throw new Error("unknown type of tag: " + tag);
          var val = ifd[key];
          if (tag == 34665) {
            var outp = UTIF2._writeIFD(bin, types2, data, eoff, ifd["exifIFD"]);
            val = [eoff];
            eoff = outp[1];
          }
          if (tag == 34853) {
            var outp = UTIF2._writeIFD(bin, UTIF2._types.gps, data, eoff, ifd["gpsiIFD"]);
            val = [eoff];
            eoff = outp[1];
          }
          if (type == 2)
            val = val[0] + "\x00";
          var num = val.length;
          bin.writeUshort(data, offset, tag);
          offset += 2;
          bin.writeUshort(data, offset, type);
          offset += 2;
          bin.writeUint(data, offset, num);
          offset += 4;
          var dlen = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][type] * num;
          var toff = offset;
          if (dlen > 4) {
            bin.writeUint(data, offset, eoff);
            toff = eoff;
          }
          if (type == 1 || type == 7) {
            for (var i2 = 0;i2 < num; i2++)
              data[toff + i2] = val[i2];
          } else if (type == 2) {
            bin.writeASCII(data, toff, val);
          } else if (type == 3) {
            for (var i2 = 0;i2 < num; i2++)
              bin.writeUshort(data, toff + 2 * i2, val[i2]);
          } else if (type == 4) {
            for (var i2 = 0;i2 < num; i2++)
              bin.writeUint(data, toff + 4 * i2, val[i2]);
          } else if (type == 5 || type == 10) {
            var wr = type == 5 ? bin.writeUint : bin.writeInt;
            for (var i2 = 0;i2 < num; i2++) {
              var v = val[i2], nu = v[0], de = v[1];
              if (nu == null)
                throw "e";
              wr(data, toff + 8 * i2, nu);
              wr(data, toff + 8 * i2 + 4, de);
            }
          } else if (type == 9) {
            for (var i2 = 0;i2 < num; i2++)
              bin.writeInt(data, toff + 4 * i2, val[i2]);
          } else if (type == 12) {
            for (var i2 = 0;i2 < num; i2++)
              bin.writeDouble(data, toff + 8 * i2, val[i2]);
          } else
            throw type;
          if (dlen > 4) {
            dlen += dlen & 1;
            eoff += dlen;
          }
          offset += 4;
        }
        return [offset, eoff];
      };
      UTIF2.toRGBA8 = function(out, scl) {
        function gamma(x2) {
          return x2 < 0.0031308 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055;
        }
        var { width: w, height: h2 } = out, area = w * h2, qarea = area * 4, data = out.data;
        var img = new Uint8Array(area * 4);
        var intp = out["t262"] ? out["t262"][0] : 2, bps = out["t258"] ? Math.min(32, out["t258"][0]) : 1;
        if (out["t262"] == null && bps == 1)
          intp = 0;
        var smpls = out["t277"] ? out["t277"][0] : out["t258"] ? out["t258"].length : [1, 1, 3, 1, 1, 4, 3][intp];
        var sfmt = out["t339"] ? out["t339"][0] : null;
        if (intp == 1 && bps == 32 && sfmt != 3)
          throw "e";
        var bpl = Math.ceil(smpls * bps * w / 8);
        if (false) {} else if (intp == 0) {
          scl = 1 / 256;
          for (var y = 0;y < h2; y++) {
            var off = y * bpl, io = y * w;
            if (bps == 1)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, px = data[off + (i2 >> 3)] >> 7 - (i2 & 7) & 1;
                img[qi] = img[qi + 1] = img[qi + 2] = (1 - px) * 255;
                img[qi + 3] = 255;
              }
            if (bps == 4)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, px = data[off + (i2 >> 1)] >> 4 - 4 * (i2 & 1) & 15;
                img[qi] = img[qi + 1] = img[qi + 2] = (15 - px) * 17;
                img[qi + 3] = 255;
              }
            if (bps == 8)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, px = data[off + i2];
                img[qi] = img[qi + 1] = img[qi + 2] = 255 - px;
                img[qi + 3] = 255;
              }
            if (bps == 16)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, o2 = off + 2 * i2, px = data[o2 + 1] << 8 | data[o2];
                img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, 255 - ~~(px * scl));
                img[qi + 3] = 255;
              }
          }
        } else if (intp == 1) {
          if (scl == null)
            scl = 1 / 256;
          var f32 = (data.length & 3) == 0 ? new Float32Array(data.buffer) : null;
          for (var y = 0;y < h2; y++) {
            var off = y * bpl, io = y * w;
            if (bps == 1)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, px = data[off + (i2 >> 3)] >> 7 - (i2 & 7) & 1;
                img[qi] = img[qi + 1] = img[qi + 2] = px * 255;
                img[qi + 3] = 255;
              }
            if (bps == 2)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, px = data[off + (i2 >> 2)] >> 6 - 2 * (i2 & 3) & 3;
                img[qi] = img[qi + 1] = img[qi + 2] = px * 85;
                img[qi + 3] = 255;
              }
            if (bps == 8)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, px = data[off + i2 * smpls];
                img[qi] = img[qi + 1] = img[qi + 2] = px;
                img[qi + 3] = 255;
              }
            if (bps == 16)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, o2 = off + 2 * i2, px = data[o2 + 1] << 8 | data[o2];
                img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, ~~(px * scl));
                img[qi + 3] = 255;
              }
            if (bps == 32)
              for (var i2 = 0;i2 < w; i2++) {
                var qi = io + i2 << 2, o2 = (off >>> 2) + i2, px = f32[o2];
                img[qi] = img[qi + 1] = img[qi + 2] = ~~(0.5 + 255 * px);
                img[qi + 3] = 255;
              }
          }
        } else if (intp == 2) {
          if (bps == 8) {
            if (smpls == 1)
              for (var i2 = 0;i2 < area; i2++) {
                img[4 * i2] = img[4 * i2 + 1] = img[4 * i2 + 2] = data[i2];
                img[4 * i2 + 3] = 255;
              }
            if (smpls == 3)
              for (var i2 = 0;i2 < area; i2++) {
                var qi = i2 << 2, ti = i2 * 3;
                img[qi] = data[ti];
                img[qi + 1] = data[ti + 1];
                img[qi + 2] = data[ti + 2];
                img[qi + 3] = 255;
              }
            if (smpls >= 4)
              for (var i2 = 0;i2 < area; i2++) {
                var qi = i2 << 2, ti = i2 * smpls;
                img[qi] = data[ti];
                img[qi + 1] = data[ti + 1];
                img[qi + 2] = data[ti + 2];
                img[qi + 3] = data[ti + 3];
              }
          } else if (bps == 16) {
            if (smpls == 4)
              for (var i2 = 0;i2 < area; i2++) {
                var qi = i2 << 2, ti = i2 * 8 + 1;
                img[qi] = data[ti];
                img[qi + 1] = data[ti + 2];
                img[qi + 2] = data[ti + 4];
                img[qi + 3] = data[ti + 6];
              }
            if (smpls == 3)
              for (var i2 = 0;i2 < area; i2++) {
                var qi = i2 << 2, ti = i2 * 6 + 1;
                img[qi] = data[ti];
                img[qi + 1] = data[ti + 2];
                img[qi + 2] = data[ti + 4];
                img[qi + 3] = 255;
              }
          } else if (bps == 32) {
            var ndt = new Float32Array(data.buffer);
            var min = 0;
            for (var i2 = 0;i2 < ndt.length; i2++)
              min = Math.min(min, ndt[i2]);
            if (min < 0)
              for (var i2 = 0;i2 < data.length; i2 += 4) {
                var t = data[i2];
                data[i2] = data[i2 + 3];
                data[i2 + 3] = t;
                t = data[i2 + 1];
                data[i2 + 1] = data[i2 + 2];
                data[i2 + 2] = t;
              }
            var pmap = [];
            for (var i2 = 0;i2 < 65536; i2++)
              pmap.push(gamma(i2 / 65535));
            for (var i2 = 0;i2 < ndt.length; i2++) {
              var cv = Math.max(0, Math.min(1, ndt[i2]));
              ndt[i2] = pmap[~~(0.5 + cv * 65535)];
            }
            if (smpls == 3)
              for (var i2 = 0;i2 < area; i2++) {
                var qi = i2 << 2, ti = i2 * 3;
                img[qi] = ~~(0.5 + ndt[ti] * 255);
                img[qi + 1] = ~~(0.5 + ndt[ti + 1] * 255);
                img[qi + 2] = ~~(0.5 + ndt[ti + 2] * 255);
                img[qi + 3] = 255;
              }
            else if (smpls == 4)
              for (var i2 = 0;i2 < area; i2++) {
                var qi = i2 << 2, ti = i2 * 4;
                img[qi] = ~~(0.5 + ndt[ti] * 255);
                img[qi + 1] = ~~(0.5 + ndt[ti + 1] * 255);
                img[qi + 2] = ~~(0.5 + ndt[ti + 2] * 255);
                img[qi + 3] = ~~(0.5 + ndt[ti + 3] * 255);
              }
            else
              throw smpls;
          } else
            throw bps;
        } else if (intp == 3) {
          var map = out["t320"];
          var cn = 1 << bps;
          var nexta = bps == 8 && smpls > 1 && out["t338"] && out["t338"][0] != 0;
          for (var y = 0;y < h2; y++)
            for (var x = 0;x < w; x++) {
              var i2 = y * w + x;
              var qi = i2 << 2, mi = 0;
              var dof = y * bpl;
              if (false) {} else if (bps == 1)
                mi = data[dof + (x >>> 3)] >>> 7 - (x & 7) & 1;
              else if (bps == 2)
                mi = data[dof + (x >>> 2)] >>> 6 - 2 * (x & 3) & 3;
              else if (bps == 4)
                mi = data[dof + (x >>> 1)] >>> 4 - 4 * (x & 1) & 15;
              else if (bps == 8)
                mi = data[dof + x * smpls];
              else
                throw bps;
              img[qi] = map[mi] >> 8;
              img[qi + 1] = map[cn + mi] >> 8;
              img[qi + 2] = map[cn + cn + mi] >> 8;
              img[qi + 3] = nexta ? data[dof + x * smpls + 1] : 255;
            }
        } else if (intp == 5) {
          var gotAlpha = smpls > 4 ? 1 : 0;
          for (var i2 = 0;i2 < area; i2++) {
            var qi = i2 << 2, si = i2 * smpls;
            if (window.UDOC) {
              var C = data[si], M = data[si + 1], Y = data[si + 2], K = data[si + 3];
              var c3 = UDOC.C.cmykToRgb([C * (1 / 255), M * (1 / 255), Y * (1 / 255), K * (1 / 255)]);
              img[qi] = ~~(0.5 + 255 * c3[0]);
              img[qi + 1] = ~~(0.5 + 255 * c3[1]);
              img[qi + 2] = ~~(0.5 + 255 * c3[2]);
            } else {
              var C = 255 - data[si], M = 255 - data[si + 1], Y = 255 - data[si + 2], K = (255 - data[si + 3]) * (1 / 255);
              img[qi] = ~~(C * K + 0.5);
              img[qi + 1] = ~~(M * K + 0.5);
              img[qi + 2] = ~~(Y * K + 0.5);
            }
            img[qi + 3] = 255 * (1 - gotAlpha) + data[si + 4] * gotAlpha;
          }
        } else if (intp == 6 && out["t278"]) {
          var rps = out["t278"][0];
          for (var y = 0;y < h2; y += rps) {
            var i2 = y * w, len = rps * w;
            for (var j = 0;j < len; j++) {
              var qi = 4 * (i2 + j), si = 3 * i2 + 4 * (j >>> 1);
              var Y = data[si + (j & 1)], Cb = data[si + 2] - 128, Cr = data[si + 3] - 128;
              var r = Y + ((Cr >> 2) + (Cr >> 3) + (Cr >> 5));
              var g = Y - ((Cb >> 2) + (Cb >> 4) + (Cb >> 5)) - ((Cr >> 1) + (Cr >> 3) + (Cr >> 4) + (Cr >> 5));
              var b = Y + (Cb + (Cb >> 1) + (Cb >> 2) + (Cb >> 6));
              img[qi] = Math.max(0, Math.min(255, r));
              img[qi + 1] = Math.max(0, Math.min(255, g));
              img[qi + 2] = Math.max(0, Math.min(255, b));
              img[qi + 3] = 255;
            }
          }
        } else if (intp == 32845) {
          for (var y = 0;y < h2; y++)
            for (var x = 0;x < w; x++) {
              var si = (y * w + x) * 6, qi = (y * w + x) * 4;
              var L = data[si + 1] << 8 | data[si];
              var L = Math.pow(2, (L + 0.5) / 256 - 64);
              var u2 = (data[si + 3] + 0.5) / 410;
              var v = (data[si + 5] + 0.5) / 410;
              var sX = 9 * u2 / (6 * u2 - 16 * v + 12);
              var sY = 4 * v / (6 * u2 - 16 * v + 12);
              var bY = L;
              var X = sX * bY / sY, Y = bY, Z = (1 - sX - sY) * bY / sY;
              var r = 2.69 * X - 1.276 * Y - 0.414 * Z;
              var g = -1.022 * X + 1.978 * Y + 0.044 * Z;
              var b = 0.061 * X - 0.224 * Y + 1.163 * Z;
              img[qi] = gamma(Math.min(r, 1)) * 255;
              img[qi + 1] = gamma(Math.min(g, 1)) * 255;
              img[qi + 2] = gamma(Math.min(b, 1)) * 255;
              img[qi + 3] = 255;
            }
        } else
          log("Unknown Photometric interpretation: " + intp);
        return img;
      };
      UTIF2.replaceIMG = function(imgs) {
        if (imgs == null)
          imgs = document.getElementsByTagName("img");
        var sufs = ["tif", "tiff", "dng", "cr2", "nef"];
        for (var i2 = 0;i2 < imgs.length; i2++) {
          var img = imgs[i2], src = img.getAttribute("src");
          if (src == null)
            continue;
          var suff = src.split(".").pop().toLowerCase();
          if (sufs.indexOf(suff) == -1)
            continue;
          var xhr = new XMLHttpRequest;
          UTIF2._xhrs.push(xhr);
          UTIF2._imgs.push(img);
          xhr.open("GET", src);
          xhr.responseType = "arraybuffer";
          xhr.onload = UTIF2._imgLoaded;
          xhr.send();
        }
      };
      UTIF2._xhrs = [];
      UTIF2._imgs = [];
      UTIF2._imgLoaded = function(e) {
        var ind = UTIF2._xhrs.indexOf(e.target), img = UTIF2._imgs[ind];
        UTIF2._xhrs.splice(ind, 1);
        UTIF2._imgs.splice(ind, 1);
        img.setAttribute("src", UTIF2.bufferToURI(e.target.response));
      };
      UTIF2.bufferToURI = function(buff) {
        var ifds = UTIF2.decode(buff);
        var vsns = ifds, ma = 0, page = vsns[0];
        if (ifds[0].subIFD)
          vsns = vsns.concat(ifds[0].subIFD);
        for (var i2 = 0;i2 < vsns.length; i2++) {
          var img = vsns[i2];
          if (img["t258"] == null || img["t258"].length < 3)
            continue;
          var ar = img["t256"] * img["t257"];
          if (ar > ma) {
            ma = ar;
            page = img;
          }
        }
        UTIF2.decodeImage(buff, page, ifds);
        var rgba = UTIF2.toRGBA8(page), w = page.width, h2 = page.height;
        var cnv = document.createElement("canvas");
        cnv.width = w;
        cnv.height = h2;
        var ctx = cnv.getContext("2d");
        var imgd = new ImageData(new Uint8ClampedArray(rgba.buffer), w, h2);
        ctx.putImageData(imgd, 0, 0);
        return cnv.toDataURL();
      };
      UTIF2._binBE = {
        nextZero: function(data, o2) {
          while (data[o2] != 0)
            o2++;
          return o2;
        },
        readUshort: function(buff, p) {
          return buff[p] << 8 | buff[p + 1];
        },
        readShort: function(buff, p) {
          var a2 = UTIF2._binBE.ui8;
          a2[0] = buff[p + 1];
          a2[1] = buff[p + 0];
          return UTIF2._binBE.i16[0];
        },
        readInt: function(buff, p) {
          var a2 = UTIF2._binBE.ui8;
          a2[0] = buff[p + 3];
          a2[1] = buff[p + 2];
          a2[2] = buff[p + 1];
          a2[3] = buff[p + 0];
          return UTIF2._binBE.i32[0];
        },
        readUint: function(buff, p) {
          var a2 = UTIF2._binBE.ui8;
          a2[0] = buff[p + 3];
          a2[1] = buff[p + 2];
          a2[2] = buff[p + 1];
          a2[3] = buff[p + 0];
          return UTIF2._binBE.ui32[0];
        },
        readASCII: function(buff, p, l) {
          var s = "";
          for (var i2 = 0;i2 < l; i2++)
            s += String.fromCharCode(buff[p + i2]);
          return s;
        },
        readFloat: function(buff, p) {
          var a2 = UTIF2._binBE.ui8;
          for (var i2 = 0;i2 < 4; i2++)
            a2[i2] = buff[p + 3 - i2];
          return UTIF2._binBE.fl32[0];
        },
        readDouble: function(buff, p) {
          var a2 = UTIF2._binBE.ui8;
          for (var i2 = 0;i2 < 8; i2++)
            a2[i2] = buff[p + 7 - i2];
          return UTIF2._binBE.fl64[0];
        },
        writeUshort: function(buff, p, n2) {
          buff[p] = n2 >> 8 & 255;
          buff[p + 1] = n2 & 255;
        },
        writeInt: function(buff, p, n2) {
          var a2 = UTIF2._binBE.ui8;
          UTIF2._binBE.i32[0] = n2;
          buff[p + 3] = a2[0];
          buff[p + 2] = a2[1];
          buff[p + 1] = a2[2];
          buff[p + 0] = a2[3];
        },
        writeUint: function(buff, p, n2) {
          buff[p] = n2 >> 24 & 255;
          buff[p + 1] = n2 >> 16 & 255;
          buff[p + 2] = n2 >> 8 & 255;
          buff[p + 3] = n2 >> 0 & 255;
        },
        writeASCII: function(buff, p, s) {
          for (var i2 = 0;i2 < s.length; i2++)
            buff[p + i2] = s.charCodeAt(i2);
        },
        writeDouble: function(buff, p, n2) {
          UTIF2._binBE.fl64[0] = n2;
          for (var i2 = 0;i2 < 8; i2++)
            buff[p + i2] = UTIF2._binBE.ui8[7 - i2];
        }
      };
      UTIF2._binBE.ui8 = new Uint8Array(8);
      UTIF2._binBE.i16 = new Int16Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binBE.i32 = new Int32Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binBE.ui32 = new Uint32Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binBE.fl32 = new Float32Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binBE.fl64 = new Float64Array(UTIF2._binBE.ui8.buffer);
      UTIF2._binLE = {
        nextZero: UTIF2._binBE.nextZero,
        readUshort: function(buff, p) {
          return buff[p + 1] << 8 | buff[p];
        },
        readShort: function(buff, p) {
          var a2 = UTIF2._binBE.ui8;
          a2[0] = buff[p + 0];
          a2[1] = buff[p + 1];
          return UTIF2._binBE.i16[0];
        },
        readInt: function(buff, p) {
          var a2 = UTIF2._binBE.ui8;
          a2[0] = buff[p + 0];
          a2[1] = buff[p + 1];
          a2[2] = buff[p + 2];
          a2[3] = buff[p + 3];
          return UTIF2._binBE.i32[0];
        },
        readUint: function(buff, p) {
          var a2 = UTIF2._binBE.ui8;
          a2[0] = buff[p + 0];
          a2[1] = buff[p + 1];
          a2[2] = buff[p + 2];
          a2[3] = buff[p + 3];
          return UTIF2._binBE.ui32[0];
        },
        readASCII: UTIF2._binBE.readASCII,
        readFloat: function(buff, p) {
          var a2 = UTIF2._binBE.ui8;
          for (var i2 = 0;i2 < 4; i2++)
            a2[i2] = buff[p + i2];
          return UTIF2._binBE.fl32[0];
        },
        readDouble: function(buff, p) {
          var a2 = UTIF2._binBE.ui8;
          for (var i2 = 0;i2 < 8; i2++)
            a2[i2] = buff[p + i2];
          return UTIF2._binBE.fl64[0];
        },
        writeUshort: function(buff, p, n2) {
          buff[p] = n2 & 255;
          buff[p + 1] = n2 >> 8 & 255;
        },
        writeInt: function(buff, p, n2) {
          var a2 = UTIF2._binBE.ui8;
          UTIF2._binBE.i32[0] = n2;
          buff[p + 0] = a2[0];
          buff[p + 1] = a2[1];
          buff[p + 2] = a2[2];
          buff[p + 3] = a2[3];
        },
        writeUint: function(buff, p, n2) {
          buff[p] = n2 >>> 0 & 255;
          buff[p + 1] = n2 >>> 8 & 255;
          buff[p + 2] = n2 >>> 16 & 255;
          buff[p + 3] = n2 >>> 24 & 255;
        },
        writeASCII: UTIF2._binBE.writeASCII
      };
      UTIF2._copyTile = function(tb, tw, th, b, w, h2, xoff, yoff) {
        var xlim = Math.min(tw, w - xoff);
        var ylim = Math.min(th, h2 - yoff);
        for (var y = 0;y < ylim; y++) {
          var tof = (yoff + y) * w + xoff;
          var sof = y * tw;
          for (var x = 0;x < xlim; x++)
            b[tof + x] = tb[sof + x];
        }
      };
      UTIF2.LosslessJpegDecode = function() {
        var b, O;
        function l() {
          return b[O++];
        }
        function m() {
          return b[O++] << 8 | b[O++];
        }
        function a0(h2) {
          var V = l(), I = [0, 0, 0, 255], f = [], G = 8;
          for (var w = 0;w < 16; w++)
            f[w] = l();
          for (var w = 0;w < 16; w++) {
            for (var x = 0;x < f[w]; x++) {
              var T = z(I, 0, w + 1, 1);
              I[T + 3] = l();
            }
          }
          var E = new Uint8Array(1 << G);
          h2[V] = [new Uint8Array(I), E];
          for (var w = 0;w < 1 << G; w++) {
            var s = G, _ = w, Y = 0, F = 0;
            while (I[Y + 3] == 255 && s != 0) {
              F = _ >> --s & 1;
              Y = I[Y + F];
            }
            E[w] = Y;
          }
        }
        function z(h2, V, I, f) {
          if (h2[V + 3] != 255)
            return 0;
          if (I == 0)
            return V;
          for (var w = 0;w < 2; w++) {
            if (h2[V + w] == 0) {
              h2[V + w] = h2.length;
              h2.push(0, 0, f, 255);
            }
            var x = z(h2, h2[V + w], I - 1, f + 1);
            if (x != 0)
              return x;
          }
          return 0;
        }
        function i2(h2) {
          var { b: V, f: I } = h2;
          while (V < 25 && h2.a < h2.d) {
            var f = h2.data[h2.a++];
            if (f == 255 && !h2.c)
              h2.a++;
            I = I << 8 | f;
            V += 8;
          }
          if (V < 0)
            throw "e";
          h2.b = V;
          h2.f = I;
        }
        function H(h2, V) {
          if (V.b < h2)
            i2(V);
          return V.f >> (V.b -= h2) & 65535 >> 16 - h2;
        }
        function g(h2, V) {
          var I = h2[0], f = 0, w = 255, x = 0;
          if (V.b < 16)
            i2(V);
          var T = V.f >> V.b - 8 & 255;
          f = h2[1][T];
          w = I[f + 3];
          V.b -= I[f + 2];
          while (w == 255) {
            x = V.f >> --V.b & 1;
            f = I[f + x];
            w = I[f + 3];
          }
          return w;
        }
        function P(h2, V) {
          if (h2 < 32768 >> 16 - V)
            h2 += -(1 << V) + 1;
          return h2;
        }
        function a2(h2, V) {
          var I = g(h2, V);
          if (I == 0)
            return 0;
          if (I == 16)
            return -32768;
          var f = H(I, V);
          return P(f, I);
        }
        function X(h2, V, I, f, w, x) {
          var T = 0;
          for (var G = 0;G < x; G++) {
            var s = G * V;
            for (var _ = 0;_ < V; _ += w) {
              T++;
              for (var Y = 0;Y < w; Y++)
                h2[s + _ + Y] = a2(f[Y], I);
            }
            if (I.e != 0 && T % I.e == 0 && G != 0) {
              var { a: F, data: t } = I;
              while (t[F] != 255 || !(208 <= t[F + 1] && t[F + 1] <= 215))
                F--;
              I.a = F + 2;
              I.f = 0;
              I.b = 0;
            }
          }
        }
        function o2(h2, V) {
          return P(H(h2, V), h2);
        }
        function a1(h2, V, I, f, w) {
          var x = b.length - O;
          for (var T = 0;T < x; T += 4) {
            var G = b[O + T];
            b[O + T] = b[O + T + 3];
            b[O + T + 3] = G;
            var G = b[O + T + 1];
            b[O + T + 1] = b[O + T + 2];
            b[O + T + 2] = G;
          }
          for (var E = 0;E < w; E++) {
            var s = 32768, _ = 32768;
            for (var Y = 0;Y < V; Y += 2) {
              var F = g(f, I), t = g(f, I);
              if (F != 0)
                s += o2(F, I);
              if (t != 0)
                _ += o2(t, I);
              h2[E * V + Y] = s & 65535;
              h2[E * V + Y + 1] = _ & 65535;
            }
          }
        }
        function C(h2) {
          b = h2;
          O = 0;
          if (m() != 65496)
            throw "e";
          var V = [], I = 0, f = 0, w = 0, x = [], T = [], G = [], E = 0, s = 0, _ = 0;
          while (true) {
            var Y = m();
            if (Y == 65535) {
              O--;
              continue;
            }
            var F = m();
            if (Y == 65475) {
              f = l();
              s = m();
              _ = m();
              E = l();
              for (var t = 0;t < E; t++) {
                var a3 = l(), J = l(), r = l();
                if (r != 0)
                  throw "e";
                V[a3] = [t, J >> 4, J & 15];
              }
            } else if (Y == 65476) {
              var a32 = O + F - 2;
              while (O < a32)
                a0(T);
            } else if (Y == 65498) {
              O++;
              for (var t = 0;t < E; t++) {
                var a5 = l(), v = V[a5];
                G[v[0]] = T[l() >>> 4];
                x[v[0]] = v.slice(1);
              }
              I = l();
              O += 2;
              break;
            } else if (Y == 65501) {
              w = m();
            } else {
              O += F - 2;
            }
          }
          var a4 = f > 8 ? Uint16Array : Uint8Array, $2 = new a4(s * _ * E), M = { b: 0, f: 0, c: I == 8, a: O, data: b, d: b.length, e: w };
          if (M.c)
            a1($2, _ * E, M, G[0], s);
          else {
            var c3 = [], p = 0, D = 0;
            for (var t = 0;t < E; t++) {
              var N = x[t], S = N[0], K = N[1];
              if (S > p)
                p = S;
              if (K > D)
                D = K;
              c3.push(S * K);
            }
            if (p != 1 || D != 1) {
              if (E != 3 || c3[1] != 1 || c3[2] != 1)
                throw "e";
              if (p != 2 || D != 1 && D != 2)
                throw "e";
              var u2 = [], Z = 0;
              for (var t = 0;t < E; t++) {
                for (var R = 0;R < c3[t]; R++)
                  u2.push(G[t]);
                Z += c3[t];
              }
              var B = _ / p, e = s / D, d = B * e;
              X($2, B * Z, M, u2, Z, e);
              j($2, I, B, e, Z - 2, Z, Z, f);
              var A = new Uint16Array(d * c3[0]);
              if (p == 2 && D == 2) {
                for (var t = 0;t < d; t++) {
                  A[4 * t] = $2[6 * t];
                  A[4 * t + 1] = $2[6 * t + 1];
                  A[4 * t + 2] = $2[6 * t + 2];
                  A[4 * t + 3] = $2[6 * t + 3];
                }
                j(A, I, B * 4, e, 0, 1, 1, f);
                for (var t = 0;t < d; t++) {
                  $2[6 * t] = A[4 * t];
                  $2[6 * t + 1] = A[4 * t + 1];
                  $2[6 * t + 2] = A[4 * t + 2];
                  $2[6 * t + 3] = A[4 * t + 3];
                }
              }
              if (p == 2 && D == 1) {
                for (var t = 0;t < d; t++) {
                  A[2 * t] = $2[4 * t];
                  A[2 * t + 1] = $2[4 * t + 1];
                }
                j(A, I, B * 2, e, 0, 1, 1, f);
                for (var t = 0;t < d; t++) {
                  $2[4 * t] = A[2 * t];
                  $2[4 * t + 1] = A[2 * t + 1];
                }
              }
              var n2 = $2.slice(0);
              for (var K = 0;K < s; K++) {
                if (D == 2)
                  for (var S = 0;S < _; S++) {
                    var q = (K * _ + S) * E, k = ((K >>> 1) * B + (S >>> 1)) * Z, y = (K & 1) * 2 + (S & 1);
                    $2[q] = n2[k + y];
                    $2[q + 1] = n2[k + 4];
                    $2[q + 2] = n2[k + 5];
                  }
                else
                  for (var S = 0;S < _; S++) {
                    var q = (K * _ + S) * E, k = (K * B + (S >>> 1)) * Z, y = S & 1;
                    $2[q] = n2[k + y];
                    $2[q + 1] = n2[k + 2];
                    $2[q + 2] = n2[k + 3];
                  }
              }
            } else {
              X($2, _ * E, M, G, E, s);
              if (w == 0)
                j($2, I, _, s, 0, E, E, f);
              else {
                var U = Math.floor(w / _);
                for (var K = 0;K < s; K += U) {
                  var L = $2.slice(K * _ * E, (K + U) * _ * E);
                  j(L, I, _, U, 0, E, E, f);
                  $2.set(L, K * _ * E);
                }
              }
            }
          }
          return $2;
        }
        function j(h2, V, I, f, w, x, G, E) {
          var s = I * G;
          for (var _ = w;_ < x; _++)
            h2[_] += 1 << E - 1;
          for (var Y = G;Y < s; Y += G)
            for (var _ = w;_ < x; _++)
              h2[Y + _] += h2[Y + _ - G];
          for (var F = 1;F < f; F++) {
            var t = F * s;
            for (var _ = w;_ < x; _++)
              h2[t + _] += h2[t + _ - s];
            for (var Y = G;Y < s; Y += G) {
              for (var _ = w;_ < x; _++) {
                var a3 = t + Y + _, J = a3 - s, r = h2[a3 - G], Q = 0;
                if (V == 0)
                  Q = 0;
                else if (V == 1)
                  Q = r;
                else if (V == 2)
                  Q = h2[J];
                else if (V == 3)
                  Q = h2[J - G];
                else if (V == 4)
                  Q = r + (h2[J] - h2[J - G]);
                else if (V == 5)
                  Q = r + (h2[J] - h2[J - G] >>> 1);
                else if (V == 6)
                  Q = h2[J] + (r - h2[J - G] >>> 1);
                else if (V == 7)
                  Q = r + h2[J] >>> 1;
                else
                  throw V;
                h2[a3] += Q;
              }
            }
          }
        }
        return C;
      }();
      (function() {
        var G = 0, F = 1, i2 = 2, b = 3, J = 4, N = 5, E = 6, s = 7, c3 = 8, T = 9, a3 = 10, f = 11, q = 12, M = 13, m = 14, x = 15, L = 16, $2 = 17, p = 18;
        function a5(t) {
          var Z = UTIF2._binBE.readUshort, u2 = { b: Z(t, 0), i: t[2], C: t[3], u: t[4], q: Z(t, 5), k: Z(t, 7), e: Z(t, 9), l: Z(t, 11), s: t[13], d: Z(t, 14) };
          if (u2.b != 18771 || u2.i > 1 || u2.q < 6 || u2.q % 6 || u2.e < 768 || u2.e % 24 || u2.l != 768 || u2.k < u2.l || u2.k % u2.l || u2.k - u2.e >= u2.l || u2.s > 16 || u2.s != u2.k / u2.l || u2.s != Math.ceil(u2.e / u2.l) || u2.d != u2.q / 6 || u2.u != 12 && u2.u != 14 && u2.u != 16 || u2.C != 16 && u2.C != 0) {
            throw "Invalid data";
          }
          if (u2.i == 0) {
            throw "Not implemented. We need this file!";
          }
          u2.h = u2.C == 16;
          u2.m = (u2.h ? u2.l * 2 / 3 : u2.l >>> 1) | 0;
          u2.A = u2.m + 2;
          u2.f = 64;
          u2.g = (1 << u2.u) - 1;
          u2.n = 4 * u2.u;
          return u2;
        }
        function a7(t, Z) {
          var u2 = new Array(Z.s), e = 4 * Z.s, Q = 16 + e;
          if (e & 12)
            Q += 16 - (e & 12);
          for (var V = 0, O = 16;V < Z.s; O += 4) {
            var o2 = UTIF2._binBE.readUint(t, O);
            u2[V] = t.slice(Q, Q + o2);
            u2[V].j = 0;
            u2[V].a = 0;
            Q += o2;
            V++;
          }
          if (Q != t.length)
            throw "Invalid data";
          return u2;
        }
        function a6(t, Z) {
          for (var u2 = -Z[4], e = 0;u2 <= Z[4]; e++, u2++) {
            t[e] = u2 <= -Z[3] ? -4 : u2 <= -Z[2] ? -3 : u2 <= -Z[1] ? -2 : u2 < -Z[0] ? -1 : u2 <= Z[0] ? 0 : u2 < Z[1] ? 1 : u2 < Z[2] ? 2 : u2 < Z[3] ? 3 : 4;
          }
        }
        function a1(t, Z, u2) {
          var e = [Z, 3 * Z + 18, 5 * Z + 67, 7 * Z + 276, u2];
          t.o = Z;
          t.w = (e[4] + 2 * Z) / (2 * Z + 1) + 1 | 0;
          t.v = Math.ceil(Math.log2(t.w));
          t.t = 9;
          a6(t.c, e);
        }
        function a2(t) {
          var Z = { c: new Int8Array(2 << t.u) };
          a1(Z, 0, t.g);
          return Z;
        }
        function D(t) {
          var Z = [[], [], []], u2 = Math.max(2, t.w + 32 >>> 6);
          for (var e = 0;e < 3; e++) {
            for (var Q = 0;Q < 41; Q++) {
              Z[e][Q] = [u2, 1];
            }
          }
          return Z;
        }
        function a4(t) {
          for (var Z = -1, u2 = 0;!u2; Z++) {
            u2 = t[t.j] >>> 7 - t.a & 1;
            t.a++;
            t.a &= 7;
            if (!t.a)
              t.j++;
          }
          return Z;
        }
        function K(t, Z) {
          var u2 = 0, e = 8 - t.a, Q = t.j, V = t.a;
          if (Z) {
            if (Z >= e) {
              do {
                u2 <<= e;
                Z -= e;
                u2 |= t[t.j] & (1 << e) - 1;
                t.j++;
                e = 8;
              } while (Z >= 8);
            }
            if (Z) {
              u2 <<= Z;
              e -= Z;
              u2 |= t[t.j] >>> e & (1 << Z) - 1;
            }
            t.a = 8 - e;
          }
          return u2;
        }
        function a0(t, Z) {
          var u2 = 0;
          if (Z < t) {
            while (u2 <= 14 && Z << ++u2 < t)
              ;
          }
          return u2;
        }
        function r(t, Z, u2, e, Q, V, O, o2) {
          if (o2 == null)
            o2 = 0;
          var X = V + 1, k = X % 2, j = 0, I = 0, a10 = 0, l, R, w = e[Q], S = e[Q - 1], H = e[Q - 2][X], g = S[X - 1], Y = S[X], P = S[X + 1], A = w[X - 1], v = w[X + 1], y = Math.abs, d, C, n2, h2;
          if (k) {
            d = y(P - Y);
            C = y(H - Y);
            n2 = y(g - Y);
          }
          if (k) {
            h2 = d > n2 && C < d ? H + g : d < n2 && C < n2 ? H + P : P + g;
            h2 = h2 + 2 * Y >>> 2;
            if (o2) {
              w[X] = h2;
              return;
            }
            l = Z.t * Z.c[t.g + Y - H] + Z.c[t.g + g - Y];
          } else {
            h2 = Y > g && Y > P || Y < g && Y < P ? v + A + 2 * Y >>> 2 : A + v >>> 1;
            l = Z.t * Z.c[t.g + Y - g] + Z.c[t.g + g - A];
          }
          R = y(l);
          var W = a4(u2);
          if (W < t.n - Z.v - 1) {
            var z = a0(O[R][0], O[R][1]);
            a10 = K(u2, z) + (W << z);
          } else {
            a10 = K(u2, Z.v) + 1;
          }
          a10 = a10 & 1 ? -1 - (a10 >>> 1) : a10 >>> 1;
          O[R][0] += y(a10);
          if (O[R][1] == t.f) {
            O[R][0] >>>= 1;
            O[R][1] >>>= 1;
          }
          O[R][1]++;
          h2 = l < 0 ? h2 - a10 : h2 + a10;
          if (t.i) {
            if (h2 < 0)
              h2 += Z.w;
            else if (h2 > t.g)
              h2 -= Z.w;
          }
          w[X] = h2 >= 0 ? Math.min(h2, t.g) : 0;
        }
        function U(t, Z, u2) {
          var e = t[0].length;
          for (var Q = Z;Q <= u2; Q++) {
            t[Q][0] = t[Q - 1][1];
            t[Q][e - 1] = t[Q - 1][e - 2];
          }
        }
        function B(t) {
          U(t, s, q);
          U(t, i2, J);
          U(t, x, $2);
        }
        function _(t, Z, u2, e, Q, V, O, o2, X, k, j, I, a10) {
          var l = 0, R = 1, w = Q < M && Q > J;
          while (R < t.m) {
            if (l < t.m) {
              r(t, Z, u2, e, Q, l, O[X], t.h && (w && k || !w && (j || (l & I) == a10)));
              r(t, Z, u2, e, V, l, O[X], t.h && (!w && k || w && (j || (l & I) == a10)));
              l += 2;
            }
            if (l > 8) {
              r(t, Z, u2, e, Q, R, o2[X]);
              r(t, Z, u2, e, V, R, o2[X]);
              R += 2;
            }
          }
          B(e);
        }
        function a8(t, Z, u2, e, Q, V) {
          _(t, Z, u2, e, i2, s, Q, V, 0, 0, 1, 0, 8);
          _(t, Z, u2, e, c3, x, Q, V, 1, 0, 1, 0, 8);
          _(t, Z, u2, e, b, T, Q, V, 2, 1, 0, 3, 0);
          _(t, Z, u2, e, a3, L, Q, V, 0, 0, 0, 3, 2);
          _(t, Z, u2, e, J, f, Q, V, 1, 0, 0, 3, 2);
          _(t, Z, u2, e, q, $2, Q, V, 2, 1, 0, 3, 0);
        }
        function a9(t, Z, u2, e, Q, V) {
          var O = V.length, o2 = t.l;
          if (Q + 1 == t.s)
            o2 = t.e - Q * t.l;
          var X = 6 * t.e * e + Q * t.l;
          for (var k = 0;k < 6; k++) {
            for (var j = 0;j < o2; j++) {
              var I = V[k % O][j % O], a10;
              if (I == 0) {
                a10 = i2 + (k >>> 1);
              } else if (I == 2) {
                a10 = x + (k >>> 1);
              } else {
                a10 = s + k;
              }
              var l = t.h ? (j * 2 / 3 & 2147483646 | j % 3 & 1) + (j % 3 >>> 1) : j >>> 1;
              Z[X + j] = u2[a10][l + 1];
            }
            X += t.e;
          }
        }
        UTIF2._decompressRAF = function(t, Z) {
          var u2 = a5(t), e = a7(t, u2), Q = a2(u2), V = new Int16Array(u2.e * u2.q);
          if (Z == null) {
            Z = u2.h ? [[1, 1, 0, 1, 1, 2], [1, 1, 2, 1, 1, 0], [2, 0, 1, 0, 2, 1], [1, 1, 2, 1, 1, 0], [1, 1, 0, 1, 1, 2], [0, 2, 1, 2, 0, 1]] : [[0, 1], [3, 2]];
          }
          var O = [[G, b], [F, J], [N, f], [E, q], [M, L], [m, $2]], o2 = [];
          for (var X = 0;X < p; X++) {
            o2[X] = new Uint16Array(u2.A);
          }
          for (var k = 0;k < u2.s; k++) {
            var j = D(Q), I = D(Q);
            for (var X = 0;X < p; X++) {
              for (var a10 = 0;a10 < u2.A; a10++) {
                o2[X][a10] = 0;
              }
            }
            for (var l = 0;l < u2.d; l++) {
              a8(u2, Q, e[k], o2, j, I);
              for (var X = 0;X < 6; X++) {
                for (var a10 = 0;a10 < u2.A; a10++) {
                  o2[O[X][0]][a10] = o2[O[X][1]][a10];
                }
              }
              a9(u2, V, o2, l, k, Z);
              for (var X = i2;X < p; X++) {
                if ([N, E, M, m].indexOf(X) == -1) {
                  for (var a10 = 0;a10 < u2.A; a10++) {
                    o2[X][a10] = 0;
                  }
                }
              }
              B(o2);
            }
          }
          return V;
        };
      })();
    })(UTIF, pako);
  })();
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS((exports) => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i2];
    i2 += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (;nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {}
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (;nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c3;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c3 = Math.pow(2, -e)) < 1) {
        e--;
        c3 *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c3;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c3 >= 2) {
        e++;
        c3 /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c3 - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (;mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {}
    e = e << mLen | m;
    eLen += mLen;
    for (;eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {}
    buffer[offset + i2 - d] |= s * 128;
  };
});

// node_modules/token-types/lib/index.js
var require_lib = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnsiStringType = exports.StringType = exports.BufferType = exports.Uint8ArrayType = exports.IgnoreType = exports.Float80_LE = exports.Float80_BE = exports.Float64_LE = exports.Float64_BE = exports.Float32_LE = exports.Float32_BE = exports.Float16_LE = exports.Float16_BE = exports.INT64_BE = exports.UINT64_BE = exports.INT64_LE = exports.UINT64_LE = exports.INT32_LE = exports.INT32_BE = exports.INT24_BE = exports.INT24_LE = exports.INT16_LE = exports.INT16_BE = exports.INT8 = exports.UINT32_BE = exports.UINT32_LE = exports.UINT24_BE = exports.UINT24_LE = exports.UINT16_BE = exports.UINT16_LE = exports.UINT8 = undefined;
  var ieee754 = require_ieee754();
  function dv(array) {
    return new DataView(array.buffer, array.byteOffset);
  }
  exports.UINT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getUint8(offset);
    },
    put(array, offset, value) {
      dv(array).setUint8(offset, value);
      return offset + 1;
    }
  };
  exports.UINT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value, true);
      return offset + 2;
    }
  };
  exports.UINT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value);
      return offset + 2;
    }
  };
  exports.UINT24_LE = {
    len: 3,
    get(array, offset) {
      const dataView = dv(array);
      return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
    },
    put(array, offset, value) {
      const dataView = dv(array);
      dataView.setUint8(offset, value & 255);
      dataView.setUint16(offset + 1, value >> 8, true);
      return offset + 3;
    }
  };
  exports.UINT24_BE = {
    len: 3,
    get(array, offset) {
      const dataView = dv(array);
      return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
    },
    put(array, offset, value) {
      const dataView = dv(array);
      dataView.setUint16(offset, value >> 8);
      dataView.setUint8(offset + 2, value & 255);
      return offset + 3;
    }
  };
  exports.UINT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value, true);
      return offset + 4;
    }
  };
  exports.UINT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value);
      return offset + 4;
    }
  };
  exports.INT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getInt8(offset);
    },
    put(array, offset, value) {
      dv(array).setInt8(offset, value);
      return offset + 1;
    }
  };
  exports.INT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getInt16(offset);
    },
    put(array, offset, value) {
      dv(array).setInt16(offset, value);
      return offset + 2;
    }
  };
  exports.INT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getInt16(offset, true);
    },
    put(array, offset, value) {
      dv(array).setInt16(offset, value, true);
      return offset + 2;
    }
  };
  exports.INT24_LE = {
    len: 3,
    get(array, offset) {
      const unsigned = exports.UINT24_LE.get(array, offset);
      return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
    },
    put(array, offset, value) {
      const dataView = dv(array);
      dataView.setUint8(offset, value & 255);
      dataView.setUint16(offset + 1, value >> 8, true);
      return offset + 3;
    }
  };
  exports.INT24_BE = {
    len: 3,
    get(array, offset) {
      const unsigned = exports.UINT24_BE.get(array, offset);
      return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
    },
    put(array, offset, value) {
      const dataView = dv(array);
      dataView.setUint16(offset, value >> 8);
      dataView.setUint8(offset + 2, value & 255);
      return offset + 3;
    }
  };
  exports.INT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset);
    },
    put(array, offset, value) {
      dv(array).setInt32(offset, value);
      return offset + 4;
    }
  };
  exports.INT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setInt32(offset, value, true);
      return offset + 4;
    }
  };
  exports.UINT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setBigUint64(offset, value, true);
      return offset + 8;
    }
  };
  exports.INT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigInt64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setBigInt64(offset, value, true);
      return offset + 8;
    }
  };
  exports.UINT64_BE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset);
    },
    put(array, offset, value) {
      dv(array).setBigUint64(offset, value);
      return offset + 8;
    }
  };
  exports.INT64_BE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigInt64(offset);
    },
    put(array, offset, value) {
      dv(array).setBigInt64(offset, value);
      return offset + 8;
    }
  };
  exports.Float16_BE = {
    len: 2,
    get(dataView, offset) {
      return ieee754.read(dataView, offset, false, 10, this.len);
    },
    put(dataView, offset, value) {
      ieee754.write(dataView, value, offset, false, 10, this.len);
      return offset + this.len;
    }
  };
  exports.Float16_LE = {
    len: 2,
    get(array, offset) {
      return ieee754.read(array, offset, true, 10, this.len);
    },
    put(array, offset, value) {
      ieee754.write(array, value, offset, true, 10, this.len);
      return offset + this.len;
    }
  };
  exports.Float32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getFloat32(offset);
    },
    put(array, offset, value) {
      dv(array).setFloat32(offset, value);
      return offset + 4;
    }
  };
  exports.Float32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getFloat32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setFloat32(offset, value, true);
      return offset + 4;
    }
  };
  exports.Float64_BE = {
    len: 8,
    get(array, offset) {
      return dv(array).getFloat64(offset);
    },
    put(array, offset, value) {
      dv(array).setFloat64(offset, value);
      return offset + 8;
    }
  };
  exports.Float64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getFloat64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setFloat64(offset, value, true);
      return offset + 8;
    }
  };
  exports.Float80_BE = {
    len: 10,
    get(array, offset) {
      return ieee754.read(array, offset, false, 63, this.len);
    },
    put(array, offset, value) {
      ieee754.write(array, value, offset, false, 63, this.len);
      return offset + this.len;
    }
  };
  exports.Float80_LE = {
    len: 10,
    get(array, offset) {
      return ieee754.read(array, offset, true, 63, this.len);
    },
    put(array, offset, value) {
      ieee754.write(array, value, offset, true, 63, this.len);
      return offset + this.len;
    }
  };

  class IgnoreType {
    constructor(len) {
      this.len = len;
    }
    get(array, off) {}
  }
  exports.IgnoreType = IgnoreType;

  class Uint8ArrayType {
    constructor(len) {
      this.len = len;
    }
    get(array, offset) {
      return array.subarray(offset, offset + this.len);
    }
  }
  exports.Uint8ArrayType = Uint8ArrayType;

  class BufferType {
    constructor(len) {
      this.len = len;
    }
    get(uint8Array, off) {
      return Buffer.from(uint8Array.subarray(off, off + this.len));
    }
  }
  exports.BufferType = BufferType;

  class StringType {
    constructor(len, encoding) {
      this.len = len;
      this.encoding = encoding;
    }
    get(uint8Array, offset) {
      return Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
    }
  }
  exports.StringType = StringType;

  class AnsiStringType {
    constructor(len) {
      this.len = len;
    }
    static decode(buffer, offset, until) {
      let str = "";
      for (let i2 = offset;i2 < until; ++i2) {
        str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i2]));
      }
      return str;
    }
    static inRange(a2, min, max) {
      return min <= a2 && a2 <= max;
    }
    static codePointToString(cp) {
      if (cp <= 65535) {
        return String.fromCharCode(cp);
      } else {
        cp -= 65536;
        return String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
      }
    }
    static singleByteDecoder(bite) {
      if (AnsiStringType.inRange(bite, 0, 127)) {
        return bite;
      }
      const codePoint = AnsiStringType.windows1252[bite - 128];
      if (codePoint === null) {
        throw Error("invaliding encoding");
      }
      return codePoint;
    }
    get(buffer, offset = 0) {
      return AnsiStringType.decode(buffer, offset, offset + this.len);
    }
  }
  exports.AnsiStringType = AnsiStringType;
  AnsiStringType.windows1252 = [
    8364,
    129,
    8218,
    402,
    8222,
    8230,
    8224,
    8225,
    710,
    8240,
    352,
    8249,
    338,
    141,
    381,
    143,
    144,
    8216,
    8217,
    8220,
    8221,
    8226,
    8211,
    8212,
    732,
    8482,
    353,
    8250,
    339,
    157,
    382,
    376,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255
  ];
});

// node_modules/peek-readable/lib/EndOfFileStream.js
var require_EndOfFileStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndOfStreamError = exports.defaultMessages = undefined;
  exports.defaultMessages = "End-Of-Stream";

  class EndOfStreamError extends Error {
    constructor() {
      super(exports.defaultMessages);
    }
  }
  exports.EndOfStreamError = EndOfStreamError;
});

// node_modules/peek-readable/lib/Deferred.js
var require_Deferred = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deferred = undefined;

  class Deferred {
    constructor() {
      this.resolve = () => null;
      this.reject = () => null;
      this.promise = new Promise((resolve2, reject2) => {
        this.reject = reject2;
        this.resolve = resolve2;
      });
    }
  }
  exports.Deferred = Deferred;
});

// node_modules/peek-readable/lib/StreamReader.js
var require_StreamReader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamReader = exports.EndOfStreamError = undefined;
  var EndOfFileStream_1 = require_EndOfFileStream();
  var Deferred_1 = require_Deferred();
  var EndOfFileStream_2 = require_EndOfFileStream();
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return EndOfFileStream_2.EndOfStreamError;
  } });
  var maxStreamReadSize = 1 * 1024 * 1024;

  class StreamReader {
    constructor(s) {
      this.s = s;
      this.deferred = null;
      this.endOfStream = false;
      this.peekQueue = [];
      if (!s.read || !s.once) {
        throw new Error("Expected an instance of stream.Readable");
      }
      this.s.once("end", () => this.reject(new EndOfFileStream_1.EndOfStreamError));
      this.s.once("error", (err) => this.reject(err));
      this.s.once("close", () => this.reject(new Error("Stream closed")));
    }
    async peek(uint8Array, offset, length) {
      const bytesRead = await this.read(uint8Array, offset, length);
      this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead));
      return bytesRead;
    }
    async read(buffer, offset, length) {
      if (length === 0) {
        return 0;
      }
      if (this.peekQueue.length === 0 && this.endOfStream) {
        throw new EndOfFileStream_1.EndOfStreamError;
      }
      let remaining = length;
      let bytesRead = 0;
      while (this.peekQueue.length > 0 && remaining > 0) {
        const peekData = this.peekQueue.pop();
        if (!peekData)
          throw new Error("peekData should be defined");
        const lenCopy = Math.min(peekData.length, remaining);
        buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
        bytesRead += lenCopy;
        remaining -= lenCopy;
        if (lenCopy < peekData.length) {
          this.peekQueue.push(peekData.subarray(lenCopy));
        }
      }
      while (remaining > 0 && !this.endOfStream) {
        const reqLen = Math.min(remaining, maxStreamReadSize);
        const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
        bytesRead += chunkLen;
        if (chunkLen < reqLen)
          break;
        remaining -= chunkLen;
      }
      return bytesRead;
    }
    async readFromStream(buffer, offset, length) {
      const readBuffer = this.s.read(length);
      if (readBuffer) {
        buffer.set(readBuffer, offset);
        return readBuffer.length;
      } else {
        const request = {
          buffer,
          offset,
          length,
          deferred: new Deferred_1.Deferred
        };
        this.deferred = request.deferred;
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
        return request.deferred.promise;
      }
    }
    readDeferred(request) {
      const readBuffer = this.s.read(request.length);
      if (readBuffer) {
        request.buffer.set(readBuffer, request.offset);
        request.deferred.resolve(readBuffer.length);
        this.deferred = null;
      } else {
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
      }
    }
    reject(err) {
      this.endOfStream = true;
      if (this.deferred) {
        this.deferred.reject(err);
        this.deferred = null;
      }
    }
  }
  exports.StreamReader = StreamReader;
});

// node_modules/peek-readable/lib/index.js
var require_lib2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamReader = exports.EndOfStreamError = undefined;
  var EndOfFileStream_1 = require_EndOfFileStream();
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return EndOfFileStream_1.EndOfStreamError;
  } });
  var StreamReader_1 = require_StreamReader();
  Object.defineProperty(exports, "StreamReader", { enumerable: true, get: function() {
    return StreamReader_1.StreamReader;
  } });
});

// node_modules/strtok3/lib/AbstractTokenizer.js
var require_AbstractTokenizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractTokenizer = undefined;
  var peek_readable_1 = require_lib2();

  class AbstractTokenizer {
    constructor(fileInfo) {
      this.position = 0;
      this.numBuffer = new Uint8Array(8);
      this.fileInfo = fileInfo ? fileInfo : {};
    }
    async readToken(token, position = this.position) {
      const uint8Array = Buffer.alloc(token.len);
      const len = await this.readBuffer(uint8Array, { position });
      if (len < token.len)
        throw new peek_readable_1.EndOfStreamError;
      return token.get(uint8Array, 0);
    }
    async peekToken(token, position = this.position) {
      const uint8Array = Buffer.alloc(token.len);
      const len = await this.peekBuffer(uint8Array, { position });
      if (len < token.len)
        throw new peek_readable_1.EndOfStreamError;
      return token.get(uint8Array, 0);
    }
    async readNumber(token) {
      const len = await this.readBuffer(this.numBuffer, { length: token.len });
      if (len < token.len)
        throw new peek_readable_1.EndOfStreamError;
      return token.get(this.numBuffer, 0);
    }
    async peekNumber(token) {
      const len = await this.peekBuffer(this.numBuffer, { length: token.len });
      if (len < token.len)
        throw new peek_readable_1.EndOfStreamError;
      return token.get(this.numBuffer, 0);
    }
    async ignore(length) {
      if (this.fileInfo.size !== undefined) {
        const bytesLeft = this.fileInfo.size - this.position;
        if (length > bytesLeft) {
          this.position += bytesLeft;
          return bytesLeft;
        }
      }
      this.position += length;
      return length;
    }
    async close() {}
    normalizeOptions(uint8Array, options) {
      if (options && options.position !== undefined && options.position < this.position) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (options) {
        return {
          mayBeLess: options.mayBeLess === true,
          offset: options.offset ? options.offset : 0,
          length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
          position: options.position ? options.position : this.position
        };
      }
      return {
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      };
    }
  }
  exports.AbstractTokenizer = AbstractTokenizer;
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var require_ReadStreamTokenizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadStreamTokenizer = undefined;
  var AbstractTokenizer_1 = require_AbstractTokenizer();
  var peek_readable_1 = require_lib2();
  var maxBufferSize = 256000;

  class ReadStreamTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
    constructor(stream2, fileInfo) {
      super(fileInfo);
      this.streamReader = new peek_readable_1.StreamReader(stream2);
    }
    async getFileInfo() {
      return this.fileInfo;
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        await this.ignore(skipBytes);
        return this.readBuffer(uint8Array, options);
      } else if (skipBytes < 0) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (normOptions.length === 0) {
        return 0;
      }
      const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
      this.position += bytesRead;
      if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
        throw new peek_readable_1.EndOfStreamError;
      }
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      let bytesRead = 0;
      if (normOptions.position) {
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
          bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
          uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
          return bytesRead - skipBytes;
        } else if (skipBytes < 0) {
          throw new Error("Cannot peek from a negative offset in a stream");
        }
      }
      if (normOptions.length > 0) {
        try {
          bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
        } catch (err) {
          if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {
            return 0;
          }
          throw err;
        }
        if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError;
        }
      }
      return bytesRead;
    }
    async ignore(length) {
      const bufSize = Math.min(maxBufferSize, length);
      const buf = new Uint8Array(bufSize);
      let totBytesRead = 0;
      while (totBytesRead < length) {
        const remaining = length - totBytesRead;
        const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
        if (bytesRead < 0) {
          return bytesRead;
        }
        totBytesRead += bytesRead;
      }
      return totBytesRead;
    }
  }
  exports.ReadStreamTokenizer = ReadStreamTokenizer;
});

// node_modules/strtok3/lib/BufferTokenizer.js
var require_BufferTokenizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferTokenizer = undefined;
  var peek_readable_1 = require_lib2();
  var AbstractTokenizer_1 = require_AbstractTokenizer();

  class BufferTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
    constructor(uint8Array, fileInfo) {
      super(fileInfo);
      this.uint8Array = uint8Array;
      this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
    }
    async readBuffer(uint8Array, options) {
      if (options && options.position) {
        if (options.position < this.position) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        this.position = options.position;
      }
      const bytesRead = await this.peekBuffer(uint8Array, options);
      this.position += bytesRead;
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
      if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
        throw new peek_readable_1.EndOfStreamError;
      } else {
        uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
        return bytes2read;
      }
    }
    async close() {}
  }
  exports.BufferTokenizer = BufferTokenizer;
});

// node_modules/strtok3/lib/core.js
var require_core = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromBuffer = exports.fromStream = exports.EndOfStreamError = undefined;
  var ReadStreamTokenizer_1 = require_ReadStreamTokenizer();
  var BufferTokenizer_1 = require_BufferTokenizer();
  var peek_readable_1 = require_lib2();
  Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function() {
    return peek_readable_1.EndOfStreamError;
  } });
  function fromStream(stream2, fileInfo) {
    fileInfo = fileInfo ? fileInfo : {};
    return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream2, fileInfo);
  }
  exports.fromStream = fromStream;
  function fromBuffer(uint8Array, fileInfo) {
    return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
  }
  exports.fromBuffer = fromBuffer;
});

// node_modules/file-type/util.js
var require_util2 = __commonJS((exports) => {
  exports.stringToBytes = (string) => [...string].map((character) => character.charCodeAt(0));
  exports.tarHeaderChecksumMatches = (buffer, offset = 0) => {
    const readSum = parseInt(buffer.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
    if (isNaN(readSum)) {
      return false;
    }
    let sum = 8 * 32;
    for (let i2 = offset;i2 < offset + 148; i2++) {
      sum += buffer[i2];
    }
    for (let i2 = offset + 156;i2 < offset + 512; i2++) {
      sum += buffer[i2];
    }
    return readSum === sum;
  };
  exports.uint32SyncSafeToken = {
    get: (buffer, offset) => {
      return buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21;
    },
    len: 4
  };
});

// node_modules/file-type/supported.js
var require_supported = __commonJS((exports, module) => {
  module.exports = {
    extensions: [
      "jpg",
      "png",
      "apng",
      "gif",
      "webp",
      "flif",
      "xcf",
      "cr2",
      "cr3",
      "orf",
      "arw",
      "dng",
      "nef",
      "rw2",
      "raf",
      "tif",
      "bmp",
      "icns",
      "jxr",
      "psd",
      "indd",
      "zip",
      "tar",
      "rar",
      "gz",
      "bz2",
      "7z",
      "dmg",
      "mp4",
      "mid",
      "mkv",
      "webm",
      "mov",
      "avi",
      "mpg",
      "mp2",
      "mp3",
      "m4a",
      "oga",
      "ogg",
      "ogv",
      "opus",
      "flac",
      "wav",
      "spx",
      "amr",
      "pdf",
      "epub",
      "exe",
      "swf",
      "rtf",
      "wasm",
      "woff",
      "woff2",
      "eot",
      "ttf",
      "otf",
      "ico",
      "flv",
      "ps",
      "xz",
      "sqlite",
      "nes",
      "crx",
      "xpi",
      "cab",
      "deb",
      "ar",
      "rpm",
      "Z",
      "lz",
      "cfb",
      "mxf",
      "mts",
      "blend",
      "bpg",
      "docx",
      "pptx",
      "xlsx",
      "3gp",
      "3g2",
      "jp2",
      "jpm",
      "jpx",
      "mj2",
      "aif",
      "qcp",
      "odt",
      "ods",
      "odp",
      "xml",
      "mobi",
      "heic",
      "cur",
      "ktx",
      "ape",
      "wv",
      "dcm",
      "ics",
      "glb",
      "pcap",
      "dsf",
      "lnk",
      "alias",
      "voc",
      "ac3",
      "m4v",
      "m4p",
      "m4b",
      "f4v",
      "f4p",
      "f4b",
      "f4a",
      "mie",
      "asf",
      "ogm",
      "ogx",
      "mpc",
      "arrow",
      "shp",
      "aac",
      "mp1",
      "it",
      "s3m",
      "xm",
      "ai",
      "skp",
      "avif",
      "eps",
      "lzh",
      "pgp",
      "asar",
      "stl",
      "chm",
      "3mf",
      "zst",
      "jxl",
      "vcf"
    ],
    mimeTypes: [
      "image/jpeg",
      "image/png",
      "image/gif",
      "image/webp",
      "image/flif",
      "image/x-xcf",
      "image/x-canon-cr2",
      "image/x-canon-cr3",
      "image/tiff",
      "image/bmp",
      "image/vnd.ms-photo",
      "image/vnd.adobe.photoshop",
      "application/x-indesign",
      "application/epub+zip",
      "application/x-xpinstall",
      "application/vnd.oasis.opendocument.text",
      "application/vnd.oasis.opendocument.spreadsheet",
      "application/vnd.oasis.opendocument.presentation",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "application/zip",
      "application/x-tar",
      "application/x-rar-compressed",
      "application/gzip",
      "application/x-bzip2",
      "application/x-7z-compressed",
      "application/x-apple-diskimage",
      "application/x-apache-arrow",
      "video/mp4",
      "audio/midi",
      "video/x-matroska",
      "video/webm",
      "video/quicktime",
      "video/vnd.avi",
      "audio/vnd.wave",
      "audio/qcelp",
      "audio/x-ms-asf",
      "video/x-ms-asf",
      "application/vnd.ms-asf",
      "video/mpeg",
      "video/3gpp",
      "audio/mpeg",
      "audio/mp4",
      "audio/opus",
      "video/ogg",
      "audio/ogg",
      "application/ogg",
      "audio/x-flac",
      "audio/ape",
      "audio/wavpack",
      "audio/amr",
      "application/pdf",
      "application/x-msdownload",
      "application/x-shockwave-flash",
      "application/rtf",
      "application/wasm",
      "font/woff",
      "font/woff2",
      "application/vnd.ms-fontobject",
      "font/ttf",
      "font/otf",
      "image/x-icon",
      "video/x-flv",
      "application/postscript",
      "application/eps",
      "application/x-xz",
      "application/x-sqlite3",
      "application/x-nintendo-nes-rom",
      "application/x-google-chrome-extension",
      "application/vnd.ms-cab-compressed",
      "application/x-deb",
      "application/x-unix-archive",
      "application/x-rpm",
      "application/x-compress",
      "application/x-lzip",
      "application/x-cfb",
      "application/x-mie",
      "application/mxf",
      "video/mp2t",
      "application/x-blender",
      "image/bpg",
      "image/jp2",
      "image/jpx",
      "image/jpm",
      "image/mj2",
      "audio/aiff",
      "application/xml",
      "application/x-mobipocket-ebook",
      "image/heif",
      "image/heif-sequence",
      "image/heic",
      "image/heic-sequence",
      "image/icns",
      "image/ktx",
      "application/dicom",
      "audio/x-musepack",
      "text/calendar",
      "text/vcard",
      "model/gltf-binary",
      "application/vnd.tcpdump.pcap",
      "audio/x-dsf",
      "application/x.ms.shortcut",
      "application/x.apple.alias",
      "audio/x-voc",
      "audio/vnd.dolby.dd-raw",
      "audio/x-m4a",
      "image/apng",
      "image/x-olympus-orf",
      "image/x-sony-arw",
      "image/x-adobe-dng",
      "image/x-nikon-nef",
      "image/x-panasonic-rw2",
      "image/x-fujifilm-raf",
      "video/x-m4v",
      "video/3gpp2",
      "application/x-esri-shape",
      "audio/aac",
      "audio/x-it",
      "audio/x-s3m",
      "audio/x-xm",
      "video/MP1S",
      "video/MP2P",
      "application/vnd.sketchup.skp",
      "image/avif",
      "application/x-lzh-compressed",
      "application/pgp-encrypted",
      "application/x-asar",
      "model/stl",
      "application/vnd.ms-htmlhelp",
      "model/3mf",
      "image/jxl",
      "application/zstd"
    ]
  };
});

// node_modules/file-type/core.js
var require_core2 = __commonJS((exports, module) => {
  var Token = require_lib();
  var strtok3 = require_core();
  var {
    stringToBytes,
    tarHeaderChecksumMatches,
    uint32SyncSafeToken
  } = require_util2();
  var supported = require_supported();
  var minimumBytes = 4100;
  async function fromStream(stream3) {
    const tokenizer = await strtok3.fromStream(stream3);
    try {
      return await fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async function fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer = input instanceof Buffer ? input : Buffer.from(input);
    if (!(buffer && buffer.length > 1)) {
      return;
    }
    const tokenizer = strtok3.fromBuffer(buffer);
    return fromTokenizer(tokenizer);
  }
  function _check(buffer, headers, options) {
    options = {
      offset: 0,
      ...options
    };
    for (const [index, header] of headers.entries()) {
      if (options.mask) {
        if (header !== (options.mask[index] & buffer[index + options.offset])) {
          return false;
        }
      } else if (header !== buffer[index + options.offset]) {
        return false;
      }
    }
    return true;
  }
  async function fromTokenizer(tokenizer) {
    try {
      return _fromTokenizer(tokenizer);
    } catch (error) {
      if (!(error instanceof strtok3.EndOfStreamError)) {
        throw error;
      }
    }
  }
  async function _fromTokenizer(tokenizer) {
    let buffer = Buffer.alloc(minimumBytes);
    const bytesRead = 12;
    const check2 = (header, options) => _check(buffer, header, options);
    const checkString = (header, options) => check2(stringToBytes(header), options);
    if (!tokenizer.fileInfo.size) {
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    }
    await tokenizer.peekBuffer(buffer, { length: bytesRead, mayBeLess: true });
    if (check2([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (check2([11, 119])) {
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw"
      };
    }
    if (check2([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (check2([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if (check2([37, 33])) {
      await tokenizer.peekBuffer(buffer, { length: 24, mayBeLess: true });
      if (checkString("PS-Adobe-", { offset: 2 }) && checkString(" EPSF-", { offset: 14 })) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (check2([31, 160]) || check2([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (check2([255, 216, 255])) {
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (check2([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (check2([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (check2([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      await tokenizer.ignore(id3HeaderLen);
      return fromTokenizer(tokenizer);
    }
    if (checkString("MP+")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if ((buffer[0] === 67 || buffer[0] === 70) && check2([87, 83], { offset: 1 })) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (check2([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (checkString("FLIF")) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if (checkString("8BPS")) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (checkString("WEBP", { offset: 8 })) {
      return {
        ext: "webp",
        mime: "image/webp"
      };
    }
    if (checkString("MPCK")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if (checkString("FORM")) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (checkString("icns", { offset: 0 })) {
      return {
        ext: "icns",
        mime: "image/icns"
      };
    }
    if (check2([80, 75, 3, 4])) {
      try {
        while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
          await tokenizer.readBuffer(buffer, { length: 30 });
          const zipHeader = {
            compressedSize: buffer.readUInt32LE(18),
            uncompressedSize: buffer.readUInt32LE(22),
            filenameLength: buffer.readUInt16LE(26),
            extraFieldLength: buffer.readUInt16LE(28)
          };
          zipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, "utf-8"));
          await tokenizer.ignore(zipHeader.extraFieldLength);
          if (zipHeader.filename === "META-INF/mozilla.rsa") {
            return {
              ext: "xpi",
              mime: "application/x-xpinstall"
            };
          }
          if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml")) {
            const type = zipHeader.filename.split("/")[0];
            switch (type) {
              case "_rels":
                break;
              case "word":
                return {
                  ext: "docx",
                  mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                };
              case "ppt":
                return {
                  ext: "pptx",
                  mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                };
              case "xl":
                return {
                  ext: "xlsx",
                  mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                };
              default:
                break;
            }
          }
          if (zipHeader.filename.startsWith("xl/")) {
            return {
              ext: "xlsx",
              mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            };
          }
          if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model")) {
            return {
              ext: "3mf",
              mime: "model/3mf"
            };
          }
          if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize) {
            const mimeType = await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, "utf-8"));
            switch (mimeType) {
              case "application/epub+zip":
                return {
                  ext: "epub",
                  mime: "application/epub+zip"
                };
              case "application/vnd.oasis.opendocument.text":
                return {
                  ext: "odt",
                  mime: "application/vnd.oasis.opendocument.text"
                };
              case "application/vnd.oasis.opendocument.spreadsheet":
                return {
                  ext: "ods",
                  mime: "application/vnd.oasis.opendocument.spreadsheet"
                };
              case "application/vnd.oasis.opendocument.presentation":
                return {
                  ext: "odp",
                  mime: "application/vnd.oasis.opendocument.presentation"
                };
              default:
            }
          }
          if (zipHeader.compressedSize === 0) {
            let nextHeaderIndex = -1;
            while (nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size) {
              await tokenizer.peekBuffer(buffer, { mayBeLess: true });
              nextHeaderIndex = buffer.indexOf("504B0304", 0, "hex");
              await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);
            }
          } else {
            await tokenizer.ignore(zipHeader.compressedSize);
          }
        }
      } catch (error) {
        if (!(error instanceof strtok3.EndOfStreamError)) {
          throw error;
        }
      }
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (checkString("OggS")) {
      await tokenizer.ignore(28);
      const type = Buffer.alloc(8);
      await tokenizer.readBuffer(type);
      if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (_check(type, [127, 70, 76, 65, 67])) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (check2([80, 75]) && (buffer[2] === 3 || buffer[2] === 5 || buffer[2] === 7) && (buffer[3] === 4 || buffer[3] === 6 || buffer[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (checkString("ftyp", { offset: 4 }) && (buffer[8] & 96) !== 0) {
      const brandMajor = buffer.toString("binary", 8, 12).replace("\x00", " ").trim();
      switch (brandMajor) {
        case "avif":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return { ext: "3g2", mime: "video/3gpp2" };
            }
            return { ext: "3gp", mime: "video/3gpp" };
          }
          return { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (checkString("MThd")) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (checkString("wOFF") && (check2([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (checkString("wOF2") && (check2([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (check2([212, 195, 178, 161]) || check2([161, 178, 195, 212])) {
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      };
    }
    if (checkString("DSD ")) {
      return {
        ext: "dsf",
        mime: "audio/x-dsf"
      };
    }
    if (checkString("LZIP")) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (checkString("fLaC")) {
      return {
        ext: "flac",
        mime: "audio/x-flac"
      };
    }
    if (check2([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (checkString("wvpk")) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (checkString("%PDF")) {
      await tokenizer.ignore(1350);
      const maxBufferSize = 10 * 1024 * 1024;
      const buffer2 = Buffer.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
      await tokenizer.readBuffer(buffer2, { mayBeLess: true });
      if (buffer2.includes(Buffer.from("AIPrivateData"))) {
        return {
          ext: "ai",
          mime: "application/postscript"
        };
      }
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (check2([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (check2([73, 73, 42, 0])) {
      if (checkString("CR", { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check2([28, 0, 254, 0], { offset: 8 }) || check2([31, 0, 11, 0], { offset: 8 })) {
        return {
          ext: "nef",
          mime: "image/x-nikon-nef"
        };
      }
      if (check2([8, 0, 0, 0], { offset: 4 }) && (check2([45, 0, 254, 0], { offset: 8 }) || check2([39, 0, 254, 0], { offset: 8 }))) {
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      }
      buffer = Buffer.alloc(24);
      await tokenizer.peekBuffer(buffer);
      if ((check2([16, 251, 134, 1], { offset: 4 }) || check2([8, 0, 0, 0], { offset: 4 })) && check2([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 })) {
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      }
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (check2([77, 77, 0, 42])) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (checkString("MAC ")) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (check2([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(Token.UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id = Buffer.alloc(ic + 1);
        await tokenizer.readBuffer(id);
        return id;
      }
      async function readElement() {
        const id = await readField();
        const lenField = await readField();
        lenField[0] ^= 128 >> lenField.length - 1;
        const nrLen = Math.min(6, lenField.length);
        return {
          id: id.readUIntBE(0, id.length),
          len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
        };
      }
      async function readChildren(level, children) {
        while (children > 0) {
          const e = await readElement();
          if (e.id === 17026) {
            return tokenizer.readToken(new Token.StringType(e.len, "utf-8"));
          }
          await tokenizer.ignore(e.len);
          --children;
        }
      }
      const re = await readElement();
      const docType = await readChildren(1, re.len);
      switch (docType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm"
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/x-matroska"
          };
        default:
          return;
      }
    }
    if (check2([82, 73, 70, 70])) {
      if (check2([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (check2([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/vnd.wave"
        };
      }
      if (check2([81, 76, 67, 77], { offset: 8 })) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (checkString("SQLi")) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (check2([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (checkString("Cr24")) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (checkString("MSCF") || checkString("ISc(")) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (check2([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (check2([197, 208, 211, 198])) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    if (check2([40, 181, 47, 253])) {
      return {
        ext: "zst",
        mime: "application/zstd"
      };
    }
    if (check2([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (checkString("#!AMR")) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (checkString("{\\rtf")) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (check2([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (checkString("IMPM")) {
      return {
        ext: "it",
        mime: "audio/x-it"
      };
    }
    if (checkString("-lh0-", { offset: 2 }) || checkString("-lh1-", { offset: 2 }) || checkString("-lh2-", { offset: 2 }) || checkString("-lh3-", { offset: 2 }) || checkString("-lh4-", { offset: 2 }) || checkString("-lh5-", { offset: 2 }) || checkString("-lh6-", { offset: 2 }) || checkString("-lh7-", { offset: 2 }) || checkString("-lzs-", { offset: 2 }) || checkString("-lz4-", { offset: 2 }) || checkString("-lz5-", { offset: 2 }) || checkString("-lhd-", { offset: 2 })) {
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed"
      };
    }
    if (check2([0, 0, 1, 186])) {
      if (check2([33], { offset: 4, mask: [241] })) {
        return {
          ext: "mpg",
          mime: "video/MP1S"
        };
      }
      if (check2([68], { offset: 4, mask: [196] })) {
        return {
          ext: "mpg",
          mime: "video/MP2P"
        };
      }
    }
    if (checkString("ITSF")) {
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp"
      };
    }
    if (check2([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (check2([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (check2([82, 97, 114, 33, 26, 7]) && (buffer[6] === 0 || buffer[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (checkString("solid ")) {
      return {
        ext: "stl",
        mime: "model/stl"
      };
    }
    if (checkString("BLENDER")) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const str = await tokenizer.readToken(new Token.StringType(13, "ascii"));
      if (str === "debian-binary") {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (check2([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(Token.INT32_BE),
          type: await tokenizer.readToken(new Token.StringType(4, "binary"))
        };
      }
      do {
        const chunk = await readChunkHeader();
        if (chunk.length < 0) {
          return;
        }
        switch (chunk.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png"
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng"
            };
          default:
            await tokenizer.ignore(chunk.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (check2([65, 82, 82, 79, 87, 49, 0, 0])) {
      return {
        ext: "arrow",
        mime: "application/x-apache-arrow"
      };
    }
    if (check2([103, 108, 84, 70, 2, 0, 0, 0])) {
      return {
        ext: "glb",
        mime: "model/gltf-binary"
      };
    }
    if (check2([102, 114, 101, 101], { offset: 4 }) || check2([109, 100, 97, 116], { offset: 4 }) || check2([109, 111, 111, 118], { offset: 4 }) || check2([119, 105, 100, 101], { offset: 4 })) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (check2([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
      return {
        ext: "orf",
        mime: "image/x-olympus-orf"
      };
    }
    if (checkString("gimp xcf ")) {
      return {
        ext: "xcf",
        mime: "image/x-xcf"
      };
    }
    if (check2([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2"
      };
    }
    if (check2([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid = Buffer.alloc(16);
        await tokenizer.readBuffer(guid);
        return {
          id: guid,
          size: Number(await tokenizer.readToken(Token.UINT64_LE))
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          const typeId = Buffer.alloc(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "audio/x-ms-asf"
            };
          }
          if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "video/x-ms-asf"
            };
          }
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf"
      };
    }
    if (check2([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    if ((check2([126, 16, 4]) || check2([126, 24, 4])) && check2([48, 77, 73, 69], { offset: 4 })) {
      return {
        ext: "mie",
        mime: "application/x-mie"
      };
    }
    if (check2([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
      return {
        ext: "shp",
        mime: "application/x-esri-shape"
      };
    }
    if (check2([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type = await tokenizer.readToken(new Token.StringType(4, "ascii"));
      switch (type) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        default:
          return;
      }
    }
    if (check2([255, 10]) || check2([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
      return {
        ext: "jxl",
        mime: "image/jxl"
      };
    }
    if (check2([0, 0, 1, 186]) || check2([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (check2([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (check2([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (check2([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    if (check2([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "cfb",
        mime: "application/x-cfb"
      };
    }
    await tokenizer.peekBuffer(buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
    if (checkString("BEGIN:")) {
      if (checkString("VCARD", { offset: 6 })) {
        return {
          ext: "vcf",
          mime: "text/vcard"
        };
      }
      if (checkString("VCALENDAR", { offset: 6 })) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
    }
    if (checkString("FUJIFILMCCD-RAW")) {
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf"
      };
    }
    if (checkString("Extended Module:")) {
      return {
        ext: "xm",
        mime: "audio/x-xm"
      };
    }
    if (checkString("Creative Voice File")) {
      return {
        ext: "voc",
        mime: "audio/x-voc"
      };
    }
    if (check2([4, 0, 0, 0]) && buffer.length >= 16) {
      const jsonSize = buffer.readUInt32LE(12);
      if (jsonSize > 12 && buffer.length >= jsonSize + 16) {
        try {
          const header = buffer.slice(16, jsonSize + 16).toString();
          const json = JSON.parse(header);
          if (json.files) {
            return {
              ext: "asar",
              mime: "application/x-asar"
            };
          }
        } catch (_) {}
      }
    }
    if (check2([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (checkString("SCRM", { offset: 44 })) {
      return {
        ext: "s3m",
        mime: "audio/x-s3m"
      };
    }
    if (check2([71], { offset: 4 }) && (check2([71], { offset: 192 }) || check2([71], { offset: 196 }))) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (check2([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (check2([68, 73, 67, 77], { offset: 128 })) {
      return {
        ext: "dcm",
        mime: "application/dicom"
      };
    }
    if (check2([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut"
      };
    }
    if (check2([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
      return {
        ext: "alias",
        mime: "application/x.apple.alias"
      };
    }
    if (check2([76, 80], { offset: 34 }) && (check2([0, 0, 1], { offset: 8 }) || check2([1, 0, 2], { offset: 8 }) || check2([2, 0, 2], { offset: 8 }))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (check2([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
      return {
        ext: "indd",
        mime: "application/x-indesign"
      };
    }
    await tokenizer.peekBuffer(buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
    if (tarHeaderChecksumMatches(buffer)) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (check2([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0])) {
      return {
        ext: "skp",
        mime: "application/vnd.sketchup.skp"
      };
    }
    if (checkString("-----BEGIN PGP MESSAGE-----")) {
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted"
      };
    }
    if (buffer.length >= 2 && check2([255, 224], { offset: 0, mask: [255, 224] })) {
      if (check2([16], { offset: 1, mask: [22] })) {
        if (check2([8], { offset: 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (check2([2], { offset: 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (check2([4], { offset: 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (check2([6], { offset: 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  }
  var stream2 = (readableStream) => new Promise((resolve, reject) => {
    const stream = eval("require")("stream");
    readableStream.on("error", reject);
    readableStream.once("readable", async () => {
      const pass = new stream.PassThrough;
      let outputStream;
      if (stream.pipeline) {
        outputStream = stream.pipeline(readableStream, pass, () => {});
      } else {
        outputStream = readableStream.pipe(pass);
      }
      const chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
      try {
        const fileType2 = await fromBuffer(chunk);
        pass.fileType = fileType2;
      } catch (error) {
        reject(error);
      }
      resolve(outputStream);
    });
  });
  var fileType = {
    fromStream,
    fromTokenizer,
    fromBuffer,
    stream: stream2
  };
  Object.defineProperty(fileType, "extensions", {
    get() {
      return new Set(supported.extensions);
    }
  });
  Object.defineProperty(fileType, "mimeTypes", {
    get() {
      return new Set(supported.mimeTypes);
    }
  });
  module.exports = fileType;
});

// node_modules/await-to-js/dist/await-to-js.umd.js
var require_await_to_js_umd = __commonJS((exports, module) => {
  (function(global3, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global3.awaitToJs = {});
  })(exports, function(exports2) {
    function to(promise, errorExt) {
      return promise.then(function(data) {
        return [null, data];
      }).catch(function(err) {
        if (errorExt) {
          Object.assign(err, errorExt);
        }
        return [err, undefined];
      });
    }
    exports2.to = to;
    exports2["default"] = to;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/mime/Mime.js
var require_Mime = __commonJS((exports, module) => {
  function Mime() {
    this._types = Object.create(null);
    this._extensions = Object.create(null);
    for (let i2 = 0;i2 < arguments.length; i2++) {
      this.define(arguments[i2]);
    }
    this.define = this.define.bind(this);
    this.getType = this.getType.bind(this);
    this.getExtension = this.getExtension.bind(this);
  }
  Mime.prototype.define = function(typeMap, force) {
    for (let type in typeMap) {
      let extensions = typeMap[type].map(function(t) {
        return t.toLowerCase();
      });
      type = type.toLowerCase();
      for (let i2 = 0;i2 < extensions.length; i2++) {
        const ext = extensions[i2];
        if (ext[0] === "*") {
          continue;
        }
        if (!force && ext in this._types) {
          throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
        }
        this._types[ext] = type;
      }
      if (force || !this._extensions[type]) {
        const ext = extensions[0];
        this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
      }
    }
  };
  Mime.prototype.getType = function(path8) {
    path8 = String(path8);
    let last = path8.replace(/^.*[/\\]/, "").toLowerCase();
    let ext = last.replace(/^.*\./, "").toLowerCase();
    let hasPath = last.length < path8.length;
    let hasDot = ext.length < last.length - 1;
    return (hasDot || !hasPath) && this._types[ext] || null;
  };
  Mime.prototype.getExtension = function(type) {
    type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
    return type && this._extensions[type.toLowerCase()] || null;
  };
  module.exports = Mime;
});

// node_modules/mime/types/standard.js
var require_standard = __commonJS((exports, module) => {
  module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
});

// node_modules/mime/lite.js
var require_lite = __commonJS((exports, module) => {
  var Mime = require_Mime();
  module.exports = new Mime(require_standard());
});

// node_modules/exif-parser/lib/jpeg.js
var require_jpeg = __commonJS((exports, module) => {
  module.exports = {
    parseSections: function(stream2, iterator) {
      var len, markerType;
      stream2.setBigEndian(true);
      while (stream2.remainingLength() > 0 && markerType !== 218) {
        if (stream2.nextUInt8() !== 255) {
          throw new Error("Invalid JPEG section offset");
        }
        markerType = stream2.nextUInt8();
        if (markerType >= 208 && markerType <= 217 || markerType === 218) {
          len = 0;
        } else {
          len = stream2.nextUInt16() - 2;
        }
        iterator(markerType, stream2.branch(0, len));
        stream2.skip(len);
      }
    },
    getSizeFromSOFSection: function(stream2) {
      stream2.skip(1);
      return {
        height: stream2.nextUInt16(),
        width: stream2.nextUInt16()
      };
    },
    getSectionName: function(markerType) {
      var name, index;
      switch (markerType) {
        case 216:
          name = "SOI";
          break;
        case 196:
          name = "DHT";
          break;
        case 219:
          name = "DQT";
          break;
        case 221:
          name = "DRI";
          break;
        case 218:
          name = "SOS";
          break;
        case 254:
          name = "COM";
          break;
        case 217:
          name = "EOI";
          break;
        default:
          if (markerType >= 224 && markerType <= 239) {
            name = "APP";
            index = markerType - 224;
          } else if (markerType >= 192 && markerType <= 207 && markerType !== 196 && markerType !== 200 && markerType !== 204) {
            name = "SOF";
            index = markerType - 192;
          } else if (markerType >= 208 && markerType <= 215) {
            name = "RST";
            index = markerType - 208;
          }
          break;
      }
      var nameStruct = {
        name
      };
      if (typeof index === "number") {
        nameStruct.index = index;
      }
      return nameStruct;
    }
  };
});

// node_modules/exif-parser/lib/exif.js
var require_exif = __commonJS((exports, module) => {
  function readExifValue(format2, stream2) {
    switch (format2) {
      case 1:
        return stream2.nextUInt8();
      case 3:
        return stream2.nextUInt16();
      case 4:
        return stream2.nextUInt32();
      case 5:
        return [stream2.nextUInt32(), stream2.nextUInt32()];
      case 6:
        return stream2.nextInt8();
      case 8:
        return stream2.nextUInt16();
      case 9:
        return stream2.nextUInt32();
      case 10:
        return [stream2.nextInt32(), stream2.nextInt32()];
      case 11:
        return stream2.nextFloat();
      case 12:
        return stream2.nextDouble();
      default:
        throw new Error("Invalid format while decoding: " + format2);
    }
  }
  function getBytesPerComponent(format2) {
    switch (format2) {
      case 1:
      case 2:
      case 6:
      case 7:
        return 1;
      case 3:
      case 8:
        return 2;
      case 4:
      case 9:
      case 11:
        return 4;
      case 5:
      case 10:
      case 12:
        return 8;
      default:
        return 0;
    }
  }
  function readExifTag(tiffMarker, stream2) {
    var tagType = stream2.nextUInt16(), format2 = stream2.nextUInt16(), bytesPerComponent = getBytesPerComponent(format2), components = stream2.nextUInt32(), valueBytes = bytesPerComponent * components, values, value, c3;
    if (valueBytes > 4) {
      stream2 = tiffMarker.openWithOffset(stream2.nextUInt32());
    }
    if (format2 === 2) {
      values = stream2.nextString(components);
      var lastNull = values.indexOf("\x00");
      if (lastNull !== -1) {
        values = values.substr(0, lastNull);
      }
    } else if (format2 === 7) {
      values = stream2.nextBuffer(components);
    } else if (format2 !== 0) {
      values = [];
      for (c3 = 0;c3 < components; ++c3) {
        values.push(readExifValue(format2, stream2));
      }
    }
    if (valueBytes < 4) {
      stream2.skip(4 - valueBytes);
    }
    return [tagType, values, format2];
  }
  function readIFDSection(tiffMarker, stream2, iterator) {
    var numberOfEntries = stream2.nextUInt16(), tag, i2;
    for (i2 = 0;i2 < numberOfEntries; ++i2) {
      tag = readExifTag(tiffMarker, stream2);
      iterator(tag[0], tag[1], tag[2]);
    }
  }
  function readHeader(stream2) {
    var exifHeader = stream2.nextString(6);
    if (exifHeader !== "Exif\x00\x00") {
      throw new Error("Invalid EXIF header");
    }
    var tiffMarker = stream2.mark();
    var tiffHeader = stream2.nextUInt16();
    if (tiffHeader === 18761) {
      stream2.setBigEndian(false);
    } else if (tiffHeader === 19789) {
      stream2.setBigEndian(true);
    } else {
      throw new Error("Invalid TIFF header");
    }
    if (stream2.nextUInt16() !== 42) {
      throw new Error("Invalid TIFF data");
    }
    return tiffMarker;
  }
  module.exports = {
    IFD0: 1,
    IFD1: 2,
    GPSIFD: 3,
    SubIFD: 4,
    InteropIFD: 5,
    parseTags: function(stream2, iterator) {
      var tiffMarker;
      try {
        tiffMarker = readHeader(stream2);
      } catch (e) {
        return false;
      }
      var subIfdOffset, gpsOffset, interopOffset;
      var ifd0Stream = tiffMarker.openWithOffset(stream2.nextUInt32()), IFD0 = this.IFD0;
      readIFDSection(tiffMarker, ifd0Stream, function(tagType, value, format2) {
        switch (tagType) {
          case 34853:
            gpsOffset = value[0];
            break;
          case 34665:
            subIfdOffset = value[0];
            break;
          default:
            iterator(IFD0, tagType, value, format2);
            break;
        }
      });
      var ifd1Offset = ifd0Stream.nextUInt32();
      if (ifd1Offset !== 0) {
        var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);
        readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));
      }
      if (gpsOffset) {
        var gpsStream = tiffMarker.openWithOffset(gpsOffset);
        readIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));
      }
      if (subIfdOffset) {
        var subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD = this.InteropIFD;
        readIFDSection(tiffMarker, subIfdStream, function(tagType, value, format2) {
          if (tagType === 40965) {
            interopOffset = value[0];
          } else {
            iterator(InteropIFD, tagType, value, format2);
          }
        });
      }
      if (interopOffset) {
        var interopStream = tiffMarker.openWithOffset(interopOffset);
        readIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));
      }
      return true;
    }
  };
});

// node_modules/exif-parser/lib/date.js
var require_date = __commonJS((exports, module) => {
  function parseNumber2(s) {
    return parseInt(s, 10);
  }
  var hours = 3600;
  var minutes = 60;
  function parseDateTimeParts(dateParts, timeParts) {
    dateParts = dateParts.map(parseNumber2);
    timeParts = timeParts.map(parseNumber2);
    var year = dateParts[0];
    var month = dateParts[1] - 1;
    var day = dateParts[2];
    var hours2 = timeParts[0];
    var minutes2 = timeParts[1];
    var seconds = timeParts[2];
    var date = Date.UTC(year, month, day, hours2, minutes2, seconds, 0);
    var timestamp = date / 1000;
    return timestamp;
  }
  function parseDateWithTimezoneFormat(dateTimeStr) {
    var dateParts = dateTimeStr.substr(0, 10).split("-");
    var timeParts = dateTimeStr.substr(11, 8).split(":");
    var timezoneStr = dateTimeStr.substr(19, 6);
    var timezoneParts = timezoneStr.split(":").map(parseNumber2);
    var timezoneOffset = timezoneParts[0] * hours + timezoneParts[1] * minutes;
    var timestamp = parseDateTimeParts(dateParts, timeParts);
    timestamp -= timezoneOffset;
    if (typeof timestamp === "number" && !isNaN(timestamp)) {
      return timestamp;
    }
  }
  function parseDateWithSpecFormat(dateTimeStr) {
    var parts = dateTimeStr.split(" "), dateParts = parts[0].split(":"), timeParts = parts[1].split(":");
    var timestamp = parseDateTimeParts(dateParts, timeParts);
    if (typeof timestamp === "number" && !isNaN(timestamp)) {
      return timestamp;
    }
  }
  function parseExifDate(dateTimeStr) {
    var isSpecFormat = dateTimeStr.length === 19 && dateTimeStr.charAt(4) === ":";
    var isTimezoneFormat = dateTimeStr.length === 25 && dateTimeStr.charAt(10) === "T";
    var timestamp;
    if (isTimezoneFormat) {
      return parseDateWithTimezoneFormat(dateTimeStr);
    } else if (isSpecFormat) {
      return parseDateWithSpecFormat(dateTimeStr);
    }
  }
  module.exports = {
    parseDateWithSpecFormat,
    parseDateWithTimezoneFormat,
    parseExifDate
  };
});

// node_modules/exif-parser/lib/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var exif = require_exif();
  var date = require_date();
  var degreeTags = [
    {
      section: exif.GPSIFD,
      type: 2,
      name: "GPSLatitude",
      refType: 1,
      refName: "GPSLatitudeRef",
      posVal: "N"
    },
    {
      section: exif.GPSIFD,
      type: 4,
      name: "GPSLongitude",
      refType: 3,
      refName: "GPSLongitudeRef",
      posVal: "E"
    }
  ];
  var dateTags = [
    {
      section: exif.SubIFD,
      type: 306,
      name: "ModifyDate"
    },
    {
      section: exif.SubIFD,
      type: 36867,
      name: "DateTimeOriginal"
    },
    {
      section: exif.SubIFD,
      type: 36868,
      name: "CreateDate"
    },
    {
      section: exif.SubIFD,
      type: 306,
      name: "ModifyDate"
    }
  ];
  module.exports = {
    castDegreeValues: function(getTagValue, setTagValue) {
      degreeTags.forEach(function(t) {
        var degreeVal = getTagValue(t);
        if (degreeVal) {
          var degreeRef = getTagValue({ section: t.section, type: t.refType, name: t.refName });
          var degreeNumRef = degreeRef === t.posVal ? 1 : -1;
          var degree = (degreeVal[0] + degreeVal[1] / 60 + degreeVal[2] / 3600) * degreeNumRef;
          setTagValue(t, degree);
        }
      });
    },
    castDateValues: function(getTagValue, setTagValue) {
      dateTags.forEach(function(t) {
        var dateStrVal = getTagValue(t);
        if (dateStrVal) {
          var timestamp = date.parseExifDate(dateStrVal);
          if (typeof timestamp !== "undefined") {
            setTagValue(t, timestamp);
          }
        }
      });
    },
    simplifyValue: function(values, format2) {
      if (Array.isArray(values)) {
        values = values.map(function(value) {
          if (format2 === 10 || format2 === 5) {
            return value[0] / value[1];
          }
          return value;
        });
        if (values.length === 1) {
          values = values[0];
        }
      }
      return values;
    }
  };
});

// node_modules/exif-parser/lib/exif-tags.js
var require_exif_tags = __commonJS((exports, module) => {
  module.exports = {
    exif: {
      1: "InteropIndex",
      2: "InteropVersion",
      11: "ProcessingSoftware",
      254: "SubfileType",
      255: "OldSubfileType",
      256: "ImageWidth",
      257: "ImageHeight",
      258: "BitsPerSample",
      259: "Compression",
      262: "PhotometricInterpretation",
      263: "Thresholding",
      264: "CellWidth",
      265: "CellLength",
      266: "FillOrder",
      269: "DocumentName",
      270: "ImageDescription",
      271: "Make",
      272: "Model",
      273: "StripOffsets",
      274: "Orientation",
      277: "SamplesPerPixel",
      278: "RowsPerStrip",
      279: "StripByteCounts",
      280: "MinSampleValue",
      281: "MaxSampleValue",
      282: "XResolution",
      283: "YResolution",
      284: "PlanarConfiguration",
      285: "PageName",
      286: "XPosition",
      287: "YPosition",
      288: "FreeOffsets",
      289: "FreeByteCounts",
      290: "GrayResponseUnit",
      291: "GrayResponseCurve",
      292: "T4Options",
      293: "T6Options",
      296: "ResolutionUnit",
      297: "PageNumber",
      300: "ColorResponseUnit",
      301: "TransferFunction",
      305: "Software",
      306: "ModifyDate",
      315: "Artist",
      316: "HostComputer",
      317: "Predictor",
      318: "WhitePoint",
      319: "PrimaryChromaticities",
      320: "ColorMap",
      321: "HalftoneHints",
      322: "TileWidth",
      323: "TileLength",
      324: "TileOffsets",
      325: "TileByteCounts",
      326: "BadFaxLines",
      327: "CleanFaxData",
      328: "ConsecutiveBadFaxLines",
      330: "SubIFD",
      332: "InkSet",
      333: "InkNames",
      334: "NumberofInks",
      336: "DotRange",
      337: "TargetPrinter",
      338: "ExtraSamples",
      339: "SampleFormat",
      340: "SMinSampleValue",
      341: "SMaxSampleValue",
      342: "TransferRange",
      343: "ClipPath",
      344: "XClipPathUnits",
      345: "YClipPathUnits",
      346: "Indexed",
      347: "JPEGTables",
      351: "OPIProxy",
      400: "GlobalParametersIFD",
      401: "ProfileType",
      402: "FaxProfile",
      403: "CodingMethods",
      404: "VersionYear",
      405: "ModeNumber",
      433: "Decode",
      434: "DefaultImageColor",
      435: "T82Options",
      437: "JPEGTables",
      512: "JPEGProc",
      513: "ThumbnailOffset",
      514: "ThumbnailLength",
      515: "JPEGRestartInterval",
      517: "JPEGLosslessPredictors",
      518: "JPEGPointTransforms",
      519: "JPEGQTables",
      520: "JPEGDCTables",
      521: "JPEGACTables",
      529: "YCbCrCoefficients",
      530: "YCbCrSubSampling",
      531: "YCbCrPositioning",
      532: "ReferenceBlackWhite",
      559: "StripRowCounts",
      700: "ApplicationNotes",
      999: "USPTOMiscellaneous",
      4096: "RelatedImageFileFormat",
      4097: "RelatedImageWidth",
      4098: "RelatedImageHeight",
      18246: "Rating",
      18247: "XP_DIP_XML",
      18248: "StitchInfo",
      18249: "RatingPercent",
      32781: "ImageID",
      32931: "WangTag1",
      32932: "WangAnnotation",
      32933: "WangTag3",
      32934: "WangTag4",
      32995: "Matteing",
      32996: "DataType",
      32997: "ImageDepth",
      32998: "TileDepth",
      33405: "Model2",
      33421: "CFARepeatPatternDim",
      33422: "CFAPattern2",
      33423: "BatteryLevel",
      33424: "KodakIFD",
      33432: "Copyright",
      33434: "ExposureTime",
      33437: "FNumber",
      33445: "MDFileTag",
      33446: "MDScalePixel",
      33447: "MDColorTable",
      33448: "MDLabName",
      33449: "MDSampleInfo",
      33450: "MDPrepDate",
      33451: "MDPrepTime",
      33452: "MDFileUnits",
      33550: "PixelScale",
      33589: "AdventScale",
      33590: "AdventRevision",
      33628: "UIC1Tag",
      33629: "UIC2Tag",
      33630: "UIC3Tag",
      33631: "UIC4Tag",
      33723: "IPTC-NAA",
      33918: "IntergraphPacketData",
      33919: "IntergraphFlagRegisters",
      33920: "IntergraphMatrix",
      33921: "INGRReserved",
      33922: "ModelTiePoint",
      34016: "Site",
      34017: "ColorSequence",
      34018: "IT8Header",
      34019: "RasterPadding",
      34020: "BitsPerRunLength",
      34021: "BitsPerExtendedRunLength",
      34022: "ColorTable",
      34023: "ImageColorIndicator",
      34024: "BackgroundColorIndicator",
      34025: "ImageColorValue",
      34026: "BackgroundColorValue",
      34027: "PixelIntensityRange",
      34028: "TransparencyIndicator",
      34029: "ColorCharacterization",
      34030: "HCUsage",
      34031: "TrapIndicator",
      34032: "CMYKEquivalent",
      34118: "SEMInfo",
      34152: "AFCP_IPTC",
      34232: "PixelMagicJBIGOptions",
      34264: "ModelTransform",
      34306: "WB_GRGBLevels",
      34310: "LeafData",
      34377: "PhotoshopSettings",
      34665: "ExifOffset",
      34675: "ICC_Profile",
      34687: "TIFF_FXExtensions",
      34688: "MultiProfiles",
      34689: "SharedData",
      34690: "T88Options",
      34732: "ImageLayer",
      34735: "GeoTiffDirectory",
      34736: "GeoTiffDoubleParams",
      34737: "GeoTiffAsciiParams",
      34850: "ExposureProgram",
      34852: "SpectralSensitivity",
      34853: "GPSInfo",
      34855: "ISO",
      34856: "Opto-ElectricConvFactor",
      34857: "Interlace",
      34858: "TimeZoneOffset",
      34859: "SelfTimerMode",
      34864: "SensitivityType",
      34865: "StandardOutputSensitivity",
      34866: "RecommendedExposureIndex",
      34867: "ISOSpeed",
      34868: "ISOSpeedLatitudeyyy",
      34869: "ISOSpeedLatitudezzz",
      34908: "FaxRecvParams",
      34909: "FaxSubAddress",
      34910: "FaxRecvTime",
      34954: "LeafSubIFD",
      36864: "ExifVersion",
      36867: "DateTimeOriginal",
      36868: "CreateDate",
      37121: "ComponentsConfiguration",
      37122: "CompressedBitsPerPixel",
      37377: "ShutterSpeedValue",
      37378: "ApertureValue",
      37379: "BrightnessValue",
      37380: "ExposureCompensation",
      37381: "MaxApertureValue",
      37382: "SubjectDistance",
      37383: "MeteringMode",
      37384: "LightSource",
      37385: "Flash",
      37386: "FocalLength",
      37387: "FlashEnergy",
      37388: "SpatialFrequencyResponse",
      37389: "Noise",
      37390: "FocalPlaneXResolution",
      37391: "FocalPlaneYResolution",
      37392: "FocalPlaneResolutionUnit",
      37393: "ImageNumber",
      37394: "SecurityClassification",
      37395: "ImageHistory",
      37396: "SubjectArea",
      37397: "ExposureIndex",
      37398: "TIFF-EPStandardID",
      37399: "SensingMethod",
      37434: "CIP3DataFile",
      37435: "CIP3Sheet",
      37436: "CIP3Side",
      37439: "StoNits",
      37500: "MakerNote",
      37510: "UserComment",
      37520: "SubSecTime",
      37521: "SubSecTimeOriginal",
      37522: "SubSecTimeDigitized",
      37679: "MSDocumentText",
      37680: "MSPropertySetStorage",
      37681: "MSDocumentTextPosition",
      37724: "ImageSourceData",
      40091: "XPTitle",
      40092: "XPComment",
      40093: "XPAuthor",
      40094: "XPKeywords",
      40095: "XPSubject",
      40960: "FlashpixVersion",
      40961: "ColorSpace",
      40962: "ExifImageWidth",
      40963: "ExifImageHeight",
      40964: "RelatedSoundFile",
      40965: "InteropOffset",
      41483: "FlashEnergy",
      41484: "SpatialFrequencyResponse",
      41485: "Noise",
      41486: "FocalPlaneXResolution",
      41487: "FocalPlaneYResolution",
      41488: "FocalPlaneResolutionUnit",
      41489: "ImageNumber",
      41490: "SecurityClassification",
      41491: "ImageHistory",
      41492: "SubjectLocation",
      41493: "ExposureIndex",
      41494: "TIFF-EPStandardID",
      41495: "SensingMethod",
      41728: "FileSource",
      41729: "SceneType",
      41730: "CFAPattern",
      41985: "CustomRendered",
      41986: "ExposureMode",
      41987: "WhiteBalance",
      41988: "DigitalZoomRatio",
      41989: "FocalLengthIn35mmFormat",
      41990: "SceneCaptureType",
      41991: "GainControl",
      41992: "Contrast",
      41993: "Saturation",
      41994: "Sharpness",
      41995: "DeviceSettingDescription",
      41996: "SubjectDistanceRange",
      42016: "ImageUniqueID",
      42032: "OwnerName",
      42033: "SerialNumber",
      42034: "LensInfo",
      42035: "LensMake",
      42036: "LensModel",
      42037: "LensSerialNumber",
      42112: "GDALMetadata",
      42113: "GDALNoData",
      42240: "Gamma",
      44992: "ExpandSoftware",
      44993: "ExpandLens",
      44994: "ExpandFilm",
      44995: "ExpandFilterLens",
      44996: "ExpandScanner",
      44997: "ExpandFlashLamp",
      48129: "PixelFormat",
      48130: "Transformation",
      48131: "Uncompressed",
      48132: "ImageType",
      48256: "ImageWidth",
      48257: "ImageHeight",
      48258: "WidthResolution",
      48259: "HeightResolution",
      48320: "ImageOffset",
      48321: "ImageByteCount",
      48322: "AlphaOffset",
      48323: "AlphaByteCount",
      48324: "ImageDataDiscard",
      48325: "AlphaDataDiscard",
      50215: "OceScanjobDesc",
      50216: "OceApplicationSelector",
      50217: "OceIDNumber",
      50218: "OceImageLogic",
      50255: "Annotations",
      50341: "PrintIM",
      50560: "USPTOOriginalContentType",
      50706: "DNGVersion",
      50707: "DNGBackwardVersion",
      50708: "UniqueCameraModel",
      50709: "LocalizedCameraModel",
      50710: "CFAPlaneColor",
      50711: "CFALayout",
      50712: "LinearizationTable",
      50713: "BlackLevelRepeatDim",
      50714: "BlackLevel",
      50715: "BlackLevelDeltaH",
      50716: "BlackLevelDeltaV",
      50717: "WhiteLevel",
      50718: "DefaultScale",
      50719: "DefaultCropOrigin",
      50720: "DefaultCropSize",
      50721: "ColorMatrix1",
      50722: "ColorMatrix2",
      50723: "CameraCalibration1",
      50724: "CameraCalibration2",
      50725: "ReductionMatrix1",
      50726: "ReductionMatrix2",
      50727: "AnalogBalance",
      50728: "AsShotNeutral",
      50729: "AsShotWhiteXY",
      50730: "BaselineExposure",
      50731: "BaselineNoise",
      50732: "BaselineSharpness",
      50733: "BayerGreenSplit",
      50734: "LinearResponseLimit",
      50735: "CameraSerialNumber",
      50736: "DNGLensInfo",
      50737: "ChromaBlurRadius",
      50738: "AntiAliasStrength",
      50739: "ShadowScale",
      50740: "DNGPrivateData",
      50741: "MakerNoteSafety",
      50752: "RawImageSegmentation",
      50778: "CalibrationIlluminant1",
      50779: "CalibrationIlluminant2",
      50780: "BestQualityScale",
      50781: "RawDataUniqueID",
      50784: "AliasLayerMetadata",
      50827: "OriginalRawFileName",
      50828: "OriginalRawFileData",
      50829: "ActiveArea",
      50830: "MaskedAreas",
      50831: "AsShotICCProfile",
      50832: "AsShotPreProfileMatrix",
      50833: "CurrentICCProfile",
      50834: "CurrentPreProfileMatrix",
      50879: "ColorimetricReference",
      50898: "PanasonicTitle",
      50899: "PanasonicTitle2",
      50931: "CameraCalibrationSig",
      50932: "ProfileCalibrationSig",
      50933: "ProfileIFD",
      50934: "AsShotProfileName",
      50935: "NoiseReductionApplied",
      50936: "ProfileName",
      50937: "ProfileHueSatMapDims",
      50938: "ProfileHueSatMapData1",
      50939: "ProfileHueSatMapData2",
      50940: "ProfileToneCurve",
      50941: "ProfileEmbedPolicy",
      50942: "ProfileCopyright",
      50964: "ForwardMatrix1",
      50965: "ForwardMatrix2",
      50966: "PreviewApplicationName",
      50967: "PreviewApplicationVersion",
      50968: "PreviewSettingsName",
      50969: "PreviewSettingsDigest",
      50970: "PreviewColorSpace",
      50971: "PreviewDateTime",
      50972: "RawImageDigest",
      50973: "OriginalRawFileDigest",
      50974: "SubTileBlockSize",
      50975: "RowInterleaveFactor",
      50981: "ProfileLookTableDims",
      50982: "ProfileLookTableData",
      51008: "OpcodeList1",
      51009: "OpcodeList2",
      51022: "OpcodeList3",
      51041: "NoiseProfile",
      51043: "TimeCodes",
      51044: "FrameRate",
      51058: "TStop",
      51081: "ReelName",
      51089: "OriginalDefaultFinalSize",
      51090: "OriginalBestQualitySize",
      51091: "OriginalDefaultCropSize",
      51105: "CameraLabel",
      51107: "ProfileHueSatMapEncoding",
      51108: "ProfileLookTableEncoding",
      51109: "BaselineExposureOffset",
      51110: "DefaultBlackRender",
      51111: "NewRawImageDigest",
      51112: "RawToPreviewGain",
      51125: "DefaultUserCrop",
      59932: "Padding",
      59933: "OffsetSchema",
      65000: "OwnerName",
      65001: "SerialNumber",
      65002: "Lens",
      65024: "KDC_IFD",
      65100: "RawFile",
      65101: "Converter",
      65102: "WhiteBalance",
      65105: "Exposure",
      65106: "Shadows",
      65107: "Brightness",
      65108: "Contrast",
      65109: "Saturation",
      65110: "Sharpness",
      65111: "Smoothness",
      65112: "MoireFilter"
    },
    gps: {
      0: "GPSVersionID",
      1: "GPSLatitudeRef",
      2: "GPSLatitude",
      3: "GPSLongitudeRef",
      4: "GPSLongitude",
      5: "GPSAltitudeRef",
      6: "GPSAltitude",
      7: "GPSTimeStamp",
      8: "GPSSatellites",
      9: "GPSStatus",
      10: "GPSMeasureMode",
      11: "GPSDOP",
      12: "GPSSpeedRef",
      13: "GPSSpeed",
      14: "GPSTrackRef",
      15: "GPSTrack",
      16: "GPSImgDirectionRef",
      17: "GPSImgDirection",
      18: "GPSMapDatum",
      19: "GPSDestLatitudeRef",
      20: "GPSDestLatitude",
      21: "GPSDestLongitudeRef",
      22: "GPSDestLongitude",
      23: "GPSDestBearingRef",
      24: "GPSDestBearing",
      25: "GPSDestDistanceRef",
      26: "GPSDestDistance",
      27: "GPSProcessingMethod",
      28: "GPSAreaInformation",
      29: "GPSDateStamp",
      30: "GPSDifferential",
      31: "GPSHPositioningError"
    }
  };
});

// node_modules/exif-parser/lib/parser.js
var require_parser2 = __commonJS((exports, module) => {
  var jpeg2 = require_jpeg();
  var exif = require_exif();
  var simplify = require_simplify();
  function ExifResult(startMarker, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset) {
    this.startMarker = startMarker;
    this.tags = tags;
    this.imageSize = imageSize;
    this.thumbnailOffset = thumbnailOffset;
    this.thumbnailLength = thumbnailLength;
    this.thumbnailType = thumbnailType;
    this.app1Offset = app1Offset;
  }
  ExifResult.prototype = {
    hasThumbnail: function(mime) {
      if (!this.thumbnailOffset || !this.thumbnailLength) {
        return false;
      }
      if (typeof mime !== "string") {
        return true;
      }
      if (mime.toLowerCase().trim() === "image/jpeg") {
        return this.thumbnailType === 6;
      }
      if (mime.toLowerCase().trim() === "image/tiff") {
        return this.thumbnailType === 1;
      }
      return false;
    },
    getThumbnailOffset: function() {
      return this.app1Offset + 6 + this.thumbnailOffset;
    },
    getThumbnailLength: function() {
      return this.thumbnailLength;
    },
    getThumbnailBuffer: function() {
      return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
    },
    _getThumbnailStream: function() {
      return this.startMarker.openWithOffset(this.getThumbnailOffset());
    },
    getImageSize: function() {
      return this.imageSize;
    },
    getThumbnailSize: function() {
      var stream2 = this._getThumbnailStream(), size;
      jpeg2.parseSections(stream2, function(sectionType, sectionStream) {
        if (jpeg2.getSectionName(sectionType).name === "SOF") {
          size = jpeg2.getSizeFromSOFSection(sectionStream);
        }
      });
      return size;
    }
  };
  function Parser(stream2) {
    this.stream = stream2;
    this.flags = {
      readBinaryTags: false,
      resolveTagNames: true,
      simplifyValues: true,
      imageSize: true,
      hidePointers: true,
      returnTags: true
    };
  }
  Parser.prototype = {
    enableBinaryFields: function(enable) {
      this.flags.readBinaryTags = !!enable;
      return this;
    },
    enablePointers: function(enable) {
      this.flags.hidePointers = !enable;
      return this;
    },
    enableTagNames: function(enable) {
      this.flags.resolveTagNames = !!enable;
      return this;
    },
    enableImageSize: function(enable) {
      this.flags.imageSize = !!enable;
      return this;
    },
    enableReturnTags: function(enable) {
      this.flags.returnTags = !!enable;
      return this;
    },
    enableSimpleValues: function(enable) {
      this.flags.simplifyValues = !!enable;
      return this;
    },
    parse: function() {
      var start = this.stream.mark(), stream2 = start.openWithOffset(0), flags = this.flags, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset, tagNames, getTagValue, setTagValue;
      if (flags.resolveTagNames) {
        tagNames = require_exif_tags();
      }
      if (flags.resolveTagNames) {
        tags = {};
        getTagValue = function(t) {
          return tags[t.name];
        };
        setTagValue = function(t, value) {
          tags[t.name] = value;
        };
      } else {
        tags = [];
        getTagValue = function(t) {
          var i2;
          for (i2 = 0;i2 < tags.length; ++i2) {
            if (tags[i2].type === t.type && tags[i2].section === t.section) {
              return tags.value;
            }
          }
        };
        setTagValue = function(t, value) {
          var i2;
          for (i2 = 0;i2 < tags.length; ++i2) {
            if (tags[i2].type === t.type && tags[i2].section === t.section) {
              tags.value = value;
              return;
            }
          }
        };
      }
      jpeg2.parseSections(stream2, function(sectionType, sectionStream) {
        var validExifHeaders, sectionOffset = sectionStream.offsetFrom(start);
        if (sectionType === 225) {
          validExifHeaders = exif.parseTags(sectionStream, function(ifdSection, tagType, value, format2) {
            if (!flags.readBinaryTags && format2 === 7) {
              return;
            }
            if (tagType === 513) {
              thumbnailOffset = value[0];
              if (flags.hidePointers) {
                return;
              }
            } else if (tagType === 514) {
              thumbnailLength = value[0];
              if (flags.hidePointers) {
                return;
              }
            } else if (tagType === 259) {
              thumbnailType = value[0];
              if (flags.hidePointers) {
                return;
              }
            }
            if (!flags.returnTags) {
              return;
            }
            if (flags.simplifyValues) {
              value = simplify.simplifyValue(value, format2);
            }
            if (flags.resolveTagNames) {
              var sectionTagNames = ifdSection === exif.GPSIFD ? tagNames.gps : tagNames.exif;
              var name = sectionTagNames[tagType];
              if (!name) {
                name = tagNames.exif[tagType];
              }
              if (!tags.hasOwnProperty(name)) {
                tags[name] = value;
              }
            } else {
              tags.push({
                section: ifdSection,
                type: tagType,
                value
              });
            }
          });
          if (validExifHeaders) {
            app1Offset = sectionOffset;
          }
        } else if (flags.imageSize && jpeg2.getSectionName(sectionType).name === "SOF") {
          imageSize = jpeg2.getSizeFromSOFSection(sectionStream);
        }
      });
      if (flags.simplifyValues) {
        simplify.castDegreeValues(getTagValue, setTagValue);
        simplify.castDateValues(getTagValue, setTagValue);
      }
      return new ExifResult(start, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset);
    }
  };
  module.exports = Parser;
});

// node_modules/exif-parser/lib/dom-bufferstream.js
var require_dom_bufferstream = __commonJS((exports, module) => {
  function DOMBufferStream(arrayBuffer, offset, length, bigEndian, global3, parentOffset) {
    this.global = global3;
    offset = offset || 0;
    length = length || arrayBuffer.byteLength - offset;
    this.arrayBuffer = arrayBuffer.slice(offset, offset + length);
    this.view = new global3.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength);
    this.setBigEndian(bigEndian);
    this.offset = 0;
    this.parentOffset = (parentOffset || 0) + offset;
  }
  DOMBufferStream.prototype = {
    setBigEndian: function(bigEndian) {
      this.littleEndian = !bigEndian;
    },
    nextUInt8: function() {
      var value = this.view.getUint8(this.offset);
      this.offset += 1;
      return value;
    },
    nextInt8: function() {
      var value = this.view.getInt8(this.offset);
      this.offset += 1;
      return value;
    },
    nextUInt16: function() {
      var value = this.view.getUint16(this.offset, this.littleEndian);
      this.offset += 2;
      return value;
    },
    nextUInt32: function() {
      var value = this.view.getUint32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    },
    nextInt16: function() {
      var value = this.view.getInt16(this.offset, this.littleEndian);
      this.offset += 2;
      return value;
    },
    nextInt32: function() {
      var value = this.view.getInt32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    },
    nextFloat: function() {
      var value = this.view.getFloat32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    },
    nextDouble: function() {
      var value = this.view.getFloat64(this.offset, this.littleEndian);
      this.offset += 8;
      return value;
    },
    nextBuffer: function(length) {
      var value = this.arrayBuffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return value;
    },
    remainingLength: function() {
      return this.arrayBuffer.byteLength - this.offset;
    },
    nextString: function(length) {
      var value = this.arrayBuffer.slice(this.offset, this.offset + length);
      value = String.fromCharCode.apply(null, new this.global.Uint8Array(value));
      this.offset += length;
      return value;
    },
    mark: function() {
      var self2 = this;
      return {
        openWithOffset: function(offset) {
          offset = (offset || 0) + this.offset;
          return new DOMBufferStream(self2.arrayBuffer, offset, self2.arrayBuffer.byteLength - offset, !self2.littleEndian, self2.global, self2.parentOffset);
        },
        offset: this.offset,
        getParentOffset: function() {
          return self2.parentOffset;
        }
      };
    },
    offsetFrom: function(marker) {
      return this.parentOffset + this.offset - (marker.offset + marker.getParentOffset());
    },
    skip: function(amount) {
      this.offset += amount;
    },
    branch: function(offset, length) {
      length = typeof length === "number" ? length : this.arrayBuffer.byteLength - (this.offset + offset);
      return new DOMBufferStream(this.arrayBuffer, this.offset + offset, length, !this.littleEndian, this.global, this.parentOffset);
    }
  };
  module.exports = DOMBufferStream;
});

// node_modules/exif-parser/lib/bufferstream.js
var require_bufferstream = __commonJS((exports, module) => {
  function BufferStream(buffer, offset, length, bigEndian) {
    this.buffer = buffer;
    this.offset = offset || 0;
    length = typeof length === "number" ? length : buffer.length;
    this.endPosition = this.offset + length;
    this.setBigEndian(bigEndian);
  }
  BufferStream.prototype = {
    setBigEndian: function(bigEndian) {
      this.bigEndian = !!bigEndian;
    },
    nextUInt8: function() {
      var value = this.buffer.readUInt8(this.offset);
      this.offset += 1;
      return value;
    },
    nextInt8: function() {
      var value = this.buffer.readInt8(this.offset);
      this.offset += 1;
      return value;
    },
    nextUInt16: function() {
      var value = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
      this.offset += 2;
      return value;
    },
    nextUInt32: function() {
      var value = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
      this.offset += 4;
      return value;
    },
    nextInt16: function() {
      var value = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
      this.offset += 2;
      return value;
    },
    nextInt32: function() {
      var value = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
      this.offset += 4;
      return value;
    },
    nextFloat: function() {
      var value = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
      this.offset += 4;
      return value;
    },
    nextDouble: function() {
      var value = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
      this.offset += 8;
      return value;
    },
    nextBuffer: function(length) {
      var value = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return value;
    },
    remainingLength: function() {
      return this.endPosition - this.offset;
    },
    nextString: function(length) {
      var value = this.buffer.toString("utf8", this.offset, this.offset + length);
      this.offset += length;
      return value;
    },
    mark: function() {
      var self2 = this;
      return {
        openWithOffset: function(offset) {
          offset = (offset || 0) + this.offset;
          return new BufferStream(self2.buffer, offset, self2.endPosition - offset, self2.bigEndian);
        },
        offset: this.offset
      };
    },
    offsetFrom: function(marker) {
      return this.offset - marker.offset;
    },
    skip: function(amount) {
      this.offset += amount;
    },
    branch: function(offset, length) {
      length = typeof length === "number" ? length : this.endPosition - (this.offset + offset);
      return new BufferStream(this.buffer, this.offset + offset, length, this.bigEndian);
    }
  };
  module.exports = BufferStream;
});

// node_modules/exif-parser/index.js
var require_exif_parser = __commonJS((exports, module) => {
  var Parser = require_parser2();
  function getGlobal() {
    return (1, eval)("this");
  }
  module.exports = {
    create: function(buffer, global3) {
      global3 = global3 || getGlobal();
      if (buffer instanceof global3.ArrayBuffer) {
        var DOMBufferStream = require_dom_bufferstream();
        return new Parser(new DOMBufferStream(buffer, 0, buffer.byteLength, true, global3));
      } else {
        var NodeBufferStream = require_bufferstream();
        return new Parser(new NodeBufferStream(buffer, 0, buffer.length, true));
      }
    }
  };
});

// node_modules/any-base/src/converter.js
var require_converter2 = __commonJS((exports, module) => {
  function Converter(srcAlphabet, dstAlphabet) {
    if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
      throw new Error("Bad alphabet");
    }
    this.srcAlphabet = srcAlphabet;
    this.dstAlphabet = dstAlphabet;
  }
  Converter.prototype.convert = function(number) {
    var i2, divide, newlen, numberMap = {}, fromBase = this.srcAlphabet.length, toBase = this.dstAlphabet.length, length = number.length, result = typeof number === "string" ? "" : [];
    if (!this.isValid(number)) {
      throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
    }
    if (this.srcAlphabet === this.dstAlphabet) {
      return number;
    }
    for (i2 = 0;i2 < length; i2++) {
      numberMap[i2] = this.srcAlphabet.indexOf(number[i2]);
    }
    do {
      divide = 0;
      newlen = 0;
      for (i2 = 0;i2 < length; i2++) {
        divide = divide * fromBase + numberMap[i2];
        if (divide >= toBase) {
          numberMap[newlen++] = parseInt(divide / toBase, 10);
          divide = divide % toBase;
        } else if (newlen > 0) {
          numberMap[newlen++] = 0;
        }
      }
      length = newlen;
      result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
    } while (newlen !== 0);
    return result;
  };
  Converter.prototype.isValid = function(number) {
    var i2 = 0;
    for (;i2 < number.length; ++i2) {
      if (this.srcAlphabet.indexOf(number[i2]) === -1) {
        return false;
      }
    }
    return true;
  };
  module.exports = Converter;
});

// node_modules/any-base/index.js
var require_any_base = __commonJS((exports, module) => {
  var Converter = require_converter2();
  function anyBase(srcAlphabet, dstAlphabet) {
    var converter = new Converter(srcAlphabet, dstAlphabet);
    return function(number) {
      return converter.convert(number);
    };
  }
  anyBase.BIN = "01";
  anyBase.OCT = "01234567";
  anyBase.DEC = "0123456789";
  anyBase.HEX = "0123456789abcdef";
  module.exports = anyBase;
});

// node_modules/jsqr/dist/jsQR.js
var require_jsQR = __commonJS((exports, module) => {
  (function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === "object" && typeof module === "object")
      module.exports = factory();
    else if (typeof define === "function" && define.amd)
      define([], factory);
    else if (typeof exports === "object")
      exports["jsQR"] = factory();
    else
      root["jsQR"] = factory();
  })(typeof self !== "undefined" ? self : exports, function() {
    return function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, {
            configurable: false,
            enumerable: true,
            get: getter
          });
        }
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? function getDefault() {
          return module2["default"];
        } : function getModuleExports() {
          return module2;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = 3);
    }([
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var BitMatrix = function() {
          function BitMatrix2(data, width) {
            this.width = width;
            this.height = data.length / width;
            this.data = data;
          }
          BitMatrix2.createEmpty = function(width, height) {
            return new BitMatrix2(new Uint8ClampedArray(width * height), width);
          };
          BitMatrix2.prototype.get = function(x2, y2) {
            if (x2 < 0 || x2 >= this.width || y2 < 0 || y2 >= this.height) {
              return false;
            }
            return !!this.data[y2 * this.width + x2];
          };
          BitMatrix2.prototype.set = function(x2, y2, v) {
            this.data[y2 * this.width + x2] = v ? 1 : 0;
          };
          BitMatrix2.prototype.setRegion = function(left, top, width, height, v) {
            for (var y2 = top;y2 < top + height; y2++) {
              for (var x2 = left;x2 < left + width; x2++) {
                this.set(x2, y2, !!v);
              }
            }
          };
          return BitMatrix2;
        }();
        exports2.BitMatrix = BitMatrix;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var GenericGFPoly_1 = __webpack_require__(2);
        function addOrSubtractGF(a2, b) {
          return a2 ^ b;
        }
        exports2.addOrSubtractGF = addOrSubtractGF;
        var GenericGF = function() {
          function GenericGF2(primitive, size, genBase) {
            this.primitive = primitive;
            this.size = size;
            this.generatorBase = genBase;
            this.expTable = new Array(this.size);
            this.logTable = new Array(this.size);
            var x2 = 1;
            for (var i2 = 0;i2 < this.size; i2++) {
              this.expTable[i2] = x2;
              x2 = x2 * 2;
              if (x2 >= this.size) {
                x2 = (x2 ^ this.primitive) & this.size - 1;
              }
            }
            for (var i2 = 0;i2 < this.size - 1; i2++) {
              this.logTable[this.expTable[i2]] = i2;
            }
            this.zero = new GenericGFPoly_1.default(this, Uint8ClampedArray.from([0]));
            this.one = new GenericGFPoly_1.default(this, Uint8ClampedArray.from([1]));
          }
          GenericGF2.prototype.multiply = function(a2, b) {
            if (a2 === 0 || b === 0) {
              return 0;
            }
            return this.expTable[(this.logTable[a2] + this.logTable[b]) % (this.size - 1)];
          };
          GenericGF2.prototype.inverse = function(a2) {
            if (a2 === 0) {
              throw new Error("Can't invert 0");
            }
            return this.expTable[this.size - this.logTable[a2] - 1];
          };
          GenericGF2.prototype.buildMonomial = function(degree, coefficient) {
            if (degree < 0) {
              throw new Error("Invalid monomial degree less than 0");
            }
            if (coefficient === 0) {
              return this.zero;
            }
            var coefficients = new Uint8ClampedArray(degree + 1);
            coefficients[0] = coefficient;
            return new GenericGFPoly_1.default(this, coefficients);
          };
          GenericGF2.prototype.log = function(a2) {
            if (a2 === 0) {
              throw new Error("Can't take log(0)");
            }
            return this.logTable[a2];
          };
          GenericGF2.prototype.exp = function(a2) {
            return this.expTable[a2];
          };
          return GenericGF2;
        }();
        exports2.default = GenericGF;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var GenericGF_1 = __webpack_require__(1);
        var GenericGFPoly = function() {
          function GenericGFPoly2(field, coefficients) {
            if (coefficients.length === 0) {
              throw new Error("No coefficients.");
            }
            this.field = field;
            var coefficientsLength = coefficients.length;
            if (coefficientsLength > 1 && coefficients[0] === 0) {
              var firstNonZero = 1;
              while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
                firstNonZero++;
              }
              if (firstNonZero === coefficientsLength) {
                this.coefficients = field.zero.coefficients;
              } else {
                this.coefficients = new Uint8ClampedArray(coefficientsLength - firstNonZero);
                for (var i2 = 0;i2 < this.coefficients.length; i2++) {
                  this.coefficients[i2] = coefficients[firstNonZero + i2];
                }
              }
            } else {
              this.coefficients = coefficients;
            }
          }
          GenericGFPoly2.prototype.degree = function() {
            return this.coefficients.length - 1;
          };
          GenericGFPoly2.prototype.isZero = function() {
            return this.coefficients[0] === 0;
          };
          GenericGFPoly2.prototype.getCoefficient = function(degree) {
            return this.coefficients[this.coefficients.length - 1 - degree];
          };
          GenericGFPoly2.prototype.addOrSubtract = function(other) {
            var _a;
            if (this.isZero()) {
              return other;
            }
            if (other.isZero()) {
              return this;
            }
            var smallerCoefficients = this.coefficients;
            var largerCoefficients = other.coefficients;
            if (smallerCoefficients.length > largerCoefficients.length) {
              _a = [largerCoefficients, smallerCoefficients], smallerCoefficients = _a[0], largerCoefficients = _a[1];
            }
            var sumDiff = new Uint8ClampedArray(largerCoefficients.length);
            var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
            for (var i2 = 0;i2 < lengthDiff; i2++) {
              sumDiff[i2] = largerCoefficients[i2];
            }
            for (var i2 = lengthDiff;i2 < largerCoefficients.length; i2++) {
              sumDiff[i2] = GenericGF_1.addOrSubtractGF(smallerCoefficients[i2 - lengthDiff], largerCoefficients[i2]);
            }
            return new GenericGFPoly2(this.field, sumDiff);
          };
          GenericGFPoly2.prototype.multiply = function(scalar) {
            if (scalar === 0) {
              return this.field.zero;
            }
            if (scalar === 1) {
              return this;
            }
            var size = this.coefficients.length;
            var product = new Uint8ClampedArray(size);
            for (var i2 = 0;i2 < size; i2++) {
              product[i2] = this.field.multiply(this.coefficients[i2], scalar);
            }
            return new GenericGFPoly2(this.field, product);
          };
          GenericGFPoly2.prototype.multiplyPoly = function(other) {
            if (this.isZero() || other.isZero()) {
              return this.field.zero;
            }
            var aCoefficients = this.coefficients;
            var aLength = aCoefficients.length;
            var bCoefficients = other.coefficients;
            var bLength = bCoefficients.length;
            var product = new Uint8ClampedArray(aLength + bLength - 1);
            for (var i2 = 0;i2 < aLength; i2++) {
              var aCoeff = aCoefficients[i2];
              for (var j = 0;j < bLength; j++) {
                product[i2 + j] = GenericGF_1.addOrSubtractGF(product[i2 + j], this.field.multiply(aCoeff, bCoefficients[j]));
              }
            }
            return new GenericGFPoly2(this.field, product);
          };
          GenericGFPoly2.prototype.multiplyByMonomial = function(degree, coefficient) {
            if (degree < 0) {
              throw new Error("Invalid degree less than 0");
            }
            if (coefficient === 0) {
              return this.field.zero;
            }
            var size = this.coefficients.length;
            var product = new Uint8ClampedArray(size + degree);
            for (var i2 = 0;i2 < size; i2++) {
              product[i2] = this.field.multiply(this.coefficients[i2], coefficient);
            }
            return new GenericGFPoly2(this.field, product);
          };
          GenericGFPoly2.prototype.evaluateAt = function(a2) {
            var result = 0;
            if (a2 === 0) {
              return this.getCoefficient(0);
            }
            var size = this.coefficients.length;
            if (a2 === 1) {
              this.coefficients.forEach(function(coefficient) {
                result = GenericGF_1.addOrSubtractGF(result, coefficient);
              });
              return result;
            }
            result = this.coefficients[0];
            for (var i2 = 1;i2 < size; i2++) {
              result = GenericGF_1.addOrSubtractGF(this.field.multiply(a2, result), this.coefficients[i2]);
            }
            return result;
          };
          return GenericGFPoly2;
        }();
        exports2.default = GenericGFPoly;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var binarizer_1 = __webpack_require__(4);
        var decoder_1 = __webpack_require__(5);
        var extractor_1 = __webpack_require__(11);
        var locator_1 = __webpack_require__(12);
        function scan2(matrix) {
          var locations = locator_1.locate(matrix);
          if (!locations) {
            return null;
          }
          for (var _i = 0, locations_1 = locations;_i < locations_1.length; _i++) {
            var location_1 = locations_1[_i];
            var extracted = extractor_1.extract(matrix, location_1);
            var decoded = decoder_1.decode(extracted.matrix);
            if (decoded) {
              return {
                binaryData: decoded.bytes,
                data: decoded.text,
                chunks: decoded.chunks,
                version: decoded.version,
                location: {
                  topRightCorner: extracted.mappingFunction(location_1.dimension, 0),
                  topLeftCorner: extracted.mappingFunction(0, 0),
                  bottomRightCorner: extracted.mappingFunction(location_1.dimension, location_1.dimension),
                  bottomLeftCorner: extracted.mappingFunction(0, location_1.dimension),
                  topRightFinderPattern: location_1.topRight,
                  topLeftFinderPattern: location_1.topLeft,
                  bottomLeftFinderPattern: location_1.bottomLeft,
                  bottomRightAlignmentPattern: location_1.alignmentPattern
                }
              };
            }
          }
          return null;
        }
        var defaultOptions = {
          inversionAttempts: "attemptBoth"
        };
        function jsQR(data, width, height, providedOptions) {
          if (providedOptions === undefined) {
            providedOptions = {};
          }
          var options = defaultOptions;
          Object.keys(options || {}).forEach(function(opt) {
            options[opt] = providedOptions[opt] || options[opt];
          });
          var shouldInvert = options.inversionAttempts === "attemptBoth" || options.inversionAttempts === "invertFirst";
          var tryInvertedFirst = options.inversionAttempts === "onlyInvert" || options.inversionAttempts === "invertFirst";
          var _a = binarizer_1.binarize(data, width, height, shouldInvert), binarized = _a.binarized, inverted = _a.inverted;
          var result = scan2(tryInvertedFirst ? inverted : binarized);
          if (!result && (options.inversionAttempts === "attemptBoth" || options.inversionAttempts === "invertFirst")) {
            result = scan2(tryInvertedFirst ? binarized : inverted);
          }
          return result;
        }
        jsQR.default = jsQR;
        exports2.default = jsQR;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var BitMatrix_1 = __webpack_require__(0);
        var REGION_SIZE = 8;
        var MIN_DYNAMIC_RANGE = 24;
        function numBetween(value, min, max) {
          return value < min ? min : value > max ? max : value;
        }
        var Matrix = function() {
          function Matrix2(width, height) {
            this.width = width;
            this.data = new Uint8ClampedArray(width * height);
          }
          Matrix2.prototype.get = function(x2, y2) {
            return this.data[y2 * this.width + x2];
          };
          Matrix2.prototype.set = function(x2, y2, value) {
            this.data[y2 * this.width + x2] = value;
          };
          return Matrix2;
        }();
        function binarize(data, width, height, returnInverted) {
          if (data.length !== width * height * 4) {
            throw new Error("Malformed data passed to binarizer.");
          }
          var greyscalePixels = new Matrix(width, height);
          for (var x2 = 0;x2 < width; x2++) {
            for (var y2 = 0;y2 < height; y2++) {
              var r = data[(y2 * width + x2) * 4 + 0];
              var g = data[(y2 * width + x2) * 4 + 1];
              var b = data[(y2 * width + x2) * 4 + 2];
              greyscalePixels.set(x2, y2, 0.2126 * r + 0.7152 * g + 0.0722 * b);
            }
          }
          var horizontalRegionCount = Math.ceil(width / REGION_SIZE);
          var verticalRegionCount = Math.ceil(height / REGION_SIZE);
          var blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount);
          for (var verticalRegion = 0;verticalRegion < verticalRegionCount; verticalRegion++) {
            for (var hortizontalRegion = 0;hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
              var sum = 0;
              var min = Infinity;
              var max = 0;
              for (var y2 = 0;y2 < REGION_SIZE; y2++) {
                for (var x2 = 0;x2 < REGION_SIZE; x2++) {
                  var pixelLumosity = greyscalePixels.get(hortizontalRegion * REGION_SIZE + x2, verticalRegion * REGION_SIZE + y2);
                  sum += pixelLumosity;
                  min = Math.min(min, pixelLumosity);
                  max = Math.max(max, pixelLumosity);
                }
              }
              var average = sum / Math.pow(REGION_SIZE, 2);
              if (max - min <= MIN_DYNAMIC_RANGE) {
                average = min / 2;
                if (verticalRegion > 0 && hortizontalRegion > 0) {
                  var averageNeighborBlackPoint = (blackPoints.get(hortizontalRegion, verticalRegion - 1) + 2 * blackPoints.get(hortizontalRegion - 1, verticalRegion) + blackPoints.get(hortizontalRegion - 1, verticalRegion - 1)) / 4;
                  if (min < averageNeighborBlackPoint) {
                    average = averageNeighborBlackPoint;
                  }
                }
              }
              blackPoints.set(hortizontalRegion, verticalRegion, average);
            }
          }
          var binarized = BitMatrix_1.BitMatrix.createEmpty(width, height);
          var inverted = null;
          if (returnInverted) {
            inverted = BitMatrix_1.BitMatrix.createEmpty(width, height);
          }
          for (var verticalRegion = 0;verticalRegion < verticalRegionCount; verticalRegion++) {
            for (var hortizontalRegion = 0;hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
              var left = numBetween(hortizontalRegion, 2, horizontalRegionCount - 3);
              var top_1 = numBetween(verticalRegion, 2, verticalRegionCount - 3);
              var sum = 0;
              for (var xRegion = -2;xRegion <= 2; xRegion++) {
                for (var yRegion = -2;yRegion <= 2; yRegion++) {
                  sum += blackPoints.get(left + xRegion, top_1 + yRegion);
                }
              }
              var threshold = sum / 25;
              for (var xRegion = 0;xRegion < REGION_SIZE; xRegion++) {
                for (var yRegion = 0;yRegion < REGION_SIZE; yRegion++) {
                  var x2 = hortizontalRegion * REGION_SIZE + xRegion;
                  var y2 = verticalRegion * REGION_SIZE + yRegion;
                  var lum = greyscalePixels.get(x2, y2);
                  binarized.set(x2, y2, lum <= threshold);
                  if (returnInverted) {
                    inverted.set(x2, y2, !(lum <= threshold));
                  }
                }
              }
            }
          }
          if (returnInverted) {
            return { binarized, inverted };
          }
          return { binarized };
        }
        exports2.binarize = binarize;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var BitMatrix_1 = __webpack_require__(0);
        var decodeData_1 = __webpack_require__(6);
        var reedsolomon_1 = __webpack_require__(9);
        var version_1 = __webpack_require__(10);
        function numBitsDiffering(x2, y2) {
          var z = x2 ^ y2;
          var bitCount = 0;
          while (z) {
            bitCount++;
            z &= z - 1;
          }
          return bitCount;
        }
        function pushBit(bit, byte) {
          return byte << 1 | bit;
        }
        var FORMAT_INFO_TABLE = [
          { bits: 21522, formatInfo: { errorCorrectionLevel: 1, dataMask: 0 } },
          { bits: 20773, formatInfo: { errorCorrectionLevel: 1, dataMask: 1 } },
          { bits: 24188, formatInfo: { errorCorrectionLevel: 1, dataMask: 2 } },
          { bits: 23371, formatInfo: { errorCorrectionLevel: 1, dataMask: 3 } },
          { bits: 17913, formatInfo: { errorCorrectionLevel: 1, dataMask: 4 } },
          { bits: 16590, formatInfo: { errorCorrectionLevel: 1, dataMask: 5 } },
          { bits: 20375, formatInfo: { errorCorrectionLevel: 1, dataMask: 6 } },
          { bits: 19104, formatInfo: { errorCorrectionLevel: 1, dataMask: 7 } },
          { bits: 30660, formatInfo: { errorCorrectionLevel: 0, dataMask: 0 } },
          { bits: 29427, formatInfo: { errorCorrectionLevel: 0, dataMask: 1 } },
          { bits: 32170, formatInfo: { errorCorrectionLevel: 0, dataMask: 2 } },
          { bits: 30877, formatInfo: { errorCorrectionLevel: 0, dataMask: 3 } },
          { bits: 26159, formatInfo: { errorCorrectionLevel: 0, dataMask: 4 } },
          { bits: 25368, formatInfo: { errorCorrectionLevel: 0, dataMask: 5 } },
          { bits: 27713, formatInfo: { errorCorrectionLevel: 0, dataMask: 6 } },
          { bits: 26998, formatInfo: { errorCorrectionLevel: 0, dataMask: 7 } },
          { bits: 5769, formatInfo: { errorCorrectionLevel: 3, dataMask: 0 } },
          { bits: 5054, formatInfo: { errorCorrectionLevel: 3, dataMask: 1 } },
          { bits: 7399, formatInfo: { errorCorrectionLevel: 3, dataMask: 2 } },
          { bits: 6608, formatInfo: { errorCorrectionLevel: 3, dataMask: 3 } },
          { bits: 1890, formatInfo: { errorCorrectionLevel: 3, dataMask: 4 } },
          { bits: 597, formatInfo: { errorCorrectionLevel: 3, dataMask: 5 } },
          { bits: 3340, formatInfo: { errorCorrectionLevel: 3, dataMask: 6 } },
          { bits: 2107, formatInfo: { errorCorrectionLevel: 3, dataMask: 7 } },
          { bits: 13663, formatInfo: { errorCorrectionLevel: 2, dataMask: 0 } },
          { bits: 12392, formatInfo: { errorCorrectionLevel: 2, dataMask: 1 } },
          { bits: 16177, formatInfo: { errorCorrectionLevel: 2, dataMask: 2 } },
          { bits: 14854, formatInfo: { errorCorrectionLevel: 2, dataMask: 3 } },
          { bits: 9396, formatInfo: { errorCorrectionLevel: 2, dataMask: 4 } },
          { bits: 8579, formatInfo: { errorCorrectionLevel: 2, dataMask: 5 } },
          { bits: 11994, formatInfo: { errorCorrectionLevel: 2, dataMask: 6 } },
          { bits: 11245, formatInfo: { errorCorrectionLevel: 2, dataMask: 7 } }
        ];
        var DATA_MASKS = [
          function(p) {
            return (p.y + p.x) % 2 === 0;
          },
          function(p) {
            return p.y % 2 === 0;
          },
          function(p) {
            return p.x % 3 === 0;
          },
          function(p) {
            return (p.y + p.x) % 3 === 0;
          },
          function(p) {
            return (Math.floor(p.y / 2) + Math.floor(p.x / 3)) % 2 === 0;
          },
          function(p) {
            return p.x * p.y % 2 + p.x * p.y % 3 === 0;
          },
          function(p) {
            return (p.y * p.x % 2 + p.y * p.x % 3) % 2 === 0;
          },
          function(p) {
            return ((p.y + p.x) % 2 + p.y * p.x % 3) % 2 === 0;
          }
        ];
        function buildFunctionPatternMask(version) {
          var dimension = 17 + 4 * version.versionNumber;
          var matrix = BitMatrix_1.BitMatrix.createEmpty(dimension, dimension);
          matrix.setRegion(0, 0, 9, 9, true);
          matrix.setRegion(dimension - 8, 0, 8, 9, true);
          matrix.setRegion(0, dimension - 8, 9, 8, true);
          for (var _i = 0, _a = version.alignmentPatternCenters;_i < _a.length; _i++) {
            var x2 = _a[_i];
            for (var _b = 0, _c = version.alignmentPatternCenters;_b < _c.length; _b++) {
              var y2 = _c[_b];
              if (!(x2 === 6 && y2 === 6 || x2 === 6 && y2 === dimension - 7 || x2 === dimension - 7 && y2 === 6)) {
                matrix.setRegion(x2 - 2, y2 - 2, 5, 5, true);
              }
            }
          }
          matrix.setRegion(6, 9, 1, dimension - 17, true);
          matrix.setRegion(9, 6, dimension - 17, 1, true);
          if (version.versionNumber > 6) {
            matrix.setRegion(dimension - 11, 0, 3, 6, true);
            matrix.setRegion(0, dimension - 11, 6, 3, true);
          }
          return matrix;
        }
        function readCodewords(matrix, version, formatInfo) {
          var dataMask = DATA_MASKS[formatInfo.dataMask];
          var dimension = matrix.height;
          var functionPatternMask = buildFunctionPatternMask(version);
          var codewords = [];
          var currentByte = 0;
          var bitsRead = 0;
          var readingUp = true;
          for (var columnIndex = dimension - 1;columnIndex > 0; columnIndex -= 2) {
            if (columnIndex === 6) {
              columnIndex--;
            }
            for (var i2 = 0;i2 < dimension; i2++) {
              var y2 = readingUp ? dimension - 1 - i2 : i2;
              for (var columnOffset = 0;columnOffset < 2; columnOffset++) {
                var x2 = columnIndex - columnOffset;
                if (!functionPatternMask.get(x2, y2)) {
                  bitsRead++;
                  var bit = matrix.get(x2, y2);
                  if (dataMask({ y: y2, x: x2 })) {
                    bit = !bit;
                  }
                  currentByte = pushBit(bit, currentByte);
                  if (bitsRead === 8) {
                    codewords.push(currentByte);
                    bitsRead = 0;
                    currentByte = 0;
                  }
                }
              }
            }
            readingUp = !readingUp;
          }
          return codewords;
        }
        function readVersion(matrix) {
          var dimension = matrix.height;
          var provisionalVersion = Math.floor((dimension - 17) / 4);
          if (provisionalVersion <= 6) {
            return version_1.VERSIONS[provisionalVersion - 1];
          }
          var topRightVersionBits = 0;
          for (var y2 = 5;y2 >= 0; y2--) {
            for (var x2 = dimension - 9;x2 >= dimension - 11; x2--) {
              topRightVersionBits = pushBit(matrix.get(x2, y2), topRightVersionBits);
            }
          }
          var bottomLeftVersionBits = 0;
          for (var x2 = 5;x2 >= 0; x2--) {
            for (var y2 = dimension - 9;y2 >= dimension - 11; y2--) {
              bottomLeftVersionBits = pushBit(matrix.get(x2, y2), bottomLeftVersionBits);
            }
          }
          var bestDifference = Infinity;
          var bestVersion;
          for (var _i = 0, VERSIONS_1 = version_1.VERSIONS;_i < VERSIONS_1.length; _i++) {
            var version = VERSIONS_1[_i];
            if (version.infoBits === topRightVersionBits || version.infoBits === bottomLeftVersionBits) {
              return version;
            }
            var difference2 = numBitsDiffering(topRightVersionBits, version.infoBits);
            if (difference2 < bestDifference) {
              bestVersion = version;
              bestDifference = difference2;
            }
            difference2 = numBitsDiffering(bottomLeftVersionBits, version.infoBits);
            if (difference2 < bestDifference) {
              bestVersion = version;
              bestDifference = difference2;
            }
          }
          if (bestDifference <= 3) {
            return bestVersion;
          }
        }
        function readFormatInformation(matrix) {
          var topLeftFormatInfoBits = 0;
          for (var x2 = 0;x2 <= 8; x2++) {
            if (x2 !== 6) {
              topLeftFormatInfoBits = pushBit(matrix.get(x2, 8), topLeftFormatInfoBits);
            }
          }
          for (var y2 = 7;y2 >= 0; y2--) {
            if (y2 !== 6) {
              topLeftFormatInfoBits = pushBit(matrix.get(8, y2), topLeftFormatInfoBits);
            }
          }
          var dimension = matrix.height;
          var topRightBottomRightFormatInfoBits = 0;
          for (var y2 = dimension - 1;y2 >= dimension - 7; y2--) {
            topRightBottomRightFormatInfoBits = pushBit(matrix.get(8, y2), topRightBottomRightFormatInfoBits);
          }
          for (var x2 = dimension - 8;x2 < dimension; x2++) {
            topRightBottomRightFormatInfoBits = pushBit(matrix.get(x2, 8), topRightBottomRightFormatInfoBits);
          }
          var bestDifference = Infinity;
          var bestFormatInfo = null;
          for (var _i = 0, FORMAT_INFO_TABLE_1 = FORMAT_INFO_TABLE;_i < FORMAT_INFO_TABLE_1.length; _i++) {
            var _a = FORMAT_INFO_TABLE_1[_i], bits = _a.bits, formatInfo = _a.formatInfo;
            if (bits === topLeftFormatInfoBits || bits === topRightBottomRightFormatInfoBits) {
              return formatInfo;
            }
            var difference2 = numBitsDiffering(topLeftFormatInfoBits, bits);
            if (difference2 < bestDifference) {
              bestFormatInfo = formatInfo;
              bestDifference = difference2;
            }
            if (topLeftFormatInfoBits !== topRightBottomRightFormatInfoBits) {
              difference2 = numBitsDiffering(topRightBottomRightFormatInfoBits, bits);
              if (difference2 < bestDifference) {
                bestFormatInfo = formatInfo;
                bestDifference = difference2;
              }
            }
          }
          if (bestDifference <= 3) {
            return bestFormatInfo;
          }
          return null;
        }
        function getDataBlocks(codewords, version, ecLevel) {
          var ecInfo = version.errorCorrectionLevels[ecLevel];
          var dataBlocks = [];
          var totalCodewords = 0;
          ecInfo.ecBlocks.forEach(function(block) {
            for (var i3 = 0;i3 < block.numBlocks; i3++) {
              dataBlocks.push({ numDataCodewords: block.dataCodewordsPerBlock, codewords: [] });
              totalCodewords += block.dataCodewordsPerBlock + ecInfo.ecCodewordsPerBlock;
            }
          });
          if (codewords.length < totalCodewords) {
            return null;
          }
          codewords = codewords.slice(0, totalCodewords);
          var shortBlockSize = ecInfo.ecBlocks[0].dataCodewordsPerBlock;
          for (var i2 = 0;i2 < shortBlockSize; i2++) {
            for (var _i = 0, dataBlocks_1 = dataBlocks;_i < dataBlocks_1.length; _i++) {
              var dataBlock = dataBlocks_1[_i];
              dataBlock.codewords.push(codewords.shift());
            }
          }
          if (ecInfo.ecBlocks.length > 1) {
            var smallBlockCount = ecInfo.ecBlocks[0].numBlocks;
            var largeBlockCount = ecInfo.ecBlocks[1].numBlocks;
            for (var i2 = 0;i2 < largeBlockCount; i2++) {
              dataBlocks[smallBlockCount + i2].codewords.push(codewords.shift());
            }
          }
          while (codewords.length > 0) {
            for (var _a = 0, dataBlocks_2 = dataBlocks;_a < dataBlocks_2.length; _a++) {
              var dataBlock = dataBlocks_2[_a];
              dataBlock.codewords.push(codewords.shift());
            }
          }
          return dataBlocks;
        }
        function decodeMatrix(matrix) {
          var version = readVersion(matrix);
          if (!version) {
            return null;
          }
          var formatInfo = readFormatInformation(matrix);
          if (!formatInfo) {
            return null;
          }
          var codewords = readCodewords(matrix, version, formatInfo);
          var dataBlocks = getDataBlocks(codewords, version, formatInfo.errorCorrectionLevel);
          if (!dataBlocks) {
            return null;
          }
          var totalBytes = dataBlocks.reduce(function(a2, b) {
            return a2 + b.numDataCodewords;
          }, 0);
          var resultBytes = new Uint8ClampedArray(totalBytes);
          var resultIndex = 0;
          for (var _i = 0, dataBlocks_3 = dataBlocks;_i < dataBlocks_3.length; _i++) {
            var dataBlock = dataBlocks_3[_i];
            var correctedBytes = reedsolomon_1.decode(dataBlock.codewords, dataBlock.codewords.length - dataBlock.numDataCodewords);
            if (!correctedBytes) {
              return null;
            }
            for (var i2 = 0;i2 < dataBlock.numDataCodewords; i2++) {
              resultBytes[resultIndex++] = correctedBytes[i2];
            }
          }
          try {
            return decodeData_1.decode(resultBytes, version.versionNumber);
          } catch (_a) {
            return null;
          }
        }
        function decode3(matrix) {
          if (matrix == null) {
            return null;
          }
          var result = decodeMatrix(matrix);
          if (result) {
            return result;
          }
          for (var x2 = 0;x2 < matrix.width; x2++) {
            for (var y2 = x2 + 1;y2 < matrix.height; y2++) {
              if (matrix.get(x2, y2) !== matrix.get(y2, x2)) {
                matrix.set(x2, y2, !matrix.get(x2, y2));
                matrix.set(y2, x2, !matrix.get(y2, x2));
              }
            }
          }
          return decodeMatrix(matrix);
        }
        exports2.decode = decode3;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var BitStream_1 = __webpack_require__(7);
        var shiftJISTable_1 = __webpack_require__(8);
        var Mode;
        (function(Mode2) {
          Mode2["Numeric"] = "numeric";
          Mode2["Alphanumeric"] = "alphanumeric";
          Mode2["Byte"] = "byte";
          Mode2["Kanji"] = "kanji";
          Mode2["ECI"] = "eci";
        })(Mode = exports2.Mode || (exports2.Mode = {}));
        var ModeByte;
        (function(ModeByte2) {
          ModeByte2[ModeByte2["Terminator"] = 0] = "Terminator";
          ModeByte2[ModeByte2["Numeric"] = 1] = "Numeric";
          ModeByte2[ModeByte2["Alphanumeric"] = 2] = "Alphanumeric";
          ModeByte2[ModeByte2["Byte"] = 4] = "Byte";
          ModeByte2[ModeByte2["Kanji"] = 8] = "Kanji";
          ModeByte2[ModeByte2["ECI"] = 7] = "ECI";
        })(ModeByte || (ModeByte = {}));
        function decodeNumeric(stream2, size) {
          var bytes = [];
          var text = "";
          var characterCountSize = [10, 12, 14][size];
          var length = stream2.readBits(characterCountSize);
          while (length >= 3) {
            var num = stream2.readBits(10);
            if (num >= 1000) {
              throw new Error("Invalid numeric value above 999");
            }
            var a2 = Math.floor(num / 100);
            var b = Math.floor(num / 10) % 10;
            var c4 = num % 10;
            bytes.push(48 + a2, 48 + b, 48 + c4);
            text += a2.toString() + b.toString() + c4.toString();
            length -= 3;
          }
          if (length === 2) {
            var num = stream2.readBits(7);
            if (num >= 100) {
              throw new Error("Invalid numeric value above 99");
            }
            var a2 = Math.floor(num / 10);
            var b = num % 10;
            bytes.push(48 + a2, 48 + b);
            text += a2.toString() + b.toString();
          } else if (length === 1) {
            var num = stream2.readBits(4);
            if (num >= 10) {
              throw new Error("Invalid numeric value above 9");
            }
            bytes.push(48 + num);
            text += num.toString();
          }
          return { bytes, text };
        }
        var AlphanumericCharacterCodes = [
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z",
          " ",
          "$",
          "%",
          "*",
          "+",
          "-",
          ".",
          "/",
          ":"
        ];
        function decodeAlphanumeric(stream2, size) {
          var bytes = [];
          var text = "";
          var characterCountSize = [9, 11, 13][size];
          var length = stream2.readBits(characterCountSize);
          while (length >= 2) {
            var v = stream2.readBits(11);
            var a2 = Math.floor(v / 45);
            var b = v % 45;
            bytes.push(AlphanumericCharacterCodes[a2].charCodeAt(0), AlphanumericCharacterCodes[b].charCodeAt(0));
            text += AlphanumericCharacterCodes[a2] + AlphanumericCharacterCodes[b];
            length -= 2;
          }
          if (length === 1) {
            var a2 = stream2.readBits(6);
            bytes.push(AlphanumericCharacterCodes[a2].charCodeAt(0));
            text += AlphanumericCharacterCodes[a2];
          }
          return { bytes, text };
        }
        function decodeByte(stream2, size) {
          var bytes = [];
          var text = "";
          var characterCountSize = [8, 16, 16][size];
          var length = stream2.readBits(characterCountSize);
          for (var i2 = 0;i2 < length; i2++) {
            var b = stream2.readBits(8);
            bytes.push(b);
          }
          try {
            text += decodeURIComponent(bytes.map(function(b2) {
              return "%" + ("0" + b2.toString(16)).substr(-2);
            }).join(""));
          } catch (_a) {}
          return { bytes, text };
        }
        function decodeKanji(stream2, size) {
          var bytes = [];
          var text = "";
          var characterCountSize = [8, 10, 12][size];
          var length = stream2.readBits(characterCountSize);
          for (var i2 = 0;i2 < length; i2++) {
            var k = stream2.readBits(13);
            var c4 = Math.floor(k / 192) << 8 | k % 192;
            if (c4 < 7936) {
              c4 += 33088;
            } else {
              c4 += 49472;
            }
            bytes.push(c4 >> 8, c4 & 255);
            text += String.fromCharCode(shiftJISTable_1.shiftJISTable[c4]);
          }
          return { bytes, text };
        }
        function decode3(data, version) {
          var _a, _b, _c, _d;
          var stream2 = new BitStream_1.BitStream(data);
          var size = version <= 9 ? 0 : version <= 26 ? 1 : 2;
          var result = {
            text: "",
            bytes: [],
            chunks: [],
            version
          };
          while (stream2.available() >= 4) {
            var mode = stream2.readBits(4);
            if (mode === ModeByte.Terminator) {
              return result;
            } else if (mode === ModeByte.ECI) {
              if (stream2.readBits(1) === 0) {
                result.chunks.push({
                  type: Mode.ECI,
                  assignmentNumber: stream2.readBits(7)
                });
              } else if (stream2.readBits(1) === 0) {
                result.chunks.push({
                  type: Mode.ECI,
                  assignmentNumber: stream2.readBits(14)
                });
              } else if (stream2.readBits(1) === 0) {
                result.chunks.push({
                  type: Mode.ECI,
                  assignmentNumber: stream2.readBits(21)
                });
              } else {
                result.chunks.push({
                  type: Mode.ECI,
                  assignmentNumber: -1
                });
              }
            } else if (mode === ModeByte.Numeric) {
              var numericResult = decodeNumeric(stream2, size);
              result.text += numericResult.text;
              (_a = result.bytes).push.apply(_a, numericResult.bytes);
              result.chunks.push({
                type: Mode.Numeric,
                text: numericResult.text
              });
            } else if (mode === ModeByte.Alphanumeric) {
              var alphanumericResult = decodeAlphanumeric(stream2, size);
              result.text += alphanumericResult.text;
              (_b = result.bytes).push.apply(_b, alphanumericResult.bytes);
              result.chunks.push({
                type: Mode.Alphanumeric,
                text: alphanumericResult.text
              });
            } else if (mode === ModeByte.Byte) {
              var byteResult = decodeByte(stream2, size);
              result.text += byteResult.text;
              (_c = result.bytes).push.apply(_c, byteResult.bytes);
              result.chunks.push({
                type: Mode.Byte,
                bytes: byteResult.bytes,
                text: byteResult.text
              });
            } else if (mode === ModeByte.Kanji) {
              var kanjiResult = decodeKanji(stream2, size);
              result.text += kanjiResult.text;
              (_d = result.bytes).push.apply(_d, kanjiResult.bytes);
              result.chunks.push({
                type: Mode.Kanji,
                bytes: kanjiResult.bytes,
                text: kanjiResult.text
              });
            }
          }
          if (stream2.available() === 0 || stream2.readBits(stream2.available()) === 0) {
            return result;
          }
        }
        exports2.decode = decode3;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var BitStream = function() {
          function BitStream2(bytes) {
            this.byteOffset = 0;
            this.bitOffset = 0;
            this.bytes = bytes;
          }
          BitStream2.prototype.readBits = function(numBits) {
            if (numBits < 1 || numBits > 32 || numBits > this.available()) {
              throw new Error("Cannot read " + numBits.toString() + " bits");
            }
            var result = 0;
            if (this.bitOffset > 0) {
              var bitsLeft = 8 - this.bitOffset;
              var toRead = numBits < bitsLeft ? numBits : bitsLeft;
              var bitsToNotRead = bitsLeft - toRead;
              var mask = 255 >> 8 - toRead << bitsToNotRead;
              result = (this.bytes[this.byteOffset] & mask) >> bitsToNotRead;
              numBits -= toRead;
              this.bitOffset += toRead;
              if (this.bitOffset === 8) {
                this.bitOffset = 0;
                this.byteOffset++;
              }
            }
            if (numBits > 0) {
              while (numBits >= 8) {
                result = result << 8 | this.bytes[this.byteOffset] & 255;
                this.byteOffset++;
                numBits -= 8;
              }
              if (numBits > 0) {
                var bitsToNotRead = 8 - numBits;
                var mask = 255 >> bitsToNotRead << bitsToNotRead;
                result = result << numBits | (this.bytes[this.byteOffset] & mask) >> bitsToNotRead;
                this.bitOffset += numBits;
              }
            }
            return result;
          };
          BitStream2.prototype.available = function() {
            return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
          };
          return BitStream2;
        }();
        exports2.BitStream = BitStream;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.shiftJISTable = {
          32: 32,
          33: 33,
          34: 34,
          35: 35,
          36: 36,
          37: 37,
          38: 38,
          39: 39,
          40: 40,
          41: 41,
          42: 42,
          43: 43,
          44: 44,
          45: 45,
          46: 46,
          47: 47,
          48: 48,
          49: 49,
          50: 50,
          51: 51,
          52: 52,
          53: 53,
          54: 54,
          55: 55,
          56: 56,
          57: 57,
          58: 58,
          59: 59,
          60: 60,
          61: 61,
          62: 62,
          63: 63,
          64: 64,
          65: 65,
          66: 66,
          67: 67,
          68: 68,
          69: 69,
          70: 70,
          71: 71,
          72: 72,
          73: 73,
          74: 74,
          75: 75,
          76: 76,
          77: 77,
          78: 78,
          79: 79,
          80: 80,
          81: 81,
          82: 82,
          83: 83,
          84: 84,
          85: 85,
          86: 86,
          87: 87,
          88: 88,
          89: 89,
          90: 90,
          91: 91,
          92: 165,
          93: 93,
          94: 94,
          95: 95,
          96: 96,
          97: 97,
          98: 98,
          99: 99,
          100: 100,
          101: 101,
          102: 102,
          103: 103,
          104: 104,
          105: 105,
          106: 106,
          107: 107,
          108: 108,
          109: 109,
          110: 110,
          111: 111,
          112: 112,
          113: 113,
          114: 114,
          115: 115,
          116: 116,
          117: 117,
          118: 118,
          119: 119,
          120: 120,
          121: 121,
          122: 122,
          123: 123,
          124: 124,
          125: 125,
          126: 8254,
          33088: 12288,
          33089: 12289,
          33090: 12290,
          33091: 65292,
          33092: 65294,
          33093: 12539,
          33094: 65306,
          33095: 65307,
          33096: 65311,
          33097: 65281,
          33098: 12443,
          33099: 12444,
          33100: 180,
          33101: 65344,
          33102: 168,
          33103: 65342,
          33104: 65507,
          33105: 65343,
          33106: 12541,
          33107: 12542,
          33108: 12445,
          33109: 12446,
          33110: 12291,
          33111: 20189,
          33112: 12293,
          33113: 12294,
          33114: 12295,
          33115: 12540,
          33116: 8213,
          33117: 8208,
          33118: 65295,
          33119: 92,
          33120: 12316,
          33121: 8214,
          33122: 65372,
          33123: 8230,
          33124: 8229,
          33125: 8216,
          33126: 8217,
          33127: 8220,
          33128: 8221,
          33129: 65288,
          33130: 65289,
          33131: 12308,
          33132: 12309,
          33133: 65339,
          33134: 65341,
          33135: 65371,
          33136: 65373,
          33137: 12296,
          33138: 12297,
          33139: 12298,
          33140: 12299,
          33141: 12300,
          33142: 12301,
          33143: 12302,
          33144: 12303,
          33145: 12304,
          33146: 12305,
          33147: 65291,
          33148: 8722,
          33149: 177,
          33150: 215,
          33152: 247,
          33153: 65309,
          33154: 8800,
          33155: 65308,
          33156: 65310,
          33157: 8806,
          33158: 8807,
          33159: 8734,
          33160: 8756,
          33161: 9794,
          33162: 9792,
          33163: 176,
          33164: 8242,
          33165: 8243,
          33166: 8451,
          33167: 65509,
          33168: 65284,
          33169: 162,
          33170: 163,
          33171: 65285,
          33172: 65283,
          33173: 65286,
          33174: 65290,
          33175: 65312,
          33176: 167,
          33177: 9734,
          33178: 9733,
          33179: 9675,
          33180: 9679,
          33181: 9678,
          33182: 9671,
          33183: 9670,
          33184: 9633,
          33185: 9632,
          33186: 9651,
          33187: 9650,
          33188: 9661,
          33189: 9660,
          33190: 8251,
          33191: 12306,
          33192: 8594,
          33193: 8592,
          33194: 8593,
          33195: 8595,
          33196: 12307,
          33208: 8712,
          33209: 8715,
          33210: 8838,
          33211: 8839,
          33212: 8834,
          33213: 8835,
          33214: 8746,
          33215: 8745,
          33224: 8743,
          33225: 8744,
          33226: 172,
          33227: 8658,
          33228: 8660,
          33229: 8704,
          33230: 8707,
          33242: 8736,
          33243: 8869,
          33244: 8978,
          33245: 8706,
          33246: 8711,
          33247: 8801,
          33248: 8786,
          33249: 8810,
          33250: 8811,
          33251: 8730,
          33252: 8765,
          33253: 8733,
          33254: 8757,
          33255: 8747,
          33256: 8748,
          33264: 8491,
          33265: 8240,
          33266: 9839,
          33267: 9837,
          33268: 9834,
          33269: 8224,
          33270: 8225,
          33271: 182,
          33276: 9711,
          33359: 65296,
          33360: 65297,
          33361: 65298,
          33362: 65299,
          33363: 65300,
          33364: 65301,
          33365: 65302,
          33366: 65303,
          33367: 65304,
          33368: 65305,
          33376: 65313,
          33377: 65314,
          33378: 65315,
          33379: 65316,
          33380: 65317,
          33381: 65318,
          33382: 65319,
          33383: 65320,
          33384: 65321,
          33385: 65322,
          33386: 65323,
          33387: 65324,
          33388: 65325,
          33389: 65326,
          33390: 65327,
          33391: 65328,
          33392: 65329,
          33393: 65330,
          33394: 65331,
          33395: 65332,
          33396: 65333,
          33397: 65334,
          33398: 65335,
          33399: 65336,
          33400: 65337,
          33401: 65338,
          33409: 65345,
          33410: 65346,
          33411: 65347,
          33412: 65348,
          33413: 65349,
          33414: 65350,
          33415: 65351,
          33416: 65352,
          33417: 65353,
          33418: 65354,
          33419: 65355,
          33420: 65356,
          33421: 65357,
          33422: 65358,
          33423: 65359,
          33424: 65360,
          33425: 65361,
          33426: 65362,
          33427: 65363,
          33428: 65364,
          33429: 65365,
          33430: 65366,
          33431: 65367,
          33432: 65368,
          33433: 65369,
          33434: 65370,
          33439: 12353,
          33440: 12354,
          33441: 12355,
          33442: 12356,
          33443: 12357,
          33444: 12358,
          33445: 12359,
          33446: 12360,
          33447: 12361,
          33448: 12362,
          33449: 12363,
          33450: 12364,
          33451: 12365,
          33452: 12366,
          33453: 12367,
          33454: 12368,
          33455: 12369,
          33456: 12370,
          33457: 12371,
          33458: 12372,
          33459: 12373,
          33460: 12374,
          33461: 12375,
          33462: 12376,
          33463: 12377,
          33464: 12378,
          33465: 12379,
          33466: 12380,
          33467: 12381,
          33468: 12382,
          33469: 12383,
          33470: 12384,
          33471: 12385,
          33472: 12386,
          33473: 12387,
          33474: 12388,
          33475: 12389,
          33476: 12390,
          33477: 12391,
          33478: 12392,
          33479: 12393,
          33480: 12394,
          33481: 12395,
          33482: 12396,
          33483: 12397,
          33484: 12398,
          33485: 12399,
          33486: 12400,
          33487: 12401,
          33488: 12402,
          33489: 12403,
          33490: 12404,
          33491: 12405,
          33492: 12406,
          33493: 12407,
          33494: 12408,
          33495: 12409,
          33496: 12410,
          33497: 12411,
          33498: 12412,
          33499: 12413,
          33500: 12414,
          33501: 12415,
          33502: 12416,
          33503: 12417,
          33504: 12418,
          33505: 12419,
          33506: 12420,
          33507: 12421,
          33508: 12422,
          33509: 12423,
          33510: 12424,
          33511: 12425,
          33512: 12426,
          33513: 12427,
          33514: 12428,
          33515: 12429,
          33516: 12430,
          33517: 12431,
          33518: 12432,
          33519: 12433,
          33520: 12434,
          33521: 12435,
          33600: 12449,
          33601: 12450,
          33602: 12451,
          33603: 12452,
          33604: 12453,
          33605: 12454,
          33606: 12455,
          33607: 12456,
          33608: 12457,
          33609: 12458,
          33610: 12459,
          33611: 12460,
          33612: 12461,
          33613: 12462,
          33614: 12463,
          33615: 12464,
          33616: 12465,
          33617: 12466,
          33618: 12467,
          33619: 12468,
          33620: 12469,
          33621: 12470,
          33622: 12471,
          33623: 12472,
          33624: 12473,
          33625: 12474,
          33626: 12475,
          33627: 12476,
          33628: 12477,
          33629: 12478,
          33630: 12479,
          33631: 12480,
          33632: 12481,
          33633: 12482,
          33634: 12483,
          33635: 12484,
          33636: 12485,
          33637: 12486,
          33638: 12487,
          33639: 12488,
          33640: 12489,
          33641: 12490,
          33642: 12491,
          33643: 12492,
          33644: 12493,
          33645: 12494,
          33646: 12495,
          33647: 12496,
          33648: 12497,
          33649: 12498,
          33650: 12499,
          33651: 12500,
          33652: 12501,
          33653: 12502,
          33654: 12503,
          33655: 12504,
          33656: 12505,
          33657: 12506,
          33658: 12507,
          33659: 12508,
          33660: 12509,
          33661: 12510,
          33662: 12511,
          33664: 12512,
          33665: 12513,
          33666: 12514,
          33667: 12515,
          33668: 12516,
          33669: 12517,
          33670: 12518,
          33671: 12519,
          33672: 12520,
          33673: 12521,
          33674: 12522,
          33675: 12523,
          33676: 12524,
          33677: 12525,
          33678: 12526,
          33679: 12527,
          33680: 12528,
          33681: 12529,
          33682: 12530,
          33683: 12531,
          33684: 12532,
          33685: 12533,
          33686: 12534,
          33695: 913,
          33696: 914,
          33697: 915,
          33698: 916,
          33699: 917,
          33700: 918,
          33701: 919,
          33702: 920,
          33703: 921,
          33704: 922,
          33705: 923,
          33706: 924,
          33707: 925,
          33708: 926,
          33709: 927,
          33710: 928,
          33711: 929,
          33712: 931,
          33713: 932,
          33714: 933,
          33715: 934,
          33716: 935,
          33717: 936,
          33718: 937,
          33727: 945,
          33728: 946,
          33729: 947,
          33730: 948,
          33731: 949,
          33732: 950,
          33733: 951,
          33734: 952,
          33735: 953,
          33736: 954,
          33737: 955,
          33738: 956,
          33739: 957,
          33740: 958,
          33741: 959,
          33742: 960,
          33743: 961,
          33744: 963,
          33745: 964,
          33746: 965,
          33747: 966,
          33748: 967,
          33749: 968,
          33750: 969,
          33856: 1040,
          33857: 1041,
          33858: 1042,
          33859: 1043,
          33860: 1044,
          33861: 1045,
          33862: 1025,
          33863: 1046,
          33864: 1047,
          33865: 1048,
          33866: 1049,
          33867: 1050,
          33868: 1051,
          33869: 1052,
          33870: 1053,
          33871: 1054,
          33872: 1055,
          33873: 1056,
          33874: 1057,
          33875: 1058,
          33876: 1059,
          33877: 1060,
          33878: 1061,
          33879: 1062,
          33880: 1063,
          33881: 1064,
          33882: 1065,
          33883: 1066,
          33884: 1067,
          33885: 1068,
          33886: 1069,
          33887: 1070,
          33888: 1071,
          33904: 1072,
          33905: 1073,
          33906: 1074,
          33907: 1075,
          33908: 1076,
          33909: 1077,
          33910: 1105,
          33911: 1078,
          33912: 1079,
          33913: 1080,
          33914: 1081,
          33915: 1082,
          33916: 1083,
          33917: 1084,
          33918: 1085,
          33920: 1086,
          33921: 1087,
          33922: 1088,
          33923: 1089,
          33924: 1090,
          33925: 1091,
          33926: 1092,
          33927: 1093,
          33928: 1094,
          33929: 1095,
          33930: 1096,
          33931: 1097,
          33932: 1098,
          33933: 1099,
          33934: 1100,
          33935: 1101,
          33936: 1102,
          33937: 1103,
          33951: 9472,
          33952: 9474,
          33953: 9484,
          33954: 9488,
          33955: 9496,
          33956: 9492,
          33957: 9500,
          33958: 9516,
          33959: 9508,
          33960: 9524,
          33961: 9532,
          33962: 9473,
          33963: 9475,
          33964: 9487,
          33965: 9491,
          33966: 9499,
          33967: 9495,
          33968: 9507,
          33969: 9523,
          33970: 9515,
          33971: 9531,
          33972: 9547,
          33973: 9504,
          33974: 9519,
          33975: 9512,
          33976: 9527,
          33977: 9535,
          33978: 9501,
          33979: 9520,
          33980: 9509,
          33981: 9528,
          33982: 9538,
          34975: 20124,
          34976: 21782,
          34977: 23043,
          34978: 38463,
          34979: 21696,
          34980: 24859,
          34981: 25384,
          34982: 23030,
          34983: 36898,
          34984: 33909,
          34985: 33564,
          34986: 31312,
          34987: 24746,
          34988: 25569,
          34989: 28197,
          34990: 26093,
          34991: 33894,
          34992: 33446,
          34993: 39925,
          34994: 26771,
          34995: 22311,
          34996: 26017,
          34997: 25201,
          34998: 23451,
          34999: 22992,
          35000: 34427,
          35001: 39156,
          35002: 32098,
          35003: 32190,
          35004: 39822,
          35005: 25110,
          35006: 31903,
          35007: 34999,
          35008: 23433,
          35009: 24245,
          35010: 25353,
          35011: 26263,
          35012: 26696,
          35013: 38343,
          35014: 38797,
          35015: 26447,
          35016: 20197,
          35017: 20234,
          35018: 20301,
          35019: 20381,
          35020: 20553,
          35021: 22258,
          35022: 22839,
          35023: 22996,
          35024: 23041,
          35025: 23561,
          35026: 24799,
          35027: 24847,
          35028: 24944,
          35029: 26131,
          35030: 26885,
          35031: 28858,
          35032: 30031,
          35033: 30064,
          35034: 31227,
          35035: 32173,
          35036: 32239,
          35037: 32963,
          35038: 33806,
          35039: 34915,
          35040: 35586,
          35041: 36949,
          35042: 36986,
          35043: 21307,
          35044: 20117,
          35045: 20133,
          35046: 22495,
          35047: 32946,
          35048: 37057,
          35049: 30959,
          35050: 19968,
          35051: 22769,
          35052: 28322,
          35053: 36920,
          35054: 31282,
          35055: 33576,
          35056: 33419,
          35057: 39983,
          35058: 20801,
          35059: 21360,
          35060: 21693,
          35061: 21729,
          35062: 22240,
          35063: 23035,
          35064: 24341,
          35065: 39154,
          35066: 28139,
          35067: 32996,
          35068: 34093,
          35136: 38498,
          35137: 38512,
          35138: 38560,
          35139: 38907,
          35140: 21515,
          35141: 21491,
          35142: 23431,
          35143: 28879,
          35144: 32701,
          35145: 36802,
          35146: 38632,
          35147: 21359,
          35148: 40284,
          35149: 31418,
          35150: 19985,
          35151: 30867,
          35152: 33276,
          35153: 28198,
          35154: 22040,
          35155: 21764,
          35156: 27421,
          35157: 34074,
          35158: 39995,
          35159: 23013,
          35160: 21417,
          35161: 28006,
          35162: 29916,
          35163: 38287,
          35164: 22082,
          35165: 20113,
          35166: 36939,
          35167: 38642,
          35168: 33615,
          35169: 39180,
          35170: 21473,
          35171: 21942,
          35172: 23344,
          35173: 24433,
          35174: 26144,
          35175: 26355,
          35176: 26628,
          35177: 27704,
          35178: 27891,
          35179: 27945,
          35180: 29787,
          35181: 30408,
          35182: 31310,
          35183: 38964,
          35184: 33521,
          35185: 34907,
          35186: 35424,
          35187: 37613,
          35188: 28082,
          35189: 30123,
          35190: 30410,
          35191: 39365,
          35192: 24742,
          35193: 35585,
          35194: 36234,
          35195: 38322,
          35196: 27022,
          35197: 21421,
          35198: 20870,
          35200: 22290,
          35201: 22576,
          35202: 22852,
          35203: 23476,
          35204: 24310,
          35205: 24616,
          35206: 25513,
          35207: 25588,
          35208: 27839,
          35209: 28436,
          35210: 28814,
          35211: 28948,
          35212: 29017,
          35213: 29141,
          35214: 29503,
          35215: 32257,
          35216: 33398,
          35217: 33489,
          35218: 34199,
          35219: 36960,
          35220: 37467,
          35221: 40219,
          35222: 22633,
          35223: 26044,
          35224: 27738,
          35225: 29989,
          35226: 20985,
          35227: 22830,
          35228: 22885,
          35229: 24448,
          35230: 24540,
          35231: 25276,
          35232: 26106,
          35233: 27178,
          35234: 27431,
          35235: 27572,
          35236: 29579,
          35237: 32705,
          35238: 35158,
          35239: 40236,
          35240: 40206,
          35241: 40644,
          35242: 23713,
          35243: 27798,
          35244: 33659,
          35245: 20740,
          35246: 23627,
          35247: 25014,
          35248: 33222,
          35249: 26742,
          35250: 29281,
          35251: 20057,
          35252: 20474,
          35253: 21368,
          35254: 24681,
          35255: 28201,
          35256: 31311,
          35257: 38899,
          35258: 19979,
          35259: 21270,
          35260: 20206,
          35261: 20309,
          35262: 20285,
          35263: 20385,
          35264: 20339,
          35265: 21152,
          35266: 21487,
          35267: 22025,
          35268: 22799,
          35269: 23233,
          35270: 23478,
          35271: 23521,
          35272: 31185,
          35273: 26247,
          35274: 26524,
          35275: 26550,
          35276: 27468,
          35277: 27827,
          35278: 28779,
          35279: 29634,
          35280: 31117,
          35281: 31166,
          35282: 31292,
          35283: 31623,
          35284: 33457,
          35285: 33499,
          35286: 33540,
          35287: 33655,
          35288: 33775,
          35289: 33747,
          35290: 34662,
          35291: 35506,
          35292: 22057,
          35293: 36008,
          35294: 36838,
          35295: 36942,
          35296: 38686,
          35297: 34442,
          35298: 20420,
          35299: 23784,
          35300: 25105,
          35301: 29273,
          35302: 30011,
          35303: 33253,
          35304: 33469,
          35305: 34558,
          35306: 36032,
          35307: 38597,
          35308: 39187,
          35309: 39381,
          35310: 20171,
          35311: 20250,
          35312: 35299,
          35313: 22238,
          35314: 22602,
          35315: 22730,
          35316: 24315,
          35317: 24555,
          35318: 24618,
          35319: 24724,
          35320: 24674,
          35321: 25040,
          35322: 25106,
          35323: 25296,
          35324: 25913,
          35392: 39745,
          35393: 26214,
          35394: 26800,
          35395: 28023,
          35396: 28784,
          35397: 30028,
          35398: 30342,
          35399: 32117,
          35400: 33445,
          35401: 34809,
          35402: 38283,
          35403: 38542,
          35404: 35997,
          35405: 20977,
          35406: 21182,
          35407: 22806,
          35408: 21683,
          35409: 23475,
          35410: 23830,
          35411: 24936,
          35412: 27010,
          35413: 28079,
          35414: 30861,
          35415: 33995,
          35416: 34903,
          35417: 35442,
          35418: 37799,
          35419: 39608,
          35420: 28012,
          35421: 39336,
          35422: 34521,
          35423: 22435,
          35424: 26623,
          35425: 34510,
          35426: 37390,
          35427: 21123,
          35428: 22151,
          35429: 21508,
          35430: 24275,
          35431: 25313,
          35432: 25785,
          35433: 26684,
          35434: 26680,
          35435: 27579,
          35436: 29554,
          35437: 30906,
          35438: 31339,
          35439: 35226,
          35440: 35282,
          35441: 36203,
          35442: 36611,
          35443: 37101,
          35444: 38307,
          35445: 38548,
          35446: 38761,
          35447: 23398,
          35448: 23731,
          35449: 27005,
          35450: 38989,
          35451: 38990,
          35452: 25499,
          35453: 31520,
          35454: 27179,
          35456: 27263,
          35457: 26806,
          35458: 39949,
          35459: 28511,
          35460: 21106,
          35461: 21917,
          35462: 24688,
          35463: 25324,
          35464: 27963,
          35465: 28167,
          35466: 28369,
          35467: 33883,
          35468: 35088,
          35469: 36676,
          35470: 19988,
          35471: 39993,
          35472: 21494,
          35473: 26907,
          35474: 27194,
          35475: 38788,
          35476: 26666,
          35477: 20828,
          35478: 31427,
          35479: 33970,
          35480: 37340,
          35481: 37772,
          35482: 22107,
          35483: 40232,
          35484: 26658,
          35485: 33541,
          35486: 33841,
          35487: 31909,
          35488: 21000,
          35489: 33477,
          35490: 29926,
          35491: 20094,
          35492: 20355,
          35493: 20896,
          35494: 23506,
          35495: 21002,
          35496: 21208,
          35497: 21223,
          35498: 24059,
          35499: 21914,
          35500: 22570,
          35501: 23014,
          35502: 23436,
          35503: 23448,
          35504: 23515,
          35505: 24178,
          35506: 24185,
          35507: 24739,
          35508: 24863,
          35509: 24931,
          35510: 25022,
          35511: 25563,
          35512: 25954,
          35513: 26577,
          35514: 26707,
          35515: 26874,
          35516: 27454,
          35517: 27475,
          35518: 27735,
          35519: 28450,
          35520: 28567,
          35521: 28485,
          35522: 29872,
          35523: 29976,
          35524: 30435,
          35525: 30475,
          35526: 31487,
          35527: 31649,
          35528: 31777,
          35529: 32233,
          35530: 32566,
          35531: 32752,
          35532: 32925,
          35533: 33382,
          35534: 33694,
          35535: 35251,
          35536: 35532,
          35537: 36011,
          35538: 36996,
          35539: 37969,
          35540: 38291,
          35541: 38289,
          35542: 38306,
          35543: 38501,
          35544: 38867,
          35545: 39208,
          35546: 33304,
          35547: 20024,
          35548: 21547,
          35549: 23736,
          35550: 24012,
          35551: 29609,
          35552: 30284,
          35553: 30524,
          35554: 23721,
          35555: 32747,
          35556: 36107,
          35557: 38593,
          35558: 38929,
          35559: 38996,
          35560: 39000,
          35561: 20225,
          35562: 20238,
          35563: 21361,
          35564: 21916,
          35565: 22120,
          35566: 22522,
          35567: 22855,
          35568: 23305,
          35569: 23492,
          35570: 23696,
          35571: 24076,
          35572: 24190,
          35573: 24524,
          35574: 25582,
          35575: 26426,
          35576: 26071,
          35577: 26082,
          35578: 26399,
          35579: 26827,
          35580: 26820,
          35648: 27231,
          35649: 24112,
          35650: 27589,
          35651: 27671,
          35652: 27773,
          35653: 30079,
          35654: 31048,
          35655: 23395,
          35656: 31232,
          35657: 32000,
          35658: 24509,
          35659: 35215,
          35660: 35352,
          35661: 36020,
          35662: 36215,
          35663: 36556,
          35664: 36637,
          35665: 39138,
          35666: 39438,
          35667: 39740,
          35668: 20096,
          35669: 20605,
          35670: 20736,
          35671: 22931,
          35672: 23452,
          35673: 25135,
          35674: 25216,
          35675: 25836,
          35676: 27450,
          35677: 29344,
          35678: 30097,
          35679: 31047,
          35680: 32681,
          35681: 34811,
          35682: 35516,
          35683: 35696,
          35684: 25516,
          35685: 33738,
          35686: 38816,
          35687: 21513,
          35688: 21507,
          35689: 21931,
          35690: 26708,
          35691: 27224,
          35692: 35440,
          35693: 30759,
          35694: 26485,
          35695: 40653,
          35696: 21364,
          35697: 23458,
          35698: 33050,
          35699: 34384,
          35700: 36870,
          35701: 19992,
          35702: 20037,
          35703: 20167,
          35704: 20241,
          35705: 21450,
          35706: 21560,
          35707: 23470,
          35708: 24339,
          35709: 24613,
          35710: 25937,
          35712: 26429,
          35713: 27714,
          35714: 27762,
          35715: 27875,
          35716: 28792,
          35717: 29699,
          35718: 31350,
          35719: 31406,
          35720: 31496,
          35721: 32026,
          35722: 31998,
          35723: 32102,
          35724: 26087,
          35725: 29275,
          35726: 21435,
          35727: 23621,
          35728: 24040,
          35729: 25298,
          35730: 25312,
          35731: 25369,
          35732: 28192,
          35733: 34394,
          35734: 35377,
          35735: 36317,
          35736: 37624,
          35737: 28417,
          35738: 31142,
          35739: 39770,
          35740: 20136,
          35741: 20139,
          35742: 20140,
          35743: 20379,
          35744: 20384,
          35745: 20689,
          35746: 20807,
          35747: 31478,
          35748: 20849,
          35749: 20982,
          35750: 21332,
          35751: 21281,
          35752: 21375,
          35753: 21483,
          35754: 21932,
          35755: 22659,
          35756: 23777,
          35757: 24375,
          35758: 24394,
          35759: 24623,
          35760: 24656,
          35761: 24685,
          35762: 25375,
          35763: 25945,
          35764: 27211,
          35765: 27841,
          35766: 29378,
          35767: 29421,
          35768: 30703,
          35769: 33016,
          35770: 33029,
          35771: 33288,
          35772: 34126,
          35773: 37111,
          35774: 37857,
          35775: 38911,
          35776: 39255,
          35777: 39514,
          35778: 20208,
          35779: 20957,
          35780: 23597,
          35781: 26241,
          35782: 26989,
          35783: 23616,
          35784: 26354,
          35785: 26997,
          35786: 29577,
          35787: 26704,
          35788: 31873,
          35789: 20677,
          35790: 21220,
          35791: 22343,
          35792: 24062,
          35793: 37670,
          35794: 26020,
          35795: 27427,
          35796: 27453,
          35797: 29748,
          35798: 31105,
          35799: 31165,
          35800: 31563,
          35801: 32202,
          35802: 33465,
          35803: 33740,
          35804: 34943,
          35805: 35167,
          35806: 35641,
          35807: 36817,
          35808: 37329,
          35809: 21535,
          35810: 37504,
          35811: 20061,
          35812: 20534,
          35813: 21477,
          35814: 21306,
          35815: 29399,
          35816: 29590,
          35817: 30697,
          35818: 33510,
          35819: 36527,
          35820: 39366,
          35821: 39368,
          35822: 39378,
          35823: 20855,
          35824: 24858,
          35825: 34398,
          35826: 21936,
          35827: 31354,
          35828: 20598,
          35829: 23507,
          35830: 36935,
          35831: 38533,
          35832: 20018,
          35833: 27355,
          35834: 37351,
          35835: 23633,
          35836: 23624,
          35904: 25496,
          35905: 31391,
          35906: 27795,
          35907: 38772,
          35908: 36705,
          35909: 31402,
          35910: 29066,
          35911: 38536,
          35912: 31874,
          35913: 26647,
          35914: 32368,
          35915: 26705,
          35916: 37740,
          35917: 21234,
          35918: 21531,
          35919: 34219,
          35920: 35347,
          35921: 32676,
          35922: 36557,
          35923: 37089,
          35924: 21350,
          35925: 34952,
          35926: 31041,
          35927: 20418,
          35928: 20670,
          35929: 21009,
          35930: 20804,
          35931: 21843,
          35932: 22317,
          35933: 29674,
          35934: 22411,
          35935: 22865,
          35936: 24418,
          35937: 24452,
          35938: 24693,
          35939: 24950,
          35940: 24935,
          35941: 25001,
          35942: 25522,
          35943: 25658,
          35944: 25964,
          35945: 26223,
          35946: 26690,
          35947: 28179,
          35948: 30054,
          35949: 31293,
          35950: 31995,
          35951: 32076,
          35952: 32153,
          35953: 32331,
          35954: 32619,
          35955: 33550,
          35956: 33610,
          35957: 34509,
          35958: 35336,
          35959: 35427,
          35960: 35686,
          35961: 36605,
          35962: 38938,
          35963: 40335,
          35964: 33464,
          35965: 36814,
          35966: 39912,
          35968: 21127,
          35969: 25119,
          35970: 25731,
          35971: 28608,
          35972: 38553,
          35973: 26689,
          35974: 20625,
          35975: 27424,
          35976: 27770,
          35977: 28500,
          35978: 31348,
          35979: 32080,
          35980: 34880,
          35981: 35363,
          35982: 26376,
          35983: 20214,
          35984: 20537,
          35985: 20518,
          35986: 20581,
          35987: 20860,
          35988: 21048,
          35989: 21091,
          35990: 21927,
          35991: 22287,
          35992: 22533,
          35993: 23244,
          35994: 24314,
          35995: 25010,
          35996: 25080,
          35997: 25331,
          35998: 25458,
          35999: 26908,
          36000: 27177,
          36001: 29309,
          36002: 29356,
          36003: 29486,
          36004: 30740,
          36005: 30831,
          36006: 32121,
          36007: 30476,
          36008: 32937,
          36009: 35211,
          36010: 35609,
          36011: 36066,
          36012: 36562,
          36013: 36963,
          36014: 37749,
          36015: 38522,
          36016: 38997,
          36017: 39443,
          36018: 40568,
          36019: 20803,
          36020: 21407,
          36021: 21427,
          36022: 24187,
          36023: 24358,
          36024: 28187,
          36025: 28304,
          36026: 29572,
          36027: 29694,
          36028: 32067,
          36029: 33335,
          36030: 35328,
          36031: 35578,
          36032: 38480,
          36033: 20046,
          36034: 20491,
          36035: 21476,
          36036: 21628,
          36037: 22266,
          36038: 22993,
          36039: 23396,
          36040: 24049,
          36041: 24235,
          36042: 24359,
          36043: 25144,
          36044: 25925,
          36045: 26543,
          36046: 28246,
          36047: 29392,
          36048: 31946,
          36049: 34996,
          36050: 32929,
          36051: 32993,
          36052: 33776,
          36053: 34382,
          36054: 35463,
          36055: 36328,
          36056: 37431,
          36057: 38599,
          36058: 39015,
          36059: 40723,
          36060: 20116,
          36061: 20114,
          36062: 20237,
          36063: 21320,
          36064: 21577,
          36065: 21566,
          36066: 23087,
          36067: 24460,
          36068: 24481,
          36069: 24735,
          36070: 26791,
          36071: 27278,
          36072: 29786,
          36073: 30849,
          36074: 35486,
          36075: 35492,
          36076: 35703,
          36077: 37264,
          36078: 20062,
          36079: 39881,
          36080: 20132,
          36081: 20348,
          36082: 20399,
          36083: 20505,
          36084: 20502,
          36085: 20809,
          36086: 20844,
          36087: 21151,
          36088: 21177,
          36089: 21246,
          36090: 21402,
          36091: 21475,
          36092: 21521,
          36160: 21518,
          36161: 21897,
          36162: 22353,
          36163: 22434,
          36164: 22909,
          36165: 23380,
          36166: 23389,
          36167: 23439,
          36168: 24037,
          36169: 24039,
          36170: 24055,
          36171: 24184,
          36172: 24195,
          36173: 24218,
          36174: 24247,
          36175: 24344,
          36176: 24658,
          36177: 24908,
          36178: 25239,
          36179: 25304,
          36180: 25511,
          36181: 25915,
          36182: 26114,
          36183: 26179,
          36184: 26356,
          36185: 26477,
          36186: 26657,
          36187: 26775,
          36188: 27083,
          36189: 27743,
          36190: 27946,
          36191: 28009,
          36192: 28207,
          36193: 28317,
          36194: 30002,
          36195: 30343,
          36196: 30828,
          36197: 31295,
          36198: 31968,
          36199: 32005,
          36200: 32024,
          36201: 32094,
          36202: 32177,
          36203: 32789,
          36204: 32771,
          36205: 32943,
          36206: 32945,
          36207: 33108,
          36208: 33167,
          36209: 33322,
          36210: 33618,
          36211: 34892,
          36212: 34913,
          36213: 35611,
          36214: 36002,
          36215: 36092,
          36216: 37066,
          36217: 37237,
          36218: 37489,
          36219: 30783,
          36220: 37628,
          36221: 38308,
          36222: 38477,
          36224: 38917,
          36225: 39321,
          36226: 39640,
          36227: 40251,
          36228: 21083,
          36229: 21163,
          36230: 21495,
          36231: 21512,
          36232: 22741,
          36233: 25335,
          36234: 28640,
          36235: 35946,
          36236: 36703,
          36237: 40633,
          36238: 20811,
          36239: 21051,
          36240: 21578,
          36241: 22269,
          36242: 31296,
          36243: 37239,
          36244: 40288,
          36245: 40658,
          36246: 29508,
          36247: 28425,
          36248: 33136,
          36249: 29969,
          36250: 24573,
          36251: 24794,
          36252: 39592,
          36253: 29403,
          36254: 36796,
          36255: 27492,
          36256: 38915,
          36257: 20170,
          36258: 22256,
          36259: 22372,
          36260: 22718,
          36261: 23130,
          36262: 24680,
          36263: 25031,
          36264: 26127,
          36265: 26118,
          36266: 26681,
          36267: 26801,
          36268: 28151,
          36269: 30165,
          36270: 32058,
          36271: 33390,
          36272: 39746,
          36273: 20123,
          36274: 20304,
          36275: 21449,
          36276: 21766,
          36277: 23919,
          36278: 24038,
          36279: 24046,
          36280: 26619,
          36281: 27801,
          36282: 29811,
          36283: 30722,
          36284: 35408,
          36285: 37782,
          36286: 35039,
          36287: 22352,
          36288: 24231,
          36289: 25387,
          36290: 20661,
          36291: 20652,
          36292: 20877,
          36293: 26368,
          36294: 21705,
          36295: 22622,
          36296: 22971,
          36297: 23472,
          36298: 24425,
          36299: 25165,
          36300: 25505,
          36301: 26685,
          36302: 27507,
          36303: 28168,
          36304: 28797,
          36305: 37319,
          36306: 29312,
          36307: 30741,
          36308: 30758,
          36309: 31085,
          36310: 25998,
          36311: 32048,
          36312: 33756,
          36313: 35009,
          36314: 36617,
          36315: 38555,
          36316: 21092,
          36317: 22312,
          36318: 26448,
          36319: 32618,
          36320: 36001,
          36321: 20916,
          36322: 22338,
          36323: 38442,
          36324: 22586,
          36325: 27018,
          36326: 32948,
          36327: 21682,
          36328: 23822,
          36329: 22524,
          36330: 30869,
          36331: 40442,
          36332: 20316,
          36333: 21066,
          36334: 21643,
          36335: 25662,
          36336: 26152,
          36337: 26388,
          36338: 26613,
          36339: 31364,
          36340: 31574,
          36341: 32034,
          36342: 37679,
          36343: 26716,
          36344: 39853,
          36345: 31545,
          36346: 21273,
          36347: 20874,
          36348: 21047,
          36416: 23519,
          36417: 25334,
          36418: 25774,
          36419: 25830,
          36420: 26413,
          36421: 27578,
          36422: 34217,
          36423: 38609,
          36424: 30352,
          36425: 39894,
          36426: 25420,
          36427: 37638,
          36428: 39851,
          36429: 30399,
          36430: 26194,
          36431: 19977,
          36432: 20632,
          36433: 21442,
          36434: 23665,
          36435: 24808,
          36436: 25746,
          36437: 25955,
          36438: 26719,
          36439: 29158,
          36440: 29642,
          36441: 29987,
          36442: 31639,
          36443: 32386,
          36444: 34453,
          36445: 35715,
          36446: 36059,
          36447: 37240,
          36448: 39184,
          36449: 26028,
          36450: 26283,
          36451: 27531,
          36452: 20181,
          36453: 20180,
          36454: 20282,
          36455: 20351,
          36456: 21050,
          36457: 21496,
          36458: 21490,
          36459: 21987,
          36460: 22235,
          36461: 22763,
          36462: 22987,
          36463: 22985,
          36464: 23039,
          36465: 23376,
          36466: 23629,
          36467: 24066,
          36468: 24107,
          36469: 24535,
          36470: 24605,
          36471: 25351,
          36472: 25903,
          36473: 23388,
          36474: 26031,
          36475: 26045,
          36476: 26088,
          36477: 26525,
          36478: 27490,
          36480: 27515,
          36481: 27663,
          36482: 29509,
          36483: 31049,
          36484: 31169,
          36485: 31992,
          36486: 32025,
          36487: 32043,
          36488: 32930,
          36489: 33026,
          36490: 33267,
          36491: 35222,
          36492: 35422,
          36493: 35433,
          36494: 35430,
          36495: 35468,
          36496: 35566,
          36497: 36039,
          36498: 36060,
          36499: 38604,
          36500: 39164,
          36501: 27503,
          36502: 20107,
          36503: 20284,
          36504: 20365,
          36505: 20816,
          36506: 23383,
          36507: 23546,
          36508: 24904,
          36509: 25345,
          36510: 26178,
          36511: 27425,
          36512: 28363,
          36513: 27835,
          36514: 29246,
          36515: 29885,
          36516: 30164,
          36517: 30913,
          36518: 31034,
          36519: 32780,
          36520: 32819,
          36521: 33258,
          36522: 33940,
          36523: 36766,
          36524: 27728,
          36525: 40575,
          36526: 24335,
          36527: 35672,
          36528: 40235,
          36529: 31482,
          36530: 36600,
          36531: 23437,
          36532: 38635,
          36533: 19971,
          36534: 21489,
          36535: 22519,
          36536: 22833,
          36537: 23241,
          36538: 23460,
          36539: 24713,
          36540: 28287,
          36541: 28422,
          36542: 30142,
          36543: 36074,
          36544: 23455,
          36545: 34048,
          36546: 31712,
          36547: 20594,
          36548: 26612,
          36549: 33437,
          36550: 23649,
          36551: 34122,
          36552: 32286,
          36553: 33294,
          36554: 20889,
          36555: 23556,
          36556: 25448,
          36557: 36198,
          36558: 26012,
          36559: 29038,
          36560: 31038,
          36561: 32023,
          36562: 32773,
          36563: 35613,
          36564: 36554,
          36565: 36974,
          36566: 34503,
          36567: 37034,
          36568: 20511,
          36569: 21242,
          36570: 23610,
          36571: 26451,
          36572: 28796,
          36573: 29237,
          36574: 37196,
          36575: 37320,
          36576: 37675,
          36577: 33509,
          36578: 23490,
          36579: 24369,
          36580: 24825,
          36581: 20027,
          36582: 21462,
          36583: 23432,
          36584: 25163,
          36585: 26417,
          36586: 27530,
          36587: 29417,
          36588: 29664,
          36589: 31278,
          36590: 33131,
          36591: 36259,
          36592: 37202,
          36593: 39318,
          36594: 20754,
          36595: 21463,
          36596: 21610,
          36597: 23551,
          36598: 25480,
          36599: 27193,
          36600: 32172,
          36601: 38656,
          36602: 22234,
          36603: 21454,
          36604: 21608,
          36672: 23447,
          36673: 23601,
          36674: 24030,
          36675: 20462,
          36676: 24833,
          36677: 25342,
          36678: 27954,
          36679: 31168,
          36680: 31179,
          36681: 32066,
          36682: 32333,
          36683: 32722,
          36684: 33261,
          36685: 33311,
          36686: 33936,
          36687: 34886,
          36688: 35186,
          36689: 35728,
          36690: 36468,
          36691: 36655,
          36692: 36913,
          36693: 37195,
          36694: 37228,
          36695: 38598,
          36696: 37276,
          36697: 20160,
          36698: 20303,
          36699: 20805,
          36700: 21313,
          36701: 24467,
          36702: 25102,
          36703: 26580,
          36704: 27713,
          36705: 28171,
          36706: 29539,
          36707: 32294,
          36708: 37325,
          36709: 37507,
          36710: 21460,
          36711: 22809,
          36712: 23487,
          36713: 28113,
          36714: 31069,
          36715: 32302,
          36716: 31899,
          36717: 22654,
          36718: 29087,
          36719: 20986,
          36720: 34899,
          36721: 36848,
          36722: 20426,
          36723: 23803,
          36724: 26149,
          36725: 30636,
          36726: 31459,
          36727: 33308,
          36728: 39423,
          36729: 20934,
          36730: 24490,
          36731: 26092,
          36732: 26991,
          36733: 27529,
          36734: 28147,
          36736: 28310,
          36737: 28516,
          36738: 30462,
          36739: 32020,
          36740: 24033,
          36741: 36981,
          36742: 37255,
          36743: 38918,
          36744: 20966,
          36745: 21021,
          36746: 25152,
          36747: 26257,
          36748: 26329,
          36749: 28186,
          36750: 24246,
          36751: 32210,
          36752: 32626,
          36753: 26360,
          36754: 34223,
          36755: 34295,
          36756: 35576,
          36757: 21161,
          36758: 21465,
          36759: 22899,
          36760: 24207,
          36761: 24464,
          36762: 24661,
          36763: 37604,
          36764: 38500,
          36765: 20663,
          36766: 20767,
          36767: 21213,
          36768: 21280,
          36769: 21319,
          36770: 21484,
          36771: 21736,
          36772: 21830,
          36773: 21809,
          36774: 22039,
          36775: 22888,
          36776: 22974,
          36777: 23100,
          36778: 23477,
          36779: 23558,
          36780: 23567,
          36781: 23569,
          36782: 23578,
          36783: 24196,
          36784: 24202,
          36785: 24288,
          36786: 24432,
          36787: 25215,
          36788: 25220,
          36789: 25307,
          36790: 25484,
          36791: 25463,
          36792: 26119,
          36793: 26124,
          36794: 26157,
          36795: 26230,
          36796: 26494,
          36797: 26786,
          36798: 27167,
          36799: 27189,
          36800: 27836,
          36801: 28040,
          36802: 28169,
          36803: 28248,
          36804: 28988,
          36805: 28966,
          36806: 29031,
          36807: 30151,
          36808: 30465,
          36809: 30813,
          36810: 30977,
          36811: 31077,
          36812: 31216,
          36813: 31456,
          36814: 31505,
          36815: 31911,
          36816: 32057,
          36817: 32918,
          36818: 33750,
          36819: 33931,
          36820: 34121,
          36821: 34909,
          36822: 35059,
          36823: 35359,
          36824: 35388,
          36825: 35412,
          36826: 35443,
          36827: 35937,
          36828: 36062,
          36829: 37284,
          36830: 37478,
          36831: 37758,
          36832: 37912,
          36833: 38556,
          36834: 38808,
          36835: 19978,
          36836: 19976,
          36837: 19998,
          36838: 20055,
          36839: 20887,
          36840: 21104,
          36841: 22478,
          36842: 22580,
          36843: 22732,
          36844: 23330,
          36845: 24120,
          36846: 24773,
          36847: 25854,
          36848: 26465,
          36849: 26454,
          36850: 27972,
          36851: 29366,
          36852: 30067,
          36853: 31331,
          36854: 33976,
          36855: 35698,
          36856: 37304,
          36857: 37664,
          36858: 22065,
          36859: 22516,
          36860: 39166,
          36928: 25325,
          36929: 26893,
          36930: 27542,
          36931: 29165,
          36932: 32340,
          36933: 32887,
          36934: 33394,
          36935: 35302,
          36936: 39135,
          36937: 34645,
          36938: 36785,
          36939: 23611,
          36940: 20280,
          36941: 20449,
          36942: 20405,
          36943: 21767,
          36944: 23072,
          36945: 23517,
          36946: 23529,
          36947: 24515,
          36948: 24910,
          36949: 25391,
          36950: 26032,
          36951: 26187,
          36952: 26862,
          36953: 27035,
          36954: 28024,
          36955: 28145,
          36956: 30003,
          36957: 30137,
          36958: 30495,
          36959: 31070,
          36960: 31206,
          36961: 32051,
          36962: 33251,
          36963: 33455,
          36964: 34218,
          36965: 35242,
          36966: 35386,
          36967: 36523,
          36968: 36763,
          36969: 36914,
          36970: 37341,
          36971: 38663,
          36972: 20154,
          36973: 20161,
          36974: 20995,
          36975: 22645,
          36976: 22764,
          36977: 23563,
          36978: 29978,
          36979: 23613,
          36980: 33102,
          36981: 35338,
          36982: 36805,
          36983: 38499,
          36984: 38765,
          36985: 31525,
          36986: 35535,
          36987: 38920,
          36988: 37218,
          36989: 22259,
          36990: 21416,
          36992: 36887,
          36993: 21561,
          36994: 22402,
          36995: 24101,
          36996: 25512,
          36997: 27700,
          36998: 28810,
          36999: 30561,
          37000: 31883,
          37001: 32736,
          37002: 34928,
          37003: 36930,
          37004: 37204,
          37005: 37648,
          37006: 37656,
          37007: 38543,
          37008: 29790,
          37009: 39620,
          37010: 23815,
          37011: 23913,
          37012: 25968,
          37013: 26530,
          37014: 36264,
          37015: 38619,
          37016: 25454,
          37017: 26441,
          37018: 26905,
          37019: 33733,
          37020: 38935,
          37021: 38592,
          37022: 35070,
          37023: 28548,
          37024: 25722,
          37025: 23544,
          37026: 19990,
          37027: 28716,
          37028: 30045,
          37029: 26159,
          37030: 20932,
          37031: 21046,
          37032: 21218,
          37033: 22995,
          37034: 24449,
          37035: 24615,
          37036: 25104,
          37037: 25919,
          37038: 25972,
          37039: 26143,
          37040: 26228,
          37041: 26866,
          37042: 26646,
          37043: 27491,
          37044: 28165,
          37045: 29298,
          37046: 29983,
          37047: 30427,
          37048: 31934,
          37049: 32854,
          37050: 22768,
          37051: 35069,
          37052: 35199,
          37053: 35488,
          37054: 35475,
          37055: 35531,
          37056: 36893,
          37057: 37266,
          37058: 38738,
          37059: 38745,
          37060: 25993,
          37061: 31246,
          37062: 33030,
          37063: 38587,
          37064: 24109,
          37065: 24796,
          37066: 25114,
          37067: 26021,
          37068: 26132,
          37069: 26512,
          37070: 30707,
          37071: 31309,
          37072: 31821,
          37073: 32318,
          37074: 33034,
          37075: 36012,
          37076: 36196,
          37077: 36321,
          37078: 36447,
          37079: 30889,
          37080: 20999,
          37081: 25305,
          37082: 25509,
          37083: 25666,
          37084: 25240,
          37085: 35373,
          37086: 31363,
          37087: 31680,
          37088: 35500,
          37089: 38634,
          37090: 32118,
          37091: 33292,
          37092: 34633,
          37093: 20185,
          37094: 20808,
          37095: 21315,
          37096: 21344,
          37097: 23459,
          37098: 23554,
          37099: 23574,
          37100: 24029,
          37101: 25126,
          37102: 25159,
          37103: 25776,
          37104: 26643,
          37105: 26676,
          37106: 27849,
          37107: 27973,
          37108: 27927,
          37109: 26579,
          37110: 28508,
          37111: 29006,
          37112: 29053,
          37113: 26059,
          37114: 31359,
          37115: 31661,
          37116: 32218,
          37184: 32330,
          37185: 32680,
          37186: 33146,
          37187: 33307,
          37188: 33337,
          37189: 34214,
          37190: 35438,
          37191: 36046,
          37192: 36341,
          37193: 36984,
          37194: 36983,
          37195: 37549,
          37196: 37521,
          37197: 38275,
          37198: 39854,
          37199: 21069,
          37200: 21892,
          37201: 28472,
          37202: 28982,
          37203: 20840,
          37204: 31109,
          37205: 32341,
          37206: 33203,
          37207: 31950,
          37208: 22092,
          37209: 22609,
          37210: 23720,
          37211: 25514,
          37212: 26366,
          37213: 26365,
          37214: 26970,
          37215: 29401,
          37216: 30095,
          37217: 30094,
          37218: 30990,
          37219: 31062,
          37220: 31199,
          37221: 31895,
          37222: 32032,
          37223: 32068,
          37224: 34311,
          37225: 35380,
          37226: 38459,
          37227: 36961,
          37228: 40736,
          37229: 20711,
          37230: 21109,
          37231: 21452,
          37232: 21474,
          37233: 20489,
          37234: 21930,
          37235: 22766,
          37236: 22863,
          37237: 29245,
          37238: 23435,
          37239: 23652,
          37240: 21277,
          37241: 24803,
          37242: 24819,
          37243: 25436,
          37244: 25475,
          37245: 25407,
          37246: 25531,
          37248: 25805,
          37249: 26089,
          37250: 26361,
          37251: 24035,
          37252: 27085,
          37253: 27133,
          37254: 28437,
          37255: 29157,
          37256: 20105,
          37257: 30185,
          37258: 30456,
          37259: 31379,
          37260: 31967,
          37261: 32207,
          37262: 32156,
          37263: 32865,
          37264: 33609,
          37265: 33624,
          37266: 33900,
          37267: 33980,
          37268: 34299,
          37269: 35013,
          37270: 36208,
          37271: 36865,
          37272: 36973,
          37273: 37783,
          37274: 38684,
          37275: 39442,
          37276: 20687,
          37277: 22679,
          37278: 24974,
          37279: 33235,
          37280: 34101,
          37281: 36104,
          37282: 36896,
          37283: 20419,
          37284: 20596,
          37285: 21063,
          37286: 21363,
          37287: 24687,
          37288: 25417,
          37289: 26463,
          37290: 28204,
          37291: 36275,
          37292: 36895,
          37293: 20439,
          37294: 23646,
          37295: 36042,
          37296: 26063,
          37297: 32154,
          37298: 21330,
          37299: 34966,
          37300: 20854,
          37301: 25539,
          37302: 23384,
          37303: 23403,
          37304: 23562,
          37305: 25613,
          37306: 26449,
          37307: 36956,
          37308: 20182,
          37309: 22810,
          37310: 22826,
          37311: 27760,
          37312: 35409,
          37313: 21822,
          37314: 22549,
          37315: 22949,
          37316: 24816,
          37317: 25171,
          37318: 26561,
          37319: 33333,
          37320: 26965,
          37321: 38464,
          37322: 39364,
          37323: 39464,
          37324: 20307,
          37325: 22534,
          37326: 23550,
          37327: 32784,
          37328: 23729,
          37329: 24111,
          37330: 24453,
          37331: 24608,
          37332: 24907,
          37333: 25140,
          37334: 26367,
          37335: 27888,
          37336: 28382,
          37337: 32974,
          37338: 33151,
          37339: 33492,
          37340: 34955,
          37341: 36024,
          37342: 36864,
          37343: 36910,
          37344: 38538,
          37345: 40667,
          37346: 39899,
          37347: 20195,
          37348: 21488,
          37349: 22823,
          37350: 31532,
          37351: 37261,
          37352: 38988,
          37353: 40441,
          37354: 28381,
          37355: 28711,
          37356: 21331,
          37357: 21828,
          37358: 23429,
          37359: 25176,
          37360: 25246,
          37361: 25299,
          37362: 27810,
          37363: 28655,
          37364: 29730,
          37365: 35351,
          37366: 37944,
          37367: 28609,
          37368: 35582,
          37369: 33592,
          37370: 20967,
          37371: 34552,
          37372: 21482,
          37440: 21481,
          37441: 20294,
          37442: 36948,
          37443: 36784,
          37444: 22890,
          37445: 33073,
          37446: 24061,
          37447: 31466,
          37448: 36799,
          37449: 26842,
          37450: 35895,
          37451: 29432,
          37452: 40008,
          37453: 27197,
          37454: 35504,
          37455: 20025,
          37456: 21336,
          37457: 22022,
          37458: 22374,
          37459: 25285,
          37460: 25506,
          37461: 26086,
          37462: 27470,
          37463: 28129,
          37464: 28251,
          37465: 28845,
          37466: 30701,
          37467: 31471,
          37468: 31658,
          37469: 32187,
          37470: 32829,
          37471: 32966,
          37472: 34507,
          37473: 35477,
          37474: 37723,
          37475: 22243,
          37476: 22727,
          37477: 24382,
          37478: 26029,
          37479: 26262,
          37480: 27264,
          37481: 27573,
          37482: 30007,
          37483: 35527,
          37484: 20516,
          37485: 30693,
          37486: 22320,
          37487: 24347,
          37488: 24677,
          37489: 26234,
          37490: 27744,
          37491: 30196,
          37492: 31258,
          37493: 32622,
          37494: 33268,
          37495: 34584,
          37496: 36933,
          37497: 39347,
          37498: 31689,
          37499: 30044,
          37500: 31481,
          37501: 31569,
          37502: 33988,
          37504: 36880,
          37505: 31209,
          37506: 31378,
          37507: 33590,
          37508: 23265,
          37509: 30528,
          37510: 20013,
          37511: 20210,
          37512: 23449,
          37513: 24544,
          37514: 25277,
          37515: 26172,
          37516: 26609,
          37517: 27880,
          37518: 34411,
          37519: 34935,
          37520: 35387,
          37521: 37198,
          37522: 37619,
          37523: 39376,
          37524: 27159,
          37525: 28710,
          37526: 29482,
          37527: 33511,
          37528: 33879,
          37529: 36015,
          37530: 19969,
          37531: 20806,
          37532: 20939,
          37533: 21899,
          37534: 23541,
          37535: 24086,
          37536: 24115,
          37537: 24193,
          37538: 24340,
          37539: 24373,
          37540: 24427,
          37541: 24500,
          37542: 25074,
          37543: 25361,
          37544: 26274,
          37545: 26397,
          37546: 28526,
          37547: 29266,
          37548: 30010,
          37549: 30522,
          37550: 32884,
          37551: 33081,
          37552: 33144,
          37553: 34678,
          37554: 35519,
          37555: 35548,
          37556: 36229,
          37557: 36339,
          37558: 37530,
          37559: 38263,
          37560: 38914,
          37561: 40165,
          37562: 21189,
          37563: 25431,
          37564: 30452,
          37565: 26389,
          37566: 27784,
          37567: 29645,
          37568: 36035,
          37569: 37806,
          37570: 38515,
          37571: 27941,
          37572: 22684,
          37573: 26894,
          37574: 27084,
          37575: 36861,
          37576: 37786,
          37577: 30171,
          37578: 36890,
          37579: 22618,
          37580: 26626,
          37581: 25524,
          37582: 27131,
          37583: 20291,
          37584: 28460,
          37585: 26584,
          37586: 36795,
          37587: 34086,
          37588: 32180,
          37589: 37716,
          37590: 26943,
          37591: 28528,
          37592: 22378,
          37593: 22775,
          37594: 23340,
          37595: 32044,
          37596: 29226,
          37597: 21514,
          37598: 37347,
          37599: 40372,
          37600: 20141,
          37601: 20302,
          37602: 20572,
          37603: 20597,
          37604: 21059,
          37605: 35998,
          37606: 21576,
          37607: 22564,
          37608: 23450,
          37609: 24093,
          37610: 24213,
          37611: 24237,
          37612: 24311,
          37613: 24351,
          37614: 24716,
          37615: 25269,
          37616: 25402,
          37617: 25552,
          37618: 26799,
          37619: 27712,
          37620: 30855,
          37621: 31118,
          37622: 31243,
          37623: 32224,
          37624: 33351,
          37625: 35330,
          37626: 35558,
          37627: 36420,
          37628: 36883,
          37696: 37048,
          37697: 37165,
          37698: 37336,
          37699: 40718,
          37700: 27877,
          37701: 25688,
          37702: 25826,
          37703: 25973,
          37704: 28404,
          37705: 30340,
          37706: 31515,
          37707: 36969,
          37708: 37841,
          37709: 28346,
          37710: 21746,
          37711: 24505,
          37712: 25764,
          37713: 36685,
          37714: 36845,
          37715: 37444,
          37716: 20856,
          37717: 22635,
          37718: 22825,
          37719: 23637,
          37720: 24215,
          37721: 28155,
          37722: 32399,
          37723: 29980,
          37724: 36028,
          37725: 36578,
          37726: 39003,
          37727: 28857,
          37728: 20253,
          37729: 27583,
          37730: 28593,
          37731: 30000,
          37732: 38651,
          37733: 20814,
          37734: 21520,
          37735: 22581,
          37736: 22615,
          37737: 22956,
          37738: 23648,
          37739: 24466,
          37740: 26007,
          37741: 26460,
          37742: 28193,
          37743: 30331,
          37744: 33759,
          37745: 36077,
          37746: 36884,
          37747: 37117,
          37748: 37709,
          37749: 30757,
          37750: 30778,
          37751: 21162,
          37752: 24230,
          37753: 22303,
          37754: 22900,
          37755: 24594,
          37756: 20498,
          37757: 20826,
          37758: 20908,
          37760: 20941,
          37761: 20992,
          37762: 21776,
          37763: 22612,
          37764: 22616,
          37765: 22871,
          37766: 23445,
          37767: 23798,
          37768: 23947,
          37769: 24764,
          37770: 25237,
          37771: 25645,
          37772: 26481,
          37773: 26691,
          37774: 26812,
          37775: 26847,
          37776: 30423,
          37777: 28120,
          37778: 28271,
          37779: 28059,
          37780: 28783,
          37781: 29128,
          37782: 24403,
          37783: 30168,
          37784: 31095,
          37785: 31561,
          37786: 31572,
          37787: 31570,
          37788: 31958,
          37789: 32113,
          37790: 21040,
          37791: 33891,
          37792: 34153,
          37793: 34276,
          37794: 35342,
          37795: 35588,
          37796: 35910,
          37797: 36367,
          37798: 36867,
          37799: 36879,
          37800: 37913,
          37801: 38518,
          37802: 38957,
          37803: 39472,
          37804: 38360,
          37805: 20685,
          37806: 21205,
          37807: 21516,
          37808: 22530,
          37809: 23566,
          37810: 24999,
          37811: 25758,
          37812: 27934,
          37813: 30643,
          37814: 31461,
          37815: 33012,
          37816: 33796,
          37817: 36947,
          37818: 37509,
          37819: 23776,
          37820: 40199,
          37821: 21311,
          37822: 24471,
          37823: 24499,
          37824: 28060,
          37825: 29305,
          37826: 30563,
          37827: 31167,
          37828: 31716,
          37829: 27602,
          37830: 29420,
          37831: 35501,
          37832: 26627,
          37833: 27233,
          37834: 20984,
          37835: 31361,
          37836: 26932,
          37837: 23626,
          37838: 40182,
          37839: 33515,
          37840: 23493,
          37841: 37193,
          37842: 28702,
          37843: 22136,
          37844: 23663,
          37845: 24775,
          37846: 25958,
          37847: 27788,
          37848: 35930,
          37849: 36929,
          37850: 38931,
          37851: 21585,
          37852: 26311,
          37853: 37389,
          37854: 22856,
          37855: 37027,
          37856: 20869,
          37857: 20045,
          37858: 20970,
          37859: 34201,
          37860: 35598,
          37861: 28760,
          37862: 25466,
          37863: 37707,
          37864: 26978,
          37865: 39348,
          37866: 32260,
          37867: 30071,
          37868: 21335,
          37869: 26976,
          37870: 36575,
          37871: 38627,
          37872: 27741,
          37873: 20108,
          37874: 23612,
          37875: 24336,
          37876: 36841,
          37877: 21250,
          37878: 36049,
          37879: 32905,
          37880: 34425,
          37881: 24319,
          37882: 26085,
          37883: 20083,
          37884: 20837,
          37952: 22914,
          37953: 23615,
          37954: 38894,
          37955: 20219,
          37956: 22922,
          37957: 24525,
          37958: 35469,
          37959: 28641,
          37960: 31152,
          37961: 31074,
          37962: 23527,
          37963: 33905,
          37964: 29483,
          37965: 29105,
          37966: 24180,
          37967: 24565,
          37968: 25467,
          37969: 25754,
          37970: 29123,
          37971: 31896,
          37972: 20035,
          37973: 24316,
          37974: 20043,
          37975: 22492,
          37976: 22178,
          37977: 24745,
          37978: 28611,
          37979: 32013,
          37980: 33021,
          37981: 33075,
          37982: 33215,
          37983: 36786,
          37984: 35223,
          37985: 34468,
          37986: 24052,
          37987: 25226,
          37988: 25773,
          37989: 35207,
          37990: 26487,
          37991: 27874,
          37992: 27966,
          37993: 29750,
          37994: 30772,
          37995: 23110,
          37996: 32629,
          37997: 33453,
          37998: 39340,
          37999: 20467,
          38000: 24259,
          38001: 25309,
          38002: 25490,
          38003: 25943,
          38004: 26479,
          38005: 30403,
          38006: 29260,
          38007: 32972,
          38008: 32954,
          38009: 36649,
          38010: 37197,
          38011: 20493,
          38012: 22521,
          38013: 23186,
          38014: 26757,
          38016: 26995,
          38017: 29028,
          38018: 29437,
          38019: 36023,
          38020: 22770,
          38021: 36064,
          38022: 38506,
          38023: 36889,
          38024: 34687,
          38025: 31204,
          38026: 30695,
          38027: 33833,
          38028: 20271,
          38029: 21093,
          38030: 21338,
          38031: 25293,
          38032: 26575,
          38033: 27850,
          38034: 30333,
          38035: 31636,
          38036: 31893,
          38037: 33334,
          38038: 34180,
          38039: 36843,
          38040: 26333,
          38041: 28448,
          38042: 29190,
          38043: 32283,
          38044: 33707,
          38045: 39361,
          38046: 40614,
          38047: 20989,
          38048: 31665,
          38049: 30834,
          38050: 31672,
          38051: 32903,
          38052: 31560,
          38053: 27368,
          38054: 24161,
          38055: 32908,
          38056: 30033,
          38057: 30048,
          38058: 20843,
          38059: 37474,
          38060: 28300,
          38061: 30330,
          38062: 37271,
          38063: 39658,
          38064: 20240,
          38065: 32624,
          38066: 25244,
          38067: 31567,
          38068: 38309,
          38069: 40169,
          38070: 22138,
          38071: 22617,
          38072: 34532,
          38073: 38588,
          38074: 20276,
          38075: 21028,
          38076: 21322,
          38077: 21453,
          38078: 21467,
          38079: 24070,
          38080: 25644,
          38081: 26001,
          38082: 26495,
          38083: 27710,
          38084: 27726,
          38085: 29256,
          38086: 29359,
          38087: 29677,
          38088: 30036,
          38089: 32321,
          38090: 33324,
          38091: 34281,
          38092: 36009,
          38093: 31684,
          38094: 37318,
          38095: 29033,
          38096: 38930,
          38097: 39151,
          38098: 25405,
          38099: 26217,
          38100: 30058,
          38101: 30436,
          38102: 30928,
          38103: 34115,
          38104: 34542,
          38105: 21290,
          38106: 21329,
          38107: 21542,
          38108: 22915,
          38109: 24199,
          38110: 24444,
          38111: 24754,
          38112: 25161,
          38113: 25209,
          38114: 25259,
          38115: 26000,
          38116: 27604,
          38117: 27852,
          38118: 30130,
          38119: 30382,
          38120: 30865,
          38121: 31192,
          38122: 32203,
          38123: 32631,
          38124: 32933,
          38125: 34987,
          38126: 35513,
          38127: 36027,
          38128: 36991,
          38129: 38750,
          38130: 39131,
          38131: 27147,
          38132: 31800,
          38133: 20633,
          38134: 23614,
          38135: 24494,
          38136: 26503,
          38137: 27608,
          38138: 29749,
          38139: 30473,
          38140: 32654,
          38208: 40763,
          38209: 26570,
          38210: 31255,
          38211: 21305,
          38212: 30091,
          38213: 39661,
          38214: 24422,
          38215: 33181,
          38216: 33777,
          38217: 32920,
          38218: 24380,
          38219: 24517,
          38220: 30050,
          38221: 31558,
          38222: 36924,
          38223: 26727,
          38224: 23019,
          38225: 23195,
          38226: 32016,
          38227: 30334,
          38228: 35628,
          38229: 20469,
          38230: 24426,
          38231: 27161,
          38232: 27703,
          38233: 28418,
          38234: 29922,
          38235: 31080,
          38236: 34920,
          38237: 35413,
          38238: 35961,
          38239: 24287,
          38240: 25551,
          38241: 30149,
          38242: 31186,
          38243: 33495,
          38244: 37672,
          38245: 37618,
          38246: 33948,
          38247: 34541,
          38248: 39981,
          38249: 21697,
          38250: 24428,
          38251: 25996,
          38252: 27996,
          38253: 28693,
          38254: 36007,
          38255: 36051,
          38256: 38971,
          38257: 25935,
          38258: 29942,
          38259: 19981,
          38260: 20184,
          38261: 22496,
          38262: 22827,
          38263: 23142,
          38264: 23500,
          38265: 20904,
          38266: 24067,
          38267: 24220,
          38268: 24598,
          38269: 25206,
          38270: 25975,
          38272: 26023,
          38273: 26222,
          38274: 28014,
          38275: 29238,
          38276: 31526,
          38277: 33104,
          38278: 33178,
          38279: 33433,
          38280: 35676,
          38281: 36000,
          38282: 36070,
          38283: 36212,
          38284: 38428,
          38285: 38468,
          38286: 20398,
          38287: 25771,
          38288: 27494,
          38289: 33310,
          38290: 33889,
          38291: 34154,
          38292: 37096,
          38293: 23553,
          38294: 26963,
          38295: 39080,
          38296: 33914,
          38297: 34135,
          38298: 20239,
          38299: 21103,
          38300: 24489,
          38301: 24133,
          38302: 26381,
          38303: 31119,
          38304: 33145,
          38305: 35079,
          38306: 35206,
          38307: 28149,
          38308: 24343,
          38309: 25173,
          38310: 27832,
          38311: 20175,
          38312: 29289,
          38313: 39826,
          38314: 20998,
          38315: 21563,
          38316: 22132,
          38317: 22707,
          38318: 24996,
          38319: 25198,
          38320: 28954,
          38321: 22894,
          38322: 31881,
          38323: 31966,
          38324: 32027,
          38325: 38640,
          38326: 25991,
          38327: 32862,
          38328: 19993,
          38329: 20341,
          38330: 20853,
          38331: 22592,
          38332: 24163,
          38333: 24179,
          38334: 24330,
          38335: 26564,
          38336: 20006,
          38337: 34109,
          38338: 38281,
          38339: 38491,
          38340: 31859,
          38341: 38913,
          38342: 20731,
          38343: 22721,
          38344: 30294,
          38345: 30887,
          38346: 21029,
          38347: 30629,
          38348: 34065,
          38349: 31622,
          38350: 20559,
          38351: 22793,
          38352: 29255,
          38353: 31687,
          38354: 32232,
          38355: 36794,
          38356: 36820,
          38357: 36941,
          38358: 20415,
          38359: 21193,
          38360: 23081,
          38361: 24321,
          38362: 38829,
          38363: 20445,
          38364: 33303,
          38365: 37610,
          38366: 22275,
          38367: 25429,
          38368: 27497,
          38369: 29995,
          38370: 35036,
          38371: 36628,
          38372: 31298,
          38373: 21215,
          38374: 22675,
          38375: 24917,
          38376: 25098,
          38377: 26286,
          38378: 27597,
          38379: 31807,
          38380: 33769,
          38381: 20515,
          38382: 20472,
          38383: 21253,
          38384: 21574,
          38385: 22577,
          38386: 22857,
          38387: 23453,
          38388: 23792,
          38389: 23791,
          38390: 23849,
          38391: 24214,
          38392: 25265,
          38393: 25447,
          38394: 25918,
          38395: 26041,
          38396: 26379,
          38464: 27861,
          38465: 27873,
          38466: 28921,
          38467: 30770,
          38468: 32299,
          38469: 32990,
          38470: 33459,
          38471: 33804,
          38472: 34028,
          38473: 34562,
          38474: 35090,
          38475: 35370,
          38476: 35914,
          38477: 37030,
          38478: 37586,
          38479: 39165,
          38480: 40179,
          38481: 40300,
          38482: 20047,
          38483: 20129,
          38484: 20621,
          38485: 21078,
          38486: 22346,
          38487: 22952,
          38488: 24125,
          38489: 24536,
          38490: 24537,
          38491: 25151,
          38492: 26292,
          38493: 26395,
          38494: 26576,
          38495: 26834,
          38496: 20882,
          38497: 32033,
          38498: 32938,
          38499: 33192,
          38500: 35584,
          38501: 35980,
          38502: 36031,
          38503: 37502,
          38504: 38450,
          38505: 21536,
          38506: 38956,
          38507: 21271,
          38508: 20693,
          38509: 21340,
          38510: 22696,
          38511: 25778,
          38512: 26420,
          38513: 29287,
          38514: 30566,
          38515: 31302,
          38516: 37350,
          38517: 21187,
          38518: 27809,
          38519: 27526,
          38520: 22528,
          38521: 24140,
          38522: 22868,
          38523: 26412,
          38524: 32763,
          38525: 20961,
          38526: 30406,
          38528: 25705,
          38529: 30952,
          38530: 39764,
          38531: 40635,
          38532: 22475,
          38533: 22969,
          38534: 26151,
          38535: 26522,
          38536: 27598,
          38537: 21737,
          38538: 27097,
          38539: 24149,
          38540: 33180,
          38541: 26517,
          38542: 39850,
          38543: 26622,
          38544: 40018,
          38545: 26717,
          38546: 20134,
          38547: 20451,
          38548: 21448,
          38549: 25273,
          38550: 26411,
          38551: 27819,
          38552: 36804,
          38553: 20397,
          38554: 32365,
          38555: 40639,
          38556: 19975,
          38557: 24930,
          38558: 28288,
          38559: 28459,
          38560: 34067,
          38561: 21619,
          38562: 26410,
          38563: 39749,
          38564: 24051,
          38565: 31637,
          38566: 23724,
          38567: 23494,
          38568: 34588,
          38569: 28234,
          38570: 34001,
          38571: 31252,
          38572: 33032,
          38573: 22937,
          38574: 31885,
          38575: 27665,
          38576: 30496,
          38577: 21209,
          38578: 22818,
          38579: 28961,
          38580: 29279,
          38581: 30683,
          38582: 38695,
          38583: 40289,
          38584: 26891,
          38585: 23167,
          38586: 23064,
          38587: 20901,
          38588: 21517,
          38589: 21629,
          38590: 26126,
          38591: 30431,
          38592: 36855,
          38593: 37528,
          38594: 40180,
          38595: 23018,
          38596: 29277,
          38597: 28357,
          38598: 20813,
          38599: 26825,
          38600: 32191,
          38601: 32236,
          38602: 38754,
          38603: 40634,
          38604: 25720,
          38605: 27169,
          38606: 33538,
          38607: 22916,
          38608: 23391,
          38609: 27611,
          38610: 29467,
          38611: 30450,
          38612: 32178,
          38613: 32791,
          38614: 33945,
          38615: 20786,
          38616: 26408,
          38617: 40665,
          38618: 30446,
          38619: 26466,
          38620: 21247,
          38621: 39173,
          38622: 23588,
          38623: 25147,
          38624: 31870,
          38625: 36016,
          38626: 21839,
          38627: 24758,
          38628: 32011,
          38629: 38272,
          38630: 21249,
          38631: 20063,
          38632: 20918,
          38633: 22812,
          38634: 29242,
          38635: 32822,
          38636: 37326,
          38637: 24357,
          38638: 30690,
          38639: 21380,
          38640: 24441,
          38641: 32004,
          38642: 34220,
          38643: 35379,
          38644: 36493,
          38645: 38742,
          38646: 26611,
          38647: 34222,
          38648: 37971,
          38649: 24841,
          38650: 24840,
          38651: 27833,
          38652: 30290,
          38720: 35565,
          38721: 36664,
          38722: 21807,
          38723: 20305,
          38724: 20778,
          38725: 21191,
          38726: 21451,
          38727: 23461,
          38728: 24189,
          38729: 24736,
          38730: 24962,
          38731: 25558,
          38732: 26377,
          38733: 26586,
          38734: 28263,
          38735: 28044,
          38736: 29494,
          38737: 29495,
          38738: 30001,
          38739: 31056,
          38740: 35029,
          38741: 35480,
          38742: 36938,
          38743: 37009,
          38744: 37109,
          38745: 38596,
          38746: 34701,
          38747: 22805,
          38748: 20104,
          38749: 20313,
          38750: 19982,
          38751: 35465,
          38752: 36671,
          38753: 38928,
          38754: 20653,
          38755: 24188,
          38756: 22934,
          38757: 23481,
          38758: 24248,
          38759: 25562,
          38760: 25594,
          38761: 25793,
          38762: 26332,
          38763: 26954,
          38764: 27096,
          38765: 27915,
          38766: 28342,
          38767: 29076,
          38768: 29992,
          38769: 31407,
          38770: 32650,
          38771: 32768,
          38772: 33865,
          38773: 33993,
          38774: 35201,
          38775: 35617,
          38776: 36362,
          38777: 36965,
          38778: 38525,
          38779: 39178,
          38780: 24958,
          38781: 25233,
          38782: 27442,
          38784: 27779,
          38785: 28020,
          38786: 32716,
          38787: 32764,
          38788: 28096,
          38789: 32645,
          38790: 34746,
          38791: 35064,
          38792: 26469,
          38793: 33713,
          38794: 38972,
          38795: 38647,
          38796: 27931,
          38797: 32097,
          38798: 33853,
          38799: 37226,
          38800: 20081,
          38801: 21365,
          38802: 23888,
          38803: 27396,
          38804: 28651,
          38805: 34253,
          38806: 34349,
          38807: 35239,
          38808: 21033,
          38809: 21519,
          38810: 23653,
          38811: 26446,
          38812: 26792,
          38813: 29702,
          38814: 29827,
          38815: 30178,
          38816: 35023,
          38817: 35041,
          38818: 37324,
          38819: 38626,
          38820: 38520,
          38821: 24459,
          38822: 29575,
          38823: 31435,
          38824: 33870,
          38825: 25504,
          38826: 30053,
          38827: 21129,
          38828: 27969,
          38829: 28316,
          38830: 29705,
          38831: 30041,
          38832: 30827,
          38833: 31890,
          38834: 38534,
          38835: 31452,
          38836: 40845,
          38837: 20406,
          38838: 24942,
          38839: 26053,
          38840: 34396,
          38841: 20102,
          38842: 20142,
          38843: 20698,
          38844: 20001,
          38845: 20940,
          38846: 23534,
          38847: 26009,
          38848: 26753,
          38849: 28092,
          38850: 29471,
          38851: 30274,
          38852: 30637,
          38853: 31260,
          38854: 31975,
          38855: 33391,
          38856: 35538,
          38857: 36988,
          38858: 37327,
          38859: 38517,
          38860: 38936,
          38861: 21147,
          38862: 32209,
          38863: 20523,
          38864: 21400,
          38865: 26519,
          38866: 28107,
          38867: 29136,
          38868: 29747,
          38869: 33256,
          38870: 36650,
          38871: 38563,
          38872: 40023,
          38873: 40607,
          38874: 29792,
          38875: 22593,
          38876: 28057,
          38877: 32047,
          38878: 39006,
          38879: 20196,
          38880: 20278,
          38881: 20363,
          38882: 20919,
          38883: 21169,
          38884: 23994,
          38885: 24604,
          38886: 29618,
          38887: 31036,
          38888: 33491,
          38889: 37428,
          38890: 38583,
          38891: 38646,
          38892: 38666,
          38893: 40599,
          38894: 40802,
          38895: 26278,
          38896: 27508,
          38897: 21015,
          38898: 21155,
          38899: 28872,
          38900: 35010,
          38901: 24265,
          38902: 24651,
          38903: 24976,
          38904: 28451,
          38905: 29001,
          38906: 31806,
          38907: 32244,
          38908: 32879,
          38976: 34030,
          38977: 36899,
          38978: 37676,
          38979: 21570,
          38980: 39791,
          38981: 27347,
          38982: 28809,
          38983: 36034,
          38984: 36335,
          38985: 38706,
          38986: 21172,
          38987: 23105,
          38988: 24266,
          38989: 24324,
          38990: 26391,
          38991: 27004,
          38992: 27028,
          38993: 28010,
          38994: 28431,
          38995: 29282,
          38996: 29436,
          38997: 31725,
          38998: 32769,
          38999: 32894,
          39000: 34635,
          39001: 37070,
          39002: 20845,
          39003: 40595,
          39004: 31108,
          39005: 32907,
          39006: 37682,
          39007: 35542,
          39008: 20525,
          39009: 21644,
          39010: 35441,
          39011: 27498,
          39012: 36036,
          39013: 33031,
          39014: 24785,
          39015: 26528,
          39016: 40434,
          39017: 20121,
          39018: 20120,
          39019: 39952,
          39020: 35435,
          39021: 34241,
          39022: 34152,
          39023: 26880,
          39024: 28286,
          39025: 30871,
          39026: 33109,
          39071: 24332,
          39072: 19984,
          39073: 19989,
          39074: 20010,
          39075: 20017,
          39076: 20022,
          39077: 20028,
          39078: 20031,
          39079: 20034,
          39080: 20054,
          39081: 20056,
          39082: 20098,
          39083: 20101,
          39084: 35947,
          39085: 20106,
          39086: 33298,
          39087: 24333,
          39088: 20110,
          39089: 20126,
          39090: 20127,
          39091: 20128,
          39092: 20130,
          39093: 20144,
          39094: 20147,
          39095: 20150,
          39096: 20174,
          39097: 20173,
          39098: 20164,
          39099: 20166,
          39100: 20162,
          39101: 20183,
          39102: 20190,
          39103: 20205,
          39104: 20191,
          39105: 20215,
          39106: 20233,
          39107: 20314,
          39108: 20272,
          39109: 20315,
          39110: 20317,
          39111: 20311,
          39112: 20295,
          39113: 20342,
          39114: 20360,
          39115: 20367,
          39116: 20376,
          39117: 20347,
          39118: 20329,
          39119: 20336,
          39120: 20369,
          39121: 20335,
          39122: 20358,
          39123: 20374,
          39124: 20760,
          39125: 20436,
          39126: 20447,
          39127: 20430,
          39128: 20440,
          39129: 20443,
          39130: 20433,
          39131: 20442,
          39132: 20432,
          39133: 20452,
          39134: 20453,
          39135: 20506,
          39136: 20520,
          39137: 20500,
          39138: 20522,
          39139: 20517,
          39140: 20485,
          39141: 20252,
          39142: 20470,
          39143: 20513,
          39144: 20521,
          39145: 20524,
          39146: 20478,
          39147: 20463,
          39148: 20497,
          39149: 20486,
          39150: 20547,
          39151: 20551,
          39152: 26371,
          39153: 20565,
          39154: 20560,
          39155: 20552,
          39156: 20570,
          39157: 20566,
          39158: 20588,
          39159: 20600,
          39160: 20608,
          39161: 20634,
          39162: 20613,
          39163: 20660,
          39164: 20658,
          39232: 20681,
          39233: 20682,
          39234: 20659,
          39235: 20674,
          39236: 20694,
          39237: 20702,
          39238: 20709,
          39239: 20717,
          39240: 20707,
          39241: 20718,
          39242: 20729,
          39243: 20725,
          39244: 20745,
          39245: 20737,
          39246: 20738,
          39247: 20758,
          39248: 20757,
          39249: 20756,
          39250: 20762,
          39251: 20769,
          39252: 20794,
          39253: 20791,
          39254: 20796,
          39255: 20795,
          39256: 20799,
          39257: 20800,
          39258: 20818,
          39259: 20812,
          39260: 20820,
          39261: 20834,
          39262: 31480,
          39263: 20841,
          39264: 20842,
          39265: 20846,
          39266: 20864,
          39267: 20866,
          39268: 22232,
          39269: 20876,
          39270: 20873,
          39271: 20879,
          39272: 20881,
          39273: 20883,
          39274: 20885,
          39275: 20886,
          39276: 20900,
          39277: 20902,
          39278: 20898,
          39279: 20905,
          39280: 20906,
          39281: 20907,
          39282: 20915,
          39283: 20913,
          39284: 20914,
          39285: 20912,
          39286: 20917,
          39287: 20925,
          39288: 20933,
          39289: 20937,
          39290: 20955,
          39291: 20960,
          39292: 34389,
          39293: 20969,
          39294: 20973,
          39296: 20976,
          39297: 20981,
          39298: 20990,
          39299: 20996,
          39300: 21003,
          39301: 21012,
          39302: 21006,
          39303: 21031,
          39304: 21034,
          39305: 21038,
          39306: 21043,
          39307: 21049,
          39308: 21071,
          39309: 21060,
          39310: 21067,
          39311: 21068,
          39312: 21086,
          39313: 21076,
          39314: 21098,
          39315: 21108,
          39316: 21097,
          39317: 21107,
          39318: 21119,
          39319: 21117,
          39320: 21133,
          39321: 21140,
          39322: 21138,
          39323: 21105,
          39324: 21128,
          39325: 21137,
          39326: 36776,
          39327: 36775,
          39328: 21164,
          39329: 21165,
          39330: 21180,
          39331: 21173,
          39332: 21185,
          39333: 21197,
          39334: 21207,
          39335: 21214,
          39336: 21219,
          39337: 21222,
          39338: 39149,
          39339: 21216,
          39340: 21235,
          39341: 21237,
          39342: 21240,
          39343: 21241,
          39344: 21254,
          39345: 21256,
          39346: 30008,
          39347: 21261,
          39348: 21264,
          39349: 21263,
          39350: 21269,
          39351: 21274,
          39352: 21283,
          39353: 21295,
          39354: 21297,
          39355: 21299,
          39356: 21304,
          39357: 21312,
          39358: 21318,
          39359: 21317,
          39360: 19991,
          39361: 21321,
          39362: 21325,
          39363: 20950,
          39364: 21342,
          39365: 21353,
          39366: 21358,
          39367: 22808,
          39368: 21371,
          39369: 21367,
          39370: 21378,
          39371: 21398,
          39372: 21408,
          39373: 21414,
          39374: 21413,
          39375: 21422,
          39376: 21424,
          39377: 21430,
          39378: 21443,
          39379: 31762,
          39380: 38617,
          39381: 21471,
          39382: 26364,
          39383: 29166,
          39384: 21486,
          39385: 21480,
          39386: 21485,
          39387: 21498,
          39388: 21505,
          39389: 21565,
          39390: 21568,
          39391: 21548,
          39392: 21549,
          39393: 21564,
          39394: 21550,
          39395: 21558,
          39396: 21545,
          39397: 21533,
          39398: 21582,
          39399: 21647,
          39400: 21621,
          39401: 21646,
          39402: 21599,
          39403: 21617,
          39404: 21623,
          39405: 21616,
          39406: 21650,
          39407: 21627,
          39408: 21632,
          39409: 21622,
          39410: 21636,
          39411: 21648,
          39412: 21638,
          39413: 21703,
          39414: 21666,
          39415: 21688,
          39416: 21669,
          39417: 21676,
          39418: 21700,
          39419: 21704,
          39420: 21672,
          39488: 21675,
          39489: 21698,
          39490: 21668,
          39491: 21694,
          39492: 21692,
          39493: 21720,
          39494: 21733,
          39495: 21734,
          39496: 21775,
          39497: 21780,
          39498: 21757,
          39499: 21742,
          39500: 21741,
          39501: 21754,
          39502: 21730,
          39503: 21817,
          39504: 21824,
          39505: 21859,
          39506: 21836,
          39507: 21806,
          39508: 21852,
          39509: 21829,
          39510: 21846,
          39511: 21847,
          39512: 21816,
          39513: 21811,
          39514: 21853,
          39515: 21913,
          39516: 21888,
          39517: 21679,
          39518: 21898,
          39519: 21919,
          39520: 21883,
          39521: 21886,
          39522: 21912,
          39523: 21918,
          39524: 21934,
          39525: 21884,
          39526: 21891,
          39527: 21929,
          39528: 21895,
          39529: 21928,
          39530: 21978,
          39531: 21957,
          39532: 21983,
          39533: 21956,
          39534: 21980,
          39535: 21988,
          39536: 21972,
          39537: 22036,
          39538: 22007,
          39539: 22038,
          39540: 22014,
          39541: 22013,
          39542: 22043,
          39543: 22009,
          39544: 22094,
          39545: 22096,
          39546: 29151,
          39547: 22068,
          39548: 22070,
          39549: 22066,
          39550: 22072,
          39552: 22123,
          39553: 22116,
          39554: 22063,
          39555: 22124,
          39556: 22122,
          39557: 22150,
          39558: 22144,
          39559: 22154,
          39560: 22176,
          39561: 22164,
          39562: 22159,
          39563: 22181,
          39564: 22190,
          39565: 22198,
          39566: 22196,
          39567: 22210,
          39568: 22204,
          39569: 22209,
          39570: 22211,
          39571: 22208,
          39572: 22216,
          39573: 22222,
          39574: 22225,
          39575: 22227,
          39576: 22231,
          39577: 22254,
          39578: 22265,
          39579: 22272,
          39580: 22271,
          39581: 22276,
          39582: 22281,
          39583: 22280,
          39584: 22283,
          39585: 22285,
          39586: 22291,
          39587: 22296,
          39588: 22294,
          39589: 21959,
          39590: 22300,
          39591: 22310,
          39592: 22327,
          39593: 22328,
          39594: 22350,
          39595: 22331,
          39596: 22336,
          39597: 22351,
          39598: 22377,
          39599: 22464,
          39600: 22408,
          39601: 22369,
          39602: 22399,
          39603: 22409,
          39604: 22419,
          39605: 22432,
          39606: 22451,
          39607: 22436,
          39608: 22442,
          39609: 22448,
          39610: 22467,
          39611: 22470,
          39612: 22484,
          39613: 22482,
          39614: 22483,
          39615: 22538,
          39616: 22486,
          39617: 22499,
          39618: 22539,
          39619: 22553,
          39620: 22557,
          39621: 22642,
          39622: 22561,
          39623: 22626,
          39624: 22603,
          39625: 22640,
          39626: 27584,
          39627: 22610,
          39628: 22589,
          39629: 22649,
          39630: 22661,
          39631: 22713,
          39632: 22687,
          39633: 22699,
          39634: 22714,
          39635: 22750,
          39636: 22715,
          39637: 22712,
          39638: 22702,
          39639: 22725,
          39640: 22739,
          39641: 22737,
          39642: 22743,
          39643: 22745,
          39644: 22744,
          39645: 22757,
          39646: 22748,
          39647: 22756,
          39648: 22751,
          39649: 22767,
          39650: 22778,
          39651: 22777,
          39652: 22779,
          39653: 22780,
          39654: 22781,
          39655: 22786,
          39656: 22794,
          39657: 22800,
          39658: 22811,
          39659: 26790,
          39660: 22821,
          39661: 22828,
          39662: 22829,
          39663: 22834,
          39664: 22840,
          39665: 22846,
          39666: 31442,
          39667: 22869,
          39668: 22864,
          39669: 22862,
          39670: 22874,
          39671: 22872,
          39672: 22882,
          39673: 22880,
          39674: 22887,
          39675: 22892,
          39676: 22889,
          39744: 22904,
          39745: 22913,
          39746: 22941,
          39747: 20318,
          39748: 20395,
          39749: 22947,
          39750: 22962,
          39751: 22982,
          39752: 23016,
          39753: 23004,
          39754: 22925,
          39755: 23001,
          39756: 23002,
          39757: 23077,
          39758: 23071,
          39759: 23057,
          39760: 23068,
          39761: 23049,
          39762: 23066,
          39763: 23104,
          39764: 23148,
          39765: 23113,
          39766: 23093,
          39767: 23094,
          39768: 23138,
          39769: 23146,
          39770: 23194,
          39771: 23228,
          39772: 23230,
          39773: 23243,
          39774: 23234,
          39775: 23229,
          39776: 23267,
          39777: 23255,
          39778: 23270,
          39779: 23273,
          39780: 23254,
          39781: 23290,
          39782: 23291,
          39783: 23308,
          39784: 23307,
          39785: 23318,
          39786: 23346,
          39787: 23248,
          39788: 23338,
          39789: 23350,
          39790: 23358,
          39791: 23363,
          39792: 23365,
          39793: 23360,
          39794: 23377,
          39795: 23381,
          39796: 23386,
          39797: 23387,
          39798: 23397,
          39799: 23401,
          39800: 23408,
          39801: 23411,
          39802: 23413,
          39803: 23416,
          39804: 25992,
          39805: 23418,
          39806: 23424,
          39808: 23427,
          39809: 23462,
          39810: 23480,
          39811: 23491,
          39812: 23495,
          39813: 23497,
          39814: 23508,
          39815: 23504,
          39816: 23524,
          39817: 23526,
          39818: 23522,
          39819: 23518,
          39820: 23525,
          39821: 23531,
          39822: 23536,
          39823: 23542,
          39824: 23539,
          39825: 23557,
          39826: 23559,
          39827: 23560,
          39828: 23565,
          39829: 23571,
          39830: 23584,
          39831: 23586,
          39832: 23592,
          39833: 23608,
          39834: 23609,
          39835: 23617,
          39836: 23622,
          39837: 23630,
          39838: 23635,
          39839: 23632,
          39840: 23631,
          39841: 23409,
          39842: 23660,
          39843: 23662,
          39844: 20066,
          39845: 23670,
          39846: 23673,
          39847: 23692,
          39848: 23697,
          39849: 23700,
          39850: 22939,
          39851: 23723,
          39852: 23739,
          39853: 23734,
          39854: 23740,
          39855: 23735,
          39856: 23749,
          39857: 23742,
          39858: 23751,
          39859: 23769,
          39860: 23785,
          39861: 23805,
          39862: 23802,
          39863: 23789,
          39864: 23948,
          39865: 23786,
          39866: 23819,
          39867: 23829,
          39868: 23831,
          39869: 23900,
          39870: 23839,
          39871: 23835,
          39872: 23825,
          39873: 23828,
          39874: 23842,
          39875: 23834,
          39876: 23833,
          39877: 23832,
          39878: 23884,
          39879: 23890,
          39880: 23886,
          39881: 23883,
          39882: 23916,
          39883: 23923,
          39884: 23926,
          39885: 23943,
          39886: 23940,
          39887: 23938,
          39888: 23970,
          39889: 23965,
          39890: 23980,
          39891: 23982,
          39892: 23997,
          39893: 23952,
          39894: 23991,
          39895: 23996,
          39896: 24009,
          39897: 24013,
          39898: 24019,
          39899: 24018,
          39900: 24022,
          39901: 24027,
          39902: 24043,
          39903: 24050,
          39904: 24053,
          39905: 24075,
          39906: 24090,
          39907: 24089,
          39908: 24081,
          39909: 24091,
          39910: 24118,
          39911: 24119,
          39912: 24132,
          39913: 24131,
          39914: 24128,
          39915: 24142,
          39916: 24151,
          39917: 24148,
          39918: 24159,
          39919: 24162,
          39920: 24164,
          39921: 24135,
          39922: 24181,
          39923: 24182,
          39924: 24186,
          39925: 40636,
          39926: 24191,
          39927: 24224,
          39928: 24257,
          39929: 24258,
          39930: 24264,
          39931: 24272,
          39932: 24271,
          40000: 24278,
          40001: 24291,
          40002: 24285,
          40003: 24282,
          40004: 24283,
          40005: 24290,
          40006: 24289,
          40007: 24296,
          40008: 24297,
          40009: 24300,
          40010: 24305,
          40011: 24307,
          40012: 24304,
          40013: 24308,
          40014: 24312,
          40015: 24318,
          40016: 24323,
          40017: 24329,
          40018: 24413,
          40019: 24412,
          40020: 24331,
          40021: 24337,
          40022: 24342,
          40023: 24361,
          40024: 24365,
          40025: 24376,
          40026: 24385,
          40027: 24392,
          40028: 24396,
          40029: 24398,
          40030: 24367,
          40031: 24401,
          40032: 24406,
          40033: 24407,
          40034: 24409,
          40035: 24417,
          40036: 24429,
          40037: 24435,
          40038: 24439,
          40039: 24451,
          40040: 24450,
          40041: 24447,
          40042: 24458,
          40043: 24456,
          40044: 24465,
          40045: 24455,
          40046: 24478,
          40047: 24473,
          40048: 24472,
          40049: 24480,
          40050: 24488,
          40051: 24493,
          40052: 24508,
          40053: 24534,
          40054: 24571,
          40055: 24548,
          40056: 24568,
          40057: 24561,
          40058: 24541,
          40059: 24755,
          40060: 24575,
          40061: 24609,
          40062: 24672,
          40064: 24601,
          40065: 24592,
          40066: 24617,
          40067: 24590,
          40068: 24625,
          40069: 24603,
          40070: 24597,
          40071: 24619,
          40072: 24614,
          40073: 24591,
          40074: 24634,
          40075: 24666,
          40076: 24641,
          40077: 24682,
          40078: 24695,
          40079: 24671,
          40080: 24650,
          40081: 24646,
          40082: 24653,
          40083: 24675,
          40084: 24643,
          40085: 24676,
          40086: 24642,
          40087: 24684,
          40088: 24683,
          40089: 24665,
          40090: 24705,
          40091: 24717,
          40092: 24807,
          40093: 24707,
          40094: 24730,
          40095: 24708,
          40096: 24731,
          40097: 24726,
          40098: 24727,
          40099: 24722,
          40100: 24743,
          40101: 24715,
          40102: 24801,
          40103: 24760,
          40104: 24800,
          40105: 24787,
          40106: 24756,
          40107: 24560,
          40108: 24765,
          40109: 24774,
          40110: 24757,
          40111: 24792,
          40112: 24909,
          40113: 24853,
          40114: 24838,
          40115: 24822,
          40116: 24823,
          40117: 24832,
          40118: 24820,
          40119: 24826,
          40120: 24835,
          40121: 24865,
          40122: 24827,
          40123: 24817,
          40124: 24845,
          40125: 24846,
          40126: 24903,
          40127: 24894,
          40128: 24872,
          40129: 24871,
          40130: 24906,
          40131: 24895,
          40132: 24892,
          40133: 24876,
          40134: 24884,
          40135: 24893,
          40136: 24898,
          40137: 24900,
          40138: 24947,
          40139: 24951,
          40140: 24920,
          40141: 24921,
          40142: 24922,
          40143: 24939,
          40144: 24948,
          40145: 24943,
          40146: 24933,
          40147: 24945,
          40148: 24927,
          40149: 24925,
          40150: 24915,
          40151: 24949,
          40152: 24985,
          40153: 24982,
          40154: 24967,
          40155: 25004,
          40156: 24980,
          40157: 24986,
          40158: 24970,
          40159: 24977,
          40160: 25003,
          40161: 25006,
          40162: 25036,
          40163: 25034,
          40164: 25033,
          40165: 25079,
          40166: 25032,
          40167: 25027,
          40168: 25030,
          40169: 25018,
          40170: 25035,
          40171: 32633,
          40172: 25037,
          40173: 25062,
          40174: 25059,
          40175: 25078,
          40176: 25082,
          40177: 25076,
          40178: 25087,
          40179: 25085,
          40180: 25084,
          40181: 25086,
          40182: 25088,
          40183: 25096,
          40184: 25097,
          40185: 25101,
          40186: 25100,
          40187: 25108,
          40188: 25115,
          40256: 25118,
          40257: 25121,
          40258: 25130,
          40259: 25134,
          40260: 25136,
          40261: 25138,
          40262: 25139,
          40263: 25153,
          40264: 25166,
          40265: 25182,
          40266: 25187,
          40267: 25179,
          40268: 25184,
          40269: 25192,
          40270: 25212,
          40271: 25218,
          40272: 25225,
          40273: 25214,
          40274: 25234,
          40275: 25235,
          40276: 25238,
          40277: 25300,
          40278: 25219,
          40279: 25236,
          40280: 25303,
          40281: 25297,
          40282: 25275,
          40283: 25295,
          40284: 25343,
          40285: 25286,
          40286: 25812,
          40287: 25288,
          40288: 25308,
          40289: 25292,
          40290: 25290,
          40291: 25282,
          40292: 25287,
          40293: 25243,
          40294: 25289,
          40295: 25356,
          40296: 25326,
          40297: 25329,
          40298: 25383,
          40299: 25346,
          40300: 25352,
          40301: 25327,
          40302: 25333,
          40303: 25424,
          40304: 25406,
          40305: 25421,
          40306: 25628,
          40307: 25423,
          40308: 25494,
          40309: 25486,
          40310: 25472,
          40311: 25515,
          40312: 25462,
          40313: 25507,
          40314: 25487,
          40315: 25481,
          40316: 25503,
          40317: 25525,
          40318: 25451,
          40320: 25449,
          40321: 25534,
          40322: 25577,
          40323: 25536,
          40324: 25542,
          40325: 25571,
          40326: 25545,
          40327: 25554,
          40328: 25590,
          40329: 25540,
          40330: 25622,
          40331: 25652,
          40332: 25606,
          40333: 25619,
          40334: 25638,
          40335: 25654,
          40336: 25885,
          40337: 25623,
          40338: 25640,
          40339: 25615,
          40340: 25703,
          40341: 25711,
          40342: 25718,
          40343: 25678,
          40344: 25898,
          40345: 25749,
          40346: 25747,
          40347: 25765,
          40348: 25769,
          40349: 25736,
          40350: 25788,
          40351: 25818,
          40352: 25810,
          40353: 25797,
          40354: 25799,
          40355: 25787,
          40356: 25816,
          40357: 25794,
          40358: 25841,
          40359: 25831,
          40360: 33289,
          40361: 25824,
          40362: 25825,
          40363: 25260,
          40364: 25827,
          40365: 25839,
          40366: 25900,
          40367: 25846,
          40368: 25844,
          40369: 25842,
          40370: 25850,
          40371: 25856,
          40372: 25853,
          40373: 25880,
          40374: 25884,
          40375: 25861,
          40376: 25892,
          40377: 25891,
          40378: 25899,
          40379: 25908,
          40380: 25909,
          40381: 25911,
          40382: 25910,
          40383: 25912,
          40384: 30027,
          40385: 25928,
          40386: 25942,
          40387: 25941,
          40388: 25933,
          40389: 25944,
          40390: 25950,
          40391: 25949,
          40392: 25970,
          40393: 25976,
          40394: 25986,
          40395: 25987,
          40396: 35722,
          40397: 26011,
          40398: 26015,
          40399: 26027,
          40400: 26039,
          40401: 26051,
          40402: 26054,
          40403: 26049,
          40404: 26052,
          40405: 26060,
          40406: 26066,
          40407: 26075,
          40408: 26073,
          40409: 26080,
          40410: 26081,
          40411: 26097,
          40412: 26482,
          40413: 26122,
          40414: 26115,
          40415: 26107,
          40416: 26483,
          40417: 26165,
          40418: 26166,
          40419: 26164,
          40420: 26140,
          40421: 26191,
          40422: 26180,
          40423: 26185,
          40424: 26177,
          40425: 26206,
          40426: 26205,
          40427: 26212,
          40428: 26215,
          40429: 26216,
          40430: 26207,
          40431: 26210,
          40432: 26224,
          40433: 26243,
          40434: 26248,
          40435: 26254,
          40436: 26249,
          40437: 26244,
          40438: 26264,
          40439: 26269,
          40440: 26305,
          40441: 26297,
          40442: 26313,
          40443: 26302,
          40444: 26300,
          40512: 26308,
          40513: 26296,
          40514: 26326,
          40515: 26330,
          40516: 26336,
          40517: 26175,
          40518: 26342,
          40519: 26345,
          40520: 26352,
          40521: 26357,
          40522: 26359,
          40523: 26383,
          40524: 26390,
          40525: 26398,
          40526: 26406,
          40527: 26407,
          40528: 38712,
          40529: 26414,
          40530: 26431,
          40531: 26422,
          40532: 26433,
          40533: 26424,
          40534: 26423,
          40535: 26438,
          40536: 26462,
          40537: 26464,
          40538: 26457,
          40539: 26467,
          40540: 26468,
          40541: 26505,
          40542: 26480,
          40543: 26537,
          40544: 26492,
          40545: 26474,
          40546: 26508,
          40547: 26507,
          40548: 26534,
          40549: 26529,
          40550: 26501,
          40551: 26551,
          40552: 26607,
          40553: 26548,
          40554: 26604,
          40555: 26547,
          40556: 26601,
          40557: 26552,
          40558: 26596,
          40559: 26590,
          40560: 26589,
          40561: 26594,
          40562: 26606,
          40563: 26553,
          40564: 26574,
          40565: 26566,
          40566: 26599,
          40567: 27292,
          40568: 26654,
          40569: 26694,
          40570: 26665,
          40571: 26688,
          40572: 26701,
          40573: 26674,
          40574: 26702,
          40576: 26803,
          40577: 26667,
          40578: 26713,
          40579: 26723,
          40580: 26743,
          40581: 26751,
          40582: 26783,
          40583: 26767,
          40584: 26797,
          40585: 26772,
          40586: 26781,
          40587: 26779,
          40588: 26755,
          40589: 27310,
          40590: 26809,
          40591: 26740,
          40592: 26805,
          40593: 26784,
          40594: 26810,
          40595: 26895,
          40596: 26765,
          40597: 26750,
          40598: 26881,
          40599: 26826,
          40600: 26888,
          40601: 26840,
          40602: 26914,
          40603: 26918,
          40604: 26849,
          40605: 26892,
          40606: 26829,
          40607: 26836,
          40608: 26855,
          40609: 26837,
          40610: 26934,
          40611: 26898,
          40612: 26884,
          40613: 26839,
          40614: 26851,
          40615: 26917,
          40616: 26873,
          40617: 26848,
          40618: 26863,
          40619: 26920,
          40620: 26922,
          40621: 26906,
          40622: 26915,
          40623: 26913,
          40624: 26822,
          40625: 27001,
          40626: 26999,
          40627: 26972,
          40628: 27000,
          40629: 26987,
          40630: 26964,
          40631: 27006,
          40632: 26990,
          40633: 26937,
          40634: 26996,
          40635: 26941,
          40636: 26969,
          40637: 26928,
          40638: 26977,
          40639: 26974,
          40640: 26973,
          40641: 27009,
          40642: 26986,
          40643: 27058,
          40644: 27054,
          40645: 27088,
          40646: 27071,
          40647: 27073,
          40648: 27091,
          40649: 27070,
          40650: 27086,
          40651: 23528,
          40652: 27082,
          40653: 27101,
          40654: 27067,
          40655: 27075,
          40656: 27047,
          40657: 27182,
          40658: 27025,
          40659: 27040,
          40660: 27036,
          40661: 27029,
          40662: 27060,
          40663: 27102,
          40664: 27112,
          40665: 27138,
          40666: 27163,
          40667: 27135,
          40668: 27402,
          40669: 27129,
          40670: 27122,
          40671: 27111,
          40672: 27141,
          40673: 27057,
          40674: 27166,
          40675: 27117,
          40676: 27156,
          40677: 27115,
          40678: 27146,
          40679: 27154,
          40680: 27329,
          40681: 27171,
          40682: 27155,
          40683: 27204,
          40684: 27148,
          40685: 27250,
          40686: 27190,
          40687: 27256,
          40688: 27207,
          40689: 27234,
          40690: 27225,
          40691: 27238,
          40692: 27208,
          40693: 27192,
          40694: 27170,
          40695: 27280,
          40696: 27277,
          40697: 27296,
          40698: 27268,
          40699: 27298,
          40700: 27299,
          40768: 27287,
          40769: 34327,
          40770: 27323,
          40771: 27331,
          40772: 27330,
          40773: 27320,
          40774: 27315,
          40775: 27308,
          40776: 27358,
          40777: 27345,
          40778: 27359,
          40779: 27306,
          40780: 27354,
          40781: 27370,
          40782: 27387,
          40783: 27397,
          40784: 34326,
          40785: 27386,
          40786: 27410,
          40787: 27414,
          40788: 39729,
          40789: 27423,
          40790: 27448,
          40791: 27447,
          40792: 30428,
          40793: 27449,
          40794: 39150,
          40795: 27463,
          40796: 27459,
          40797: 27465,
          40798: 27472,
          40799: 27481,
          40800: 27476,
          40801: 27483,
          40802: 27487,
          40803: 27489,
          40804: 27512,
          40805: 27513,
          40806: 27519,
          40807: 27520,
          40808: 27524,
          40809: 27523,
          40810: 27533,
          40811: 27544,
          40812: 27541,
          40813: 27550,
          40814: 27556,
          40815: 27562,
          40816: 27563,
          40817: 27567,
          40818: 27570,
          40819: 27569,
          40820: 27571,
          40821: 27575,
          40822: 27580,
          40823: 27590,
          40824: 27595,
          40825: 27603,
          40826: 27615,
          40827: 27628,
          40828: 27627,
          40829: 27635,
          40830: 27631,
          40832: 40638,
          40833: 27656,
          40834: 27667,
          40835: 27668,
          40836: 27675,
          40837: 27684,
          40838: 27683,
          40839: 27742,
          40840: 27733,
          40841: 27746,
          40842: 27754,
          40843: 27778,
          40844: 27789,
          40845: 27802,
          40846: 27777,
          40847: 27803,
          40848: 27774,
          40849: 27752,
          40850: 27763,
          40851: 27794,
          40852: 27792,
          40853: 27844,
          40854: 27889,
          40855: 27859,
          40856: 27837,
          40857: 27863,
          40858: 27845,
          40859: 27869,
          40860: 27822,
          40861: 27825,
          40862: 27838,
          40863: 27834,
          40864: 27867,
          40865: 27887,
          40866: 27865,
          40867: 27882,
          40868: 27935,
          40869: 34893,
          40870: 27958,
          40871: 27947,
          40872: 27965,
          40873: 27960,
          40874: 27929,
          40875: 27957,
          40876: 27955,
          40877: 27922,
          40878: 27916,
          40879: 28003,
          40880: 28051,
          40881: 28004,
          40882: 27994,
          40883: 28025,
          40884: 27993,
          40885: 28046,
          40886: 28053,
          40887: 28644,
          40888: 28037,
          40889: 28153,
          40890: 28181,
          40891: 28170,
          40892: 28085,
          40893: 28103,
          40894: 28134,
          40895: 28088,
          40896: 28102,
          40897: 28140,
          40898: 28126,
          40899: 28108,
          40900: 28136,
          40901: 28114,
          40902: 28101,
          40903: 28154,
          40904: 28121,
          40905: 28132,
          40906: 28117,
          40907: 28138,
          40908: 28142,
          40909: 28205,
          40910: 28270,
          40911: 28206,
          40912: 28185,
          40913: 28274,
          40914: 28255,
          40915: 28222,
          40916: 28195,
          40917: 28267,
          40918: 28203,
          40919: 28278,
          40920: 28237,
          40921: 28191,
          40922: 28227,
          40923: 28218,
          40924: 28238,
          40925: 28196,
          40926: 28415,
          40927: 28189,
          40928: 28216,
          40929: 28290,
          40930: 28330,
          40931: 28312,
          40932: 28361,
          40933: 28343,
          40934: 28371,
          40935: 28349,
          40936: 28335,
          40937: 28356,
          40938: 28338,
          40939: 28372,
          40940: 28373,
          40941: 28303,
          40942: 28325,
          40943: 28354,
          40944: 28319,
          40945: 28481,
          40946: 28433,
          40947: 28748,
          40948: 28396,
          40949: 28408,
          40950: 28414,
          40951: 28479,
          40952: 28402,
          40953: 28465,
          40954: 28399,
          40955: 28466,
          40956: 28364,
          161: 65377,
          162: 65378,
          163: 65379,
          164: 65380,
          165: 65381,
          166: 65382,
          167: 65383,
          168: 65384,
          169: 65385,
          170: 65386,
          171: 65387,
          172: 65388,
          173: 65389,
          174: 65390,
          175: 65391,
          176: 65392,
          177: 65393,
          178: 65394,
          179: 65395,
          180: 65396,
          181: 65397,
          182: 65398,
          183: 65399,
          184: 65400,
          185: 65401,
          186: 65402,
          187: 65403,
          188: 65404,
          189: 65405,
          190: 65406,
          191: 65407,
          192: 65408,
          193: 65409,
          194: 65410,
          195: 65411,
          196: 65412,
          197: 65413,
          198: 65414,
          199: 65415,
          200: 65416,
          201: 65417,
          202: 65418,
          203: 65419,
          204: 65420,
          205: 65421,
          206: 65422,
          207: 65423,
          208: 65424,
          209: 65425,
          210: 65426,
          211: 65427,
          212: 65428,
          213: 65429,
          214: 65430,
          215: 65431,
          216: 65432,
          217: 65433,
          218: 65434,
          219: 65435,
          220: 65436,
          221: 65437,
          222: 65438,
          223: 65439,
          57408: 28478,
          57409: 28435,
          57410: 28407,
          57411: 28550,
          57412: 28538,
          57413: 28536,
          57414: 28545,
          57415: 28544,
          57416: 28527,
          57417: 28507,
          57418: 28659,
          57419: 28525,
          57420: 28546,
          57421: 28540,
          57422: 28504,
          57423: 28558,
          57424: 28561,
          57425: 28610,
          57426: 28518,
          57427: 28595,
          57428: 28579,
          57429: 28577,
          57430: 28580,
          57431: 28601,
          57432: 28614,
          57433: 28586,
          57434: 28639,
          57435: 28629,
          57436: 28652,
          57437: 28628,
          57438: 28632,
          57439: 28657,
          57440: 28654,
          57441: 28635,
          57442: 28681,
          57443: 28683,
          57444: 28666,
          57445: 28689,
          57446: 28673,
          57447: 28687,
          57448: 28670,
          57449: 28699,
          57450: 28698,
          57451: 28532,
          57452: 28701,
          57453: 28696,
          57454: 28703,
          57455: 28720,
          57456: 28734,
          57457: 28722,
          57458: 28753,
          57459: 28771,
          57460: 28825,
          57461: 28818,
          57462: 28847,
          57463: 28913,
          57464: 28844,
          57465: 28856,
          57466: 28851,
          57467: 28846,
          57468: 28895,
          57469: 28875,
          57470: 28893,
          57472: 28889,
          57473: 28937,
          57474: 28925,
          57475: 28956,
          57476: 28953,
          57477: 29029,
          57478: 29013,
          57479: 29064,
          57480: 29030,
          57481: 29026,
          57482: 29004,
          57483: 29014,
          57484: 29036,
          57485: 29071,
          57486: 29179,
          57487: 29060,
          57488: 29077,
          57489: 29096,
          57490: 29100,
          57491: 29143,
          57492: 29113,
          57493: 29118,
          57494: 29138,
          57495: 29129,
          57496: 29140,
          57497: 29134,
          57498: 29152,
          57499: 29164,
          57500: 29159,
          57501: 29173,
          57502: 29180,
          57503: 29177,
          57504: 29183,
          57505: 29197,
          57506: 29200,
          57507: 29211,
          57508: 29224,
          57509: 29229,
          57510: 29228,
          57511: 29232,
          57512: 29234,
          57513: 29243,
          57514: 29244,
          57515: 29247,
          57516: 29248,
          57517: 29254,
          57518: 29259,
          57519: 29272,
          57520: 29300,
          57521: 29310,
          57522: 29314,
          57523: 29313,
          57524: 29319,
          57525: 29330,
          57526: 29334,
          57527: 29346,
          57528: 29351,
          57529: 29369,
          57530: 29362,
          57531: 29379,
          57532: 29382,
          57533: 29380,
          57534: 29390,
          57535: 29394,
          57536: 29410,
          57537: 29408,
          57538: 29409,
          57539: 29433,
          57540: 29431,
          57541: 20495,
          57542: 29463,
          57543: 29450,
          57544: 29468,
          57545: 29462,
          57546: 29469,
          57547: 29492,
          57548: 29487,
          57549: 29481,
          57550: 29477,
          57551: 29502,
          57552: 29518,
          57553: 29519,
          57554: 40664,
          57555: 29527,
          57556: 29546,
          57557: 29544,
          57558: 29552,
          57559: 29560,
          57560: 29557,
          57561: 29563,
          57562: 29562,
          57563: 29640,
          57564: 29619,
          57565: 29646,
          57566: 29627,
          57567: 29632,
          57568: 29669,
          57569: 29678,
          57570: 29662,
          57571: 29858,
          57572: 29701,
          57573: 29807,
          57574: 29733,
          57575: 29688,
          57576: 29746,
          57577: 29754,
          57578: 29781,
          57579: 29759,
          57580: 29791,
          57581: 29785,
          57582: 29761,
          57583: 29788,
          57584: 29801,
          57585: 29808,
          57586: 29795,
          57587: 29802,
          57588: 29814,
          57589: 29822,
          57590: 29835,
          57591: 29854,
          57592: 29863,
          57593: 29898,
          57594: 29903,
          57595: 29908,
          57596: 29681,
          57664: 29920,
          57665: 29923,
          57666: 29927,
          57667: 29929,
          57668: 29934,
          57669: 29938,
          57670: 29936,
          57671: 29937,
          57672: 29944,
          57673: 29943,
          57674: 29956,
          57675: 29955,
          57676: 29957,
          57677: 29964,
          57678: 29966,
          57679: 29965,
          57680: 29973,
          57681: 29971,
          57682: 29982,
          57683: 29990,
          57684: 29996,
          57685: 30012,
          57686: 30020,
          57687: 30029,
          57688: 30026,
          57689: 30025,
          57690: 30043,
          57691: 30022,
          57692: 30042,
          57693: 30057,
          57694: 30052,
          57695: 30055,
          57696: 30059,
          57697: 30061,
          57698: 30072,
          57699: 30070,
          57700: 30086,
          57701: 30087,
          57702: 30068,
          57703: 30090,
          57704: 30089,
          57705: 30082,
          57706: 30100,
          57707: 30106,
          57708: 30109,
          57709: 30117,
          57710: 30115,
          57711: 30146,
          57712: 30131,
          57713: 30147,
          57714: 30133,
          57715: 30141,
          57716: 30136,
          57717: 30140,
          57718: 30129,
          57719: 30157,
          57720: 30154,
          57721: 30162,
          57722: 30169,
          57723: 30179,
          57724: 30174,
          57725: 30206,
          57726: 30207,
          57728: 30204,
          57729: 30209,
          57730: 30192,
          57731: 30202,
          57732: 30194,
          57733: 30195,
          57734: 30219,
          57735: 30221,
          57736: 30217,
          57737: 30239,
          57738: 30247,
          57739: 30240,
          57740: 30241,
          57741: 30242,
          57742: 30244,
          57743: 30260,
          57744: 30256,
          57745: 30267,
          57746: 30279,
          57747: 30280,
          57748: 30278,
          57749: 30300,
          57750: 30296,
          57751: 30305,
          57752: 30306,
          57753: 30312,
          57754: 30313,
          57755: 30314,
          57756: 30311,
          57757: 30316,
          57758: 30320,
          57759: 30322,
          57760: 30326,
          57761: 30328,
          57762: 30332,
          57763: 30336,
          57764: 30339,
          57765: 30344,
          57766: 30347,
          57767: 30350,
          57768: 30358,
          57769: 30355,
          57770: 30361,
          57771: 30362,
          57772: 30384,
          57773: 30388,
          57774: 30392,
          57775: 30393,
          57776: 30394,
          57777: 30402,
          57778: 30413,
          57779: 30422,
          57780: 30418,
          57781: 30430,
          57782: 30433,
          57783: 30437,
          57784: 30439,
          57785: 30442,
          57786: 34351,
          57787: 30459,
          57788: 30472,
          57789: 30471,
          57790: 30468,
          57791: 30505,
          57792: 30500,
          57793: 30494,
          57794: 30501,
          57795: 30502,
          57796: 30491,
          57797: 30519,
          57798: 30520,
          57799: 30535,
          57800: 30554,
          57801: 30568,
          57802: 30571,
          57803: 30555,
          57804: 30565,
          57805: 30591,
          57806: 30590,
          57807: 30585,
          57808: 30606,
          57809: 30603,
          57810: 30609,
          57811: 30624,
          57812: 30622,
          57813: 30640,
          57814: 30646,
          57815: 30649,
          57816: 30655,
          57817: 30652,
          57818: 30653,
          57819: 30651,
          57820: 30663,
          57821: 30669,
          57822: 30679,
          57823: 30682,
          57824: 30684,
          57825: 30691,
          57826: 30702,
          57827: 30716,
          57828: 30732,
          57829: 30738,
          57830: 31014,
          57831: 30752,
          57832: 31018,
          57833: 30789,
          57834: 30862,
          57835: 30836,
          57836: 30854,
          57837: 30844,
          57838: 30874,
          57839: 30860,
          57840: 30883,
          57841: 30901,
          57842: 30890,
          57843: 30895,
          57844: 30929,
          57845: 30918,
          57846: 30923,
          57847: 30932,
          57848: 30910,
          57849: 30908,
          57850: 30917,
          57851: 30922,
          57852: 30956,
          57920: 30951,
          57921: 30938,
          57922: 30973,
          57923: 30964,
          57924: 30983,
          57925: 30994,
          57926: 30993,
          57927: 31001,
          57928: 31020,
          57929: 31019,
          57930: 31040,
          57931: 31072,
          57932: 31063,
          57933: 31071,
          57934: 31066,
          57935: 31061,
          57936: 31059,
          57937: 31098,
          57938: 31103,
          57939: 31114,
          57940: 31133,
          57941: 31143,
          57942: 40779,
          57943: 31146,
          57944: 31150,
          57945: 31155,
          57946: 31161,
          57947: 31162,
          57948: 31177,
          57949: 31189,
          57950: 31207,
          57951: 31212,
          57952: 31201,
          57953: 31203,
          57954: 31240,
          57955: 31245,
          57956: 31256,
          57957: 31257,
          57958: 31264,
          57959: 31263,
          57960: 31104,
          57961: 31281,
          57962: 31291,
          57963: 31294,
          57964: 31287,
          57965: 31299,
          57966: 31319,
          57967: 31305,
          57968: 31329,
          57969: 31330,
          57970: 31337,
          57971: 40861,
          57972: 31344,
          57973: 31353,
          57974: 31357,
          57975: 31368,
          57976: 31383,
          57977: 31381,
          57978: 31384,
          57979: 31382,
          57980: 31401,
          57981: 31432,
          57982: 31408,
          57984: 31414,
          57985: 31429,
          57986: 31428,
          57987: 31423,
          57988: 36995,
          57989: 31431,
          57990: 31434,
          57991: 31437,
          57992: 31439,
          57993: 31445,
          57994: 31443,
          57995: 31449,
          57996: 31450,
          57997: 31453,
          57998: 31457,
          57999: 31458,
          58000: 31462,
          58001: 31469,
          58002: 31472,
          58003: 31490,
          58004: 31503,
          58005: 31498,
          58006: 31494,
          58007: 31539,
          58008: 31512,
          58009: 31513,
          58010: 31518,
          58011: 31541,
          58012: 31528,
          58013: 31542,
          58014: 31568,
          58015: 31610,
          58016: 31492,
          58017: 31565,
          58018: 31499,
          58019: 31564,
          58020: 31557,
          58021: 31605,
          58022: 31589,
          58023: 31604,
          58024: 31591,
          58025: 31600,
          58026: 31601,
          58027: 31596,
          58028: 31598,
          58029: 31645,
          58030: 31640,
          58031: 31647,
          58032: 31629,
          58033: 31644,
          58034: 31642,
          58035: 31627,
          58036: 31634,
          58037: 31631,
          58038: 31581,
          58039: 31641,
          58040: 31691,
          58041: 31681,
          58042: 31692,
          58043: 31695,
          58044: 31668,
          58045: 31686,
          58046: 31709,
          58047: 31721,
          58048: 31761,
          58049: 31764,
          58050: 31718,
          58051: 31717,
          58052: 31840,
          58053: 31744,
          58054: 31751,
          58055: 31763,
          58056: 31731,
          58057: 31735,
          58058: 31767,
          58059: 31757,
          58060: 31734,
          58061: 31779,
          58062: 31783,
          58063: 31786,
          58064: 31775,
          58065: 31799,
          58066: 31787,
          58067: 31805,
          58068: 31820,
          58069: 31811,
          58070: 31828,
          58071: 31823,
          58072: 31808,
          58073: 31824,
          58074: 31832,
          58075: 31839,
          58076: 31844,
          58077: 31830,
          58078: 31845,
          58079: 31852,
          58080: 31861,
          58081: 31875,
          58082: 31888,
          58083: 31908,
          58084: 31917,
          58085: 31906,
          58086: 31915,
          58087: 31905,
          58088: 31912,
          58089: 31923,
          58090: 31922,
          58091: 31921,
          58092: 31918,
          58093: 31929,
          58094: 31933,
          58095: 31936,
          58096: 31941,
          58097: 31938,
          58098: 31960,
          58099: 31954,
          58100: 31964,
          58101: 31970,
          58102: 39739,
          58103: 31983,
          58104: 31986,
          58105: 31988,
          58106: 31990,
          58107: 31994,
          58108: 32006,
          58176: 32002,
          58177: 32028,
          58178: 32021,
          58179: 32010,
          58180: 32069,
          58181: 32075,
          58182: 32046,
          58183: 32050,
          58184: 32063,
          58185: 32053,
          58186: 32070,
          58187: 32115,
          58188: 32086,
          58189: 32078,
          58190: 32114,
          58191: 32104,
          58192: 32110,
          58193: 32079,
          58194: 32099,
          58195: 32147,
          58196: 32137,
          58197: 32091,
          58198: 32143,
          58199: 32125,
          58200: 32155,
          58201: 32186,
          58202: 32174,
          58203: 32163,
          58204: 32181,
          58205: 32199,
          58206: 32189,
          58207: 32171,
          58208: 32317,
          58209: 32162,
          58210: 32175,
          58211: 32220,
          58212: 32184,
          58213: 32159,
          58214: 32176,
          58215: 32216,
          58216: 32221,
          58217: 32228,
          58218: 32222,
          58219: 32251,
          58220: 32242,
          58221: 32225,
          58222: 32261,
          58223: 32266,
          58224: 32291,
          58225: 32289,
          58226: 32274,
          58227: 32305,
          58228: 32287,
          58229: 32265,
          58230: 32267,
          58231: 32290,
          58232: 32326,
          58233: 32358,
          58234: 32315,
          58235: 32309,
          58236: 32313,
          58237: 32323,
          58238: 32311,
          58240: 32306,
          58241: 32314,
          58242: 32359,
          58243: 32349,
          58244: 32342,
          58245: 32350,
          58246: 32345,
          58247: 32346,
          58248: 32377,
          58249: 32362,
          58250: 32361,
          58251: 32380,
          58252: 32379,
          58253: 32387,
          58254: 32213,
          58255: 32381,
          58256: 36782,
          58257: 32383,
          58258: 32392,
          58259: 32393,
          58260: 32396,
          58261: 32402,
          58262: 32400,
          58263: 32403,
          58264: 32404,
          58265: 32406,
          58266: 32398,
          58267: 32411,
          58268: 32412,
          58269: 32568,
          58270: 32570,
          58271: 32581,
          58272: 32588,
          58273: 32589,
          58274: 32590,
          58275: 32592,
          58276: 32593,
          58277: 32597,
          58278: 32596,
          58279: 32600,
          58280: 32607,
          58281: 32608,
          58282: 32616,
          58283: 32617,
          58284: 32615,
          58285: 32632,
          58286: 32642,
          58287: 32646,
          58288: 32643,
          58289: 32648,
          58290: 32647,
          58291: 32652,
          58292: 32660,
          58293: 32670,
          58294: 32669,
          58295: 32666,
          58296: 32675,
          58297: 32687,
          58298: 32690,
          58299: 32697,
          58300: 32686,
          58301: 32694,
          58302: 32696,
          58303: 35697,
          58304: 32709,
          58305: 32710,
          58306: 32714,
          58307: 32725,
          58308: 32724,
          58309: 32737,
          58310: 32742,
          58311: 32745,
          58312: 32755,
          58313: 32761,
          58314: 39132,
          58315: 32774,
          58316: 32772,
          58317: 32779,
          58318: 32786,
          58319: 32792,
          58320: 32793,
          58321: 32796,
          58322: 32801,
          58323: 32808,
          58324: 32831,
          58325: 32827,
          58326: 32842,
          58327: 32838,
          58328: 32850,
          58329: 32856,
          58330: 32858,
          58331: 32863,
          58332: 32866,
          58333: 32872,
          58334: 32883,
          58335: 32882,
          58336: 32880,
          58337: 32886,
          58338: 32889,
          58339: 32893,
          58340: 32895,
          58341: 32900,
          58342: 32902,
          58343: 32901,
          58344: 32923,
          58345: 32915,
          58346: 32922,
          58347: 32941,
          58348: 20880,
          58349: 32940,
          58350: 32987,
          58351: 32997,
          58352: 32985,
          58353: 32989,
          58354: 32964,
          58355: 32986,
          58356: 32982,
          58357: 33033,
          58358: 33007,
          58359: 33009,
          58360: 33051,
          58361: 33065,
          58362: 33059,
          58363: 33071,
          58364: 33099,
          58432: 38539,
          58433: 33094,
          58434: 33086,
          58435: 33107,
          58436: 33105,
          58437: 33020,
          58438: 33137,
          58439: 33134,
          58440: 33125,
          58441: 33126,
          58442: 33140,
          58443: 33155,
          58444: 33160,
          58445: 33162,
          58446: 33152,
          58447: 33154,
          58448: 33184,
          58449: 33173,
          58450: 33188,
          58451: 33187,
          58452: 33119,
          58453: 33171,
          58454: 33193,
          58455: 33200,
          58456: 33205,
          58457: 33214,
          58458: 33208,
          58459: 33213,
          58460: 33216,
          58461: 33218,
          58462: 33210,
          58463: 33225,
          58464: 33229,
          58465: 33233,
          58466: 33241,
          58467: 33240,
          58468: 33224,
          58469: 33242,
          58470: 33247,
          58471: 33248,
          58472: 33255,
          58473: 33274,
          58474: 33275,
          58475: 33278,
          58476: 33281,
          58477: 33282,
          58478: 33285,
          58479: 33287,
          58480: 33290,
          58481: 33293,
          58482: 33296,
          58483: 33302,
          58484: 33321,
          58485: 33323,
          58486: 33336,
          58487: 33331,
          58488: 33344,
          58489: 33369,
          58490: 33368,
          58491: 33373,
          58492: 33370,
          58493: 33375,
          58494: 33380,
          58496: 33378,
          58497: 33384,
          58498: 33386,
          58499: 33387,
          58500: 33326,
          58501: 33393,
          58502: 33399,
          58503: 33400,
          58504: 33406,
          58505: 33421,
          58506: 33426,
          58507: 33451,
          58508: 33439,
          58509: 33467,
          58510: 33452,
          58511: 33505,
          58512: 33507,
          58513: 33503,
          58514: 33490,
          58515: 33524,
          58516: 33523,
          58517: 33530,
          58518: 33683,
          58519: 33539,
          58520: 33531,
          58521: 33529,
          58522: 33502,
          58523: 33542,
          58524: 33500,
          58525: 33545,
          58526: 33497,
          58527: 33589,
          58528: 33588,
          58529: 33558,
          58530: 33586,
          58531: 33585,
          58532: 33600,
          58533: 33593,
          58534: 33616,
          58535: 33605,
          58536: 33583,
          58537: 33579,
          58538: 33559,
          58539: 33560,
          58540: 33669,
          58541: 33690,
          58542: 33706,
          58543: 33695,
          58544: 33698,
          58545: 33686,
          58546: 33571,
          58547: 33678,
          58548: 33671,
          58549: 33674,
          58550: 33660,
          58551: 33717,
          58552: 33651,
          58553: 33653,
          58554: 33696,
          58555: 33673,
          58556: 33704,
          58557: 33780,
          58558: 33811,
          58559: 33771,
          58560: 33742,
          58561: 33789,
          58562: 33795,
          58563: 33752,
          58564: 33803,
          58565: 33729,
          58566: 33783,
          58567: 33799,
          58568: 33760,
          58569: 33778,
          58570: 33805,
          58571: 33826,
          58572: 33824,
          58573: 33725,
          58574: 33848,
          58575: 34054,
          58576: 33787,
          58577: 33901,
          58578: 33834,
          58579: 33852,
          58580: 34138,
          58581: 33924,
          58582: 33911,
          58583: 33899,
          58584: 33965,
          58585: 33902,
          58586: 33922,
          58587: 33897,
          58588: 33862,
          58589: 33836,
          58590: 33903,
          58591: 33913,
          58592: 33845,
          58593: 33994,
          58594: 33890,
          58595: 33977,
          58596: 33983,
          58597: 33951,
          58598: 34009,
          58599: 33997,
          58600: 33979,
          58601: 34010,
          58602: 34000,
          58603: 33985,
          58604: 33990,
          58605: 34006,
          58606: 33953,
          58607: 34081,
          58608: 34047,
          58609: 34036,
          58610: 34071,
          58611: 34072,
          58612: 34092,
          58613: 34079,
          58614: 34069,
          58615: 34068,
          58616: 34044,
          58617: 34112,
          58618: 34147,
          58619: 34136,
          58620: 34120,
          58688: 34113,
          58689: 34306,
          58690: 34123,
          58691: 34133,
          58692: 34176,
          58693: 34212,
          58694: 34184,
          58695: 34193,
          58696: 34186,
          58697: 34216,
          58698: 34157,
          58699: 34196,
          58700: 34203,
          58701: 34282,
          58702: 34183,
          58703: 34204,
          58704: 34167,
          58705: 34174,
          58706: 34192,
          58707: 34249,
          58708: 34234,
          58709: 34255,
          58710: 34233,
          58711: 34256,
          58712: 34261,
          58713: 34269,
          58714: 34277,
          58715: 34268,
          58716: 34297,
          58717: 34314,
          58718: 34323,
          58719: 34315,
          58720: 34302,
          58721: 34298,
          58722: 34310,
          58723: 34338,
          58724: 34330,
          58725: 34352,
          58726: 34367,
          58727: 34381,
          58728: 20053,
          58729: 34388,
          58730: 34399,
          58731: 34407,
          58732: 34417,
          58733: 34451,
          58734: 34467,
          58735: 34473,
          58736: 34474,
          58737: 34443,
          58738: 34444,
          58739: 34486,
          58740: 34479,
          58741: 34500,
          58742: 34502,
          58743: 34480,
          58744: 34505,
          58745: 34851,
          58746: 34475,
          58747: 34516,
          58748: 34526,
          58749: 34537,
          58750: 34540,
          58752: 34527,
          58753: 34523,
          58754: 34543,
          58755: 34578,
          58756: 34566,
          58757: 34568,
          58758: 34560,
          58759: 34563,
          58760: 34555,
          58761: 34577,
          58762: 34569,
          58763: 34573,
          58764: 34553,
          58765: 34570,
          58766: 34612,
          58767: 34623,
          58768: 34615,
          58769: 34619,
          58770: 34597,
          58771: 34601,
          58772: 34586,
          58773: 34656,
          58774: 34655,
          58775: 34680,
          58776: 34636,
          58777: 34638,
          58778: 34676,
          58779: 34647,
          58780: 34664,
          58781: 34670,
          58782: 34649,
          58783: 34643,
          58784: 34659,
          58785: 34666,
          58786: 34821,
          58787: 34722,
          58788: 34719,
          58789: 34690,
          58790: 34735,
          58791: 34763,
          58792: 34749,
          58793: 34752,
          58794: 34768,
          58795: 38614,
          58796: 34731,
          58797: 34756,
          58798: 34739,
          58799: 34759,
          58800: 34758,
          58801: 34747,
          58802: 34799,
          58803: 34802,
          58804: 34784,
          58805: 34831,
          58806: 34829,
          58807: 34814,
          58808: 34806,
          58809: 34807,
          58810: 34830,
          58811: 34770,
          58812: 34833,
          58813: 34838,
          58814: 34837,
          58815: 34850,
          58816: 34849,
          58817: 34865,
          58818: 34870,
          58819: 34873,
          58820: 34855,
          58821: 34875,
          58822: 34884,
          58823: 34882,
          58824: 34898,
          58825: 34905,
          58826: 34910,
          58827: 34914,
          58828: 34923,
          58829: 34945,
          58830: 34942,
          58831: 34974,
          58832: 34933,
          58833: 34941,
          58834: 34997,
          58835: 34930,
          58836: 34946,
          58837: 34967,
          58838: 34962,
          58839: 34990,
          58840: 34969,
          58841: 34978,
          58842: 34957,
          58843: 34980,
          58844: 34992,
          58845: 35007,
          58846: 34993,
          58847: 35011,
          58848: 35012,
          58849: 35028,
          58850: 35032,
          58851: 35033,
          58852: 35037,
          58853: 35065,
          58854: 35074,
          58855: 35068,
          58856: 35060,
          58857: 35048,
          58858: 35058,
          58859: 35076,
          58860: 35084,
          58861: 35082,
          58862: 35091,
          58863: 35139,
          58864: 35102,
          58865: 35109,
          58866: 35114,
          58867: 35115,
          58868: 35137,
          58869: 35140,
          58870: 35131,
          58871: 35126,
          58872: 35128,
          58873: 35148,
          58874: 35101,
          58875: 35168,
          58876: 35166,
          58944: 35174,
          58945: 35172,
          58946: 35181,
          58947: 35178,
          58948: 35183,
          58949: 35188,
          58950: 35191,
          58951: 35198,
          58952: 35203,
          58953: 35208,
          58954: 35210,
          58955: 35219,
          58956: 35224,
          58957: 35233,
          58958: 35241,
          58959: 35238,
          58960: 35244,
          58961: 35247,
          58962: 35250,
          58963: 35258,
          58964: 35261,
          58965: 35263,
          58966: 35264,
          58967: 35290,
          58968: 35292,
          58969: 35293,
          58970: 35303,
          58971: 35316,
          58972: 35320,
          58973: 35331,
          58974: 35350,
          58975: 35344,
          58976: 35340,
          58977: 35355,
          58978: 35357,
          58979: 35365,
          58980: 35382,
          58981: 35393,
          58982: 35419,
          58983: 35410,
          58984: 35398,
          58985: 35400,
          58986: 35452,
          58987: 35437,
          58988: 35436,
          58989: 35426,
          58990: 35461,
          58991: 35458,
          58992: 35460,
          58993: 35496,
          58994: 35489,
          58995: 35473,
          58996: 35493,
          58997: 35494,
          58998: 35482,
          58999: 35491,
          59000: 35524,
          59001: 35533,
          59002: 35522,
          59003: 35546,
          59004: 35563,
          59005: 35571,
          59006: 35559,
          59008: 35556,
          59009: 35569,
          59010: 35604,
          59011: 35552,
          59012: 35554,
          59013: 35575,
          59014: 35550,
          59015: 35547,
          59016: 35596,
          59017: 35591,
          59018: 35610,
          59019: 35553,
          59020: 35606,
          59021: 35600,
          59022: 35607,
          59023: 35616,
          59024: 35635,
          59025: 38827,
          59026: 35622,
          59027: 35627,
          59028: 35646,
          59029: 35624,
          59030: 35649,
          59031: 35660,
          59032: 35663,
          59033: 35662,
          59034: 35657,
          59035: 35670,
          59036: 35675,
          59037: 35674,
          59038: 35691,
          59039: 35679,
          59040: 35692,
          59041: 35695,
          59042: 35700,
          59043: 35709,
          59044: 35712,
          59045: 35724,
          59046: 35726,
          59047: 35730,
          59048: 35731,
          59049: 35734,
          59050: 35737,
          59051: 35738,
          59052: 35898,
          59053: 35905,
          59054: 35903,
          59055: 35912,
          59056: 35916,
          59057: 35918,
          59058: 35920,
          59059: 35925,
          59060: 35938,
          59061: 35948,
          59062: 35960,
          59063: 35962,
          59064: 35970,
          59065: 35977,
          59066: 35973,
          59067: 35978,
          59068: 35981,
          59069: 35982,
          59070: 35988,
          59071: 35964,
          59072: 35992,
          59073: 25117,
          59074: 36013,
          59075: 36010,
          59076: 36029,
          59077: 36018,
          59078: 36019,
          59079: 36014,
          59080: 36022,
          59081: 36040,
          59082: 36033,
          59083: 36068,
          59084: 36067,
          59085: 36058,
          59086: 36093,
          59087: 36090,
          59088: 36091,
          59089: 36100,
          59090: 36101,
          59091: 36106,
          59092: 36103,
          59093: 36111,
          59094: 36109,
          59095: 36112,
          59096: 40782,
          59097: 36115,
          59098: 36045,
          59099: 36116,
          59100: 36118,
          59101: 36199,
          59102: 36205,
          59103: 36209,
          59104: 36211,
          59105: 36225,
          59106: 36249,
          59107: 36290,
          59108: 36286,
          59109: 36282,
          59110: 36303,
          59111: 36314,
          59112: 36310,
          59113: 36300,
          59114: 36315,
          59115: 36299,
          59116: 36330,
          59117: 36331,
          59118: 36319,
          59119: 36323,
          59120: 36348,
          59121: 36360,
          59122: 36361,
          59123: 36351,
          59124: 36381,
          59125: 36382,
          59126: 36368,
          59127: 36383,
          59128: 36418,
          59129: 36405,
          59130: 36400,
          59131: 36404,
          59132: 36426,
          59200: 36423,
          59201: 36425,
          59202: 36428,
          59203: 36432,
          59204: 36424,
          59205: 36441,
          59206: 36452,
          59207: 36448,
          59208: 36394,
          59209: 36451,
          59210: 36437,
          59211: 36470,
          59212: 36466,
          59213: 36476,
          59214: 36481,
          59215: 36487,
          59216: 36485,
          59217: 36484,
          59218: 36491,
          59219: 36490,
          59220: 36499,
          59221: 36497,
          59222: 36500,
          59223: 36505,
          59224: 36522,
          59225: 36513,
          59226: 36524,
          59227: 36528,
          59228: 36550,
          59229: 36529,
          59230: 36542,
          59231: 36549,
          59232: 36552,
          59233: 36555,
          59234: 36571,
          59235: 36579,
          59236: 36604,
          59237: 36603,
          59238: 36587,
          59239: 36606,
          59240: 36618,
          59241: 36613,
          59242: 36629,
          59243: 36626,
          59244: 36633,
          59245: 36627,
          59246: 36636,
          59247: 36639,
          59248: 36635,
          59249: 36620,
          59250: 36646,
          59251: 36659,
          59252: 36667,
          59253: 36665,
          59254: 36677,
          59255: 36674,
          59256: 36670,
          59257: 36684,
          59258: 36681,
          59259: 36678,
          59260: 36686,
          59261: 36695,
          59262: 36700,
          59264: 36706,
          59265: 36707,
          59266: 36708,
          59267: 36764,
          59268: 36767,
          59269: 36771,
          59270: 36781,
          59271: 36783,
          59272: 36791,
          59273: 36826,
          59274: 36837,
          59275: 36834,
          59276: 36842,
          59277: 36847,
          59278: 36999,
          59279: 36852,
          59280: 36869,
          59281: 36857,
          59282: 36858,
          59283: 36881,
          59284: 36885,
          59285: 36897,
          59286: 36877,
          59287: 36894,
          59288: 36886,
          59289: 36875,
          59290: 36903,
          59291: 36918,
          59292: 36917,
          59293: 36921,
          59294: 36856,
          59295: 36943,
          59296: 36944,
          59297: 36945,
          59298: 36946,
          59299: 36878,
          59300: 36937,
          59301: 36926,
          59302: 36950,
          59303: 36952,
          59304: 36958,
          59305: 36968,
          59306: 36975,
          59307: 36982,
          59308: 38568,
          59309: 36978,
          59310: 36994,
          59311: 36989,
          59312: 36993,
          59313: 36992,
          59314: 37002,
          59315: 37001,
          59316: 37007,
          59317: 37032,
          59318: 37039,
          59319: 37041,
          59320: 37045,
          59321: 37090,
          59322: 37092,
          59323: 25160,
          59324: 37083,
          59325: 37122,
          59326: 37138,
          59327: 37145,
          59328: 37170,
          59329: 37168,
          59330: 37194,
          59331: 37206,
          59332: 37208,
          59333: 37219,
          59334: 37221,
          59335: 37225,
          59336: 37235,
          59337: 37234,
          59338: 37259,
          59339: 37257,
          59340: 37250,
          59341: 37282,
          59342: 37291,
          59343: 37295,
          59344: 37290,
          59345: 37301,
          59346: 37300,
          59347: 37306,
          59348: 37312,
          59349: 37313,
          59350: 37321,
          59351: 37323,
          59352: 37328,
          59353: 37334,
          59354: 37343,
          59355: 37345,
          59356: 37339,
          59357: 37372,
          59358: 37365,
          59359: 37366,
          59360: 37406,
          59361: 37375,
          59362: 37396,
          59363: 37420,
          59364: 37397,
          59365: 37393,
          59366: 37470,
          59367: 37463,
          59368: 37445,
          59369: 37449,
          59370: 37476,
          59371: 37448,
          59372: 37525,
          59373: 37439,
          59374: 37451,
          59375: 37456,
          59376: 37532,
          59377: 37526,
          59378: 37523,
          59379: 37531,
          59380: 37466,
          59381: 37583,
          59382: 37561,
          59383: 37559,
          59384: 37609,
          59385: 37647,
          59386: 37626,
          59387: 37700,
          59388: 37678,
          59456: 37657,
          59457: 37666,
          59458: 37658,
          59459: 37667,
          59460: 37690,
          59461: 37685,
          59462: 37691,
          59463: 37724,
          59464: 37728,
          59465: 37756,
          59466: 37742,
          59467: 37718,
          59468: 37808,
          59469: 37804,
          59470: 37805,
          59471: 37780,
          59472: 37817,
          59473: 37846,
          59474: 37847,
          59475: 37864,
          59476: 37861,
          59477: 37848,
          59478: 37827,
          59479: 37853,
          59480: 37840,
          59481: 37832,
          59482: 37860,
          59483: 37914,
          59484: 37908,
          59485: 37907,
          59486: 37891,
          59487: 37895,
          59488: 37904,
          59489: 37942,
          59490: 37931,
          59491: 37941,
          59492: 37921,
          59493: 37946,
          59494: 37953,
          59495: 37970,
          59496: 37956,
          59497: 37979,
          59498: 37984,
          59499: 37986,
          59500: 37982,
          59501: 37994,
          59502: 37417,
          59503: 38000,
          59504: 38005,
          59505: 38007,
          59506: 38013,
          59507: 37978,
          59508: 38012,
          59509: 38014,
          59510: 38017,
          59511: 38015,
          59512: 38274,
          59513: 38279,
          59514: 38282,
          59515: 38292,
          59516: 38294,
          59517: 38296,
          59518: 38297,
          59520: 38304,
          59521: 38312,
          59522: 38311,
          59523: 38317,
          59524: 38332,
          59525: 38331,
          59526: 38329,
          59527: 38334,
          59528: 38346,
          59529: 28662,
          59530: 38339,
          59531: 38349,
          59532: 38348,
          59533: 38357,
          59534: 38356,
          59535: 38358,
          59536: 38364,
          59537: 38369,
          59538: 38373,
          59539: 38370,
          59540: 38433,
          59541: 38440,
          59542: 38446,
          59543: 38447,
          59544: 38466,
          59545: 38476,
          59546: 38479,
          59547: 38475,
          59548: 38519,
          59549: 38492,
          59550: 38494,
          59551: 38493,
          59552: 38495,
          59553: 38502,
          59554: 38514,
          59555: 38508,
          59556: 38541,
          59557: 38552,
          59558: 38549,
          59559: 38551,
          59560: 38570,
          59561: 38567,
          59562: 38577,
          59563: 38578,
          59564: 38576,
          59565: 38580,
          59566: 38582,
          59567: 38584,
          59568: 38585,
          59569: 38606,
          59570: 38603,
          59571: 38601,
          59572: 38605,
          59573: 35149,
          59574: 38620,
          59575: 38669,
          59576: 38613,
          59577: 38649,
          59578: 38660,
          59579: 38662,
          59580: 38664,
          59581: 38675,
          59582: 38670,
          59583: 38673,
          59584: 38671,
          59585: 38678,
          59586: 38681,
          59587: 38692,
          59588: 38698,
          59589: 38704,
          59590: 38713,
          59591: 38717,
          59592: 38718,
          59593: 38724,
          59594: 38726,
          59595: 38728,
          59596: 38722,
          59597: 38729,
          59598: 38748,
          59599: 38752,
          59600: 38756,
          59601: 38758,
          59602: 38760,
          59603: 21202,
          59604: 38763,
          59605: 38769,
          59606: 38777,
          59607: 38789,
          59608: 38780,
          59609: 38785,
          59610: 38778,
          59611: 38790,
          59612: 38795,
          59613: 38799,
          59614: 38800,
          59615: 38812,
          59616: 38824,
          59617: 38822,
          59618: 38819,
          59619: 38835,
          59620: 38836,
          59621: 38851,
          59622: 38854,
          59623: 38856,
          59624: 38859,
          59625: 38876,
          59626: 38893,
          59627: 40783,
          59628: 38898,
          59629: 31455,
          59630: 38902,
          59631: 38901,
          59632: 38927,
          59633: 38924,
          59634: 38968,
          59635: 38948,
          59636: 38945,
          59637: 38967,
          59638: 38973,
          59639: 38982,
          59640: 38991,
          59641: 38987,
          59642: 39019,
          59643: 39023,
          59644: 39024,
          59712: 39025,
          59713: 39028,
          59714: 39027,
          59715: 39082,
          59716: 39087,
          59717: 39089,
          59718: 39094,
          59719: 39108,
          59720: 39107,
          59721: 39110,
          59722: 39145,
          59723: 39147,
          59724: 39171,
          59725: 39177,
          59726: 39186,
          59727: 39188,
          59728: 39192,
          59729: 39201,
          59730: 39197,
          59731: 39198,
          59732: 39204,
          59733: 39200,
          59734: 39212,
          59735: 39214,
          59736: 39229,
          59737: 39230,
          59738: 39234,
          59739: 39241,
          59740: 39237,
          59741: 39248,
          59742: 39243,
          59743: 39249,
          59744: 39250,
          59745: 39244,
          59746: 39253,
          59747: 39319,
          59748: 39320,
          59749: 39333,
          59750: 39341,
          59751: 39342,
          59752: 39356,
          59753: 39391,
          59754: 39387,
          59755: 39389,
          59756: 39384,
          59757: 39377,
          59758: 39405,
          59759: 39406,
          59760: 39409,
          59761: 39410,
          59762: 39419,
          59763: 39416,
          59764: 39425,
          59765: 39439,
          59766: 39429,
          59767: 39394,
          59768: 39449,
          59769: 39467,
          59770: 39479,
          59771: 39493,
          59772: 39490,
          59773: 39488,
          59774: 39491,
          59776: 39486,
          59777: 39509,
          59778: 39501,
          59779: 39515,
          59780: 39511,
          59781: 39519,
          59782: 39522,
          59783: 39525,
          59784: 39524,
          59785: 39529,
          59786: 39531,
          59787: 39530,
          59788: 39597,
          59789: 39600,
          59790: 39612,
          59791: 39616,
          59792: 39631,
          59793: 39633,
          59794: 39635,
          59795: 39636,
          59796: 39646,
          59797: 39647,
          59798: 39650,
          59799: 39651,
          59800: 39654,
          59801: 39663,
          59802: 39659,
          59803: 39662,
          59804: 39668,
          59805: 39665,
          59806: 39671,
          59807: 39675,
          59808: 39686,
          59809: 39704,
          59810: 39706,
          59811: 39711,
          59812: 39714,
          59813: 39715,
          59814: 39717,
          59815: 39719,
          59816: 39720,
          59817: 39721,
          59818: 39722,
          59819: 39726,
          59820: 39727,
          59821: 39730,
          59822: 39748,
          59823: 39747,
          59824: 39759,
          59825: 39757,
          59826: 39758,
          59827: 39761,
          59828: 39768,
          59829: 39796,
          59830: 39827,
          59831: 39811,
          59832: 39825,
          59833: 39830,
          59834: 39831,
          59835: 39839,
          59836: 39840,
          59837: 39848,
          59838: 39860,
          59839: 39872,
          59840: 39882,
          59841: 39865,
          59842: 39878,
          59843: 39887,
          59844: 39889,
          59845: 39890,
          59846: 39907,
          59847: 39906,
          59848: 39908,
          59849: 39892,
          59850: 39905,
          59851: 39994,
          59852: 39922,
          59853: 39921,
          59854: 39920,
          59855: 39957,
          59856: 39956,
          59857: 39945,
          59858: 39955,
          59859: 39948,
          59860: 39942,
          59861: 39944,
          59862: 39954,
          59863: 39946,
          59864: 39940,
          59865: 39982,
          59866: 39963,
          59867: 39973,
          59868: 39972,
          59869: 39969,
          59870: 39984,
          59871: 40007,
          59872: 39986,
          59873: 40006,
          59874: 39998,
          59875: 40026,
          59876: 40032,
          59877: 40039,
          59878: 40054,
          59879: 40056,
          59880: 40167,
          59881: 40172,
          59882: 40176,
          59883: 40201,
          59884: 40200,
          59885: 40171,
          59886: 40195,
          59887: 40198,
          59888: 40234,
          59889: 40230,
          59890: 40367,
          59891: 40227,
          59892: 40223,
          59893: 40260,
          59894: 40213,
          59895: 40210,
          59896: 40257,
          59897: 40255,
          59898: 40254,
          59899: 40262,
          59900: 40264,
          59968: 40285,
          59969: 40286,
          59970: 40292,
          59971: 40273,
          59972: 40272,
          59973: 40281,
          59974: 40306,
          59975: 40329,
          59976: 40327,
          59977: 40363,
          59978: 40303,
          59979: 40314,
          59980: 40346,
          59981: 40356,
          59982: 40361,
          59983: 40370,
          59984: 40388,
          59985: 40385,
          59986: 40379,
          59987: 40376,
          59988: 40378,
          59989: 40390,
          59990: 40399,
          59991: 40386,
          59992: 40409,
          59993: 40403,
          59994: 40440,
          59995: 40422,
          59996: 40429,
          59997: 40431,
          59998: 40445,
          59999: 40474,
          60000: 40475,
          60001: 40478,
          60002: 40565,
          60003: 40569,
          60004: 40573,
          60005: 40577,
          60006: 40584,
          60007: 40587,
          60008: 40588,
          60009: 40594,
          60010: 40597,
          60011: 40593,
          60012: 40605,
          60013: 40613,
          60014: 40617,
          60015: 40632,
          60016: 40618,
          60017: 40621,
          60018: 38753,
          60019: 40652,
          60020: 40654,
          60021: 40655,
          60022: 40656,
          60023: 40660,
          60024: 40668,
          60025: 40670,
          60026: 40669,
          60027: 40672,
          60028: 40677,
          60029: 40680,
          60030: 40687,
          60032: 40692,
          60033: 40694,
          60034: 40695,
          60035: 40697,
          60036: 40699,
          60037: 40700,
          60038: 40701,
          60039: 40711,
          60040: 40712,
          60041: 30391,
          60042: 40725,
          60043: 40737,
          60044: 40748,
          60045: 40766,
          60046: 40778,
          60047: 40786,
          60048: 40788,
          60049: 40803,
          60050: 40799,
          60051: 40800,
          60052: 40801,
          60053: 40806,
          60054: 40807,
          60055: 40812,
          60056: 40810,
          60057: 40823,
          60058: 40818,
          60059: 40822,
          60060: 40853,
          60061: 40860,
          60062: 40864,
          60063: 22575,
          60064: 27079,
          60065: 36953,
          60066: 29796,
          60067: 20956,
          60068: 29081
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var GenericGF_1 = __webpack_require__(1);
        var GenericGFPoly_1 = __webpack_require__(2);
        function runEuclideanAlgorithm(field, a2, b, R) {
          var _a;
          if (a2.degree() < b.degree()) {
            _a = [b, a2], a2 = _a[0], b = _a[1];
          }
          var rLast = a2;
          var r = b;
          var tLast = field.zero;
          var t = field.one;
          while (r.degree() >= R / 2) {
            var rLastLast = rLast;
            var tLastLast = tLast;
            rLast = r;
            tLast = t;
            if (rLast.isZero()) {
              return null;
            }
            r = rLastLast;
            var q = field.zero;
            var denominatorLeadingTerm = rLast.getCoefficient(rLast.degree());
            var dltInverse = field.inverse(denominatorLeadingTerm);
            while (r.degree() >= rLast.degree() && !r.isZero()) {
              var degreeDiff = r.degree() - rLast.degree();
              var scale = field.multiply(r.getCoefficient(r.degree()), dltInverse);
              q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));
              r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
            }
            t = q.multiplyPoly(tLast).addOrSubtract(tLastLast);
            if (r.degree() >= rLast.degree()) {
              return null;
            }
          }
          var sigmaTildeAtZero = t.getCoefficient(0);
          if (sigmaTildeAtZero === 0) {
            return null;
          }
          var inverse2 = field.inverse(sigmaTildeAtZero);
          return [t.multiply(inverse2), r.multiply(inverse2)];
        }
        function findErrorLocations(field, errorLocator) {
          var numErrors = errorLocator.degree();
          if (numErrors === 1) {
            return [errorLocator.getCoefficient(1)];
          }
          var result = new Array(numErrors);
          var errorCount = 0;
          for (var i2 = 1;i2 < field.size && errorCount < numErrors; i2++) {
            if (errorLocator.evaluateAt(i2) === 0) {
              result[errorCount] = field.inverse(i2);
              errorCount++;
            }
          }
          if (errorCount !== numErrors) {
            return null;
          }
          return result;
        }
        function findErrorMagnitudes(field, errorEvaluator, errorLocations) {
          var s = errorLocations.length;
          var result = new Array(s);
          for (var i2 = 0;i2 < s; i2++) {
            var xiInverse = field.inverse(errorLocations[i2]);
            var denominator = 1;
            for (var j = 0;j < s; j++) {
              if (i2 !== j) {
                denominator = field.multiply(denominator, GenericGF_1.addOrSubtractGF(1, field.multiply(errorLocations[j], xiInverse)));
              }
            }
            result[i2] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
            if (field.generatorBase !== 0) {
              result[i2] = field.multiply(result[i2], xiInverse);
            }
          }
          return result;
        }
        function decode3(bytes, twoS) {
          var outputBytes = new Uint8ClampedArray(bytes.length);
          outputBytes.set(bytes);
          var field = new GenericGF_1.default(285, 256, 0);
          var poly = new GenericGFPoly_1.default(field, outputBytes);
          var syndromeCoefficients = new Uint8ClampedArray(twoS);
          var error = false;
          for (var s = 0;s < twoS; s++) {
            var evaluation = poly.evaluateAt(field.exp(s + field.generatorBase));
            syndromeCoefficients[syndromeCoefficients.length - 1 - s] = evaluation;
            if (evaluation !== 0) {
              error = true;
            }
          }
          if (!error) {
            return outputBytes;
          }
          var syndrome = new GenericGFPoly_1.default(field, syndromeCoefficients);
          var sigmaOmega = runEuclideanAlgorithm(field, field.buildMonomial(twoS, 1), syndrome, twoS);
          if (sigmaOmega === null) {
            return null;
          }
          var errorLocations = findErrorLocations(field, sigmaOmega[0]);
          if (errorLocations == null) {
            return null;
          }
          var errorMagnitudes = findErrorMagnitudes(field, sigmaOmega[1], errorLocations);
          for (var i2 = 0;i2 < errorLocations.length; i2++) {
            var position = outputBytes.length - 1 - field.log(errorLocations[i2]);
            if (position < 0) {
              return null;
            }
            outputBytes[position] = GenericGF_1.addOrSubtractGF(outputBytes[position], errorMagnitudes[i2]);
          }
          return outputBytes;
        }
        exports2.decode = decode3;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.VERSIONS = [
          {
            infoBits: null,
            versionNumber: 1,
            alignmentPatternCenters: [],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 7,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 19 }]
              },
              {
                ecCodewordsPerBlock: 10,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 16 }]
              },
              {
                ecCodewordsPerBlock: 13,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 13 }]
              },
              {
                ecCodewordsPerBlock: 17,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 9 }]
              }
            ]
          },
          {
            infoBits: null,
            versionNumber: 2,
            alignmentPatternCenters: [6, 18],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 10,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 34 }]
              },
              {
                ecCodewordsPerBlock: 16,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 28 }]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 22 }]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 16 }]
              }
            ]
          },
          {
            infoBits: null,
            versionNumber: 3,
            alignmentPatternCenters: [6, 22],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 15,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 55 }]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 44 }]
              },
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 17 }]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 13 }]
              }
            ]
          },
          {
            infoBits: null,
            versionNumber: 4,
            alignmentPatternCenters: [6, 26],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 20,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 80 }]
              },
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 32 }]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 24 }]
              },
              {
                ecCodewordsPerBlock: 16,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 9 }]
              }
            ]
          },
          {
            infoBits: null,
            versionNumber: 5,
            alignmentPatternCenters: [6, 30],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 108 }]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 43 }]
              },
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 15 },
                  { numBlocks: 2, dataCodewordsPerBlock: 16 }
                ]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 11 },
                  { numBlocks: 2, dataCodewordsPerBlock: 12 }
                ]
              }
            ]
          },
          {
            infoBits: null,
            versionNumber: 6,
            alignmentPatternCenters: [6, 34],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 68 }]
              },
              {
                ecCodewordsPerBlock: 16,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 27 }]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 19 }]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 15 }]
              }
            ]
          },
          {
            infoBits: 31892,
            versionNumber: 7,
            alignmentPatternCenters: [6, 22, 38],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 20,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 78 }]
              },
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 31 }]
              },
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 14 },
                  { numBlocks: 4, dataCodewordsPerBlock: 15 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 13 },
                  { numBlocks: 1, dataCodewordsPerBlock: 14 }
                ]
              }
            ]
          },
          {
            infoBits: 34236,
            versionNumber: 8,
            alignmentPatternCenters: [6, 24, 42],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 97 }]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 38 },
                  { numBlocks: 2, dataCodewordsPerBlock: 39 }
                ]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 18 },
                  { numBlocks: 2, dataCodewordsPerBlock: 19 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 14 },
                  { numBlocks: 2, dataCodewordsPerBlock: 15 }
                ]
              }
            ]
          },
          {
            infoBits: 39577,
            versionNumber: 9,
            alignmentPatternCenters: [6, 26, 46],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 116 }]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 36 },
                  { numBlocks: 2, dataCodewordsPerBlock: 37 }
                ]
              },
              {
                ecCodewordsPerBlock: 20,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 16 },
                  { numBlocks: 4, dataCodewordsPerBlock: 17 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 12 },
                  { numBlocks: 4, dataCodewordsPerBlock: 13 }
                ]
              }
            ]
          },
          {
            infoBits: 42195,
            versionNumber: 10,
            alignmentPatternCenters: [6, 28, 50],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 18,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 68 },
                  { numBlocks: 2, dataCodewordsPerBlock: 69 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 43 },
                  { numBlocks: 1, dataCodewordsPerBlock: 44 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 19 },
                  { numBlocks: 2, dataCodewordsPerBlock: 20 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 15 },
                  { numBlocks: 2, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 48118,
            versionNumber: 11,
            alignmentPatternCenters: [6, 30, 54],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 20,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 81 }]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 1, dataCodewordsPerBlock: 50 },
                  { numBlocks: 4, dataCodewordsPerBlock: 51 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 22 },
                  { numBlocks: 4, dataCodewordsPerBlock: 23 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 12 },
                  { numBlocks: 8, dataCodewordsPerBlock: 13 }
                ]
              }
            ]
          },
          {
            infoBits: 51042,
            versionNumber: 12,
            alignmentPatternCenters: [6, 32, 58],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 92 },
                  { numBlocks: 2, dataCodewordsPerBlock: 93 }
                ]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 36 },
                  { numBlocks: 2, dataCodewordsPerBlock: 37 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 20 },
                  { numBlocks: 6, dataCodewordsPerBlock: 21 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 7, dataCodewordsPerBlock: 14 },
                  { numBlocks: 4, dataCodewordsPerBlock: 15 }
                ]
              }
            ]
          },
          {
            infoBits: 55367,
            versionNumber: 13,
            alignmentPatternCenters: [6, 34, 62],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 107 }]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 8, dataCodewordsPerBlock: 37 },
                  { numBlocks: 1, dataCodewordsPerBlock: 38 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 8, dataCodewordsPerBlock: 20 },
                  { numBlocks: 4, dataCodewordsPerBlock: 21 }
                ]
              },
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 12, dataCodewordsPerBlock: 11 },
                  { numBlocks: 4, dataCodewordsPerBlock: 12 }
                ]
              }
            ]
          },
          {
            infoBits: 58893,
            versionNumber: 14,
            alignmentPatternCenters: [6, 26, 46, 66],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 115 },
                  { numBlocks: 1, dataCodewordsPerBlock: 116 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 40 },
                  { numBlocks: 5, dataCodewordsPerBlock: 41 }
                ]
              },
              {
                ecCodewordsPerBlock: 20,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 16 },
                  { numBlocks: 5, dataCodewordsPerBlock: 17 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 12 },
                  { numBlocks: 5, dataCodewordsPerBlock: 13 }
                ]
              }
            ]
          },
          {
            infoBits: 63784,
            versionNumber: 15,
            alignmentPatternCenters: [6, 26, 48, 70],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 22,
                ecBlocks: [
                  { numBlocks: 5, dataCodewordsPerBlock: 87 },
                  { numBlocks: 1, dataCodewordsPerBlock: 88 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 5, dataCodewordsPerBlock: 41 },
                  { numBlocks: 5, dataCodewordsPerBlock: 42 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 5, dataCodewordsPerBlock: 24 },
                  { numBlocks: 7, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 12 },
                  { numBlocks: 7, dataCodewordsPerBlock: 13 }
                ]
              }
            ]
          },
          {
            infoBits: 68472,
            versionNumber: 16,
            alignmentPatternCenters: [6, 26, 50, 74],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 5, dataCodewordsPerBlock: 98 },
                  { numBlocks: 1, dataCodewordsPerBlock: 99 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 7, dataCodewordsPerBlock: 45 },
                  { numBlocks: 3, dataCodewordsPerBlock: 46 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [
                  { numBlocks: 15, dataCodewordsPerBlock: 19 },
                  { numBlocks: 2, dataCodewordsPerBlock: 20 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 15 },
                  { numBlocks: 13, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 70749,
            versionNumber: 17,
            alignmentPatternCenters: [6, 30, 54, 78],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 1, dataCodewordsPerBlock: 107 },
                  { numBlocks: 5, dataCodewordsPerBlock: 108 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 10, dataCodewordsPerBlock: 46 },
                  { numBlocks: 1, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 1, dataCodewordsPerBlock: 22 },
                  { numBlocks: 15, dataCodewordsPerBlock: 23 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 14 },
                  { numBlocks: 17, dataCodewordsPerBlock: 15 }
                ]
              }
            ]
          },
          {
            infoBits: 76311,
            versionNumber: 18,
            alignmentPatternCenters: [6, 30, 56, 82],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 5, dataCodewordsPerBlock: 120 },
                  { numBlocks: 1, dataCodewordsPerBlock: 121 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 9, dataCodewordsPerBlock: 43 },
                  { numBlocks: 4, dataCodewordsPerBlock: 44 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 17, dataCodewordsPerBlock: 22 },
                  { numBlocks: 1, dataCodewordsPerBlock: 23 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 14 },
                  { numBlocks: 19, dataCodewordsPerBlock: 15 }
                ]
              }
            ]
          },
          {
            infoBits: 79154,
            versionNumber: 19,
            alignmentPatternCenters: [6, 30, 58, 86],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 113 },
                  { numBlocks: 4, dataCodewordsPerBlock: 114 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 44 },
                  { numBlocks: 11, dataCodewordsPerBlock: 45 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 17, dataCodewordsPerBlock: 21 },
                  { numBlocks: 4, dataCodewordsPerBlock: 22 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 9, dataCodewordsPerBlock: 13 },
                  { numBlocks: 16, dataCodewordsPerBlock: 14 }
                ]
              }
            ]
          },
          {
            infoBits: 84390,
            versionNumber: 20,
            alignmentPatternCenters: [6, 34, 62, 90],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 107 },
                  { numBlocks: 5, dataCodewordsPerBlock: 108 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 41 },
                  { numBlocks: 13, dataCodewordsPerBlock: 42 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 15, dataCodewordsPerBlock: 24 },
                  { numBlocks: 5, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 15, dataCodewordsPerBlock: 15 },
                  { numBlocks: 10, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 87683,
            versionNumber: 21,
            alignmentPatternCenters: [6, 28, 50, 72, 94],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 116 },
                  { numBlocks: 4, dataCodewordsPerBlock: 117 }
                ]
              },
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 42 }]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 17, dataCodewordsPerBlock: 22 },
                  { numBlocks: 6, dataCodewordsPerBlock: 23 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 19, dataCodewordsPerBlock: 16 },
                  { numBlocks: 6, dataCodewordsPerBlock: 17 }
                ]
              }
            ]
          },
          {
            infoBits: 92361,
            versionNumber: 22,
            alignmentPatternCenters: [6, 26, 50, 74, 98],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 111 },
                  { numBlocks: 7, dataCodewordsPerBlock: 112 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 46 }]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 7, dataCodewordsPerBlock: 24 },
                  { numBlocks: 16, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 24,
                ecBlocks: [{ numBlocks: 34, dataCodewordsPerBlock: 13 }]
              }
            ]
          },
          {
            infoBits: 96236,
            versionNumber: 23,
            alignmentPatternCenters: [6, 30, 54, 74, 102],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 121 },
                  { numBlocks: 5, dataCodewordsPerBlock: 122 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 47 },
                  { numBlocks: 14, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 24 },
                  { numBlocks: 14, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 16, dataCodewordsPerBlock: 15 },
                  { numBlocks: 14, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 102084,
            versionNumber: 24,
            alignmentPatternCenters: [6, 28, 54, 80, 106],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 117 },
                  { numBlocks: 4, dataCodewordsPerBlock: 118 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 45 },
                  { numBlocks: 14, dataCodewordsPerBlock: 46 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 24 },
                  { numBlocks: 16, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 30, dataCodewordsPerBlock: 16 },
                  { numBlocks: 2, dataCodewordsPerBlock: 17 }
                ]
              }
            ]
          },
          {
            infoBits: 102881,
            versionNumber: 25,
            alignmentPatternCenters: [6, 32, 58, 84, 110],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 26,
                ecBlocks: [
                  { numBlocks: 8, dataCodewordsPerBlock: 106 },
                  { numBlocks: 4, dataCodewordsPerBlock: 107 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 8, dataCodewordsPerBlock: 47 },
                  { numBlocks: 13, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 7, dataCodewordsPerBlock: 24 },
                  { numBlocks: 22, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 22, dataCodewordsPerBlock: 15 },
                  { numBlocks: 13, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 110507,
            versionNumber: 26,
            alignmentPatternCenters: [6, 30, 58, 86, 114],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 10, dataCodewordsPerBlock: 114 },
                  { numBlocks: 2, dataCodewordsPerBlock: 115 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 19, dataCodewordsPerBlock: 46 },
                  { numBlocks: 4, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 28, dataCodewordsPerBlock: 22 },
                  { numBlocks: 6, dataCodewordsPerBlock: 23 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 33, dataCodewordsPerBlock: 16 },
                  { numBlocks: 4, dataCodewordsPerBlock: 17 }
                ]
              }
            ]
          },
          {
            infoBits: 110734,
            versionNumber: 27,
            alignmentPatternCenters: [6, 34, 62, 90, 118],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 8, dataCodewordsPerBlock: 122 },
                  { numBlocks: 4, dataCodewordsPerBlock: 123 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 22, dataCodewordsPerBlock: 45 },
                  { numBlocks: 3, dataCodewordsPerBlock: 46 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 8, dataCodewordsPerBlock: 23 },
                  { numBlocks: 26, dataCodewordsPerBlock: 24 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 12, dataCodewordsPerBlock: 15 },
                  { numBlocks: 28, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 117786,
            versionNumber: 28,
            alignmentPatternCenters: [6, 26, 50, 74, 98, 122],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 117 },
                  { numBlocks: 10, dataCodewordsPerBlock: 118 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 3, dataCodewordsPerBlock: 45 },
                  { numBlocks: 23, dataCodewordsPerBlock: 46 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 24 },
                  { numBlocks: 31, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 15 },
                  { numBlocks: 31, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 119615,
            versionNumber: 29,
            alignmentPatternCenters: [6, 30, 54, 78, 102, 126],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 7, dataCodewordsPerBlock: 116 },
                  { numBlocks: 7, dataCodewordsPerBlock: 117 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 21, dataCodewordsPerBlock: 45 },
                  { numBlocks: 7, dataCodewordsPerBlock: 46 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 1, dataCodewordsPerBlock: 23 },
                  { numBlocks: 37, dataCodewordsPerBlock: 24 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 19, dataCodewordsPerBlock: 15 },
                  { numBlocks: 26, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 126325,
            versionNumber: 30,
            alignmentPatternCenters: [6, 26, 52, 78, 104, 130],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 5, dataCodewordsPerBlock: 115 },
                  { numBlocks: 10, dataCodewordsPerBlock: 116 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 19, dataCodewordsPerBlock: 47 },
                  { numBlocks: 10, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 15, dataCodewordsPerBlock: 24 },
                  { numBlocks: 25, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 23, dataCodewordsPerBlock: 15 },
                  { numBlocks: 25, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 127568,
            versionNumber: 31,
            alignmentPatternCenters: [6, 30, 56, 82, 108, 134],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 13, dataCodewordsPerBlock: 115 },
                  { numBlocks: 3, dataCodewordsPerBlock: 116 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 46 },
                  { numBlocks: 29, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 42, dataCodewordsPerBlock: 24 },
                  { numBlocks: 1, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 23, dataCodewordsPerBlock: 15 },
                  { numBlocks: 28, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 133589,
            versionNumber: 32,
            alignmentPatternCenters: [6, 34, 60, 86, 112, 138],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 115 }]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 10, dataCodewordsPerBlock: 46 },
                  { numBlocks: 23, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 10, dataCodewordsPerBlock: 24 },
                  { numBlocks: 35, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 19, dataCodewordsPerBlock: 15 },
                  { numBlocks: 35, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 136944,
            versionNumber: 33,
            alignmentPatternCenters: [6, 30, 58, 86, 114, 142],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 17, dataCodewordsPerBlock: 115 },
                  { numBlocks: 1, dataCodewordsPerBlock: 116 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 14, dataCodewordsPerBlock: 46 },
                  { numBlocks: 21, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 29, dataCodewordsPerBlock: 24 },
                  { numBlocks: 19, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 11, dataCodewordsPerBlock: 15 },
                  { numBlocks: 46, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 141498,
            versionNumber: 34,
            alignmentPatternCenters: [6, 34, 62, 90, 118, 146],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 13, dataCodewordsPerBlock: 115 },
                  { numBlocks: 6, dataCodewordsPerBlock: 116 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 14, dataCodewordsPerBlock: 46 },
                  { numBlocks: 23, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 44, dataCodewordsPerBlock: 24 },
                  { numBlocks: 7, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 59, dataCodewordsPerBlock: 16 },
                  { numBlocks: 1, dataCodewordsPerBlock: 17 }
                ]
              }
            ]
          },
          {
            infoBits: 145311,
            versionNumber: 35,
            alignmentPatternCenters: [6, 30, 54, 78, 102, 126, 150],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 12, dataCodewordsPerBlock: 121 },
                  { numBlocks: 7, dataCodewordsPerBlock: 122 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 12, dataCodewordsPerBlock: 47 },
                  { numBlocks: 26, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 39, dataCodewordsPerBlock: 24 },
                  { numBlocks: 14, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 22, dataCodewordsPerBlock: 15 },
                  { numBlocks: 41, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 150283,
            versionNumber: 36,
            alignmentPatternCenters: [6, 24, 50, 76, 102, 128, 154],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 121 },
                  { numBlocks: 14, dataCodewordsPerBlock: 122 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 6, dataCodewordsPerBlock: 47 },
                  { numBlocks: 34, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 46, dataCodewordsPerBlock: 24 },
                  { numBlocks: 10, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 2, dataCodewordsPerBlock: 15 },
                  { numBlocks: 64, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 152622,
            versionNumber: 37,
            alignmentPatternCenters: [6, 28, 54, 80, 106, 132, 158],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 17, dataCodewordsPerBlock: 122 },
                  { numBlocks: 4, dataCodewordsPerBlock: 123 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 29, dataCodewordsPerBlock: 46 },
                  { numBlocks: 14, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 49, dataCodewordsPerBlock: 24 },
                  { numBlocks: 10, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 24, dataCodewordsPerBlock: 15 },
                  { numBlocks: 46, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 158308,
            versionNumber: 38,
            alignmentPatternCenters: [6, 32, 58, 84, 110, 136, 162],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 4, dataCodewordsPerBlock: 122 },
                  { numBlocks: 18, dataCodewordsPerBlock: 123 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 13, dataCodewordsPerBlock: 46 },
                  { numBlocks: 32, dataCodewordsPerBlock: 47 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 48, dataCodewordsPerBlock: 24 },
                  { numBlocks: 14, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 42, dataCodewordsPerBlock: 15 },
                  { numBlocks: 32, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 161089,
            versionNumber: 39,
            alignmentPatternCenters: [6, 26, 54, 82, 110, 138, 166],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 20, dataCodewordsPerBlock: 117 },
                  { numBlocks: 4, dataCodewordsPerBlock: 118 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 40, dataCodewordsPerBlock: 47 },
                  { numBlocks: 7, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 43, dataCodewordsPerBlock: 24 },
                  { numBlocks: 22, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 10, dataCodewordsPerBlock: 15 },
                  { numBlocks: 67, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          },
          {
            infoBits: 167017,
            versionNumber: 40,
            alignmentPatternCenters: [6, 30, 58, 86, 114, 142, 170],
            errorCorrectionLevels: [
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 19, dataCodewordsPerBlock: 118 },
                  { numBlocks: 6, dataCodewordsPerBlock: 119 }
                ]
              },
              {
                ecCodewordsPerBlock: 28,
                ecBlocks: [
                  { numBlocks: 18, dataCodewordsPerBlock: 47 },
                  { numBlocks: 31, dataCodewordsPerBlock: 48 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 34, dataCodewordsPerBlock: 24 },
                  { numBlocks: 34, dataCodewordsPerBlock: 25 }
                ]
              },
              {
                ecCodewordsPerBlock: 30,
                ecBlocks: [
                  { numBlocks: 20, dataCodewordsPerBlock: 15 },
                  { numBlocks: 61, dataCodewordsPerBlock: 16 }
                ]
              }
            ]
          }
        ];
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var BitMatrix_1 = __webpack_require__(0);
        function squareToQuadrilateral(p1, p2, p3, p4) {
          var dx3 = p1.x - p2.x + p3.x - p4.x;
          var dy3 = p1.y - p2.y + p3.y - p4.y;
          if (dx3 === 0 && dy3 === 0) {
            return {
              a11: p2.x - p1.x,
              a12: p2.y - p1.y,
              a13: 0,
              a21: p3.x - p2.x,
              a22: p3.y - p2.y,
              a23: 0,
              a31: p1.x,
              a32: p1.y,
              a33: 1
            };
          } else {
            var dx1 = p2.x - p3.x;
            var dx2 = p4.x - p3.x;
            var dy1 = p2.y - p3.y;
            var dy2 = p4.y - p3.y;
            var denominator = dx1 * dy2 - dx2 * dy1;
            var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
            var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
            return {
              a11: p2.x - p1.x + a13 * p2.x,
              a12: p2.y - p1.y + a13 * p2.y,
              a13,
              a21: p4.x - p1.x + a23 * p4.x,
              a22: p4.y - p1.y + a23 * p4.y,
              a23,
              a31: p1.x,
              a32: p1.y,
              a33: 1
            };
          }
        }
        function quadrilateralToSquare(p1, p2, p3, p4) {
          var sToQ = squareToQuadrilateral(p1, p2, p3, p4);
          return {
            a11: sToQ.a22 * sToQ.a33 - sToQ.a23 * sToQ.a32,
            a12: sToQ.a13 * sToQ.a32 - sToQ.a12 * sToQ.a33,
            a13: sToQ.a12 * sToQ.a23 - sToQ.a13 * sToQ.a22,
            a21: sToQ.a23 * sToQ.a31 - sToQ.a21 * sToQ.a33,
            a22: sToQ.a11 * sToQ.a33 - sToQ.a13 * sToQ.a31,
            a23: sToQ.a13 * sToQ.a21 - sToQ.a11 * sToQ.a23,
            a31: sToQ.a21 * sToQ.a32 - sToQ.a22 * sToQ.a31,
            a32: sToQ.a12 * sToQ.a31 - sToQ.a11 * sToQ.a32,
            a33: sToQ.a11 * sToQ.a22 - sToQ.a12 * sToQ.a21
          };
        }
        function times(a2, b) {
          return {
            a11: a2.a11 * b.a11 + a2.a21 * b.a12 + a2.a31 * b.a13,
            a12: a2.a12 * b.a11 + a2.a22 * b.a12 + a2.a32 * b.a13,
            a13: a2.a13 * b.a11 + a2.a23 * b.a12 + a2.a33 * b.a13,
            a21: a2.a11 * b.a21 + a2.a21 * b.a22 + a2.a31 * b.a23,
            a22: a2.a12 * b.a21 + a2.a22 * b.a22 + a2.a32 * b.a23,
            a23: a2.a13 * b.a21 + a2.a23 * b.a22 + a2.a33 * b.a23,
            a31: a2.a11 * b.a31 + a2.a21 * b.a32 + a2.a31 * b.a33,
            a32: a2.a12 * b.a31 + a2.a22 * b.a32 + a2.a32 * b.a33,
            a33: a2.a13 * b.a31 + a2.a23 * b.a32 + a2.a33 * b.a33
          };
        }
        function extract(image3, location) {
          var qToS = quadrilateralToSquare({ x: 3.5, y: 3.5 }, { x: location.dimension - 3.5, y: 3.5 }, { x: location.dimension - 6.5, y: location.dimension - 6.5 }, { x: 3.5, y: location.dimension - 3.5 });
          var sToQ = squareToQuadrilateral(location.topLeft, location.topRight, location.alignmentPattern, location.bottomLeft);
          var transform = times(sToQ, qToS);
          var matrix = BitMatrix_1.BitMatrix.createEmpty(location.dimension, location.dimension);
          var mappingFunction = function(x3, y3) {
            var denominator = transform.a13 * x3 + transform.a23 * y3 + transform.a33;
            return {
              x: (transform.a11 * x3 + transform.a21 * y3 + transform.a31) / denominator,
              y: (transform.a12 * x3 + transform.a22 * y3 + transform.a32) / denominator
            };
          };
          for (var y2 = 0;y2 < location.dimension; y2++) {
            for (var x2 = 0;x2 < location.dimension; x2++) {
              var xValue = x2 + 0.5;
              var yValue = y2 + 0.5;
              var sourcePixel = mappingFunction(xValue, yValue);
              matrix.set(x2, y2, image3.get(Math.floor(sourcePixel.x), Math.floor(sourcePixel.y)));
            }
          }
          return {
            matrix,
            mappingFunction
          };
        }
        exports2.extract = extract;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var MAX_FINDERPATTERNS_TO_SEARCH = 4;
        var MIN_QUAD_RATIO = 0.5;
        var MAX_QUAD_RATIO = 1.5;
        var distance2 = function(a2, b) {
          return Math.sqrt(Math.pow(b.x - a2.x, 2) + Math.pow(b.y - a2.y, 2));
        };
        function sum(values) {
          return values.reduce(function(a2, b) {
            return a2 + b;
          });
        }
        function reorderFinderPatterns(pattern1, pattern2, pattern3) {
          var _a, _b, _c, _d;
          var oneTwoDistance = distance2(pattern1, pattern2);
          var twoThreeDistance = distance2(pattern2, pattern3);
          var oneThreeDistance = distance2(pattern1, pattern3);
          var bottomLeft;
          var topLeft;
          var topRight;
          if (twoThreeDistance >= oneTwoDistance && twoThreeDistance >= oneThreeDistance) {
            _a = [pattern2, pattern1, pattern3], bottomLeft = _a[0], topLeft = _a[1], topRight = _a[2];
          } else if (oneThreeDistance >= twoThreeDistance && oneThreeDistance >= oneTwoDistance) {
            _b = [pattern1, pattern2, pattern3], bottomLeft = _b[0], topLeft = _b[1], topRight = _b[2];
          } else {
            _c = [pattern1, pattern3, pattern2], bottomLeft = _c[0], topLeft = _c[1], topRight = _c[2];
          }
          if ((topRight.x - topLeft.x) * (bottomLeft.y - topLeft.y) - (topRight.y - topLeft.y) * (bottomLeft.x - topLeft.x) < 0) {
            _d = [topRight, bottomLeft], bottomLeft = _d[0], topRight = _d[1];
          }
          return { bottomLeft, topLeft, topRight };
        }
        function computeDimension(topLeft, topRight, bottomLeft, matrix) {
          var moduleSize = (sum(countBlackWhiteRun(topLeft, bottomLeft, matrix, 5)) / 7 + sum(countBlackWhiteRun(topLeft, topRight, matrix, 5)) / 7 + sum(countBlackWhiteRun(bottomLeft, topLeft, matrix, 5)) / 7 + sum(countBlackWhiteRun(topRight, topLeft, matrix, 5)) / 7) / 4;
          if (moduleSize < 1) {
            throw new Error("Invalid module size");
          }
          var topDimension = Math.round(distance2(topLeft, topRight) / moduleSize);
          var sideDimension = Math.round(distance2(topLeft, bottomLeft) / moduleSize);
          var dimension = Math.floor((topDimension + sideDimension) / 2) + 7;
          switch (dimension % 4) {
            case 0:
              dimension++;
              break;
            case 2:
              dimension--;
              break;
          }
          return { dimension, moduleSize };
        }
        function countBlackWhiteRunTowardsPoint(origin, end, matrix, length) {
          var switchPoints = [{ x: Math.floor(origin.x), y: Math.floor(origin.y) }];
          var steep = Math.abs(end.y - origin.y) > Math.abs(end.x - origin.x);
          var fromX;
          var fromY;
          var toX;
          var toY;
          if (steep) {
            fromX = Math.floor(origin.y);
            fromY = Math.floor(origin.x);
            toX = Math.floor(end.y);
            toY = Math.floor(end.x);
          } else {
            fromX = Math.floor(origin.x);
            fromY = Math.floor(origin.y);
            toX = Math.floor(end.x);
            toY = Math.floor(end.y);
          }
          var dx = Math.abs(toX - fromX);
          var dy = Math.abs(toY - fromY);
          var error = Math.floor(-dx / 2);
          var xStep = fromX < toX ? 1 : -1;
          var yStep = fromY < toY ? 1 : -1;
          var currentPixel = true;
          for (var x2 = fromX, y2 = fromY;x2 !== toX + xStep; x2 += xStep) {
            var realX = steep ? y2 : x2;
            var realY = steep ? x2 : y2;
            if (matrix.get(realX, realY) !== currentPixel) {
              currentPixel = !currentPixel;
              switchPoints.push({ x: realX, y: realY });
              if (switchPoints.length === length + 1) {
                break;
              }
            }
            error += dy;
            if (error > 0) {
              if (y2 === toY) {
                break;
              }
              y2 += yStep;
              error -= dx;
            }
          }
          var distances = [];
          for (var i2 = 0;i2 < length; i2++) {
            if (switchPoints[i2] && switchPoints[i2 + 1]) {
              distances.push(distance2(switchPoints[i2], switchPoints[i2 + 1]));
            } else {
              distances.push(0);
            }
          }
          return distances;
        }
        function countBlackWhiteRun(origin, end, matrix, length) {
          var _a;
          var rise = end.y - origin.y;
          var run = end.x - origin.x;
          var towardsEnd = countBlackWhiteRunTowardsPoint(origin, end, matrix, Math.ceil(length / 2));
          var awayFromEnd = countBlackWhiteRunTowardsPoint(origin, { x: origin.x - run, y: origin.y - rise }, matrix, Math.ceil(length / 2));
          var middleValue = towardsEnd.shift() + awayFromEnd.shift() - 1;
          return (_a = awayFromEnd.concat(middleValue)).concat.apply(_a, towardsEnd);
        }
        function scoreBlackWhiteRun(sequence, ratios) {
          var averageSize = sum(sequence) / sum(ratios);
          var error = 0;
          ratios.forEach(function(ratio, i2) {
            error += Math.pow(sequence[i2] - ratio * averageSize, 2);
          });
          return { averageSize, error };
        }
        function scorePattern(point, ratios, matrix) {
          try {
            var horizontalRun = countBlackWhiteRun(point, { x: -1, y: point.y }, matrix, ratios.length);
            var verticalRun = countBlackWhiteRun(point, { x: point.x, y: -1 }, matrix, ratios.length);
            var topLeftPoint = {
              x: Math.max(0, point.x - point.y) - 1,
              y: Math.max(0, point.y - point.x) - 1
            };
            var topLeftBottomRightRun = countBlackWhiteRun(point, topLeftPoint, matrix, ratios.length);
            var bottomLeftPoint = {
              x: Math.min(matrix.width, point.x + point.y) + 1,
              y: Math.min(matrix.height, point.y + point.x) + 1
            };
            var bottomLeftTopRightRun = countBlackWhiteRun(point, bottomLeftPoint, matrix, ratios.length);
            var horzError = scoreBlackWhiteRun(horizontalRun, ratios);
            var vertError = scoreBlackWhiteRun(verticalRun, ratios);
            var diagDownError = scoreBlackWhiteRun(topLeftBottomRightRun, ratios);
            var diagUpError = scoreBlackWhiteRun(bottomLeftTopRightRun, ratios);
            var ratioError = Math.sqrt(horzError.error * horzError.error + vertError.error * vertError.error + diagDownError.error * diagDownError.error + diagUpError.error * diagUpError.error);
            var avgSize = (horzError.averageSize + vertError.averageSize + diagDownError.averageSize + diagUpError.averageSize) / 4;
            var sizeError = (Math.pow(horzError.averageSize - avgSize, 2) + Math.pow(vertError.averageSize - avgSize, 2) + Math.pow(diagDownError.averageSize - avgSize, 2) + Math.pow(diagUpError.averageSize - avgSize, 2)) / avgSize;
            return ratioError + sizeError;
          } catch (_a) {
            return Infinity;
          }
        }
        function recenterLocation(matrix, p) {
          var leftX = Math.round(p.x);
          while (matrix.get(leftX, Math.round(p.y))) {
            leftX--;
          }
          var rightX = Math.round(p.x);
          while (matrix.get(rightX, Math.round(p.y))) {
            rightX++;
          }
          var x2 = (leftX + rightX) / 2;
          var topY = Math.round(p.y);
          while (matrix.get(Math.round(x2), topY)) {
            topY--;
          }
          var bottomY = Math.round(p.y);
          while (matrix.get(Math.round(x2), bottomY)) {
            bottomY++;
          }
          var y2 = (topY + bottomY) / 2;
          return { x: x2, y: y2 };
        }
        function locate(matrix) {
          var finderPatternQuads = [];
          var activeFinderPatternQuads = [];
          var alignmentPatternQuads = [];
          var activeAlignmentPatternQuads = [];
          var _loop_1 = function(y3) {
            var length_1 = 0;
            var lastBit = false;
            var scans = [0, 0, 0, 0, 0];
            var _loop_2 = function(x3) {
              var v = matrix.get(x3, y3);
              if (v === lastBit) {
                length_1++;
              } else {
                scans = [scans[1], scans[2], scans[3], scans[4], length_1];
                length_1 = 1;
                lastBit = v;
                var averageFinderPatternBlocksize = sum(scans) / 7;
                var validFinderPattern = Math.abs(scans[0] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[1] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[2] - 3 * averageFinderPatternBlocksize) < 3 * averageFinderPatternBlocksize && Math.abs(scans[3] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[4] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && !v;
                var averageAlignmentPatternBlocksize = sum(scans.slice(-3)) / 3;
                var validAlignmentPattern = Math.abs(scans[2] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && Math.abs(scans[3] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && Math.abs(scans[4] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && v;
                if (validFinderPattern) {
                  var endX_1 = x3 - scans[3] - scans[4];
                  var startX_1 = endX_1 - scans[2];
                  var line = { startX: startX_1, endX: endX_1, y: y3 };
                  var matchingQuads = activeFinderPatternQuads.filter(function(q) {
                    return startX_1 >= q.bottom.startX && startX_1 <= q.bottom.endX || endX_1 >= q.bottom.startX && startX_1 <= q.bottom.endX || startX_1 <= q.bottom.startX && endX_1 >= q.bottom.endX && (scans[2] / (q.bottom.endX - q.bottom.startX) < MAX_QUAD_RATIO && scans[2] / (q.bottom.endX - q.bottom.startX) > MIN_QUAD_RATIO);
                  });
                  if (matchingQuads.length > 0) {
                    matchingQuads[0].bottom = line;
                  } else {
                    activeFinderPatternQuads.push({ top: line, bottom: line });
                  }
                }
                if (validAlignmentPattern) {
                  var endX_2 = x3 - scans[4];
                  var startX_2 = endX_2 - scans[3];
                  var line = { startX: startX_2, y: y3, endX: endX_2 };
                  var matchingQuads = activeAlignmentPatternQuads.filter(function(q) {
                    return startX_2 >= q.bottom.startX && startX_2 <= q.bottom.endX || endX_2 >= q.bottom.startX && startX_2 <= q.bottom.endX || startX_2 <= q.bottom.startX && endX_2 >= q.bottom.endX && (scans[2] / (q.bottom.endX - q.bottom.startX) < MAX_QUAD_RATIO && scans[2] / (q.bottom.endX - q.bottom.startX) > MIN_QUAD_RATIO);
                  });
                  if (matchingQuads.length > 0) {
                    matchingQuads[0].bottom = line;
                  } else {
                    activeAlignmentPatternQuads.push({ top: line, bottom: line });
                  }
                }
              }
            };
            for (var x2 = -1;x2 <= matrix.width; x2++) {
              _loop_2(x2);
            }
            finderPatternQuads.push.apply(finderPatternQuads, activeFinderPatternQuads.filter(function(q) {
              return q.bottom.y !== y3 && q.bottom.y - q.top.y >= 2;
            }));
            activeFinderPatternQuads = activeFinderPatternQuads.filter(function(q) {
              return q.bottom.y === y3;
            });
            alignmentPatternQuads.push.apply(alignmentPatternQuads, activeAlignmentPatternQuads.filter(function(q) {
              return q.bottom.y !== y3;
            }));
            activeAlignmentPatternQuads = activeAlignmentPatternQuads.filter(function(q) {
              return q.bottom.y === y3;
            });
          };
          for (var y2 = 0;y2 <= matrix.height; y2++) {
            _loop_1(y2);
          }
          finderPatternQuads.push.apply(finderPatternQuads, activeFinderPatternQuads.filter(function(q) {
            return q.bottom.y - q.top.y >= 2;
          }));
          alignmentPatternQuads.push.apply(alignmentPatternQuads, activeAlignmentPatternQuads);
          var finderPatternGroups = finderPatternQuads.filter(function(q) {
            return q.bottom.y - q.top.y >= 2;
          }).map(function(q) {
            var x2 = (q.top.startX + q.top.endX + q.bottom.startX + q.bottom.endX) / 4;
            var y3 = (q.top.y + q.bottom.y + 1) / 2;
            if (!matrix.get(Math.round(x2), Math.round(y3))) {
              return;
            }
            var lengths = [q.top.endX - q.top.startX, q.bottom.endX - q.bottom.startX, q.bottom.y - q.top.y + 1];
            var size = sum(lengths) / lengths.length;
            var score = scorePattern({ x: Math.round(x2), y: Math.round(y3) }, [1, 1, 3, 1, 1], matrix);
            return { score, x: x2, y: y3, size };
          }).filter(function(q) {
            return !!q;
          }).sort(function(a2, b) {
            return a2.score - b.score;
          }).map(function(point, i2, finderPatterns) {
            if (i2 > MAX_FINDERPATTERNS_TO_SEARCH) {
              return null;
            }
            var otherPoints = finderPatterns.filter(function(p, ii) {
              return i2 !== ii;
            }).map(function(p) {
              return { x: p.x, y: p.y, score: p.score + Math.pow(p.size - point.size, 2) / point.size, size: p.size };
            }).sort(function(a2, b) {
              return a2.score - b.score;
            });
            if (otherPoints.length < 2) {
              return null;
            }
            var score = point.score + otherPoints[0].score + otherPoints[1].score;
            return { points: [point].concat(otherPoints.slice(0, 2)), score };
          }).filter(function(q) {
            return !!q;
          }).sort(function(a2, b) {
            return a2.score - b.score;
          });
          if (finderPatternGroups.length === 0) {
            return null;
          }
          var _a = reorderFinderPatterns(finderPatternGroups[0].points[0], finderPatternGroups[0].points[1], finderPatternGroups[0].points[2]), topRight = _a.topRight, topLeft = _a.topLeft, bottomLeft = _a.bottomLeft;
          var alignment = findAlignmentPattern(matrix, alignmentPatternQuads, topRight, topLeft, bottomLeft);
          var result = [];
          if (alignment) {
            result.push({
              alignmentPattern: { x: alignment.alignmentPattern.x, y: alignment.alignmentPattern.y },
              bottomLeft: { x: bottomLeft.x, y: bottomLeft.y },
              dimension: alignment.dimension,
              topLeft: { x: topLeft.x, y: topLeft.y },
              topRight: { x: topRight.x, y: topRight.y }
            });
          }
          var midTopRight = recenterLocation(matrix, topRight);
          var midTopLeft = recenterLocation(matrix, topLeft);
          var midBottomLeft = recenterLocation(matrix, bottomLeft);
          var centeredAlignment = findAlignmentPattern(matrix, alignmentPatternQuads, midTopRight, midTopLeft, midBottomLeft);
          if (centeredAlignment) {
            result.push({
              alignmentPattern: { x: centeredAlignment.alignmentPattern.x, y: centeredAlignment.alignmentPattern.y },
              bottomLeft: { x: midBottomLeft.x, y: midBottomLeft.y },
              topLeft: { x: midTopLeft.x, y: midTopLeft.y },
              topRight: { x: midTopRight.x, y: midTopRight.y },
              dimension: centeredAlignment.dimension
            });
          }
          if (result.length === 0) {
            return null;
          }
          return result;
        }
        exports2.locate = locate;
        function findAlignmentPattern(matrix, alignmentPatternQuads, topRight, topLeft, bottomLeft) {
          var _a;
          var dimension;
          var moduleSize;
          try {
            _a = computeDimension(topLeft, topRight, bottomLeft, matrix), dimension = _a.dimension, moduleSize = _a.moduleSize;
          } catch (e) {
            return null;
          }
          var bottomRightFinderPattern = {
            x: topRight.x - topLeft.x + bottomLeft.x,
            y: topRight.y - topLeft.y + bottomLeft.y
          };
          var modulesBetweenFinderPatterns = (distance2(topLeft, bottomLeft) + distance2(topLeft, topRight)) / 2 / moduleSize;
          var correctionToTopLeft = 1 - 3 / modulesBetweenFinderPatterns;
          var expectedAlignmentPattern = {
            x: topLeft.x + correctionToTopLeft * (bottomRightFinderPattern.x - topLeft.x),
            y: topLeft.y + correctionToTopLeft * (bottomRightFinderPattern.y - topLeft.y)
          };
          var alignmentPatterns = alignmentPatternQuads.map(function(q) {
            var x2 = (q.top.startX + q.top.endX + q.bottom.startX + q.bottom.endX) / 4;
            var y2 = (q.top.y + q.bottom.y + 1) / 2;
            if (!matrix.get(Math.floor(x2), Math.floor(y2))) {
              return;
            }
            var lengths = [q.top.endX - q.top.startX, q.bottom.endX - q.bottom.startX, q.bottom.y - q.top.y + 1];
            var size = sum(lengths) / lengths.length;
            var sizeScore = scorePattern({ x: Math.floor(x2), y: Math.floor(y2) }, [1, 1, 1], matrix);
            var score = sizeScore + distance2({ x: x2, y: y2 }, expectedAlignmentPattern);
            return { x: x2, y: y2, score };
          }).filter(function(v) {
            return !!v;
          }).sort(function(a2, b) {
            return a2.score - b.score;
          });
          var alignmentPattern = modulesBetweenFinderPatterns >= 15 && alignmentPatterns.length ? alignmentPatterns[0] : expectedAlignmentPattern;
          return { alignmentPattern, dimension };
        }
      }
    ])["default"];
  });
});

// node_modules/qrcode-terminal/vendor/QRCode/QRMode.js
var require_QRMode = __commonJS((exports, module) => {
  module.exports = {
    MODE_NUMBER: 1 << 0,
    MODE_ALPHA_NUM: 1 << 1,
    MODE_8BIT_BYTE: 1 << 2,
    MODE_KANJI: 1 << 3
  };
});

// node_modules/qrcode-terminal/vendor/QRCode/QR8bitByte.js
var require_QR8bitByte = __commonJS((exports, module) => {
  var QRMode = require_QRMode();
  function QR8bitByte(data) {
    this.mode = QRMode.MODE_8BIT_BYTE;
    this.data = data;
  }
  QR8bitByte.prototype = {
    getLength: function() {
      return this.data.length;
    },
    write: function(buffer) {
      for (var i2 = 0;i2 < this.data.length; i2++) {
        buffer.put(this.data.charCodeAt(i2), 8);
      }
    }
  };
  module.exports = QR8bitByte;
});

// node_modules/qrcode-terminal/vendor/QRCode/QRMath.js
var require_QRMath = __commonJS((exports, module) => {
  var QRMath = {
    glog: function(n2) {
      if (n2 < 1) {
        throw new Error("glog(" + n2 + ")");
      }
      return QRMath.LOG_TABLE[n2];
    },
    gexp: function(n2) {
      while (n2 < 0) {
        n2 += 255;
      }
      while (n2 >= 256) {
        n2 -= 255;
      }
      return QRMath.EXP_TABLE[n2];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256)
  };
  for (i2 = 0;i2 < 8; i2++) {
    QRMath.EXP_TABLE[i2] = 1 << i2;
  }
  var i2;
  for (i2 = 8;i2 < 256; i2++) {
    QRMath.EXP_TABLE[i2] = QRMath.EXP_TABLE[i2 - 4] ^ QRMath.EXP_TABLE[i2 - 5] ^ QRMath.EXP_TABLE[i2 - 6] ^ QRMath.EXP_TABLE[i2 - 8];
  }
  var i2;
  for (i2 = 0;i2 < 255; i2++) {
    QRMath.LOG_TABLE[QRMath.EXP_TABLE[i2]] = i2;
  }
  var i2;
  module.exports = QRMath;
});

// node_modules/qrcode-terminal/vendor/QRCode/QRPolynomial.js
var require_QRPolynomial = __commonJS((exports, module) => {
  var QRMath = require_QRMath();
  function QRPolynomial(num, shift) {
    if (num.length === undefined) {
      throw new Error(num.length + "/" + shift);
    }
    var offset = 0;
    while (offset < num.length && num[offset] === 0) {
      offset++;
    }
    this.num = new Array(num.length - offset + shift);
    for (var i2 = 0;i2 < num.length - offset; i2++) {
      this.num[i2] = num[i2 + offset];
    }
  }
  QRPolynomial.prototype = {
    get: function(index) {
      return this.num[index];
    },
    getLength: function() {
      return this.num.length;
    },
    multiply: function(e) {
      var num = new Array(this.getLength() + e.getLength() - 1);
      for (var i2 = 0;i2 < this.getLength(); i2++) {
        for (var j = 0;j < e.getLength(); j++) {
          num[i2 + j] ^= QRMath.gexp(QRMath.glog(this.get(i2)) + QRMath.glog(e.get(j)));
        }
      }
      return new QRPolynomial(num, 0);
    },
    mod: function(e) {
      if (this.getLength() - e.getLength() < 0) {
        return this;
      }
      var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
      var num = new Array(this.getLength());
      for (var i2 = 0;i2 < this.getLength(); i2++) {
        num[i2] = this.get(i2);
      }
      for (var x2 = 0;x2 < e.getLength(); x2++) {
        num[x2] ^= QRMath.gexp(QRMath.glog(e.get(x2)) + ratio);
      }
      return new QRPolynomial(num, 0).mod(e);
    }
  };
  module.exports = QRPolynomial;
});

// node_modules/qrcode-terminal/vendor/QRCode/QRMaskPattern.js
var require_QRMaskPattern = __commonJS((exports, module) => {
  module.exports = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
});

// node_modules/qrcode-terminal/vendor/QRCode/QRUtil.js
var require_QRUtil = __commonJS((exports, module) => {
  var QRMode = require_QRMode();
  var QRPolynomial = require_QRPolynomial();
  var QRMath = require_QRMath();
  var QRMaskPattern = require_QRMaskPattern();
  var QRUtil = {
    PATTERN_POSITION_TABLE: [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ],
    G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
    G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
    G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
    getBCHTypeInfo: function(data) {
      var d = data << 10;
      while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
        d ^= QRUtil.G15 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15);
      }
      return (data << 10 | d) ^ QRUtil.G15_MASK;
    },
    getBCHTypeNumber: function(data) {
      var d = data << 12;
      while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
        d ^= QRUtil.G18 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18);
      }
      return data << 12 | d;
    },
    getBCHDigit: function(data) {
      var digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    },
    getPatternPosition: function(typeNumber) {
      return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    },
    getMask: function(maskPattern, i2, j) {
      switch (maskPattern) {
        case QRMaskPattern.PATTERN000:
          return (i2 + j) % 2 === 0;
        case QRMaskPattern.PATTERN001:
          return i2 % 2 === 0;
        case QRMaskPattern.PATTERN010:
          return j % 3 === 0;
        case QRMaskPattern.PATTERN011:
          return (i2 + j) % 3 === 0;
        case QRMaskPattern.PATTERN100:
          return (Math.floor(i2 / 2) + Math.floor(j / 3)) % 2 === 0;
        case QRMaskPattern.PATTERN101:
          return i2 * j % 2 + i2 * j % 3 === 0;
        case QRMaskPattern.PATTERN110:
          return (i2 * j % 2 + i2 * j % 3) % 2 === 0;
        case QRMaskPattern.PATTERN111:
          return (i2 * j % 3 + (i2 + j) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    },
    getErrorCorrectPolynomial: function(errorCorrectLength) {
      var a2 = new QRPolynomial([1], 0);
      for (var i2 = 0;i2 < errorCorrectLength; i2++) {
        a2 = a2.multiply(new QRPolynomial([1, QRMath.gexp(i2)], 0));
      }
      return a2;
    },
    getLengthInBits: function(mode, type) {
      if (1 <= type && type < 10) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 10;
          case QRMode.MODE_ALPHA_NUM:
            return 9;
          case QRMode.MODE_8BIT_BYTE:
            return 8;
          case QRMode.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type < 27) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 12;
          case QRMode.MODE_ALPHA_NUM:
            return 11;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type < 41) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 14;
          case QRMode.MODE_ALPHA_NUM:
            return 13;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 12;
          default:
            throw new Error("mode:" + mode);
        }
      } else {
        throw new Error("type:" + type);
      }
    },
    getLostPoint: function(qrCode) {
      var moduleCount = qrCode.getModuleCount();
      var lostPoint = 0;
      var row = 0;
      var col = 0;
      for (row = 0;row < moduleCount; row++) {
        for (col = 0;col < moduleCount; col++) {
          var sameCount = 0;
          var dark = qrCode.isDark(row, col);
          for (var r = -1;r <= 1; r++) {
            if (row + r < 0 || moduleCount <= row + r) {
              continue;
            }
            for (var c4 = -1;c4 <= 1; c4++) {
              if (col + c4 < 0 || moduleCount <= col + c4) {
                continue;
              }
              if (r === 0 && c4 === 0) {
                continue;
              }
              if (dark === qrCode.isDark(row + r, col + c4)) {
                sameCount++;
              }
            }
          }
          if (sameCount > 5) {
            lostPoint += 3 + sameCount - 5;
          }
        }
      }
      for (row = 0;row < moduleCount - 1; row++) {
        for (col = 0;col < moduleCount - 1; col++) {
          var count2 = 0;
          if (qrCode.isDark(row, col))
            count2++;
          if (qrCode.isDark(row + 1, col))
            count2++;
          if (qrCode.isDark(row, col + 1))
            count2++;
          if (qrCode.isDark(row + 1, col + 1))
            count2++;
          if (count2 === 0 || count2 === 4) {
            lostPoint += 3;
          }
        }
      }
      for (row = 0;row < moduleCount; row++) {
        for (col = 0;col < moduleCount - 6; col++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
            lostPoint += 40;
          }
        }
      }
      for (col = 0;col < moduleCount; col++) {
        for (row = 0;row < moduleCount - 6; row++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
            lostPoint += 40;
          }
        }
      }
      var darkCount = 0;
      for (col = 0;col < moduleCount; col++) {
        for (row = 0;row < moduleCount; row++) {
          if (qrCode.isDark(row, col)) {
            darkCount++;
          }
        }
      }
      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;
      return lostPoint;
    }
  };
  module.exports = QRUtil;
});

// node_modules/qrcode-terminal/vendor/QRCode/QRErrorCorrectLevel.js
var require_QRErrorCorrectLevel = __commonJS((exports, module) => {
  module.exports = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2
  };
});

// node_modules/qrcode-terminal/vendor/QRCode/QRRSBlock.js
var require_QRRSBlock = __commonJS((exports, module) => {
  var QRErrorCorrectLevel = require_QRErrorCorrectLevel();
  function QRRSBlock(totalCount, dataCount) {
    this.totalCount = totalCount;
    this.dataCount = dataCount;
  }
  QRRSBlock.RS_BLOCK_TABLE = [
    [1, 26, 19],
    [1, 26, 16],
    [1, 26, 13],
    [1, 26, 9],
    [1, 44, 34],
    [1, 44, 28],
    [1, 44, 22],
    [1, 44, 16],
    [1, 70, 55],
    [1, 70, 44],
    [2, 35, 17],
    [2, 35, 13],
    [1, 100, 80],
    [2, 50, 32],
    [2, 50, 24],
    [4, 25, 9],
    [1, 134, 108],
    [2, 67, 43],
    [2, 33, 15, 2, 34, 16],
    [2, 33, 11, 2, 34, 12],
    [2, 86, 68],
    [4, 43, 27],
    [4, 43, 19],
    [4, 43, 15],
    [2, 98, 78],
    [4, 49, 31],
    [2, 32, 14, 4, 33, 15],
    [4, 39, 13, 1, 40, 14],
    [2, 121, 97],
    [2, 60, 38, 2, 61, 39],
    [4, 40, 18, 2, 41, 19],
    [4, 40, 14, 2, 41, 15],
    [2, 146, 116],
    [3, 58, 36, 2, 59, 37],
    [4, 36, 16, 4, 37, 17],
    [4, 36, 12, 4, 37, 13],
    [2, 86, 68, 2, 87, 69],
    [4, 69, 43, 1, 70, 44],
    [6, 43, 19, 2, 44, 20],
    [6, 43, 15, 2, 44, 16],
    [4, 101, 81],
    [1, 80, 50, 4, 81, 51],
    [4, 50, 22, 4, 51, 23],
    [3, 36, 12, 8, 37, 13],
    [2, 116, 92, 2, 117, 93],
    [6, 58, 36, 2, 59, 37],
    [4, 46, 20, 6, 47, 21],
    [7, 42, 14, 4, 43, 15],
    [4, 133, 107],
    [8, 59, 37, 1, 60, 38],
    [8, 44, 20, 4, 45, 21],
    [12, 33, 11, 4, 34, 12],
    [3, 145, 115, 1, 146, 116],
    [4, 64, 40, 5, 65, 41],
    [11, 36, 16, 5, 37, 17],
    [11, 36, 12, 5, 37, 13],
    [5, 109, 87, 1, 110, 88],
    [5, 65, 41, 5, 66, 42],
    [5, 54, 24, 7, 55, 25],
    [11, 36, 12],
    [5, 122, 98, 1, 123, 99],
    [7, 73, 45, 3, 74, 46],
    [15, 43, 19, 2, 44, 20],
    [3, 45, 15, 13, 46, 16],
    [1, 135, 107, 5, 136, 108],
    [10, 74, 46, 1, 75, 47],
    [1, 50, 22, 15, 51, 23],
    [2, 42, 14, 17, 43, 15],
    [5, 150, 120, 1, 151, 121],
    [9, 69, 43, 4, 70, 44],
    [17, 50, 22, 1, 51, 23],
    [2, 42, 14, 19, 43, 15],
    [3, 141, 113, 4, 142, 114],
    [3, 70, 44, 11, 71, 45],
    [17, 47, 21, 4, 48, 22],
    [9, 39, 13, 16, 40, 14],
    [3, 135, 107, 5, 136, 108],
    [3, 67, 41, 13, 68, 42],
    [15, 54, 24, 5, 55, 25],
    [15, 43, 15, 10, 44, 16],
    [4, 144, 116, 4, 145, 117],
    [17, 68, 42],
    [17, 50, 22, 6, 51, 23],
    [19, 46, 16, 6, 47, 17],
    [2, 139, 111, 7, 140, 112],
    [17, 74, 46],
    [7, 54, 24, 16, 55, 25],
    [34, 37, 13],
    [4, 151, 121, 5, 152, 122],
    [4, 75, 47, 14, 76, 48],
    [11, 54, 24, 14, 55, 25],
    [16, 45, 15, 14, 46, 16],
    [6, 147, 117, 4, 148, 118],
    [6, 73, 45, 14, 74, 46],
    [11, 54, 24, 16, 55, 25],
    [30, 46, 16, 2, 47, 17],
    [8, 132, 106, 4, 133, 107],
    [8, 75, 47, 13, 76, 48],
    [7, 54, 24, 22, 55, 25],
    [22, 45, 15, 13, 46, 16],
    [10, 142, 114, 2, 143, 115],
    [19, 74, 46, 4, 75, 47],
    [28, 50, 22, 6, 51, 23],
    [33, 46, 16, 4, 47, 17],
    [8, 152, 122, 4, 153, 123],
    [22, 73, 45, 3, 74, 46],
    [8, 53, 23, 26, 54, 24],
    [12, 45, 15, 28, 46, 16],
    [3, 147, 117, 10, 148, 118],
    [3, 73, 45, 23, 74, 46],
    [4, 54, 24, 31, 55, 25],
    [11, 45, 15, 31, 46, 16],
    [7, 146, 116, 7, 147, 117],
    [21, 73, 45, 7, 74, 46],
    [1, 53, 23, 37, 54, 24],
    [19, 45, 15, 26, 46, 16],
    [5, 145, 115, 10, 146, 116],
    [19, 75, 47, 10, 76, 48],
    [15, 54, 24, 25, 55, 25],
    [23, 45, 15, 25, 46, 16],
    [13, 145, 115, 3, 146, 116],
    [2, 74, 46, 29, 75, 47],
    [42, 54, 24, 1, 55, 25],
    [23, 45, 15, 28, 46, 16],
    [17, 145, 115],
    [10, 74, 46, 23, 75, 47],
    [10, 54, 24, 35, 55, 25],
    [19, 45, 15, 35, 46, 16],
    [17, 145, 115, 1, 146, 116],
    [14, 74, 46, 21, 75, 47],
    [29, 54, 24, 19, 55, 25],
    [11, 45, 15, 46, 46, 16],
    [13, 145, 115, 6, 146, 116],
    [14, 74, 46, 23, 75, 47],
    [44, 54, 24, 7, 55, 25],
    [59, 46, 16, 1, 47, 17],
    [12, 151, 121, 7, 152, 122],
    [12, 75, 47, 26, 76, 48],
    [39, 54, 24, 14, 55, 25],
    [22, 45, 15, 41, 46, 16],
    [6, 151, 121, 14, 152, 122],
    [6, 75, 47, 34, 76, 48],
    [46, 54, 24, 10, 55, 25],
    [2, 45, 15, 64, 46, 16],
    [17, 152, 122, 4, 153, 123],
    [29, 74, 46, 14, 75, 47],
    [49, 54, 24, 10, 55, 25],
    [24, 45, 15, 46, 46, 16],
    [4, 152, 122, 18, 153, 123],
    [13, 74, 46, 32, 75, 47],
    [48, 54, 24, 14, 55, 25],
    [42, 45, 15, 32, 46, 16],
    [20, 147, 117, 4, 148, 118],
    [40, 75, 47, 7, 76, 48],
    [43, 54, 24, 22, 55, 25],
    [10, 45, 15, 67, 46, 16],
    [19, 148, 118, 6, 149, 119],
    [18, 75, 47, 31, 76, 48],
    [34, 54, 24, 34, 55, 25],
    [20, 45, 15, 61, 46, 16]
  ];
  QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
    var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
    if (rsBlock === undefined) {
      throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
    }
    var length = rsBlock.length / 3;
    var list = [];
    for (var i2 = 0;i2 < length; i2++) {
      var count2 = rsBlock[i2 * 3 + 0];
      var totalCount = rsBlock[i2 * 3 + 1];
      var dataCount = rsBlock[i2 * 3 + 2];
      for (var j = 0;j < count2; j++) {
        list.push(new QRRSBlock(totalCount, dataCount));
      }
    }
    return list;
  };
  QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
    switch (errorCorrectLevel) {
      case QRErrorCorrectLevel.L:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
      case QRErrorCorrectLevel.M:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
      case QRErrorCorrectLevel.Q:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
      case QRErrorCorrectLevel.H:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
      default:
        return;
    }
  };
  module.exports = QRRSBlock;
});

// node_modules/qrcode-terminal/vendor/QRCode/QRBitBuffer.js
var require_QRBitBuffer = __commonJS((exports, module) => {
  function QRBitBuffer() {
    this.buffer = [];
    this.length = 0;
  }
  QRBitBuffer.prototype = {
    get: function(index) {
      var bufIndex = Math.floor(index / 8);
      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
    },
    put: function(num, length) {
      for (var i2 = 0;i2 < length; i2++) {
        this.putBit((num >>> length - i2 - 1 & 1) == 1);
      }
    },
    getLengthInBits: function() {
      return this.length;
    },
    putBit: function(bit) {
      var bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    }
  };
  module.exports = QRBitBuffer;
});

// node_modules/qrcode-terminal/vendor/QRCode/index.js
var require_QRCode = __commonJS((exports, module) => {
  var QR8bitByte = require_QR8bitByte();
  var QRUtil = require_QRUtil();
  var QRPolynomial = require_QRPolynomial();
  var QRRSBlock = require_QRRSBlock();
  var QRBitBuffer = require_QRBitBuffer();
  function QRCode(typeNumber, errorCorrectLevel) {
    this.typeNumber = typeNumber;
    this.errorCorrectLevel = errorCorrectLevel;
    this.modules = null;
    this.moduleCount = 0;
    this.dataCache = null;
    this.dataList = [];
  }
  QRCode.prototype = {
    addData: function(data) {
      var newData = new QR8bitByte(data);
      this.dataList.push(newData);
      this.dataCache = null;
    },
    isDark: function(row, col) {
      if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
        throw new Error(row + "," + col);
      }
      return this.modules[row][col];
    },
    getModuleCount: function() {
      return this.moduleCount;
    },
    make: function() {
      if (this.typeNumber < 1) {
        var typeNumber = 1;
        for (typeNumber = 1;typeNumber < 40; typeNumber++) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);
          var buffer = new QRBitBuffer;
          var totalDataCount = 0;
          for (var i2 = 0;i2 < rsBlocks.length; i2++) {
            totalDataCount += rsBlocks[i2].dataCount;
          }
          for (var x2 = 0;x2 < this.dataList.length; x2++) {
            var data = this.dataList[x2];
            buffer.put(data.mode, 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
            data.write(buffer);
          }
          if (buffer.getLengthInBits() <= totalDataCount * 8)
            break;
        }
        this.typeNumber = typeNumber;
      }
      this.makeImpl(false, this.getBestMaskPattern());
    },
    makeImpl: function(test, maskPattern) {
      this.moduleCount = this.typeNumber * 4 + 17;
      this.modules = new Array(this.moduleCount);
      for (var row = 0;row < this.moduleCount; row++) {
        this.modules[row] = new Array(this.moduleCount);
        for (var col = 0;col < this.moduleCount; col++) {
          this.modules[row][col] = null;
        }
      }
      this.setupPositionProbePattern(0, 0);
      this.setupPositionProbePattern(this.moduleCount - 7, 0);
      this.setupPositionProbePattern(0, this.moduleCount - 7);
      this.setupPositionAdjustPattern();
      this.setupTimingPattern();
      this.setupTypeInfo(test, maskPattern);
      if (this.typeNumber >= 7) {
        this.setupTypeNumber(test);
      }
      if (this.dataCache === null) {
        this.dataCache = QRCode.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
      }
      this.mapData(this.dataCache, maskPattern);
    },
    setupPositionProbePattern: function(row, col) {
      for (var r = -1;r <= 7; r++) {
        if (row + r <= -1 || this.moduleCount <= row + r)
          continue;
        for (var c4 = -1;c4 <= 7; c4++) {
          if (col + c4 <= -1 || this.moduleCount <= col + c4)
            continue;
          if (0 <= r && r <= 6 && (c4 === 0 || c4 === 6) || 0 <= c4 && c4 <= 6 && (r === 0 || r === 6) || 2 <= r && r <= 4 && 2 <= c4 && c4 <= 4) {
            this.modules[row + r][col + c4] = true;
          } else {
            this.modules[row + r][col + c4] = false;
          }
        }
      }
    },
    getBestMaskPattern: function() {
      var minLostPoint = 0;
      var pattern = 0;
      for (var i2 = 0;i2 < 8; i2++) {
        this.makeImpl(true, i2);
        var lostPoint = QRUtil.getLostPoint(this);
        if (i2 === 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i2;
        }
      }
      return pattern;
    },
    createMovieClip: function(target_mc, instance_name, depth) {
      var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
      var cs = 1;
      this.make();
      for (var row = 0;row < this.modules.length; row++) {
        var y2 = row * cs;
        for (var col = 0;col < this.modules[row].length; col++) {
          var x2 = col * cs;
          var dark = this.modules[row][col];
          if (dark) {
            qr_mc.beginFill(0, 100);
            qr_mc.moveTo(x2, y2);
            qr_mc.lineTo(x2 + cs, y2);
            qr_mc.lineTo(x2 + cs, y2 + cs);
            qr_mc.lineTo(x2, y2 + cs);
            qr_mc.endFill();
          }
        }
      }
      return qr_mc;
    },
    setupTimingPattern: function() {
      for (var r = 8;r < this.moduleCount - 8; r++) {
        if (this.modules[r][6] !== null) {
          continue;
        }
        this.modules[r][6] = r % 2 === 0;
      }
      for (var c4 = 8;c4 < this.moduleCount - 8; c4++) {
        if (this.modules[6][c4] !== null) {
          continue;
        }
        this.modules[6][c4] = c4 % 2 === 0;
      }
    },
    setupPositionAdjustPattern: function() {
      var pos = QRUtil.getPatternPosition(this.typeNumber);
      for (var i2 = 0;i2 < pos.length; i2++) {
        for (var j = 0;j < pos.length; j++) {
          var row = pos[i2];
          var col = pos[j];
          if (this.modules[row][col] !== null) {
            continue;
          }
          for (var r = -2;r <= 2; r++) {
            for (var c4 = -2;c4 <= 2; c4++) {
              if (Math.abs(r) === 2 || Math.abs(c4) === 2 || r === 0 && c4 === 0) {
                this.modules[row + r][col + c4] = true;
              } else {
                this.modules[row + r][col + c4] = false;
              }
            }
          }
        }
      }
    },
    setupTypeNumber: function(test) {
      var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
      var mod2;
      for (var i2 = 0;i2 < 18; i2++) {
        mod2 = !test && (bits >> i2 & 1) === 1;
        this.modules[Math.floor(i2 / 3)][i2 % 3 + this.moduleCount - 8 - 3] = mod2;
      }
      for (var x2 = 0;x2 < 18; x2++) {
        mod2 = !test && (bits >> x2 & 1) === 1;
        this.modules[x2 % 3 + this.moduleCount - 8 - 3][Math.floor(x2 / 3)] = mod2;
      }
    },
    setupTypeInfo: function(test, maskPattern) {
      var data = this.errorCorrectLevel << 3 | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);
      var mod2;
      for (var v = 0;v < 15; v++) {
        mod2 = !test && (bits >> v & 1) === 1;
        if (v < 6) {
          this.modules[v][8] = mod2;
        } else if (v < 8) {
          this.modules[v + 1][8] = mod2;
        } else {
          this.modules[this.moduleCount - 15 + v][8] = mod2;
        }
      }
      for (var h2 = 0;h2 < 15; h2++) {
        mod2 = !test && (bits >> h2 & 1) === 1;
        if (h2 < 8) {
          this.modules[8][this.moduleCount - h2 - 1] = mod2;
        } else if (h2 < 9) {
          this.modules[8][15 - h2 - 1 + 1] = mod2;
        } else {
          this.modules[8][15 - h2 - 1] = mod2;
        }
      }
      this.modules[this.moduleCount - 8][8] = !test;
    },
    mapData: function(data, maskPattern) {
      var inc = -1;
      var row = this.moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = this.moduleCount - 1;col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (var c4 = 0;c4 < 2; c4++) {
            if (this.modules[row][col - c4] === null) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              var mask = QRUtil.getMask(maskPattern, row, col - c4);
              if (mask) {
                dark = !dark;
              }
              this.modules[row][col - c4] = dark;
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || this.moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
  };
  QRCode.PAD0 = 236;
  QRCode.PAD1 = 17;
  QRCode.createData = function(typeNumber, errorCorrectLevel, dataList) {
    var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
    var buffer = new QRBitBuffer;
    for (var i2 = 0;i2 < dataList.length; i2++) {
      var data = dataList[i2];
      buffer.put(data.mode, 4);
      buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
      data.write(buffer);
    }
    var totalDataCount = 0;
    for (var x2 = 0;x2 < rsBlocks.length; x2++) {
      totalDataCount += rsBlocks[x2].dataCount;
    }
    if (buffer.getLengthInBits() > totalDataCount * 8) {
      throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
    }
    if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
      buffer.put(0, 4);
    }
    while (buffer.getLengthInBits() % 8 !== 0) {
      buffer.putBit(false);
    }
    while (true) {
      if (buffer.getLengthInBits() >= totalDataCount * 8) {
        break;
      }
      buffer.put(QRCode.PAD0, 8);
      if (buffer.getLengthInBits() >= totalDataCount * 8) {
        break;
      }
      buffer.put(QRCode.PAD1, 8);
    }
    return QRCode.createBytes(buffer, rsBlocks);
  };
  QRCode.createBytes = function(buffer, rsBlocks) {
    var offset = 0;
    var maxDcCount = 0;
    var maxEcCount = 0;
    var dcdata = new Array(rsBlocks.length);
    var ecdata = new Array(rsBlocks.length);
    for (var r = 0;r < rsBlocks.length; r++) {
      var dcCount = rsBlocks[r].dataCount;
      var ecCount = rsBlocks[r].totalCount - dcCount;
      maxDcCount = Math.max(maxDcCount, dcCount);
      maxEcCount = Math.max(maxEcCount, ecCount);
      dcdata[r] = new Array(dcCount);
      for (var i2 = 0;i2 < dcdata[r].length; i2++) {
        dcdata[r][i2] = 255 & buffer.buffer[i2 + offset];
      }
      offset += dcCount;
      var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
      var rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
      var modPoly = rawPoly.mod(rsPoly);
      ecdata[r] = new Array(rsPoly.getLength() - 1);
      for (var x2 = 0;x2 < ecdata[r].length; x2++) {
        var modIndex = x2 + modPoly.getLength() - ecdata[r].length;
        ecdata[r][x2] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
      }
    }
    var totalCodeCount = 0;
    for (var y2 = 0;y2 < rsBlocks.length; y2++) {
      totalCodeCount += rsBlocks[y2].totalCount;
    }
    var data = new Array(totalCodeCount);
    var index = 0;
    for (var z = 0;z < maxDcCount; z++) {
      for (var s = 0;s < rsBlocks.length; s++) {
        if (z < dcdata[s].length) {
          data[index++] = dcdata[s][z];
        }
      }
    }
    for (var xx = 0;xx < maxEcCount; xx++) {
      for (var t = 0;t < rsBlocks.length; t++) {
        if (xx < ecdata[t].length) {
          data[index++] = ecdata[t][xx];
        }
      }
    }
    return data;
  };
  module.exports = QRCode;
});

// node_modules/qrcode-terminal/lib/main.js
var require_main = __commonJS((exports, module) => {
  var QRCode = require_QRCode();
  var QRErrorCorrectLevel = require_QRErrorCorrectLevel();
  var black2 = "\x1B[40m  \x1B[0m";
  var white2 = "\x1B[47m  \x1B[0m";
  var toCell = function(isBlack) {
    return isBlack ? black2 : white2;
  };
  var repeat = function(color) {
    return {
      times: function(count2) {
        return new Array(count2).join(color);
      }
    };
  };
  var fill = function(length, value) {
    var arr = new Array(length);
    for (var i2 = 0;i2 < length; i2++) {
      arr[i2] = value;
    }
    return arr;
  };
  module.exports = {
    error: QRErrorCorrectLevel.L,
    generate: function(input, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      var qrcode = new QRCode(-1, this.error);
      qrcode.addData(input);
      qrcode.make();
      var output = "";
      if (opts && opts.small) {
        var BLACK = true, WHITE = false;
        var moduleCount = qrcode.getModuleCount();
        var moduleData = qrcode.modules.slice();
        var oddRow = moduleCount % 2 === 1;
        if (oddRow) {
          moduleData.push(fill(moduleCount, WHITE));
        }
        var platte = {
          WHITE_ALL: "",
          WHITE_BLACK: "",
          BLACK_WHITE: "",
          BLACK_ALL: " "
        };
        var borderTop = repeat(platte.BLACK_WHITE).times(moduleCount + 3);
        var borderBottom = repeat(platte.WHITE_BLACK).times(moduleCount + 3);
        output += borderTop + `
`;
        for (var row = 0;row < moduleCount; row += 2) {
          output += platte.WHITE_ALL;
          for (var col = 0;col < moduleCount; col++) {
            if (moduleData[row][col] === WHITE && moduleData[row + 1][col] === WHITE) {
              output += platte.WHITE_ALL;
            } else if (moduleData[row][col] === WHITE && moduleData[row + 1][col] === BLACK) {
              output += platte.WHITE_BLACK;
            } else if (moduleData[row][col] === BLACK && moduleData[row + 1][col] === WHITE) {
              output += platte.BLACK_WHITE;
            } else {
              output += platte.BLACK_ALL;
            }
          }
          output += platte.WHITE_ALL + `
`;
        }
        if (!oddRow) {
          output += borderBottom;
        }
      } else {
        var border = repeat(white2).times(qrcode.getModuleCount() + 3);
        output += border + `
`;
        qrcode.modules.forEach(function(row2) {
          output += white2;
          output += row2.map(toCell).join("");
          output += white2 + `
`;
        });
        output += border;
      }
      if (cb)
        cb(output);
      else
        console.log(output);
    },
    setErrorLevel: function(error) {
      this.error = QRErrorCorrectLevel[error] || this.error;
    }
  };
});

// node_modules/react/cjs/react-jsx-dev-runtime.development.js
var require_react_jsx_dev_runtime_development = __commonJS((exports) => {
  var React11 = __toESM(require_react());
  (function() {
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x2) {}
        }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch (e) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE)
        return "<>";
      if (typeof type === "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x2) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return dispatcher === null ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning)
          return false;
      }
      return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return componentName !== undefined ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
      var refProp = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props,
        _owner: owner
      };
      (refProp !== undefined ? refProp : null) !== null ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
      var children = config.children;
      if (children !== undefined)
        if (isStaticChildren)
          if (isArrayImpl(children)) {
            for (isStaticChildren = 0;isStaticChildren < children.length; isStaticChildren++)
              validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
          } else
            console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          validateChildKeys(children);
      if (hasOwnProperty.call(config, "key")) {
        children = getComponentNameFromType(type);
        var keys = Object.keys(config).filter(function(k) {
          return k !== "key";
        });
        isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = true);
      }
      children = null;
      maybeKey !== undefined && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
      hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          propName !== "key" && (maybeKey[propName] = config[propName]);
      } else
        maybeKey = config;
      children && defineKeyPropWarningGetter(maybeKey, typeof type === "function" ? type.displayName || type.name || "Unknown" : type);
      return ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
    }
    function validateChildKeys(node) {
      isValidElement(node) ? node._store && (node._store.validated = 1) : typeof node === "object" && node !== null && node.$$typeof === REACT_LAZY_TYPE && (node._payload.status === "fulfilled" ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
      return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React11.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    React11 = {
      react_stack_bottom_frame: function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React11.react_stack_bottom_frame.bind(React11, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
  })();
});

// node_modules/react/jsx-dev-runtime.js
var require_jsx_dev_runtime = __commonJS((exports, module) => {
  var react_jsx_dev_runtime_development = __toESM(require_react_jsx_dev_runtime_development());
  if (false) {} else {
    module.exports = react_jsx_dev_runtime_development;
  }
});

// index.tsx
var import_react27 = __toESM(require_react(), 1);

// node_modules/ink/build/render.js
import { Stream } from "node:stream";
import process12 from "node:process";

// node_modules/ink/build/ink.js
var import_react13 = __toESM(require_react(), 1);
import process11 from "node:process";

// node_modules/es-toolkit/dist/function/debounce.mjs
function debounce(func, debounceMs, { signal, edges } = {}) {
  let pendingThis = undefined;
  let pendingArgs = null;
  const leading = edges != null && edges.includes("leading");
  const trailing = edges == null || edges.includes("trailing");
  const invoke = () => {
    if (pendingArgs !== null) {
      func.apply(pendingThis, pendingArgs);
      pendingThis = undefined;
      pendingArgs = null;
    }
  };
  const onTimerEnd = () => {
    if (trailing) {
      invoke();
    }
    cancel();
  };
  let timeoutId = null;
  const schedule = () => {
    if (timeoutId != null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      timeoutId = null;
      onTimerEnd();
    }, debounceMs);
  };
  const cancelTimer = () => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  const cancel = () => {
    cancelTimer();
    pendingThis = undefined;
    pendingArgs = null;
  };
  const flush = () => {
    invoke();
  };
  const debounced = function(...args) {
    if (signal?.aborted) {
      return;
    }
    pendingThis = this;
    pendingArgs = args;
    const isFirstCall = timeoutId == null;
    schedule();
    if (leading && isFirstCall) {
      invoke();
    }
  };
  debounced.schedule = schedule;
  debounced.cancel = cancel;
  debounced.flush = flush;
  signal?.addEventListener("abort", cancel, { once: true });
  return debounced;
}

// node_modules/es-toolkit/dist/compat/function/debounce.mjs
function debounce2(func, debounceMs = 0, options = {}) {
  if (typeof options !== "object") {
    options = {};
  }
  const { leading = false, trailing = true, maxWait } = options;
  const edges = Array(2);
  if (leading) {
    edges[0] = "leading";
  }
  if (trailing) {
    edges[1] = "trailing";
  }
  let result = undefined;
  let pendingAt = null;
  const _debounced = debounce(function(...args) {
    result = func.apply(this, args);
    pendingAt = null;
  }, debounceMs, { edges });
  const debounced = function(...args) {
    if (maxWait != null) {
      if (pendingAt === null) {
        pendingAt = Date.now();
      }
      if (Date.now() - pendingAt >= maxWait) {
        result = func.apply(this, args);
        pendingAt = Date.now();
        _debounced.cancel();
        _debounced.schedule();
        return result;
      }
    }
    _debounced.apply(this, args);
    return result;
  };
  const flush = () => {
    _debounced.flush();
    return result;
  };
  debounced.cancel = _debounced.cancel;
  debounced.flush = flush;
  return debounced;
}

// node_modules/es-toolkit/dist/compat/function/throttle.mjs
function throttle(func, throttleMs = 0, options = {}) {
  const { leading = true, trailing = true } = options;
  return debounce2(func, throttleMs, {
    leading,
    maxWait: throttleMs,
    trailing
  });
}
// node_modules/ansi-escapes/base.js
var exports_base = {};
__export(exports_base, {
  setCwd: () => setCwd,
  scrollUp: () => scrollUp,
  scrollDown: () => scrollDown,
  link: () => link,
  image: () => image2,
  iTerm: () => iTerm,
  exitAlternativeScreen: () => exitAlternativeScreen,
  eraseUp: () => eraseUp,
  eraseStartLine: () => eraseStartLine,
  eraseScreen: () => eraseScreen,
  eraseLines: () => eraseLines,
  eraseLine: () => eraseLine,
  eraseEndLine: () => eraseEndLine,
  eraseDown: () => eraseDown,
  enterAlternativeScreen: () => enterAlternativeScreen,
  cursorUp: () => cursorUp,
  cursorTo: () => cursorTo,
  cursorShow: () => cursorShow,
  cursorSavePosition: () => cursorSavePosition,
  cursorRestorePosition: () => cursorRestorePosition,
  cursorPrevLine: () => cursorPrevLine,
  cursorNextLine: () => cursorNextLine,
  cursorMove: () => cursorMove,
  cursorLeft: () => cursorLeft,
  cursorHide: () => cursorHide,
  cursorGetPosition: () => cursorGetPosition,
  cursorForward: () => cursorForward,
  cursorDown: () => cursorDown,
  cursorBackward: () => cursorBackward,
  clearViewport: () => clearViewport,
  clearTerminal: () => clearTerminal,
  clearScreen: () => clearScreen,
  beep: () => beep,
  ConEmu: () => ConEmu
});
import process2 from "node:process";
import os from "node:os";

// node_modules/environment/index.js
var isBrowser = globalThis.window?.document !== undefined;
var isNode = globalThis.process?.versions?.node !== undefined;
var isBun = globalThis.process?.versions?.bun !== undefined;
var isDeno = globalThis.Deno?.version?.deno !== undefined;
var isElectron = globalThis.process?.versions?.electron !== undefined;
var isJsDom = globalThis.navigator?.userAgent?.includes("jsdom") === true;
var isWebWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var isDedicatedWorker = typeof DedicatedWorkerGlobalScope !== "undefined" && globalThis instanceof DedicatedWorkerGlobalScope;
var isSharedWorker = typeof SharedWorkerGlobalScope !== "undefined" && globalThis instanceof SharedWorkerGlobalScope;
var isServiceWorker = typeof ServiceWorkerGlobalScope !== "undefined" && globalThis instanceof ServiceWorkerGlobalScope;
var platform = globalThis.navigator?.userAgentData?.platform;
var isMacOs = platform === "macOS" || globalThis.navigator?.platform === "MacIntel" || globalThis.navigator?.userAgent?.includes(" Mac ") === true || globalThis.process?.platform === "darwin";
var isWindows = platform === "Windows" || globalThis.navigator?.platform === "Win32" || globalThis.process?.platform === "win32";
var isLinux = platform === "Linux" || globalThis.navigator?.platform?.startsWith("Linux") === true || globalThis.navigator?.userAgent?.includes(" Linux ") === true || globalThis.process?.platform === "linux";
var isIos = platform === "iOS" || globalThis.navigator?.platform === "MacIntel" && globalThis.navigator?.maxTouchPoints > 1 || /iPad|iPhone|iPod/.test(globalThis.navigator?.platform);
var isAndroid = platform === "Android" || globalThis.navigator?.platform === "Android" || globalThis.navigator?.userAgent?.includes(" Android ") === true || globalThis.process?.platform === "android";

// node_modules/ansi-escapes/base.js
var ESC = "\x1B[";
var OSC = "\x1B]";
var BEL = "\x07";
var SEP = ";";
var isTerminalApp = !isBrowser && process2.env.TERM_PROGRAM === "Apple_Terminal";
var isWindows2 = !isBrowser && process2.platform === "win32";
var isTmux = !isBrowser && (process2.env.TERM?.startsWith("screen") || process2.env.TERM?.startsWith("tmux") || process2.env.TMUX !== undefined);
var cwdFunction = isBrowser ? () => {
  throw new Error("`process.cwd()` only works in Node.js, not the browser.");
} : process2.cwd;
var wrapOsc = (sequence) => {
  if (isTmux) {
    return "\x1BPtmux;" + sequence.replaceAll("\x1B", "\x1B\x1B") + "\x1B\\";
  }
  return sequence;
};
var cursorTo = (x, y) => {
  if (typeof x !== "number") {
    throw new TypeError("The `x` argument is required");
  }
  if (typeof y !== "number") {
    return ESC + (x + 1) + "G";
  }
  return ESC + (y + 1) + SEP + (x + 1) + "H";
};
var cursorMove = (x, y) => {
  if (typeof x !== "number") {
    throw new TypeError("The `x` argument is required");
  }
  let returnValue = "";
  if (x < 0) {
    returnValue += ESC + -x + "D";
  } else if (x > 0) {
    returnValue += ESC + x + "C";
  }
  if (y < 0) {
    returnValue += ESC + -y + "A";
  } else if (y > 0) {
    returnValue += ESC + y + "B";
  }
  return returnValue;
};
var cursorUp = (count = 1) => ESC + count + "A";
var cursorDown = (count = 1) => ESC + count + "B";
var cursorForward = (count = 1) => ESC + count + "C";
var cursorBackward = (count = 1) => ESC + count + "D";
var cursorLeft = ESC + "G";
var cursorSavePosition = isTerminalApp ? "\x1B7" : ESC + "s";
var cursorRestorePosition = isTerminalApp ? "\x1B8" : ESC + "u";
var cursorGetPosition = ESC + "6n";
var cursorNextLine = ESC + "E";
var cursorPrevLine = ESC + "F";
var cursorHide = ESC + "?25l";
var cursorShow = ESC + "?25h";
var eraseLines = (count) => {
  let clear = "";
  for (let i = 0;i < count; i++) {
    clear += eraseLine + (i < count - 1 ? cursorUp() : "");
  }
  if (count) {
    clear += cursorLeft;
  }
  return clear;
};
var eraseEndLine = ESC + "K";
var eraseStartLine = ESC + "1K";
var eraseLine = ESC + "2K";
var eraseDown = ESC + "J";
var eraseUp = ESC + "1J";
var eraseScreen = ESC + "2J";
var scrollUp = ESC + "S";
var scrollDown = ESC + "T";
var clearScreen = "\x1Bc";
var clearViewport = `${eraseScreen}${ESC}H`;
var isOldWindows = () => {
  if (isBrowser || !isWindows2) {
    return false;
  }
  const parts = os.release().split(".");
  const major = Number(parts[0]);
  const build = Number(parts[2] ?? 0);
  if (major < 10) {
    return true;
  }
  if (major === 10 && build < 10586) {
    return true;
  }
  return false;
};
var clearTerminal = isOldWindows() ? `${eraseScreen}${ESC}0f` : `${eraseScreen}${ESC}3J${ESC}H`;
var enterAlternativeScreen = ESC + "?1049h";
var exitAlternativeScreen = ESC + "?1049l";
var beep = BEL;
var link = (text, url) => {
  const openLink = wrapOsc(`${OSC}8${SEP}${SEP}${url}${BEL}`);
  const closeLink = wrapOsc(`${OSC}8${SEP}${SEP}${BEL}`);
  return openLink + text + closeLink;
};
var image2 = (data, options = {}) => {
  let returnValue = `${OSC}1337;File=inline=1`;
  if (options.width) {
    returnValue += `;width=${options.width}`;
  }
  if (options.height) {
    returnValue += `;height=${options.height}`;
  }
  if (options.preserveAspectRatio === false) {
    returnValue += ";preserveAspectRatio=0";
  }
  const imageBuffer = Buffer.from(data);
  return wrapOsc(returnValue + `;size=${imageBuffer.byteLength}` + ":" + imageBuffer.toString("base64") + BEL);
};
var iTerm = {
  setCwd: (cwd = cwdFunction()) => wrapOsc(`${OSC}50;CurrentDir=${cwd}${BEL}`),
  annotation(message, options = {}) {
    let returnValue = `${OSC}1337;`;
    const hasX = options.x !== undefined;
    const hasY = options.y !== undefined;
    if ((hasX || hasY) && !(hasX && hasY && options.length !== undefined)) {
      throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
    }
    message = message.replaceAll("|", "");
    returnValue += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
    if (options.length > 0) {
      returnValue += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|");
    } else {
      returnValue += message;
    }
    return wrapOsc(returnValue + BEL);
  }
};
var ConEmu = {
  setCwd: (cwd = cwdFunction()) => wrapOsc(`${OSC}9;9;${cwd}${BEL}`)
};
var setCwd = (cwd = cwdFunction()) => iTerm.setCwd(cwd) + ConEmu.setCwd(cwd);
// node_modules/is-in-ci/index.js
import { env } from "node:process";
var check = (key) => (key in env) && env[key] !== "0" && env[key] !== "false";
var isInCi = check("CI") || check("CONTINUOUS_INTEGRATION");
var is_in_ci_default = isInCi;

// node_modules/auto-bind/index.js
var getAllProperties = (object) => {
  const properties = new Set;
  do {
    for (const key of Reflect.ownKeys(object)) {
      properties.add([object, key]);
    }
  } while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);
  return properties;
};
function autoBind(self2, { include, exclude } = {}) {
  const filter = (key) => {
    const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
    if (include) {
      return include.some(match);
    }
    if (exclude) {
      return !exclude.some(match);
    }
    return true;
  };
  for (const [object, key] of getAllProperties(self2.constructor.prototype)) {
    if (key === "constructor" || !filter(key)) {
      continue;
    }
    const descriptor = Reflect.getOwnPropertyDescriptor(object, key);
    if (descriptor && typeof descriptor.value === "function") {
      self2[key] = self2[key].bind(self2);
    }
  }
  return self2;
}

// node_modules/ink/build/ink.js
var import_signal_exit2 = __toESM(require_signal_exit(), 1);

// node_modules/patch-console/dist/index.js
import { PassThrough } from "node:stream";
var consoleMethods = [
  "assert",
  "count",
  "countReset",
  "debug",
  "dir",
  "dirxml",
  "error",
  "group",
  "groupCollapsed",
  "groupEnd",
  "info",
  "log",
  "table",
  "time",
  "timeEnd",
  "timeLog",
  "trace",
  "warn"
];
var originalMethods = {};
var patchConsole = (callback) => {
  const stdout = new PassThrough;
  const stderr = new PassThrough;
  stdout.write = (data) => {
    callback("stdout", data);
  };
  stderr.write = (data) => {
    callback("stderr", data);
  };
  const internalConsole = new console.Console(stdout, stderr);
  for (const method of consoleMethods) {
    originalMethods[method] = console[method];
    console[method] = internalConsole[method];
  }
  return () => {
    for (const method of consoleMethods) {
      console[method] = originalMethods[method];
    }
    originalMethods = {};
  };
};
var dist_default = patchConsole;

// node_modules/ink/build/ink.js
var import_constants2 = __toESM(require_constants(), 1);

// node_modules/yoga-layout/dist/binaries/yoga-wasm-base64-esm.js
var loadYoga = (() => {
  var _scriptDir = import.meta.url;
  return function(loadYoga2) {
    loadYoga2 = loadYoga2 || {};
    var h;
    h || (h = typeof loadYoga2 !== "undefined" ? loadYoga2 : {});
    var aa, ca;
    h.ready = new Promise(function(a, b) {
      aa = a;
      ca = b;
    });
    var da = Object.assign({}, h), q = "";
    typeof document != "undefined" && document.currentScript && (q = document.currentScript.src);
    _scriptDir && (q = _scriptDir);
    q.indexOf("blob:") !== 0 ? q = q.substr(0, q.replace(/[?#].*/, "").lastIndexOf("/") + 1) : q = "";
    var ea = h.print || console.log.bind(console), v = h.printErr || console.warn.bind(console);
    Object.assign(h, da);
    da = null;
    var w;
    h.wasmBinary && (w = h.wasmBinary);
    var noExitRuntime = h.noExitRuntime || true;
    typeof WebAssembly != "object" && x("no native wasm support detected");
    var fa, ha = false;
    function z(a, b, c) {
      c = b + c;
      for (var d = "";!(b >= c); ) {
        var e = a[b++];
        if (!e)
          break;
        if (e & 128) {
          var f = a[b++] & 63;
          if ((e & 224) == 192)
            d += String.fromCharCode((e & 31) << 6 | f);
          else {
            var g = a[b++] & 63;
            e = (e & 240) == 224 ? (e & 15) << 12 | f << 6 | g : (e & 7) << 18 | f << 12 | g << 6 | a[b++] & 63;
            65536 > e ? d += String.fromCharCode(e) : (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023));
          }
        } else
          d += String.fromCharCode(e);
      }
      return d;
    }
    var ia, ja, A, C, ka, D, E, la, ma;
    function na() {
      var a = fa.buffer;
      ia = a;
      h.HEAP8 = ja = new Int8Array(a);
      h.HEAP16 = C = new Int16Array(a);
      h.HEAP32 = D = new Int32Array(a);
      h.HEAPU8 = A = new Uint8Array(a);
      h.HEAPU16 = ka = new Uint16Array(a);
      h.HEAPU32 = E = new Uint32Array(a);
      h.HEAPF32 = la = new Float32Array(a);
      h.HEAPF64 = ma = new Float64Array(a);
    }
    var oa, pa = [], qa = [], ra = [];
    function sa() {
      var a = h.preRun.shift();
      pa.unshift(a);
    }
    var F = 0, ta = null, G = null;
    function x(a) {
      if (h.onAbort)
        h.onAbort(a);
      a = "Aborted(" + a + ")";
      v(a);
      ha = true;
      a = new WebAssembly.RuntimeError(a + ". Build with -sASSERTIONS for more info.");
      ca(a);
      throw a;
    }
    function ua(a) {
      return a.startsWith("data:application/octet-stream;base64,");
    }
    var H;
    H = "data:application/octet-stream;base64,AGFzbQEAAAABugM3YAF/AGACf38AYAF/AX9gA39/fwBgAn98AGACf38Bf2ADf39/AX9gBH9/f30BfWADf398AGAAAGAEf39/fwBgAX8BfGACf38BfGAFf39/f38Bf2AAAX9gA39/fwF9YAZ/f31/fX8AYAV/f39/fwBgAn9/AX1gBX9/f319AX1gAX8BfWADf35/AX5gB39/f39/f38AYAZ/f39/f38AYAR/f39/AX9gBn9/f319fQF9YAR/f31/AGADf399AX1gBn98f39/fwF/YAR/fHx/AGACf30AYAh/f39/f39/fwBgDX9/f39/f39/f39/f38AYAp/f39/f39/f39/AGAFf39/f38BfGAEfHx/fwF9YA1/fX1/f399fX9/f39/AX9gB39/f319f38AYAJ+fwF/YAN/fX0BfWABfAF8YAN/fHwAYAR/f319AGAHf39/fX19fQF9YA1/fX99f31/fX19fX1/AX9gC39/f39/f399fX19AX9gCH9/f39/f319AGAEf39+fgBgB39/f39/f38Bf2ACfH8BfGAFf398fH8AYAN/f38BfGAEf39/fABgA39/fQBgBn9/fX99fwF/ArUBHgFhAWEAHwFhAWIAAwFhAWMACQFhAWQAFgFhAWUAEQFhAWYAIAFhAWcAAAFhAWgAIQFhAWkAAwFhAWoAAAFhAWsAFwFhAWwACgFhAW0ABQFhAW4AAwFhAW8AAQFhAXAAFwFhAXEABgFhAXIAAAFhAXMAIgFhAXQACgFhAXUADQFhAXYAFgFhAXcAAgFhAXgAAwFhAXkAGAFhAXoAAgFhAUEAAQFhAUIAEQFhAUMAAQFhAUQAAAOiAqACAgMSBwcACRkDAAoRBgYKEwAPDxMBBiMTCgcHGgMUASQFJRQHAwMKCgMmAQYYDxobFAAKBw8KBwMDAgkCAAAFGwACBwIHBgIDAQMIDAABKAkHBQURACkZASoAAAIrLAIALQcHBy4HLwkFCgMCMA0xAgMJAgACAQYKAQIBBQEACQIFAQEABQAODQ0GFQIBHBUGAgkCEAAAAAUyDzMMBQYINAUCAwUODg41AgMCAgIDBgICNgIBDAwMAQsLCwsLCx0CAAIAAAABABABBQICAQMCEgMMCwEBAQEBAQsLAQICAwICAgICAgIDAgIICAEICAgEBAQEBAQEBAQABAQABAQEBAAEBAQBAQEICAEBAQEBAQEBCAgBAQEAAg4CAgUBAR4DBAcBcAHUAdQBBQcBAYACgIACBg0CfwFBkMQEC38BQQALByQIAUUCAAFGAG0BRwCwAQFIAK8BAUkAYQFKAQABSwAjAUwApgEJjQMBAEEBC9MBqwGqAaUB5QHiAZwB0AFazwHOAVlZWpsBmgGZAc0BzAHLAcoBWpgByQFZWVqbAZoBmQHIAccBxgGjAZcBpAGWAaMBvQKVAbwCxQG7Ajq6Ajq5ApQBuAI+twI+xAFqwwFqwgFqaWjBAcABvwGhAZcBtgK+AbUClgGhAbQCmAGzAjqxAjqwAr0BrwKuAq0CrAKrAqoCqAKnAqYCpQKkAqMCogKhArwBoAKfAp4CnQKcApsCmgKZApgClwKWApUClAKTApICkQKQAo8CjgKyAo0CjAKLAooCiAKHAqkChQI+hAK7AYMCggKBAoAC/gH9AfwB+QG6AfgBuQH3AfYB9QH0AfMB8gHxAYYC8AHvAbgB+wH6Ae4B7QG3AesBlQHqATrpAT7oAT7nAZQB0QE67AE+iQLmATrkAeMBOuEB4AHfAT7eAd0B3AG2AdsB2gHZAdgB1wHWAdUBtQHUAdMB0gH/AWloaWiPAZABsgGxAZEBhQGSAbQBswGRAa4BrQGsAakBqAGnAYUBCtj+A6ACMwEBfyAAQQEgABshAAJAA0AgABBhIgENAUGIxAAoAgAiAQRAIAERCQAMAQsLEAIACyABC+0BAgJ9A39DAADAfyEEAkACQAJAAkAgAkEHcSIGDgUCAQEBAAELQQMhBQwBCyAGQQFrQQJPDQEgAkHw/wNxQQR2IQcCfSACQQhxBEAgASAHEJ4BvgwBC0EAIAdB/w9xIgFrIAEgAsFBAEgbsgshAyAGQQFGBEAgAyADXA0BQwAAwH8gAyADQwAAgH9bIANDAACA/1tyIgEbIQQgAUUhBQwBCyADIANcDQBBAEECIANDAACAf1sgA0MAAID/W3IiARshBUMAAMB/IAMgARshBAsgACAFOgAEIAAgBDgCAA8LQfQNQakYQTpB+RYQCwALZwIBfQF/QwAAwH8hAgJAAkACQCABQQdxDgQCAAABAAtBxBJBqRhByQBBuhIQCwALIAFB8P8DcUEEdiEDIAFBCHEEQCAAIAMQngG+DwtBACADQf8PcSIAayAAIAHBQQBIG7IhAgsgAgt4AgF/AX0jAEEQayIEJAAgBEEIaiAAQQMgAkECR0EBdCABQf4BcUECRxsgAhAoQwAAwH8hBQJAAkACQCAELQAMQQFrDgIAAQILIAQqAgghBQwBCyAEKgIIIAOUQwrXIzyUIQULIARBEGokACAFQwAAAAAgBSAFWxsLeAIBfwF9IwBBEGsiBCQAIARBCGogAEEBIAJBAkZBAXQgAUH+AXFBAkcbIAIQKEMAAMB/IQUCQAJAAkAgBC0ADEEBaw4CAAECCyAEKgIIIQUMAQsgBCoCCCADlEMK1yM8lCEFCyAEQRBqJAAgBUMAAAAAIAUgBVsbC8wCAQV/IAAEQCAAQQRrIgEoAgAiBSEDIAEhAiAAQQhrKAIAIgAgAEF+cSIERwRAIAEgBGsiAigCBCIAIAIoAgg2AgggAigCCCAANgIEIAQgBWohAwsgASAFaiIEKAIAIgEgASAEakEEaygCAEcEQCAEKAIEIgAgBCgCCDYCCCAEKAIIIAA2AgQgASADaiEDCyACIAM2AgAgA0F8cSACakEEayADQQFyNgIAIAICfyACKAIAQQhrIgFB/wBNBEAgAUEDdkEBawwBCyABQR0gAWciAGt2QQRzIABBAnRrQe4AaiABQf8fTQ0AGkE/IAFBHiAAa3ZBAnMgAEEBdGtBxwBqIgAgAEE/TxsLIgFBBHQiAEHgMmo2AgQgAiAAQegyaiIAKAIANgIIIAAgAjYCACACKAIIIAI2AgRB6DpB6DopAwBCASABrYaENwMACwsOAEHYMigCABEJABBYAAunAQIBfQJ/IABBFGoiByACIAFBAkkiCCAEIAUQNSEGAkAgByACIAggBCAFEC0iBEMAAAAAYCADIARecQ0AIAZDAAAAAGBFBEAgAyEEDAELIAYgAyADIAZdGyEECyAAQRRqIgAgASACIAUQOCAAIAEgAhAwkiAAIAEgAiAFEDcgACABIAIQL5KSIgMgBCADIAReGyADIAQgBCAEXBsgBCAEWyADIANbcRsLvwEBA38gAC0AAEEgcUUEQAJAIAEhAwJAIAIgACIBKAIQIgAEfyAABSABEJ0BDQEgASgCEAsgASgCFCIFa0sEQCABIAMgAiABKAIkEQYAGgwCCwJAIAEoAlBBAEgNACACIQADQCAAIgRFDQEgAyAEQQFrIgBqLQAAQQpHDQALIAEgAyAEIAEoAiQRBgAgBEkNASADIARqIQMgAiAEayECIAEoAhQhBQsgBSADIAIQKxogASABKAIUIAJqNgIUCwsLCwYAIAAQIwtQAAJAAkACQAJAAkAgAg4EBAABAgMLIAAgASABQQxqEEMPCyAAIAEgAUEMaiADEEQPCyAAIAEgAUEMahBCDwsQJAALIAAgASABQQxqIAMQRQttAQF/IwBBgAJrIgUkACAEQYDABHEgAiADTHJFBEAgBSABQf8BcSACIANrIgNBgAIgA0GAAkkiARsQKhogAUUEQANAIAAgBUGAAhAmIANBgAJrIgNB/wFLDQALCyAAIAUgAxAmCyAFQYACaiQAC/ICAgJ/AX4CQCACRQ0AIAAgAToAACAAIAJqIgNBAWsgAToAACACQQNJDQAgACABOgACIAAgAToAASADQQNrIAE6AAAgA0ECayABOgAAIAJBB0kNACAAIAE6AAMgA0EEayABOgAAIAJBCUkNACAAQQAgAGtBA3EiBGoiAyABQf8BcUGBgoQIbCIBNgIAIAMgAiAEa0F8cSIEaiICQQRrIAE2AgAgBEEJSQ0AIAMgATYCCCADIAE2AgQgAkEIayABNgIAIAJBDGsgATYCACAEQRlJDQAgAyABNgIYIAMgATYCFCADIAE2AhAgAyABNgIMIAJBEGsgATYCACACQRRrIAE2AgAgAkEYayABNgIAIAJBHGsgATYCACAEIANBBHFBGHIiBGsiAkEgSQ0AIAGtQoGAgIAQfiEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkEgayICQR9LDQALCyAAC4AEAQN/IAJBgARPBEAgACABIAIQFyAADwsgACACaiEDAkAgACABc0EDcUUEQAJAIABBA3FFBEAgACECDAELIAJFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICQQNxRQ0BIAIgA0kNAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAtIAQF/IwBBEGsiBCQAIAQgAzYCDAJAIABFBEBBAEEAIAEgAiAEKAIMEHEMAQsgACgC9AMgACABIAIgBCgCDBBxCyAEQRBqJAALkwECAX0BfyMAQRBrIgYkACAGQQhqIABB6ABqIAAgAkEBdGovAWIQH0MAAMB/IQUCQAJAAkAgBi0ADEEBaw4CAAECCyAGKgIIIQUMAQsgBioCCCADlEMK1yM8lCEFCyAALQADQRB0QYCAwABxBEAgBSAAIAEgAiAEEFQiA0MAAAAAIAMgA1sbkiEFCyAGQRBqJAAgBQu1AQECfyAAKAIEQQFqIgEgACgCACICKALsAyACKALoAyICa0ECdU8EQANAIAAoAggiAUUEQCAAQQA2AgggAEIANwIADwsgACABKAIENgIAIAAgASgCCDYCBCAAIAEoAgA2AgggARAjIAAoAgRBAWoiASAAKAIAIgIoAuwDIAIoAugDIgJrQQJ1Tw0ACwsgACABNgIEIAIgAUECdGooAgAtABdBEHRBgIAwcUGAgCBGBEAgABB9CwuBAQIBfwF9IwBBEGsiAyQAIANBCGogAEEDIAJBAkdBAXQgAUH+AXFBAkcbIAIQU0MAAMB/IQQCQAJAAkAgAy0ADEEBaw4CAAECCyADKgIIIQQMAQsgAyoCCEMAAAAAlEMK1yM8lCEECyADQRBqJAAgBEMAAAAAl0MAAAAAIAQgBFsbC4EBAgF/AX0jAEEQayIDJAAgA0EIaiAAQQEgAkECRkEBdCABQf4BcUECRxsgAhBTQwAAwH8hBAJAAkACQCADLQAMQQFrDgIAAQILIAMqAgghBAwBCyADKgIIQwAAAACUQwrXIzyUIQQLIANBEGokACAEQwAAAACXQwAAAAAgBCAEWxsLeAICfQF/IAAgAkEDdGoiByoC+AMhBkMAAMB/IQUCQAJAAkAgBy0A/ANBAWsOAgABAgsgBiEFDAELIAYgA5RDCtcjPJQhBQsgAC0AF0EQdEGAgMAAcQR9IAUgAEEUaiABIAIgBBBUIgNDAAAAACADIANbG5IFIAULC1EBAX8CQCABKALoAyICIAEoAuwDRwRAIABCADcCBCAAIAE2AgAgAigCAC0AF0EQdEGAgDBxQYCAIEcNASAAEH0PCyAAQgA3AgAgAEEANgIICwvoAgECfwJAIAAgAUYNACABIAAgAmoiBGtBACACQQF0a00EQCAAIAEgAhArDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkEBayECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkEBayICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQQRrIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkEBayICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AA0AgAyABKAIANgIAIAFBBGohASADQQRqIQMgAkEEayICQQNLDQALCyACRQ0AA0AgAyABLQAAOgAAIANBAWohAyABQQFqIQEgAkEBayICDQALCyAAC5QCAgF8AX8CQCAAIAGiIgAQbCIERAAAAAAAAPA/oCAEIAREAAAAAAAAAABjGyIEIARiIgUgBJlELUMc6+I2Gj9jRXJFBEAgACAEoSEADAELIAUgBEQAAAAAAADwv6CZRC1DHOviNho/Y0VyRQRAIAAgBKFEAAAAAAAA8D+gIQAMAQsgACAEoSEAIAIEQCAARAAAAAAAAPA/oCEADAELIAMNACAAAnxEAAAAAAAAAAAgBQ0AGkQAAAAAAADwPyAERAAAAAAAAOA/ZA0AGkQAAAAAAADwP0QAAAAAAAAAACAERAAAAAAAAOC/oJlELUMc6+I2Gj9jGwugIQALIAAgAGIgASABYnIEQEMAAMB/DwsgACABo7YLkwECAX0BfyMAQRBrIgYkACAGQQhqIABB6ABqIAAgAkEBdGovAV4QH0MAAMB/IQUCQAJAAkAgBi0ADEEBaw4CAAECCyAGKgIIIQUMAQsgBioCCCADlEMK1yM8lCEFCyAALQADQRB0QYCAwABxBEAgBSAAIAEgAiAEEFQiA0MAAAAAIAMgA1sbkiEFCyAGQRBqJAAgBQtQAAJAAkACQAJAAkAgAg4EBAABAgMLIAAgASABQR5qEEMPCyAAIAEgAUEeaiADEEQPCyAAIAEgAUEeahBCDwsQJAALIAAgASABQR5qIAMQRQt+AgF/AX0jAEEQayIEJAAgBEEIaiAAQQMgAkECR0EBdCABQf4BcUECRxsgAhBQQwAAwH8hBQJAAkACQCAELQAMQQFrDgIAAQILIAQqAgghBQwBCyAEKgIIIAOUQwrXIzyUIQULIARBEGokACAFQwAAAACXQwAAAAAgBSAFWxsLfgIBfwF9IwBBEGsiBCQAIARBCGogAEEBIAJBAkZBAXQgAUH+AXFBAkcbIAIQUEMAAMB/IQUCQAJAAkAgBC0ADEEBaw4CAAECCyAEKgIIIQUMAQsgBCoCCCADlEMK1yM8lCEFCyAEQRBqJAAgBUMAAAAAl0MAAAAAIAUgBVsbC08AAkACQAJAIANB/wFxIgMOBAACAgECCyABIAEvAABB+P8DcTsAAA8LIAEgAS8AAEH4/wNxQQRyOwAADwsgACABIAJBAUECIANBAUYbEEwLNwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEBAAtiAgJ9An8CQCAAKALkA0UNACAAQfwAaiIDIABBGmoiBC8BABAgIgIgAlwEQCADIABBGGoiBC8BABAgIgIgAlwNASADIAAvARgQIEMAAAAAXkUNAQsgAyAELwEAECAhAQsgAQtfAQN/IAEEQEEMEB4iAyABKQIENwIEIAMhAiABKAIAIgEEQCADIQQDQEEMEB4iAiABKQIENwIEIAQgAjYCACACIQQgASgCACIBDQALCyACIAAoAgA2AgAgACADNgIACwvXawMtfxx9AX4CfwJAIAAtAABBBHEEQCAAKAKgASAMRw0BCyAAKAKkASAAKAL0AygCDEcNAEEAIAAtAKgBIANGDQEaCyAAQoCAgPyLgIDAv383AoADIABCgYCAgBA3AvgCIABCgICA/IuAgMC/fzcC8AIgAEEANgKsAUEBCyErAkACQAJAAkAgACgCCARAIABBFGoiDkECQQEgBhAiIT4gDkECQQEgBhAhITwgDkEAQQEgBhAiITsgDkEAQQEgBhAhIUAgBCABIAUgAiAAKAL4AiAAQfACaiIOKgIAIAAoAvwCIAAqAvQCIAAqAoADIAAqAoQDID4gPJIiPiA7IECSIjwgACgC9AMiEBB7DQEgACgCrAEiEUUNAyAAQbABaiETA0AgBCABIAUgAiATIB1BGGxqIg4oAgggDioCACAOKAIMIA4qAgQgDioCECAOKgIUID4gPCAQEHsNAiAdQQFqIh0gEUcNAAsMAgsgCEUEQCAAKAKsASITRQ0CIABBsAFqIRADQAJAAkAgECAdQRhsIhFqIg4qAgAiPiA+XCABIAFcckUEQCA+IAGTi0MXt9E4XQ0BDAILIAEgAVsgPiA+W3INAQsCQCAQIBFqIhEqAgQiPiA+XCACIAJcckUEQCA+IAKTi0MXt9E4XQ0BDAILIAIgAlsgPiA+W3INAQsgESgCCCAERw0AIBEoAgwgBUYNAwsgEyAdQQFqIh1HDQALDAILAkAgAEHwAmoiDioCACI+ID5cIAEgAVxyRQRAID4gAZOLQxe30ThdDQEMBAsgASABWyA+ID5bcg0DCyAOQQAgACgC/AIgBUYbQQAgACgC+AIgBEYbQQACfyACIAJcIg4gACoC9AIiPiA+XHJFBEAgPiACk4tDF7fROF0MAQtBACA+ID5bDQAaIA4LGyEOCyAORSArcgRAIA4hHQwCCyAAIA4qAhA4ApQDIAAgDioCFDgCmAMgCkEMQRAgCBtqIgMgAygCAEEBajYCACAOIR0MAgtBACEdCyAGIUAgByFHIAtBAWohIiMAQaABayINJAACQAJAIARBAUYgASABW3JFBEAgDUGqCzYCICAAQQVB2CUgDUEgahAsDAELIAVBAUYgAiACW3JFBEAgDUHZCjYCECAAQQVB2CUgDUEQahAsDAELIApBAEEEIAgbaiILIAsoAgBBAWo2AgAgACAALQCIA0H8AXEgAC0AFEEDcSILIANBASADGyIsIAsbIg9BA3FyOgCIAyAAQawDaiIQIA9BAUdBA3QiC2ogAEEUaiIUQQNBAiAPQQJGGyIRIA8gQBAiIgY4AgAgECAPQQFGQQN0Ig5qIBQgESAPIEAQISIHOAIAIAAgFEEAIA8gQBAiIjw4ArADIAAgFEEAIA8gQBAhIjs4ArgDIABBvANqIhAgC2ogFCARIA8QMDgCACAOIBBqIBQgESAPEC84AgAgACAUQQAgDxAwOALAAyAAIBRBACAPEC84AsgDIAsgAEHMA2oiC2ogFCARIA8gQBA4OAIAIAsgDmogFCARIA8gQBA3OAIAIAAgFEEAIA8gQBA4OALQAyAAIBRBACAPIEAQNyI6OALYAyAGIAeSIT4gPCA7kiE8AkACQCAAKAIIIgsEQEMAAMB/IAEgPpMgBEEBRhshBkMAAMB/IAIgPJMgBUEBRhshPiAAAn0gBCAFckUEQCAAIABBAiAPIAYgQCBAECU4ApQDIABBACAPID4gRyBAECUMAQsgBEEDTyAFQQNPcg0EIA1BiAFqIAAgBiAGIAAqAswDIAAqAtQDkiAAKgK8A5IgACoCxAOSIjyTIgdDAAAAACAHQwAAAABeGyAGIAZcG0GBgAggBEEDdEH4//8HcXZB/wFxID4gPiAAKgLQAyA6kiAAKgLAA5IgACoCyAOSIjuTIgdDAAAAACAHQwAAAABeGyA+ID5cG0GBgAggBUEDdEH4//8HcXZB/wFxIAsREAAgDSoCjAEiPUMAAAAAYCANKgKIASIHQwAAAABgcUUEQCANID27OQMIIA0gB7s5AwAgAEEBQdwdIA0QLCANKgKMASIHQwAAAAAgB0MAAAAAXhshPSANKgKIASIHQwAAAAAgB0MAAAAAXhshBwsgCiAKKAIUQQFqNgIUIAogCUECdGoiCSAJKAIYQQFqNgIYIAAgAEECIA8gPCAHkiAGIARBAWtBAkkbIEAgQBAlOAKUAyAAQQAgDyA7ID2SID4gBUEBa0ECSRsgRyBAECULOAKYAwwBCwJAIAAoAuADRQRAIAAoAuwDIAAoAugDa0ECdSELDAELIA1BiAFqIAAQMgJAIA0oAogBRQRAQQAhCyANKAKMAUUNAQsgDUGAAWohEEEAIQsDQCANQQA2AoABIA0gDSkDiAE3A3ggECANKAKQARA8IA1BiAFqEC4gDSgCgAEiCQRAA0AgCSgCACEOIAkQJyAOIgkNAAsLIAtBAWohCyANQQA2AoABIA0oAowBIA0oAogBcg0ACwsgDSgCkAEiCUUNAANAIAkoAgAhDiAJECcgDiIJDQALCyALRQRAIAAgAEECIA8gBEEBa0EBSwR9IAEgPpMFIAAqAswDIAAqAtQDkiAAKgK8A5IgACoCxAOSCyBAIEAQJTgClAMgACAAQQAgDyAFQQFrQQFLBH0gAiA8kwUgACoC0AMgACoC2AOSIAAqAsADkiAAKgLIA5ILIEcgQBAlOAKYAwwBCwJAIAgNACAFQQJGIAIgPJMiBiAGW3EgBkMAAAAAX3EgBCAFckUgBEECRiABID6TIgdDAAAAAF9xcnJFDQAgACAAQQIgD0MAAAAAQwAAAAAgByAHQwAAAABdGyAHIARBAkYbIAcgB1wbIEAgQBAlOAKUAyAAIABBACAPQwAAAABDAAAAACAGIAZDAAAAAF0bIAYgBUECRhsgBiAGXBsgRyBAECU4ApgDDAELIAAQTyAAIAAtAIgDQfsBcToAiAMgABBeQQMhEyAALQAUQQJ2QQNxIQkCQAJAIA9BAkcNAAJAIAlBAmsOAgIAAQtBAiETDAELIAkhEwsgAC8AFSEnIBQgEyAPIEAQOCEGIBQgEyAPEDAhByAUIBMgDyBAEDchOyAUIBMgDxAvITpBACEQIBQgEUEAIBNBAkkbIhYgDyBAEDghPyAUIBYgDxAwIT0gFCAWIA8gQBA3IUEgFCAWIA8QLyFEIBQgFiAPIEAQYCFCIBQgFiAPEEshQyAAIA9BACABID6TIlAgBiAHkiA7IDqSkiJKID8gPZIgQSBEkpIiRiATQQFLIhkbIEAgQBB6ITsgACAPQQEgAiA8kyJRIEYgSiAZGyBHIEAQeiFFAkACQCAEIAUgGRsiHA0AIA1BiAFqIAAQMgJAAkAgDSgCiAEiDiANKAKMASIJckUNAANAIA4oAuwDIA4oAugDIg5rQQJ1IAlNDQQCQCAOIAlBAnRqKAIAIgkQeUUNACAQDQIgCRA7IgYgBlsgBotDF7fROF1xDQIgCRBAIgYgBlwEQCAJIRAMAQsgCSEQIAaLQxe30ThdDQILIA1BiAFqEC4gDSgCjAEiCSANKAKIASIOcg0ACwwBC0EAIRALIA0oApABIglFDQADQCAJKAIAIQ4gCRAnIA4iCQ0ACwsgDUGIAWogABAyIA0oAowBIQkCQCANKAKIASIORQRAQwAAAAAhPSAJRQ0BCyBFIEVcIiMgBUEAR3IhKCA7IDtcIiQgBEEAR3IhKUMAAAAAIT0DQCAOKALsAyAOKALoAyIOa0ECdSAJTQ0CIA4gCUECdGooAgAiDhB4AkAgDi8AFSAOLQAXQRB0ciIJQYCAMHFBgIAQRgRAIA4QdyAOIA4tAAAiCUEBciIOQfsBcSAOIAlBBHEbOgAADAELIAgEfyAOIA4tABRBA3EiCSAPIAkbIDsgRRB2IA4vABUgDi0AF0EQdHIFIAkLQYDgAHFBgMAARg0AIA5BFGohEQJAIA4gEEYEQCAQQQA2ApwBIBAgDDYCmAFDAAAAACEHDAELIBQtAABBAnZBA3EhCQJAAkAgD0ECRw0AQQMhEgJAIAlBAmsOAgIAAQtBAiESDAELIAkhEgsgDUGAgID+BzYCaCANQYCAgP4HNgJQIA1B+ABqIA5B/ABqIhcgDi8BHhAfIDsgRSASQQFLIh4bIT4CQAJAAkACQCANLQB8IgkOBAABAQABCwJAIBcgDi8BGBAgIgYgBlwNACAXIA4vARgQIEMAAAAAXkUNACAOKAL0Ay0ACEEBcSIJDQBDAADAf0MAAAAAIAkbIQcMAgtDAADAfyEGDAILIA0qAnghB0MAAMB/IQYCQCAJQQFrDgIBAAILIAcgPpRDCtcjPJQhBgwBCyAHIQYLIA4tABdBEHRBgIDAAHEEQCAGIBEgD0GBAiASQQN0dkEBcSA7EFQiBkMAAAAAIAYgBlsbkiEGCyAOKgL4AyEHQQAhH0EAIRgCQAJAAkAgDi0A/ANBAWsOAgEAAgsgOyAHlEMK1yM8lCEHCyAHIAdcDQAgB0MAAAAAYCEYCyAOKgKABCEHAkACQAJAIA4tAIQEQQFrDgIBAAILIEUgB5RDCtcjPJQhBwsgByAHXA0AIAdDAAAAAGAhHwsCQCAOAn0gBiAGXCIJID4gPlxyRQRAIA4qApwBIgcgB1sEQCAOKAL0Ay0AEEEBcUUNAyAOKAKYASAMRg0DCyARIBIgDyA7EDggESASIA8QMJIgESASIA8gOxA3IBEgEiAPEC+SkiIHIAYgBiAHXRsgByAGIAkbIAYgBlsgByAHW3EbDAELIBggHnEEQCARQQIgDyA7EDggEUECIA8QMJIgEUECIA8gOxA3IBFBAiAPEC+SkiIHIA4gD0EAIDsgOxAxIgYgBiAHXRsgByAGIAYgBlwbIAYgBlsgByAHW3EbDAELIB4gH0VyRQRAIBFBACAPIDsQOCARQQAgDxAwkiARQQAgDyA7EDcgEUEAIA8QL5KSIgcgDiAPQQEgRSA7EDEiBiAGIAddGyAHIAYgBiAGXBsgBiAGWyAHIAdbcRsMAQtBASEaIA1BATYCZCANQQE2AnggEUECQQEgOxAiIBFBAkEBIDsQIZIhPiARQQBBASA7ECIhPCARQQBBASA7ECEhOkMAAMB/IQdBASEVQwAAwH8hBiAYBEAgDiAPQQAgOyA7EDEhBiANQQA2AnggDSA+IAaSIgY4AmhBACEVCyA8IDqSITwgHwRAIA4gD0EBIEUgOxAxIQcgDUEANgJkIA0gPCAHkiIHOAJQQQAhGgsCQAJAAkAgAC0AF0EQdEGAgAxxQYCACEYiCSASQQJJIiBxRQRAIAkgJHINAiAGIAZcDQEMAgsgJCAGIAZbcg0CC0ECIRUgDUECNgJ4IA0gOzgCaCA7IQYLAkAgIEEBIAkbBEAgCSAjcg0CIAcgB1wNAQwCCyAjIAcgB1tyDQELQQIhGiANQQI2AmQgDSBFOAJQIEUhBwsCQCAXIA4vAXoQICI6IDpcDQACfyAVIB5yRQRAIBcgDi8BehAgIQcgDUEANgJkIA0gPCAGID6TIAeVkjgCUEEADAELIBogIHINASAXIA4vAXoQICEGIA1BADYCeCANIAYgByA8k5QgPpI4AmhBAAshGkEAIRULIA4vABZBD3EiCUUEQCAALQAVQQR2IQkLAkAgFUUgCUEFRiAeciAYIClyIAlBBEdycnINACANQQA2AnggDSA7OAJoIBcgDi8BehAgIgYgBlwNAEEAIRogFyAOLwF6ECAhBiANQQA2AmQgDSA7ID6TIAaVOAJQCyAOLwAWQQ9xIhhFBEAgAC0AFUEEdiEYCwJAICAgKHIgH3IgGEEFRnIgGkUgGEEER3JyDQAgDUEANgJkIA0gRTgCUCAXIA4vAXoQICIGIAZcDQAgFyAOLwF6ECAhBiANQQA2AnggDSAGIEUgPJOUOAJoCyAOIA9BAiA7IDsgDUH4AGogDUHoAGoQPyAOIA9BACBFIDsgDUHkAGogDUHQAGoQPyAOIA0qAmggDSoCUCAPIA0oAnggDSgCZCA7IEVBAEEFIAogIiAMED0aIA4gEkECdEH8JWooAgBBAnRqKgKUAyEGIBEgEiAPIDsQOCARIBIgDxAwkiARIBIgDyA7EDcgESASIA8QL5KSIgcgBiAGIAddGyAHIAYgBiAGXBsgBiAGWyAHIAdbcRsLIgc4ApwBCyAOIAw2ApgBCyA9IAcgESATQQEgOxAiIBEgE0EBIDsQIZKSkiE9CyANQYgBahAuIA0oAowBIgkgDSgCiAEiDnINAAsLIA0oApABIgkEQANAIAkoAgAhDiAJECcgDiIJDQALCyA7IEUgGRshByA9QwAAAACSIQYgC0ECTwRAIBQgEyAHEE0gC0EBa7OUIAaSIQYLIEIgQ5IhPiAFIAQgGRshGiBHIEAgGRshTSBAIEcgGRshSSANQdAAaiAAEDJBACAcIAYgB14iCxsgHCAcQQJGGyAcICdBgIADcSIfGyEeIBQgFiBFIDsgGRsiRBBNIU8gDSgCVCIRIA0oAlAiCXIEQEEBQQIgRCBEXCIpGyEtIAtFIBxBAUZyIS4gE0ECSSEZIABB8gBqIS8gAEH8AGohMCATQQJ0IgtB7CVqITEgC0HcJWohMiAWQQJ0Ig5B7CVqIRwgDkHcJWohICALQfwlaiEkIA5B/CVqISMgGkEARyIzIAhyITQgGkUiNSAIQQFzcSE2IBogH3JFITcgDUHwAGohOCANQYABaiEnQYECIBNBA3R2Qf8BcSEoIBpBAWtBAkkhOQNAIA1BADYCgAEgDUIANwN4AkAgACgC7AMiCyAAKALoAyIORg0AIAsgDmsiC0EASA0DIA1BiAFqIAtBAnVBACAnEEohECANKAKMASANKAJ8IA0oAngiC2siDmsgCyAOEDMhDiANIA0oAngiCzYCjAEgDSAONgJ4IA0pA5ABIVYgDSANKAJ8Ig42ApABIA0oAoABIRIgDSBWNwJ8IA0gEjYClAEgECALNgIAIAsgDkcEQCANIA4gCyAOa0EDakF8cWo2ApABCyALRQ0AIAsQJwsgFC0AACIOQQJ2QQNxIQsCQAJAIA5BA3EiDiAsIA4bIhJBAkcNAEEDIRACQCALQQJrDgICAAELQQIhEAwBCyALIRALIAAvABUhCyAUIBAgBxBNIT8CQCAJIBFyRQRAQwAAAAAhQ0EAIRFDAAAAACFCQwAAAAAhQUEAIRUMAQsgC0GAgANxISUgEEECSSEYIBBBAnQiC0HsJWohISALQdwlaiEqQQAhFUMAAAAAIUEgESEOQwAAAAAhQkMAAAAAIUNBACEXQwAAAAAhPQNAIAkoAuwDIAkoAugDIglrQQJ1IA5NDQQCQCAJIA5BAnRqKAIAIgkvABUgCS0AF0EQdHIiC0GAgDBxQYCAEEYgC0GA4ABxQYDAAEZyDQAgDUGIAWoiESAJQRRqIgsgKigCACADECggDS0AjAEhJiARIAsgISgCACADECggDS0AjAEhESAJIBs2AtwDIBUgJkEDRmohFSARQQNGIREgCyAQQQEgOxAiIUsgCyAQQQEgOxAhIU4gCSAXIAkgFxsiF0YhJiAJKgKcASE8IAsgEiAYIEkgQBA1IToCQCALIBIgGCBJIEAQLSIGQwAAAABgIAYgPF1xDQAgOkMAAAAAYEUEQCA8IQYMAQsgOiA8IDogPF4bIQYLIBEgFWohFQJAICVFQwAAAAAgPyAmGyI8IEsgTpIiOiA9IAaSkpIgB15Fcg0AIA0oAnggDSgCfEYNACAOIREMAwsgCRB5BEAgQiAJEDuSIUIgQyAJEEAgCSoCnAGUkyFDCyBBIDwgOiAGkpIiBpIhQSA9IAaSIT0gDSgCfCILIA0oAoABRwRAIAsgCTYCACANIAtBBGo2AnwMAQsgCyANKAJ4ayILQQJ1IhFBAWoiDkGAgICABE8NBSANQYgBakH/////AyALQQF1IiYgDiAOICZJGyALQfz///8HTxsgESAnEEohDiANKAKQASAJNgIAIA0gDSgCkAFBBGo2ApABIA0oAowBIA0oAnwgDSgCeCIJayILayAJIAsQMyELIA0gDSgCeCIJNgKMASANIAs2AnggDSkDkAEhViANIA0oAnwiCzYCkAEgDSgCgAEhESANIFY3AnwgDSARNgKUASAOIAk2AgAgCSALRwRAIA0gCyAJIAtrQQNqQXxxajYCkAELIAlFDQAgCRAnCyANQQA2AnAgDSANKQNQNwNoIDggDSgCWBA8IA1B0ABqEC4gDSgCcCIJBEADQCAJKAIAIQsgCRAnIAsiCQ0ACwtBACERIA1BADYCcCANKAJUIg4gDSgCUCIJcg0ACwtDAACAPyBCIEJDAACAP10bIEIgQkMAAAAAXhshPCANKAJ8IRcgDSgCeCEJAn0CQAJ9AkACQAJAIB5FDQAgFCAPQQAgQCBAEDUhBiAUIA9BACBAIEAQLSE6IBQgD0EBIEcgQBA1IT8gFCAPQQEgRyBAEC0hPSAGID8gE0EBSyILGyBKkyIGIAZbIAYgQV5xDQEgOiA9IAsbIEqTIgYgBlsgBiBBXXENASAAKAL0Ay0AFEEBcQ0AIEEgPEMAAAAAWw0DGiAAEDsiBiAGXA0CIEEgABA7QwAAAABbDQMaDAILIAchBgsgBiAGWw0CIAYhBwsgBwshBiBBjEMAAAAAIEFDAAAAAF0bIT8gBgwBCyAGIEGTIT8gBgshByA2RQRAAkAgCSAXRgRAQwAAAAAhQQwBC0MAAIA/IEMgQ0MAAIA/XRsgQyBDQwAAAABeGyE9QwAAAAAhQSAJIQ4DQCAOKAIAIgsqApwBITogC0EUaiIQIA8gGSBJIEAQNSFCAkAgECAPIBkgSSBAEC0iBkMAAAAAYCAGIDpdcQ0AIEJDAAAAAGBFBEAgOiEGDAELIEIgOiA6IEJdGyEGCwJAID9DAAAAAF0EQCAGIAsQQIyUIjpDAAAAAF4gOkMAAAAAXXJFDQEgCyATIA8gPyA9lSA6lCAGkiJCIAcgOxAlITogQiBCXCA6IDpcciA6IEJbcg0BIEEgOiAGk5IhQSALEEAgCyoCnAGUID2SIT0MAQsgP0MAAAAAXkUNACALEDsiQkMAAAAAXiBCQwAAAABdckUNACALIBMgDyA/IDyVIEKUIAaSIkMgByA7ECUhOiBDIENcIDogOlxyIDogQ1tyDQAgPCBCkyE8IEEgOiAGk5IhQQsgDkEEaiIOIBdHDQALID8gQZMiQiA9lSFLIEIgPJUhTiAALwAVQYCAA3FFIC5yISVDAAAAACFBIAkhCwNAIAsoAgAiDioCnAEhPCAOQRRqIhggDyAZIEkgQBA1IToCQCAYIA8gGSBJIEAQLSIGQwAAAABgIAYgPF1xDQAgOkMAAAAAYEUEQCA8IQYMAQsgOiA8IDogPF4bIQYLAn0gDiATIA8CfSBCQwAAAABdBEAgBiAGIA4QQIyUIjxDAAAAAFsNAhogBiA8kiA9QwAAAABbDQEaIEsgPJQgBpIMAQsgBiBCQwAAAABeRQ0BGiAGIA4QOyI8QwAAAABeIDxDAAAAAF1yRQ0BGiBOIDyUIAaSCyAHIDsQJQshQyAYIBNBASA7ECIhPCAYIBNBASA7ECEhOiAYIBZBASA7ECIhUiAYIBZBASA7ECEhUyANIEMgPCA6kiJUkiJVOAJoIA1BADYCYCBSIFOSITwCQCAOQfwAaiIQIA4vAXoQICI6IDpbBEAgECAOLwF6ECAhOiANQQA2AmQgDSA8IFUgVJMiPCA6lCA8IDqVIBkbkjgCeAwBCyAjKAIAIRACQCApDQAgDiAQQQN0aiIhKgL4AyE6QQAhEgJAAkACQCAhLQD8A0EBaw4CAQACCyBEIDqUQwrXIzyUIToLIDogOlwNACA6QwAAAABgIRILICUgNSASQQFzcXFFDQAgDi8AFkEPcSISBH8gEgUgAC0AFUEEdgtBBEcNACANQYgBaiAYICAoAgAgDxAoIA0tAIwBQQNGDQAgDUGIAWogGCAcKAIAIA8QKCANLQCMAUEDRg0AIA1BADYCZCANIEQ4AngMAQsgDkH4A2oiEiAQQQN0aiIQKgIAIToCQAJAAkACQCAQLQAEQQFrDgIBAAILIEQgOpRDCtcjPJQhOgsgOkMAAAAAYA0BCyANIC02AmQgDSBEOAJ4DAELAkACfwJAAkACQCAWQQJrDgICAAELIDwgDiAPQQAgRCA7EDGSITpBAAwCC0EBIRAgDSA8IA4gD0EBIEQgOxAxkiI6OAJ4IBNBAU0NDAwCCyA8IA4gD0EAIEQgOxAxkiE6QQALIRAgDSA6OAJ4CyANIDMgEiAQQQN0ajEABEIghkKAgICAIFFxIDogOlxyNgJkCyAOIA8gEyAHIDsgDUHgAGogDUHoAGoQPyAOIA8gFiBEIDsgDUHkAGogDUH4AGoQPyAOICMoAgBBA3RqIhAqAvgDIToCQAJAAkACQCAQLQD8A0EBaw4CAQACCyBEIDqUQwrXIzyUIToLQQEhECA6QwAAAABgDQELQQEhECAOLwAWQQ9xIhIEfyASBSAALQAVQQR2C0EERw0AIA1BiAFqIBggICgCACAPECggDS0AjAFBA0YNACANQYgBaiAYIBwoAgAgDxAoIA0tAIwBQQNGIRALIA4gDSoCaCI8IA0qAngiOiATQQFLIhIbIDogPCASGyAALQCIA0EDcSANKAJgIhggDSgCZCIhIBIbICEgGCASGyA7IEUgCCAQcSIQQQRBByAQGyAKICIgDBA9GiBBIEMgBpOSIUEgAAJ/IAAtAIgDIhBBBHFFBEBBACAOLQCIA0EEcUUNARoLQQQLIBBB+wFxcjoAiAMgC0EEaiILIBdHDQALCyA/IEGTIT8LIAAgAC0AiAMiC0H7AXFBBCA/QwAAAABdQQJ0IAtBBHFBAnYbcjoAiAMgFCATIA8gQBBgIBQgEyAPEEuSITogFCATIA8gQBB/IBQgEyAPEFKSIUsgFCATIAcQTSFCAn8CQAJ9ID9DAAAAAF5FIB5BAkdyRQRAIA1BiAFqIDAgLyAkKAIAQQF0ai8BABAfAkAgDS0AjAEEQCAUIA8gKCBJIEAQNSIGIAZbDQELQwAAAAAMAgtDAAAAACAUIA8gKCBJIEAQNSA6kyBLkyAHID+TkyI/QwAAAABeRQ0BGgsgP0MAAAAAYEUNASA/CyE8IBQtAABBBHZBB3EMAQsgPyE8IBQtAABBBHZBB3EiC0EAIAtBA2tBA08bCyELQwAAAAAhBgJAAkAgFQ0AQwAAAAAhPQJAAkACQAJAAkAgC0EBaw4FAAECBAMGCyA8QwAAAD+UIT0MBQsgPCE9DAQLIBcgCWsiC0EFSQ0CIEIgPCALQQJ1QQFrs5WSIUIMAgsgQiA8IBcgCWtBAnVBAWqzlSI9kiFCDAILIDxDAAAAP5QgFyAJa0ECdbOVIj0gPZIgQpIhQgwBC0MAAAAAIT0LIDogPZIhPSAAEHwhEgJAIAkgF0YiGARAQwAAAAAhP0MAAAAAIToMAQsgF0EEayElIDwgFbOVIU4gMigCACEhQwAAAAAhOkMAAAAAIT8gCSELA0AgDUGIAWogCygCACIOQRRqIhAgISAPECggPUMAAACAIE5DAAAAgCA8QwAAAABeGyJBIA0tAIwBQQNHG5IhPSAIBEACfwJAAkACQAJAIBNBAWsOAwECAwALQQEhFSAOQaADagwDC0EDIRUgDkGoA2oMAgtBACEVIA5BnANqDAELQQIhFSAOQaQDagshKiAOIBVBAnRqICoqAgAgPZI4ApwDCyAlKAIAIRUgDUGIAWogECAxKAIAIA8QKCA9QwAAAIAgQiAOIBVGG5JDAAAAgCBBIA0tAIwBQQNHG5IhPQJAIDRFBEAgPSAQIBNBASA7ECIgECATQQEgOxAhkiAOKgKcAZKSIT0gRCEGDAELIA4gEyA7EF0gPZIhPSASBEAgDhBOIUEgEEEAIA8gOxBBIUMgDioCmAMgEEEAQQEgOxAiIBBBAEEBIDsQIZKSIEEgQ5IiQZMiQyA/ID8gQ10bIEMgPyA/ID9cGyA/ID9bIEMgQ1txGyE/IEEgOiA6IEFdGyBBIDogOiA6XBsgOiA6WyBBIEFbcRshOgwBCyAOIBYgOxBdIkEgBiAGIEFdGyBBIAYgBiAGXBsgBiAGWyBBIEFbcRshBgsgC0EEaiILIBdHDQALCyA/IDqSIAYgEhshQQJ9IDkEQCAAIBYgDyBGIEGSIE0gQBAlIEaTDAELIEQgQSA3GyFBIEQLIT8gH0UEQCAAIBYgDyBGIEGSIE0gQBAlIEaTIUELIEsgPZIhPAJAIAhFDQAgCSELIBgNAANAIAsoAgAiFS8AFkEPcSIORQRAIAAtABVBBHYhDgsCQAJAAkACQCAOQQRrDgIAAQILIA1BiAFqIBVBFGoiECAgKAIAIA8QKEEEIQ4gDS0AjAFBA0YNASANQYgBaiAQIBwoAgAgDxAoIA0tAIwBQQNGDQEgFSAjKAIAQQN0aiIOKgL4AyE9AkACQAJAIA4tAPwDQQFrDgIBAAILIEQgPZRDCtcjPJQhPQsgPiEGID1DAAAAAGANAwsgFSAkKAIAQQJ0aioClAMhBiANIBVB/ABqIg4gFS8BehAgIjogOlsEfSAQIBZBASA7ECIgECAWQQEgOxAhkiAGIA4gFS8BehAgIjqUIAYgOpUgGRuSBSBBCzgCeCANIAYgECATQQEgOxAiIBAgE0EBIDsQIZKSOAKIASANQQA2AmggDUEANgJkIBUgDyATIAcgOyANQegAaiANQYgBahA/IBUgDyAWIEQgOyANQeQAaiANQfgAahA/IA0qAngiOiANKgKIASI9IBNBAUsiGCIOGyEGIB9BAEcgAC8AFUEPcUEER3EiECAZcSA9IDogDhsiOiA6XHIhDiAVIDogBiAPIA4gECAYcSAGIAZcciA7IEVBAUECIAogIiAMED0aID4hBgwCC0EFQQEgFC0AAEEIcRshDgsgFSAWIDsQXSEGIA1BiAFqIBVBFGoiECAgKAIAIhggDxAoID8gBpMhOgJAIA0tAIwBQQNHBEAgHCgCACESDAELIA1BiAFqIBAgHCgCACISIA8QKCANLQCMAUEDRw0AID4gOkMAAAA/lCIGQwAAAAAgBkMAAAAAXhuSIQYMAQsgDUGIAWogECASIA8QKCA+IQYgDS0AjAFBA0YNACANQYgBaiAQIBggDxAoIA0tAIwBQQNGBEAgPiA6QwAAAAAgOkMAAAAAXhuSIQYMAQsCQAJAIA5BAWsOAgIAAQsgPiA6QwAAAD+UkiEGDAELID4gOpIhBgsCfwJAAkACQAJAIBZBAWsOAwECAwALQQEhECAVQaADagwDC0EDIRAgFUGoA2oMAgtBACEQIBVBnANqDAELQQIhECAVQaQDagshDiAVIBBBAnRqIAYgTCAOKgIAkpI4ApwDIAtBBGoiCyAXRw0ACwsgCQRAIAkQJwsgPCBIIDwgSF4bIDwgSCBIIEhcGyBIIEhbIDwgPFtxGyFIIEwgT0MAAAAAIBsbIEGSkiFMIBtBAWohGyANKAJQIgkgEXINAAsLAkAgCEUNACAfRQRAIAAQfEUNAQsgACAWIA8CfSBGIESSIBpFDQAaIAAgFkECdEH8JWooAgBBA3RqIgkqAvgDIQYCQAJAAkAgCS0A/ANBAWsOAgEAAgsgTSAGlEMK1yM8lCEGCyAGQwAAAABgRQ0AIAAgD0GBAiAWQQN0dkEBcSBNIEAQMQwBCyBGIEySCyBHIEAQJSEGQwAAAAAhPCAALwAVQQ9xIQkCQAJAAkACQAJAAkACQAJAAkAgBiBGkyBMkyIGQwAAAABgRQRAQwAAAAAhQyAJQQJrDgICAQcLQwAAAAAhQyAJQQJrDgcBAAUGBAIDBgsgPiAGkiE+DAULID4gBkMAAAA/lJIhPgwECyAGIBuzIjqVITwgPiAGIDogOpKVkiE+DAMLID4gBiAbQQFqs5UiPJIhPgwCCyAbQQJJBEAMAgsgDUGIAWogABAyIAYgG0EBa7OVITwMAgsgBiAbs5UhQwsgDUGIAWogABAyIBtFDQELIBZBAnQiCUHcJWohECAJQfwlaiERIA1BOGohGCANQcgAaiEZIA1B8ABqIRUgDUGQAWohHCANQYABaiEfQQAhEgNAIA1BADYCgAEgDSANKQOIATcDeCAfIA0oApABEDwgDUEANgJwIA0gDSkDeCJWNwNoIBUgDSgCgAEiCxA8IA0oAmwhCQJAAkAgDSgCaCIOBEBDAAAAACE6QwAAAAAhP0MAAAAAIQYMAQtDAAAAACE6QwAAAAAhP0MAAAAAIQYgCUUNAQsDQCAOKALsAyAOKALoAyIOa0ECdSAJTQ0FAkAgDiAJQQJ0aigCACIJLwAVIAktABdBEHRyIhdBgIAwcUGAgBBGIBdBgOAAcUGAwABGcg0AIAkoAtwDIBJHDQIgCUEUaiEOIAkgESgCAEECdGoqApQDIj1DAAAAAGAEfyA9IA4gFkEBIDsQIiAOIBZBASA7ECGSkiI9IAYgBiA9XRsgPSAGIAYgBlwbIAYgBlsgPSA9W3EbIQYgCS0AFgUgF0EIdgtBD3EiFwR/IBcFIAAtABVBBHYLQQVHDQAgFC0AAEEIcUUNACAJEE4gDkEAIA8gOxBBkiI9ID8gPSA/XhsgPSA/ID8gP1wbID8gP1sgPSA9W3EbIj8gCSoCmAMgDkEAQQEgOxAiIA5BAEEBIDsQIZKSID2TIj0gOiA6ID1dGyA9IDogOiA6XBsgOiA6WyA9ID1bcRsiOpIiPSAGIAYgPV0bID0gBiAGIAZcGyAGIAZbID0gPVtxGyEGCyANQQA2AkggDSANKQNoNwNAIBkgDSgCcBA8IA1B6ABqEC4gDSgCSCIJBEADQCAJKAIAIQ4gCRAnIA4iCQ0ACwsgDUEANgJIIA0oAmwiCSANKAJoIg5yDQALCyANIA0pA2g3A4gBIBwgDSgCcBB1IA0gVjcDaCAVIAsQdSA+IE9DAAAAACASG5IhPiBDIAaSIT0gDSgCbCEJAkAgDSgCaCIOIA0oAogBRgRAIAkgDSgCjAFGDQELID4gP5IhQiA+ID2SIUsgPCA9kiEGA0AgDigC7AMgDigC6AMiDmtBAnUgCU0NBQJAIA4gCUECdGooAgAiCS8AFSAJLQAXQRB0ciIXQYCAMHFBgIAQRiAXQYDgAHFBgMAARnINACAJQRRqIQ4CQAJAAkACQAJAAkAgF0EIdkEPcSIXBH8gFwUgAC0AFUEEdgtBAWsOBQEDAgQABgsgFC0AAEEIcQ0ECyAOIBYgDyA7EFEhOiAJIBAoAgBBAnRqID4gOpI4ApwDDAQLIA4gFiAPIDsQYiE/AkACQAJAAkAgFkECaw4CAgABCyAJKgKUAyE6QQIhDgwCC0EBIQ4gCSoCmAMhOgJAIBYOAgIADwtBAyEODAELIAkqApQDITpBACEOCyAJIA5BAnRqIEsgP5MgOpM4ApwDDAMLAkACQAJAAkAgFkECaw4CAgABCyAJKgKUAyE/QQIhDgwCC0EBIQ4gCSoCmAMhPwJAIBYOAgIADgtBAyEODAELIAkqApQDIT9BACEOCyAJIA5BAnRqID4gPSA/k0MAAAA/lJI4ApwDDAILIA4gFiAPIDsQQSE6IAkgECgCAEECdGogPiA6kjgCnAMgCSARKAIAQQN0aiIXKgL4AyE/AkACQAJAIBctAPwDQQFrDgIBAAILIEQgP5RDCtcjPJQhPwsgP0MAAAAAYA0CCwJAAkACfSATQQFNBEAgCSoCmAMgDiAWQQEgOxAiIA4gFkEBIDsQIZKSITogBgwBCyAGITogCSoClAMgDiATQQEgOxAiIA4gE0EBIDsQIZKSCyI/ID9cIAkqApQDIkEgQVxyRQRAID8gQZOLQxe30ThdDQEMAgsgPyA/WyBBIEFbcg0BCyAJKgKYAyJBIEFcIg4gOiA6XHJFBEAgOiBBk4tDF7fROF1FDQEMAwsgOiA6Ww0AIA4NAgsgCSA/IDogD0EAQQAgOyBFQQFBAyAKICIgDBA9GgwBCyAJIEIgCRBOkyAOQQAgDyBEEFGSOAKgAwsgDUEANgI4IA0gDSkDaDcDMCAYIA0oAnAQPCANQegAahAuIA0oAjgiCQRAA0AgCSgCACEOIAkQJyAOIgkNAAsLIA1BADYCOCANKAJsIQkgDSgCaCIOIA0oAogBRw0AIAkgDSgCjAFHDQALCyANKAJwIgkEQANAIAkoAgAhDiAJECcgDiIJDQALCyALBEADQCALKAIAIQkgCxAnIAkiCw0ACwsgPCA+kiA9kiE+IBJBAWoiEiAbRw0ACwsgDSgCkAEiCUUNAANAIAkoAgAhCyAJECcgCyIJDQALCyAAQZQDaiIQIABBAiAPIFAgQCBAECU4AgAgAEGYA2oiESAAQQAgDyBRIEcgQBAlOAIAAkAgEEGBAiATQQN0dkEBcUECdGoCfQJAIB5BAUcEQCAALQAXQQNxIglBAkYgHkECR3INAQsgACATIA8gSCBJIEAQJQwBCyAeQQJHIAlBAkdyDQEgSiAAIA8gEyBIIEkgQBB0Ij4gSiAHkiIGIAYgPl4bID4gBiAGIAZcGyAGIAZbID4gPltxGyIGIAYgSl0bIEogBiAGIAZcGyAGIAZbIEogSltxGws4AgALAkAgEEGBAiAWQQN0dkEBcUECdGoCfQJAIBpBAUcEQCAaQQJHIgkgAC0AF0EDcSILQQJGcg0BCyAAIBYgDyBGIEySIE0gQBAlDAELIAkgC0ECR3INASBGIAAgDyAWIEYgTJIgTSBAEHQiByBGIESSIgYgBiAHXhsgByAGIAYgBlwbIAYgBlsgByAHW3EbIgYgBiBGXRsgRiAGIAYgBlwbIAYgBlsgRiBGW3EbCzgCAAsCQCAIRQ0AAkAgAC8AFUGAgANxQYCAAkcNACANQYgBaiAAEDIDQCANKAKMASIJIA0oAogBIgtyRQRAIA0oApABIglFDQIDQCAJKAIAIQsgCRAnIAsiCQ0ACwwCCyALKALsAyALKALoAyILa0ECdSAJTQ0DIAsgCUECdGooAgAiCS8AFUGA4ABxQYDAAEcEQCAJAn8CQAJAAkAgFkECaw4CAAECCyAJQZQDaiEOIBAqAgAgCSoCnAOTIQZBAAwCCyAJQZQDaiEOIBAqAgAgCSoCpAOTIQZBAgwBCyARKgIAIQYCQAJAIBYOAgABCgsgCUGYA2ohDiAGIAkqAqADkyEGQQEMAQsgCUGYA2ohDiAGIAkqAqgDkyEGQQMLQQJ0aiAGIA4qAgCTOAKcAwsgDUGIAWoQLgwACwALAkAgEyAWckEBcUUNACAWQQFxIRQgE0EBcSEVIA1BiAFqIAAQMgNAIA0oAowBIgkgDSgCiAEiC3JFBEAgDSgCkAEiCUUNAgNAIAkoAgAhCyAJECcgCyIJDQALDAILIAsoAuwDIAsoAugDIgtrQQJ1IAlNDQMCQCALIAlBAnRqKAIAIgkvABUgCS0AF0EQdHIiC0GAgDBxQYCAEEYgC0GA4ABxQYDAAEZyDQAgFQRAAn8CfwJAAkACQCATQQFrDgMAAQINCyAJQZgDaiEOIAlBqANqIQtBASESIBEMAwsgCUGUA2ohDkECIRIgCUGcA2oMAQsgCUGUA2ohDkEAIRIgCUGkA2oLIQsgEAshGyAJIBJBAnRqIBsqAgAgDioCAJMgCyoCAJM4ApwDCyAURQ0AAn8CfwJAAkACQCAWQQFrDgMAAQIMCyAJQZgDaiELIAlBqANqIRJBASEXIBEMAwsgCUGUA2ohCyAJQZwDaiESQQIMAQsgCUGUA2ohCyAJQaQDaiESQQALIRcgEAshDiAJIBdBAnRqIA4qAgAgCyoCAJMgEioCAJM4ApwDCyANQYgBahAuDAALAAsgAC8AFUGA4ABxICJBAUZyRQRAIAAtAABBCHFFDQELIAAgACAeIAQgE0EBSxsgDyAKICIgDEMAAAAAQwAAAAAgOyBFEH4aCyANKAJYIglFDQIDQCAJKAIAIQsgCRAnIAsiCQ0ACwwCCxACAAsgABBeCyANQaABaiQADAELECQACyAAIAM6AKgBIAAgACgC9AMoAgw2AqQBIB0NACAKIAooAggiAyAAKAKsASIOQQFqIgkgAyAJSxs2AgggDkEIRgRAIABBADYCrAFBACEOCyAIBH8gAEHwAmoFIAAgDkEBajYCrAEgACAOQRhsakGwAWoLIgMgBTYCDCADIAQ2AgggAyACOAIEIAMgATgCACADIAAqApQDOAIQIAMgACoCmAM4AhRBACEdCyAIBEAgACAAKQKUAzcCjAMgACAALQAAIgNBAXIiBEH7AXEgBCADQQRxGzoAAAsgACAMNgKgASArIB1Fcgs1AQF/IAEgACgCBCICQQF1aiEBIAAoAgAhACABIAJBAXEEfyABKAIAIABqKAIABSAACxECAAt9ACAAQRRqIgAgAUGBAiACQQN0dkH/AXEgAyAEEC0gACACQQEgBBAiIAAgAkEBIAQQIZKSIQQCQAJAAkACQCAFKAIADgMAAQADCyAGKgIAIgMgAyAEIAMgBF0bIAQgBFwbIQQMAQsgBCAEXA0BIAVBAjYCAAsgBiAEOAIACwuMAQIBfwF9IAAoAuQDRQRAQwAAAAAPCyAAQfwAaiIBIAAvARwQICICIAJbBEAgASAALwEcECAPCwJAIAAoAvQDLQAIQQFxDQAgASAALwEYECAiAiACXA0AIAEgAC8BGBAgQwAAAABdRQ0AIAEgAC8BGBAgjA8LQwAAgD9DAAAAACAAKAL0Ay0ACEEBcRsLcAIBfwF9IwBBEGsiBCQAIARBCGogACABQQJ0QdwlaigCACACEChDAADAfyEFAkACQAJAIAQtAAxBAWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwtHAQF/IAIvAAYiA0EHcQRAIAAgAUHoAGogAxAfDwsgAUHoAGohASACLwAOIgNBB3EEQCAAIAEgAxAfDwsgACABIAIvABAQHwtHAQF/IAIvAAIiA0EHcQRAIAAgAUHoAGogAxAfDwsgAUHoAGohASACLwAOIgNBB3EEQCAAIAEgAxAfDwsgACABIAIvABAQHwt7AAJAAkACQAJAIANBAWsOAgABAgsgAi8ACiIDQQdxRQ0BDAILIAIvAAgiA0EHcUUNAAwBCyACLwAEIgNBB3EEQAwBCyABQegAaiEBIAIvAAwiA0EHcQRAIAAgASADEB8PCyAAIAEgAi8AEBAfDwsgACABQegAaiADEB8LewACQAJAAkACQCADQQFrDgIAAQILIAIvAAgiA0EHcUUNAQwCCyACLwAKIgNBB3FFDQAMAQsgAi8AACIDQQdxBEAMAQsgAUHoAGohASACLwAMIgNBB3EEQCAAIAEgAxAfDwsgACABIAIvABAQHw8LIAAgAUHoAGogAxAfC84BAgN/An0jAEEQayIDJABBASEEIANBCGogAEH8AGoiBSAAIAFBAXRqQe4AaiIBLwEAEB8CQAJAIAMqAggiByACKgIAIgZcBEAgByAHWwRAIAItAAQhAgwCCyAGIAZcIQQLIAItAAQhAiAERQ0AIAMtAAwgAkH/AXFGDQELIAUgASAGIAIQOQNAIAAtAAAiAUEEcQ0BIAAgAUEEcjoAACAAKAIQIgEEQCAAIAERAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLIANBEGokAAuFAQIDfwF+AkAgAEKAgICAEFQEQCAAIQUMAQsDQCABQQFrIgEgAEIKgCIFQvYBfiAAfKdBMHI6AAAgAEL/////nwFWIQIgBSEAIAINAAsLIAWnIgIEQANAIAFBAWsiASACQQpuIgNB9gFsIAJqQTByOgAAIAJBCUshBCADIQIgBA0ACwsgAQs3AQJ/QQQQHiICIAE2AgBBBBAeIgMgATYCAEHBOyAAQeI7QfooQb8BIAJB4jtB/ihBwAEgAxAHCw8AIAAgASACQQFBAhCLAQteAQF/IABBADYCDCAAIAM2AhACQCABBEAgAUGAgICABE8NASABQQJ0EB4hBAsgACAENgIAIAAgBCACQQJ0aiICNgIIIAAgBCABQQJ0ajYCDCAAIAI2AgQgAA8LEFgAC3kCAX8BfSMAQRBrIgMkACADQQhqIAAgAUECdEHcJWooAgAgAhBTQwAAwH8hBAJAAkACQCADLQAMQQFrDgIAAQILIAMqAgghBAwBCyADKgIIQwAAAACUQwrXIzyUIQQLIANBEGokACAEQwAAAACXQwAAAAAgBCAEWxsLnAoBC38jAEEQayIIJAAgASABLwAAQXhxIANyIgM7AAACQAJAAkACQAJAAkACQAJAAkACQCADQQhxBEAgA0H//wNxIgZBBHYhBCAGQT9NBH8gACAEQQJ0akEEagUgBEEEayIEIAAoAhgiACgCBCAAKAIAIgBrQQJ1Tw0CIAAgBEECdGoLIAI4AgAMCgsCfyACi0MAAABPXQRAIAKoDAELQYCAgIB4CyIEQf8PakH+H0sgBLIgAlxyRQRAIANBD3FBACAEa0GAEHIgBCACQwAAAABdG0EEdHIhAwwKCyAAIAAvAQAiC0EBajsBACALQYAgTw0DIAtBA00EQCAAIAtBAnRqIAI4AgQMCQsgACgCGCIDRQRAQRgQHiIDQgA3AgAgA0IANwIQIANCADcCCCAAIAM2AhgLAkAgAygCBCIEIAMoAghHBEAgBCACOAIAIAMgBEEEajYCBAwBCyAEIAMoAgAiB2siBEECdSIJQQFqIgZBgICAgARPDQECf0H/////AyAEQQF1IgUgBiAFIAZLGyAEQfz///8HTxsiBkUEQEEAIQUgCQwBCyAGQYCAgIAETw0GIAZBAnQQHiEFIAMoAgQgAygCACIHayIEQQJ1CyEKIAUgCUECdGoiCSACOAIAIAkgCkECdGsgByAEEDMhByADIAUgBkECdGo2AgggAyAJQQRqNgIEIAMoAgAhBCADIAc2AgAgBEUNACAEECMLIAAoAhgiBigCECIDIAYoAhQiAEEFdEcNByADQQFqQQBIDQAgA0H+////A0sNASADIABBBnQiACADQWBxQSBqIgQgACAESxsiAE8NByAAQQBODQILEAIAC0H/////ByEAIANB/////wdPDQULIAhBADYCCCAIQgA3AwAgCCAAEJ8BIAYoAgwhBCAIIAgoAgQiByAGKAIQIgBBH3FqIABBYHFqIgM2AgQgB0UEQCADQQFrIQUMAwsgA0EBayIFIAdBAWtzQR9LDQIgCCgCACEKDAMLQZUlQeEXQSJB3BcQCwALEFgACyAIKAIAIgogBUEFdkEAIANBIU8bQQJ0akEANgIACyAKIAdBA3ZB/P///wFxaiEDAkAgB0EfcSIHRQRAIABBAEwNASAAQSBtIQUgAEEfakE/TwRAIAMgBCAFQQJ0EDMaCyAAIAVBBXRrIgBBAEwNASADIAVBAnQiBWoiAyADKAIAQX9BICAAa3YiAEF/c3EgBCAFaigCACAAcXI2AgAMAQsgAEEATA0AQX8gB3QhDEEgIAdrIQkgAEEgTgRAIAxBf3MhDSADKAIAIQUDQCADIAUgDXEgBCgCACIFIAd0cjYCACADIAMoAgQgDHEgBSAJdnIiBTYCBCAEQQRqIQQgA0EEaiEDIABBP0shDiAAQSBrIQAgDg0ACyAAQQBMDQELIAMgAygCAEF/IAkgCSAAIAAgCUobIgVrdiAMcUF/c3EgBCgCAEF/QSAgAGt2cSIEIAd0cjYCACAAIAVrIgBBAEwNACADIAUgB2pBA3ZB/P///wFxaiIDIAMoAgBBf0EgIABrdkF/c3EgBCAFdnI2AgALIAYoAgwhACAGIAo2AgwgBiAIKAIEIgM2AhAgBiAIKAIINgIUIABFDQAgABAjIAYoAhAhAwsgBiADQQFqNgIQIAYoAgwgA0EDdkH8////AXFqIgAgACgCAEF+IAN3cTYCACABLwAAIQMLIANBB3EgC0EEdHJBCHIhAwsgASADOwAAIAhBEGokAAuPAQIBfwF9IwBBEGsiAyQAIANBCGogAEHoAGogAEHUAEHWACABQf4BcUECRhtqLwEAIgEgAC8BWCABQQdxGxAfQwAAwH8hBAJAAkACQCADLQAMQQFrDgIAAQILIAMqAgghBAwBCyADKgIIIAKUQwrXIzyUIQQLIANBEGokACAEQwAAAACXQwAAAAAgBCAEWxsL2AICBH8BfSMAQSBrIgMkAAJAIAAoAgwiAQRAIAAgACoClAMgACoCmAMgAREnACIFIAVbDQEgA0GqHjYCACAAQQVB2CUgAxAsECQACyADQRBqIAAQMgJAIAMoAhAiAiADKAIUIgFyRQ0AAkADQCABIAIoAuwDIAIoAugDIgJrQQJ1SQRAIAIgAUECdGooAgAiASgC3AMNAyABLwAVIAEtABdBEHRyIgJBgOAAcUGAwABHBEAgAkEIdkEPcSICBH8gAgUgAC0AFUEEdgtBBUYEQCAALQAUQQhxDQQLIAEtAABBAnENAyAEIAEgBBshBAsgA0EQahAuIAMoAhQiASADKAIQIgJyDQEMAwsLEAIACyABIQQLIAMoAhgiAQRAA0AgASgCACECIAEQIyACIgENAAsLIARFBEAgACoCmAMhBQwBCyAEEE4gBCoCoAOSIQULIANBIGokACAFC6EDAQh/AkAgACgC6AMiBSAAKALsAyIHRwRAA0AgACAFKAIAIgIoAuQDRwRAAkAgACgC9AMoAgAiAQRAIAIgACAGIAERBgAiAQ0BC0GIBBAeIgEgAigCEDYCECABIAIpAgg3AgggASACKQIANwIAIAFBFGogAkEUakHoABArGiABQgA3AoABIAFB/ABqIgNBADsBACABQgA3AogBIAFCADcCkAEgAyACQfwAahCgASABQZgBaiACQZgBakHQAhArGiABQQA2AvADIAFCADcC6AMgAigC7AMiAyACKALoAyIERwRAIAMgBGsiBEEASA0FIAEgBBAeIgM2AuwDIAEgAzYC6AMgASADIARqNgLwAyACKALoAyIEIAIoAuwDIghHBEADQCADIAQoAgA2AgAgA0EEaiEDIARBBGoiBCAIRw0ACwsgASADNgLsAwsgASACKQL0AzcC9AMgASACKAKEBDYChAQgASACKQL8AzcC/AMgAUEANgLkAwsgBSABNgIAIAEgADYC5AMLIAZBAWohBiAFQQRqIgUgB0cNAAsLDwsQAgALUAACQAJAAkACQAJAIAIOBAQAAQIDCyAAIAEgAUEwahBDDwsgACABIAFBMGogAxBEDwsgACABIAFBMGoQQg8LECQACyAAIAEgAUEwaiADEEULcAIBfwF9IwBBEGsiBCQAIARBCGogACABQQJ0QdwlaigCACACEDZDAADAfyEFAkACQAJAIAQtAAxBAWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwt5AgF/AX0jAEEQayIDJAAgA0EIaiAAIAFBAnRB7CVqKAIAIAIQU0MAAMB/IQQCQAJAAkAgAy0ADEEBaw4CAAECCyADKgIIIQQMAQsgAyoCCEMAAAAAlEMK1yM8lCEECyADQRBqJAAgBEMAAAAAl0MAAAAAIAQgBFsbC1QAAkACQAJAAkACQCACDgQEAAECAwsgACABIAFBwgBqEEMPCyAAIAEgAUHCAGogAxBEDwsgACABIAFBwgBqEEIPCxAkAAsgACABIAFBwgBqIAMQRQsvACAAIAJFQQF0IgIgASADEGAgACACIAEQS5IgACACIAEgAxB/IAAgAiABEFKSkgvOAQIDfwJ9IwBBEGsiAyQAQQEhBCADQQhqIABB/ABqIgUgACABQQF0akH2AGoiAS8BABAfAkACQCADKgIIIgcgAioCACIGXARAIAcgB1sEQCACLQAEIQIMAgsgBiAGXCEECyACLQAEIQIgBEUNACADLQAMIAJB/wFxRg0BCyAFIAEgBiACEDkDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCyADQRBqJAALzgECA38CfSMAQRBrIgMkAEEBIQQgA0EIaiAAQfwAaiIFIAAgAUEBdGpB8gBqIgEvAQAQHwJAAkAgAyoCCCIHIAIqAgAiBlwEQCAHIAdbBEAgAi0ABCECDAILIAYgBlwhBAsgAi0ABCECIARFDQAgAy0ADCACQf8BcUYNAQsgBSABIAYgAhA5A0AgAC0AACIBQQRxDQEgACABQQRyOgAAIAAoAhAiAQRAIAAgAREAAAsgAEGAgID+BzYCnAEgACgC5AMiAA0ACwsgA0EQaiQACwoAIABBMGtBCkkLBQAQAgALBAAgAAsUACAABEAgACAAKAIAKAIEEQAACwsrAQF/IAAoAgwiAQRAIAEQIwsgACgCACIBBEAgACABNgIEIAEQIwsgABAjC4EEAQN/IwBBEGsiAyQAIABCADcCBCAAQcEgOwAVIABCADcCDCAAQoCAgICAgIACNwIYIAAgAC0AF0HgAXE6ABcgACAALQAAQeABcUEFcjoAACAAIAAtABRBgAFxOgAUIABBIGpBAEHOABAqGiAAQgA3AXIgAEGEgBA2AW4gAEEANgF6IABCADcCgAEgAEIANwKIASAAQgA3ApABIABCADcCoAEgAEKAgICAgICA4P8ANwKYASAAQQA6AKgBIABBrAFqQQBBxAEQKhogAEHwAmohBCAAQbABaiECA0AgAkKAgID8i4CAwL9/NwIQIAJCgYCAgBA3AgggAkKAgID8i4CAwL9/NwIAIAJBGGoiAiAERw0ACyAAQoCAgPyLgIDAv383AvACIABCgICA/IuAgMC/fzcCgAMgAEKBgICAEDcC+AIgAEKAgID+h4CA4P8ANwKUAyAAQoCAgP6HgIDg/wA3AowDIABBiANqIgIgAi0AAEH4AXE6AAAgAEGcA2pBAEHYABAqGiAAQQA6AIQEIABBgICA/gc2AoAEIABBADoA/AMgAEGAgID+BzYC+AMgACABNgL0AyABBEAgAS0ACEEBcQRAIAAgAC0AFEHzAXFBCHI6ABQgACAALwAVQfD/A3FBBHI7ABULIANBEGokACAADwsgA0GiGjYCACADEHIQJAALMwAgACABQQJ0QfwlaigCAEECdGoqApQDIABBFGoiACABQQEgAhAiIAAgAUEBIAIQIZKSC44DAQp/IwBB0AJrIgEkACAAKALoAyIDIAAoAuwDIgVHBEAgAUGMAmohBiABQeABaiEHIAFBIGohCCABQRxqIQkgAUEQaiEEA0AgAygCACICLQAXQRB0QYCAMHFBgIAgRgRAIAFBCGpBAEHEAhAqGiABQYCAgP4HNgIMIARBADoACCAEQgA3AgAgCUEAQcQBECoaIAghAANAIABCgICA/IuAgMC/fzcCECAAQoGAgIAQNwIIIABCgICA/IuAgMC/fzcCACAAQRhqIgAgB0cNAAsgAUKAgID8i4CAwL9/NwPwASABQoGAgIAQNwPoASABQoCAgPyLgIDAv383A+ABIAFCgICA/oeAgOD/ADcChAIgAUKAgID+h4CA4P8ANwL8ASABIAEtAPgBQfgBcToA+AEgBkEAQcAAECoaIAJBmAFqIAFBCGpBxAIQKxogAkIANwKMAyACIAItAAAiAEEBciIKQfsBcSAKIABBBHEbOgAAIAIQTyACEF4LIANBBGoiAyAFRw0ACwsgAUHQAmokAAtMAQF/QQEhAQJAIAAtAB5BB3ENACAALQAiQQdxDQAgAC0ALkEHcQ0AIAAtACpBB3ENACAALQAmQQdxDQAgAC0AKEEHcUEARyEBCyABC3YCAX8BfSMAQRBrIgQkACAEQQhqIAAgAUECdEHcJWooAgAgAhBQQwAAwH8hBQJAAkACQCAELQAMQQFrDgIAAQILIAQqAgghBQwBCyAEKgIIIAOUQwrXIzyUIQULIARBEGokACAFQwAAAACXQwAAAAAgBSAFWxsLogQCBn8CfgJ/QQghBAJAAkAgAEFHSw0AA0BBCCAEIARBCE0bIQRB6DopAwAiBwJ/QQggAEEDakF8cSAAQQhNGyIAQf8ATQRAIABBA3ZBAWsMAQsgAEEdIABnIgFrdkEEcyABQQJ0a0HuAGogAEH/H00NABpBPyAAQR4gAWt2QQJzIAFBAXRrQccAaiIBIAFBP08bCyIDrYgiCFBFBEADQCAIIAh6IgiIIQcCfiADIAinaiIDQQR0IgJB6DJqKAIAIgEgAkHgMmoiBkcEQCABIAQgABBjIgUNBSABKAIEIgUgASgCCDYCCCABKAIIIAU2AgQgASAGNgIIIAEgAkHkMmoiAigCADYCBCACIAE2AgAgASgCBCABNgIIIANBAWohAyAHQgGIDAELQeg6Qeg6KQMAQn4gA62JgzcDACAHQgGFCyIIQgBSDQALQeg6KQMAIQcLAkAgB1BFBEBBPyAHeadrIgZBBHQiAkHoMmooAgAhAQJAIAdCgICAgARUDQBB4wAhAyABIAJB4DJqIgJGDQADQCADRQ0BIAEgBCAAEGMiBQ0FIANBAWshAyABKAIIIgEgAkcNAAsgAiEBCyAAQTBqEGQNASABRQ0EIAEgBkEEdEHgMmoiAkYNBANAIAEgBCAAEGMiBQ0EIAEoAggiASACRw0ACwwECyAAQTBqEGRFDQMLQQAhBSAEIARBAWtxDQEgAEFHTQ0ACwsgBQwBC0EACwtwAgF/AX0jAEEQayIEJAAgBEEIaiAAIAFBAnRB7CVqKAIAIAIQKEMAAMB/IQUCQAJAAkAgBC0ADEEBaw4CAAECCyAEKgIIIQUMAQsgBCoCCCADlEMK1yM8lCEFCyAEQRBqJAAgBUMAAAAAIAUgBVsbC6ADAQN/IAEgAEEEaiIEakEBa0EAIAFrcSIFIAJqIAAgACgCACIBakEEa00EfyAAKAIEIgMgACgCCDYCCCAAKAIIIAM2AgQgBCAFRwRAIAAgAEEEaygCAEF+cWsiAyAFIARrIgQgAygCAGoiBTYCACAFQXxxIANqQQRrIAU2AgAgACAEaiIAIAEgBGsiATYCAAsCQCABIAJBGGpPBEAgACACakEIaiIDIAEgAmtBCGsiATYCACABQXxxIANqQQRrIAFBAXI2AgAgAwJ/IAMoAgBBCGsiAUH/AE0EQCABQQN2QQFrDAELIAFnIQQgAUEdIARrdkEEcyAEQQJ0a0HuAGogAUH/H00NABpBPyABQR4gBGt2QQJzIARBAXRrQccAaiIBIAFBP08bCyIBQQR0IgRB4DJqNgIEIAMgBEHoMmoiBCgCADYCCCAEIAM2AgAgAygCCCADNgIEQeg6Qeg6KQMAQgEgAa2GhDcDACAAIAJBCGoiATYCACABQXxxIABqQQRrIAE2AgAMAQsgACABakEEayABNgIACyAAQQRqBSADCwvmAwEFfwJ/QbAwKAIAIgEgAEEHakF4cSIDaiECAkAgA0EAIAEgAk8bDQAgAj8AQRB0SwRAIAIQFkUNAQtBsDAgAjYCACABDAELQfw7QTA2AgBBfwsiAkF/RwRAIAAgAmoiA0EQayIBQRA2AgwgAUEQNgIAAkACf0HgOigCACIABH8gACgCCAVBAAsgAkYEQCACIAJBBGsoAgBBfnFrIgRBBGsoAgAhBSAAIAM2AghBcCAEIAVBfnFrIgAgACgCAGpBBGstAABBAXFFDQEaIAAoAgQiAyAAKAIINgIIIAAoAgggAzYCBCAAIAEgAGsiATYCAAwCCyACQRA2AgwgAkEQNgIAIAIgAzYCCCACIAA2AgRB4DogAjYCAEEQCyACaiIAIAEgAGsiATYCAAsgAUF8cSAAakEEayABQQFyNgIAIAACfyAAKAIAQQhrIgFB/wBNBEAgAUEDdkEBawwBCyABQR0gAWciA2t2QQRzIANBAnRrQe4AaiABQf8fTQ0AGkE/IAFBHiADa3ZBAnMgA0EBdGtBxwBqIgEgAUE/TxsLIgFBBHQiA0HgMmo2AgQgACADQegyaiIDKAIANgIIIAMgADYCACAAKAIIIAA2AgRB6DpB6DopAwBCASABrYaENwMACyACQX9HC80BAgN/An0jAEEQayIDJABBASEEIANBCGogAEH8AGoiBSAAIAFBAXRqQSBqIgEvAQAQHwJAAkAgAyoCCCIHIAIqAgAiBlwEQCAHIAdbBEAgAi0ABCECDAILIAYgBlwhBAsgAi0ABCECIARFDQAgAy0ADCACQf8BcUYNAQsgBSABIAYgAhA5A0AgAC0AACIBQQRxDQEgACABQQRyOgAAIAAoAhAiAQRAIAAgAREAAAsgAEGAgID+BzYCnAEgACgC5AMiAA0ACwsgA0EQaiQAC0ABAX8CQEGsOy0AAEEBcQRAQag7KAIAIQIMAQtBAUGAJxAMIQJBrDtBAToAAEGoOyACNgIACyACIAAgAUEAEBMLzQECA38CfSMAQRBrIgMkAEEBIQQgA0EIaiAAQfwAaiIFIAAgAUEBdGpBMmoiAS8BABAfAkACQCADKgIIIgcgAioCACIGXARAIAcgB1sEQCACLQAEIQIMAgsgBiAGXCEECyACLQAEIQIgBEUNACADLQAMIAJB/wFxRg0BCyAFIAEgBiACEDkDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCyADQRBqJAALDwAgASAAKAIAaiACOQMACw0AIAEgACgCAGorAwALCwAgAARAIAAQIwsLxwECBH8CfSMAQRBrIgIkACACQQhqIABB/ABqIgQgAEEeaiIFLwEAEB9BASEDAkACQCACKgIIIgcgASoCACIGXARAIAcgB1sEQCABLQAEIQEMAgsgBiAGXCEDCyABLQAEIQEgA0UNACACLQAMIAFB/wFxRg0BCyAEIAUgBiABEDkDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCyACQRBqJAALlgMCA34CfyAAvSICQjSIp0H/D3EiBEH/D0YEQCAARAAAAAAAAPA/oiIAIACjDwsgAkIBhiIBQoCAgICAgIDw/wBYBEAgAEQAAAAAAAAAAKIgACABQoCAgICAgIDw/wBRGw8LAn4gBEUEQEEAIQQgAkIMhiIBQgBZBEADQCAEQQFrIQQgAUIBhiIBQgBZDQALCyACQQEgBGuthgwBCyACQv////////8Hg0KAgICAgICACIQLIQEgBEH/B0oEQANAAkAgAUKAgICAgICACH0iA0IAUw0AIAMiAUIAUg0AIABEAAAAAAAAAACiDwsgAUIBhiEBIARBAWsiBEH/B0oNAAtB/wchBAsCQCABQoCAgICAgIAIfSIDQgBTDQAgAyIBQgBSDQAgAEQAAAAAAAAAAKIPCyABQv////////8HWARAA0AgBEEBayEEIAFCgICAgICAgARUIQUgAUIBhiEBIAUNAAsLIAJCgICAgICAgICAf4MgAUKAgICAgICACH0gBK1CNIaEIAFBASAEa62IIARBAEobhL8LiwEBA38DQCAAQQR0IgFB5DJqIAFB4DJqIgI2AgAgAUHoMmogAjYCACAAQQFqIgBBwABHDQALQTAQZBpBmDtBBjYCAEGcO0EANgIAEJwBQZw7Qcg7KAIANgIAQcg7QZg7NgIAQcw7QcMBNgIAQdA7QQA2AgAQjwFB0DtByDsoAgA2AgBByDtBzDs2AgALjwEBAn8jAEEQayIEJAACfUMAAAAAIAAvABVBgOAAcUUNABogBEEIaiAAQRRqIgBBASACQQJGQQF0IAFB/gFxQQJHGyIFIAIQNgJAIAQtAAxFDQAgBEEIaiAAIAUgAhA2IAQtAAxBA0YNACAAIAEgAiADEIEBDAELIAAgASACIAMQgAGMCyEDIARBEGokACADC4QBAQJ/AkACQCAAKALoAyICIAAoAuwDIgNGDQADQCACKAIAIAFGDQEgAkEEaiICIANHDQALDAELIAIgA0YNACABLQAXQRB0QYCAMHFBgIAgRgRAIAAgACgC4ANBAWs2AuADCyACIAJBBGoiASADIAFrEDMaIAAgA0EEazYC7ANBAQ8LQQALCwBByDEgACABEEkLPAAgAEUEQCACQQVHQQAgAhtFBEBBuDAgAyAEEEkaDwsgAyAEEHAaDwsgACABIAIgAyAEIAAoAgQRDQAaCyYBAX8jAEEQayIBJAAgASAANgIMQbgwQdglIAAQSRogAUEQaiQAC4cDAwN/BXwCfSAAKgKgA7siBiACoCECIAAqApwDuyIHIAGgIQggACgC9AMqAhgiC0MAAAAAXARAIAAqApADuyEJIAAqAowDIQwgACAHIAu7IgFBACAALQAAQRBxIgNBBHYiBBA0OAKcAyAAIAYgAUEAIAQQNDgCoAMgASAMuyIHohBsIgYgBmIiBEUgBplELUMc6+I2Gj9jcUUEQCAEIAZEAAAAAAAA8L+gmUQtQxzr4jYaP2NFciEFCyACIAmgIQogCCAHoCEHAn8gASAJohBsIgYgBmIiBEUEQEEAIAaZRC1DHOviNho/Yw0BGgsgBCAGRAAAAAAAAPC/oJlELUMc6+I2Gj9jRXILIQQgACAHIAEgA0EARyIDIAVxIAMgBUEBc3EQNCAIIAFBACADEDSTOAKMAyAAIAogASADIARxIAMgBEEBc3EQNCACIAFBACADEDSTOAKQAwsgACgC6AMiAyAAKALsAyIARwRAA0AgAygCACAIIAIQcyADQQRqIgMgAEcNAAsLC1UBAX0gAEEUaiIAIAEgAkECSSICIAQgBRA1IQYgACABIAIgBCAFEC0iBUMAAAAAYCADIAVecQR9IAUFIAZDAAAAAGBFBEAgAw8LIAYgAyADIAZdGwsLeAEBfwJAIAAoAgAiAgRAA0AgAUUNAiACIAEoAgQ2AgQgAiABKAIINgIIIAEoAgAhASAAKAIAIQAgAigCACICDQALCyAAIAEQPA8LAkAgAEUNACAAKAIAIgFFDQAgAEEANgIAA0AgASgCACEAIAEQIyAAIgENAAsLC5kCAgZ/AX0gAEEUaiEHQQMhBCAALQAUQQJ2QQNxIQUCQAJ/AkAgAUEBIAAoAuQDGyIIQQJGBEACQCAFQQJrDgIEAAILQQIhBAwDC0ECIQRBACAFQQFLDQEaCyAECyEGIAUhBAsgACAEIAggAyACIARBAkkiBRsQbiEKIAAgBiAIIAIgAyAFGxBuIQMgAEGcA2oiAEEBIAFBAkZBAXQiCCAFG0ECdGogCiAHIAQgASACECKSOAIAIABBAyABQQJHQQF0IgkgBRtBAnRqIAogByAEIAEgAhAhkjgCACAAIAhBASAGQQF2IgQbQQJ0aiADIAcgBiABIAIQIpI4AgAgACAJQQMgBBtBAnRqIAMgByAGIAEgAhAhkjgCAAvUAgEDfyMAQdACayIBJAAgAUEIakEAQcQCECoaIAFBADoAGCABQgA3AxAgAUGAgID+BzYCDCABQRxqQQBBxAEQKhogAUHgAWohAyABQSBqIQIDQCACQoCAgPyLgIDAv383AhAgAkKBgICAEDcCCCACQoCAgPyLgIDAv383AgAgAkEYaiICIANHDQALIAFCgICA/IuAgMC/fzcD8AEgAUKBgICAEDcD6AEgAUKAgID8i4CAwL9/NwPgASABQoCAgP6HgIDg/wA3AoQCIAFCgICA/oeAgOD/ADcC/AEgASABLQD4AUH4AXE6APgBIAFBjAJqQQBBwAAQKhogAEGYAWogAUEIakHEAhArGiAAQgA3AowDIAAgAC0AAEEBcjoAACAAEE8gACgC6AMiAiAAKALsAyIARwRAA0AgAigCABB3IAJBBGoiAiAARw0ACwsgAUHQAmokAAuuAgIKfwJ9IwBBIGsiASQAIAFBgAI7AB4gAEHuAGohByAAQfgDaiEFIABB8gBqIQggAEH2AGohCSAAQfwAaiEDQQAhAANAIAFBEGogAyAJIAFBHmogBGotAAAiAkEBdCIEaiIGLwEAEB8CQAJAIAEtABRFDQAgAUEIaiADIAYvAQAQHyABIAMgBCAIai8BABAfIAEtAAwgAS0ABEcNAAJAIAEqAggiDCAMXCIKIAEqAgAiCyALXHJFBEAgDCALk4tDF7fROF0NAQwCCyAKRSALIAtbcg0BCyABQRBqIAMgBi8BABAfDAELIAFBEGogAyAEIAdqLwEAEB8LIAUgAkEDdGoiAiABLQAUOgAEIAIgASgCEDYCAEEBIQQgACECQQEhACACRQ0ACyABQSBqJAALMgACf0EAIAAvABVBgOAAcUGAwABGDQAaQQEgABA7QwAAAABcDQAaIAAQQEMAAAAAXAsLewEBfSADIASTIgMgA1sEfUMAAAAAIABBFGoiACABIAIgBSAGEDUiByAEkyAHIAdcGyIHQ///f38gACABIAIgBSAGEC0iBSAEkyAFIAVcGyIEIAMgAyAEXhsiAyADIAddGyAHIAMgAyADXBsgAyADWyAHIAdbcRsFIAMLC98FAwR/BX0BfCAJQwAAAABdIAhDAAAAAF1yBH8gDQUgBSESIAEhEyADIRQgByERIAwqAhgiFUMAAAAAXARAIAG7IBW7IhZBAEEAEDQhEyADuyAWQQBBABA0IRQgBbsgFkEAQQAQNCESIAe7IBZBAEEAEDQhEQsCf0EAIAAgBEcNABogEiATk4tDF7fROF0gEyATXCINIBIgElxyRQ0AGkEAIBIgElsNABogDQshDAJAIAIgBkcNACAUIBRcIg0gESARXHJFBEAgESAUk4tDF7fROF0hDwwBCyARIBFbDQAgDSEPC0EBIQ5BASENAkAgDA0AIAEgCpMhAQJAIABFBEAgASABXCIAIAggCFxyRQRAQQAhDCABIAiTi0MXt9E4XUUNAgwDC0EAIQwgCCAIWw0BIAANAgwBCyAAQQJGIQwgAEECRw0AIARBAUcNACABIAhgDQECQCAIIAhcIgAgASABXHJFBEAgASAIk4tDF7fROF1FDQEMAwtBACENIAEgAVsNAkEBIQ0gAA0CC0EAIQ0MAQtBACENIAggCFwiACABIAVdRXINACAMRSABIAFcIhAgBSAFXHIgBEECR3JyDQBBASENIAEgCGANAEEAIQ0gACAQcg0AIAEgCJOLQxe30ThdIQ0LAkAgDw0AIAMgC5MhAQJAAkAgAkUEQCABIAFcIgIgCSAJXHJFBEBBACEAIAEgCZOLQxe30ThdRQ0CDAQLQQAhACAJIAlbDQEgAg0DDAELIAJBAkYhACACQQJHIAZBAUdyDQAgASAJYARADAMLIAkgCVwiACABIAFcckUEQCABIAmTi0MXt9E4XUUNAgwDC0EAIQ4gASABWw0CQQEhDiAADQIMAQsgCSAJXCICIAEgB11Fcg0AIABFIAEgAVwiBCAHIAdcciAGQQJHcnINACABIAlgDQFBACEOIAIgBHINASABIAmTi0MXt9E4XSEODAELQQAhDgsgDSAOcQsL4wEBA38jAEEQayIBJAACQAJAIAAtABRBCHFFDQBBASEDIAAvABVB8AFxQdAARg0AIAEgABAyIAEoAgQhAAJAIAEoAgAiAkUEQEEAIQMgAEUNAQsDQCACKALsAyACKALoAyICa0ECdSAATQ0DIAIgAEECdGooAgAiAC8AFSAALQAXQRB0ciIAQYDgAHFBgMAARyAAQYAecUGACkZxIgMNASABEC4gASgCBCIAIAEoAgAiAnINAAsLIAEoAggiAEUNAANAIAAoAgAhAiAAECMgAiIADQALCyABQRBqJAAgAw8LEAIAC7IBAQR/AkACQCAAKAIEIgMgACgCACIEKALsAyAEKALoAyIBa0ECdUkEQCABIANBAnRqIQIDQCACKAIAIgEtABdBEHRBgIAwcUGAgCBHDQMgASgC7AMgASgC6ANGDQJBDBAeIgIgBDYCBCACIAM2AgggAiAAKAIINgIAQQAhAyAAQQA2AgQgACABNgIAIAAgAjYCCCABIQQgASgC6AMiAiABKALsA0cNAAsLEAIACyAAEC4LC4wQAgx/B30jAEEgayINJAAgDUEIaiABEDIgDSgCCCIOIA0oAgwiDHIEQCADQQEgAxshFSAAQRRqIRQgBUEBaiEWA0ACQAJAAn8CQAJAAkACQAJAIAwgDigC7AMgDigC6AMiDmtBAnVJBEAgDiAMQQJ0aigCACILLwAVIAstABdBEHRyIgxBgIAwcUGAgBBGDQgCQAJAIAxBDHZBA3EOAwEKAAoLIAkhFyAKIRogASgC9AMtABRBBHFFBEAgACoClAMgFEECQQEQMCAUQQJBARAvkpMhFyAAKgKYAyAUQQBBARAwIBRBAEEBEC+SkyEaCyALQRRqIQ8gAS0AFEECdkEDcSEQAkACfwJAIANBAkciE0UEQEEAIQ5BAyEMAkAgEEECaw4CBAACC0ECIQwMAwtBAiEMQQAgEEEBSw0BGgsgDAshDiAQIQwLIA9BAkEBIBcQIiAPQQJBASAXECGSIR0gD0EAQQEgFxAiIRwgD0EAQQEgFxAhIRsgCyoC+AMhGAJAAkACQAJAIAstAPwDQQFrDgIBAAILIBggF5RDCtcjPJQhGAsgGEMAAAAAYEUNACAdIAsgA0EAIBcgFxAxkiEYDAELIA1BGGogDyALQTJqIhAgAxBFQwAAwH8hGCANLQAcRQ0AIA1BGGogDyAQIAMQRCANLQAcRQ0AIA1BGGogDyAQIAMQRSANLQAcQQNGDQAgDUEYaiAPIBAgAxBEIA0tABxBA0YNACALQQIgAyAAKgKUAyAUQQIgAxBLIBRBAiADEFKSkyAPQQIgAyAXEFEgD0ECIAMgFxCDAZKTIBcgFxAlIRgLIBwgG5IhHCALKgKABCEZAkACQAJAIAstAIQEQQFrDgIBAAILIBkgGpRDCtcjPJQhGQsgGUMAAAAAYEUNACAcIAsgA0EBIBogFxAxkiEZDAMLIA1BGGogDyALQTJqIhAQQwJAIA0tABxFDQAgDUEYaiAPIBAQQiANLQAcRQ0AIA1BGGogDyAQEEMgDS0AHEEDRg0AIA1BGGogDyAQEEIgDS0AHEEDRg0AIAtBACADIAAqApgDIBRBACADEEsgFEEAIAMQUpKTIA9BACADIBoQUSAPQQAgAyAaEIMBkpMgGiAXECUhGQwDC0MAAMB/IRkgGCAYXA0GIAtB/ABqIhAgC0H6AGoiEi8BABAgIhsgG1sNAwwFCyALLQAAQQhxDQggCxBPIAAgCyACIAstABRBA3EiDCAVIAwbIAQgFiAGIAsqApwDIAeSIAsqAqADIAiSIAkgChB+IBFyIQxBACERIAxBAXFFDQhBASERIAsgCy0AAEEBcjoAAAwICxACAAsgGCAYXCAZIBlcRg0BIAtB/ABqIhAgC0H6AGoiEi8BABAgIhsgG1wNASAYIBhcBEAgGSAckyAQIAsvAXoQIJQgHZIhGAwCCyAZIBlbDQELIBwgGCAdkyAQIBIvAQAQIJWSIRkLIBggGFwNASAZIBlbDQMLQQAMAQtBAQshEiALIBcgGCACQQFHIAxBAklxIBdDAAAAAF5xIBJxIhAbIBkgA0ECIBIgEBsgGSAZXCAXIBpBAEEGIAQgBSAGED0aIAsqApQDIA9BAkEBIBcQIiAPQQJBASAXECGSkiEYIAsqApgDIA9BAEEBIBcQIiAPQQBBASAXECGSkiEZC0EBIRAgCyAYIBkgA0EAQQAgFyAaQQFBASAEIAUgBhA9GiAAIAEgCyADIAxBASAXIBoQggEgACABIAsgAyAOQQAgFyAaEIIBIBFBAXFFBEAgCy0AAEEBcSEQCyABLQAUIhJBAnZBA3EhDAJAAn8CQAJAAkACQAJAAkACQAJAAkACfwJAIBNFBEBBACERQQMhDiAMQQJrDgIDDQELQQIhDkEAIAxBAUsNARoLIA4LIREgEkEEcUUNBCASQQhxRQ0BIAwhDgsgASEMIA8QXw0BDAILAkAgCy0ANEEHcQ0AIAstADhBB3ENACALLQBCQQdxDQAgDCEOIAEhDCALQUBrLwEAQQdxRQ0CDAELIAwhDgsgACEMCwJ/AkACQAJAIA5BAWsOAwABAgULIAtBmANqIQ4gC0GoA2ohE0EBIRIgDEGYA2oMAgsgC0GUA2ohDiALQZwDaiETQQIhEiAMQZQDagwBCyALQZQDaiEOIAtBpANqIRNBACESIAxBlANqCyEMIAsgEkECdGogDCoCACAOKgIAkyATKgIAkzgCnAMLIBFBAXFFDQUCQAJAIBFBAnEEQCABIQwgDxBfDQEMAgsgCy0ANEEHcQ0AIAstADhBB3ENACALLQBCQQdxDQAgASEMIAtBQGsvAQBBB3FFDQELIAAhDAsgEUEBaw4DAQIDAAsQJAALIAtBmANqIREgC0GoA2ohDkEBIRMgDEGYA2oMAgsgC0GUA2ohESALQZwDaiEOQQIhEyAMQZQDagwBCyALQZQDaiERIAtBpANqIQ5BACETIAxBlANqCyEMIAsgE0ECdGogDCoCACARKgIAkyAOKgIAkzgCnAMLIAsqAqADIRsgCyoCnAMgB0MAAAAAIA8QXxuTIRcCfQJAIAstADRBB3ENACALLQA4QQdxDQAgCy0AQkEHcQ0AIAtBQGsvAQBBB3ENAEMAAAAADAELIAgLIRogCyAXOAKcAyALIBsgGpM4AqADIBAhEQsgDUEIahAuIA0oAgwiDCANKAIIIg5yDQALCyANKAIQIgwEQANAIAwoAgAhACAMECMgACIMDQALCyANQSBqJAAgEUEBcQt2AgF/AX0jAEEQayIEJAAgBEEIaiAAIAFBAnRB7CVqKAIAIAIQUEMAAMB/IQUCQAJAAkAgBC0ADEEBaw4CAAECCyAEKgIIIQUMAQsgBCoCCCADlEMK1yM8lCEFCyAEQRBqJAAgBUMAAAAAl0MAAAAAIAUgBVsbC3gCAX8BfSMAQRBrIgQkACAEQQhqIABBAyACQQJHQQF0IAFB/gFxQQJHGyACEDZDAADAfyEFAkACQAJAIAQtAAxBAWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwt4AgF/AX0jAEEQayIEJAAgBEEIaiAAQQEgAkECRkEBdCABQf4BcUECRxsgAhA2QwAAwH8hBQJAAkACQCAELQAMQQFrDgIAAQILIAQqAgghBQwBCyAEKgIIIAOUQwrXIzyUIQULIARBEGokACAFQwAAAAAgBSAFWxsLoA0BBH8jAEEQayIJJAAgCUEIaiACQRRqIgggA0ECRkEBdEEBIARB/gFxQQJGIgobIgsgAxA2IAYgByAKGyEHAkACQAJAAkACQAJAIAktAAxFDQAgCUEIaiAIIAsgAxA2IAktAAxBA0YNACAIIAQgAyAHEIEBIABBFGogBCADEDCSIAggBCADIAcQIpIhBkEBIQMCQAJ/AkACQAJAAkAgBA4EAgMBAAcLQQIhAwwBC0EAIQMLIAMgC0YNAgJAAkAgBA4EAgIAAQYLIABBlANqIQNBAAwCCyAAQZQDaiEDQQAMAQsgAEGYA2ohA0EBCyEAIAMqAgAgAiAAQQJ0aioClAOTIAaTIQYLIAIgBEECdEHcJWooAgBBAnRqIAY4ApwDDAULIAlBCGogCCADQQJHQQF0QQMgChsiCiADEDYCQCAJLQAMRQ0AIAlBCGogCCAKIAMQNiAJLQAMQQNGDQACfwJAAkACQCAEDgQCAgABBQsgAEGUA2ohBUEADAILIABBlANqIQVBAAwBCyAAQZgDaiEFQQELIQEgBSoCACACQZQDaiIFIAFBAnRqKgIAkyAAQRRqIAQgAxAvkyAIIAQgAyAHECGTIAggBCADIAcQgAGTIQZBASEDAkACfwJAAkACQAJAIAQOBAIDAQAHC0ECIQMMAQtBACEDCyADIAtGDQICQAJAIAQOBAICAAEGCyAAQZQDaiEDQQAMAgsgAEGUA2ohA0EADAELIABBmANqIQNBAQshACADKgIAIAUgAEECdGoqAgCTIAaTIQYLIAIgBEECdEHcJWooAgBBAnRqIAY4ApwDDAULAkACQAJAIAUEQCABLQAUQQR2QQdxIgBBBUsNCEEBIAB0IgBBMnENASAAQQlxBEAgBEECdEHcJWooAgAhACAIIAQgAyAGEEEgASAAQQJ0IgBqIgEqArwDkiEGIAAgAmogAigC9AMtABRBAnEEfSAGBSAGIAEqAswDkgs4ApwDDAkLIAEgBEECdEHsJWooAgBBAnRqIgAqArwDIAggBCADIAYQYpIhBiACKAL0Ay0AFEECcUUEQCAGIAAqAswDkiEGCwJAAkACQAJAIAQOBAEBAgAICyABKgKUAyACKgKUA5MhB0ECIQMMAgsgASoCmAMgAioCmAOTIQdBASEDAkAgBA4CAgAHC0EDIQMMAQsgASoClAMgAioClAOTIQdBACEDCyACIANBAnRqIAcgBpM4ApwDDAgLIAIvABZBD3EiBUUEQCABLQAVQQR2IQULIAVBBUYEQCABLQAUQQhxRQ0CCyABLwAVQYCAA3FBgIACRgRAIAVBAmsOAgEHAwsgBUEISw0HQQEgBXRB8wNxDQYgBUECRw0CC0EAIQACfQJ/AkACQAJAAkACfwJAAkACQCAEDgQCAgABBAsgASoClAMhB0ECIQAgAUG8A2oMAgsgASoClAMhByABQcQDagwBCyABKgKYAyEHAkACQCAEDgIAAQMLQQMhACABQcADagwBC0EBIQAgAUHIA2oLIQUgByAFKgIAkyABQbwDaiIIIABBAnRqKgIAkyIHIAIoAvQDLQAUQQJxDQUaAkAgBA4EAAIDBAELQQMhACABQdADagwECxAkAAtBASEAIAFB2ANqDAILQQIhACABQcwDagwBC0EAIQAgAUHUA2oLIQUgByAFKgIAkyABIABBAnRqKgLMA5MLIAIgBEECdCIFQfwlaigCAEECdGoqApQDIAJBFGoiACAEQQEgBhAiIAAgBEEBIAYQIZKSk0MAAAA/lCAIIAVB3CVqKAIAIgVBAnRqKgIAkiAAIAQgAyAGEEGSIQYgAiAFQQJ0aiACKAL0Ay0AFEECcQR9IAYFIAYgASAFQQJ0aioCzAOSCzgCnAMMBgsgAS8AFUGAgANxQYCAAkcNBAsgASAEQQJ0QewlaigCAEECdGoiACoCvAMgCCAEIAMgBhBikiEGIAIoAvQDLQAUQQJxRQRAIAYgACoCzAOSIQYLAkACQCAEDgQBAQMAAgsgASoClAMgAioClAOTIQdBAiEDDAMLIAEqApgDIAIqApgDkyEHQQEhAwJAIAQOAgMAAQtBAyEDDAILECQACyABKgKUAyACKgKUA5MhB0EAIQMLIAIgA0ECdGogByAGkzgCnAMMAQsgBEECdEHcJWooAgAhACAIIAQgAyAGEEEgASAAQQJ0IgBqIgEqArwDkiEGIAAgAmogAigC9AMtABRBAnEEfSAGBSAGIAEqAswDkgs4ApwDCyAJQRBqJAALcAIBfwF9IwBBEGsiBCQAIARBCGogACABQQJ0QewlaigCACACEDZDAADAfyEFAkACQAJAIAQtAAxBAWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwscACAAIAFBCCACpyACQiCIpyADpyADQiCIpxAVCwUAEFgACzkAIABFBEBBAA8LAn8gAUGAf3FBgL8DRiABQf8ATXJFBEBB/DtBGTYCAEF/DAELIAAgAToAAEEBCwvEAgACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQQlrDhIACgsMCgsCAwQFDAsMDAoLBwgJCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCwALIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LAAsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAQALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC84BAgN/An0jAEEQayIDJABBASEEIANBCGogAEH8AGoiBSAAIAFBAXRqQegAaiIBLwEAEB8CQAJAIAMqAggiByACKgIAIgZcBEAgByAHWwRAIAItAAQhAgwCCyAGIAZcIQQLIAItAAQhAiAERQ0AIAMtAAwgAkH/AXFGDQELIAUgASAGIAIQOQNAIAAtAAAiAUEEcQ0BIAAgAUEEcjoAACAAKAIQIgEEQCAAIAERAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLIANBEGokAAtdAQR/IAAoAgAhAgNAIAIsAAAiAxBXBEBBfyEEIAAgAkEBaiICNgIAIAFBzJmz5gBNBH9BfyADQTBrIgMgAUEKbCIEaiADIARB/////wdzShsFIAQLIQEMAQsLIAELrhQCEn8BfiMAQdAAayIIJAAgCCABNgJMIAhBN2ohFyAIQThqIRQCQAJAAkACQANAIAEhDSAHIA5B/////wdzSg0BIAcgDmohDgJAAkACQCANIgctAAAiCQRAA0ACQAJAIAlB/wFxIgFFBEAgByEBDAELIAFBJUcNASAHIQkDQCAJLQABQSVHBEAgCSEBDAILIAdBAWohByAJLQACIQogCUECaiIBIQkgCkElRg0ACwsgByANayIHIA5B/////wdzIhhKDQcgAARAIAAgDSAHECYLIAcNBiAIIAE2AkwgAUEBaiEHQX8hEgJAIAEsAAEiChBXRQ0AIAEtAAJBJEcNACABQQNqIQcgCkEwayESQQEhFQsgCCAHNgJMQQAhDAJAIAcsAAAiCUEgayIBQR9LBEAgByEKDAELIAchCkEBIAF0IgFBidEEcUUNAANAIAggB0EBaiIKNgJMIAEgDHIhDCAHLAABIglBIGsiAUEgTw0BIAohB0EBIAF0IgFBidEEcQ0ACwsCQCAJQSpGBEACfwJAIAosAAEiARBXRQ0AIAotAAJBJEcNACABQQJ0IARqQcABa0EKNgIAIApBA2ohCUEBIRUgCiwAAUEDdCADakGAA2soAgAMAQsgFQ0GIApBAWohCSAARQRAIAggCTYCTEEAIRVBACETDAMLIAIgAigCACIBQQRqNgIAQQAhFSABKAIACyETIAggCTYCTCATQQBODQFBACATayETIAxBgMAAciEMDAELIAhBzABqEIkBIhNBAEgNCCAIKAJMIQkLQQAhB0F/IQsCfyAJLQAAQS5HBEAgCSEBQQAMAQsgCS0AAUEqRgRAAn8CQCAJLAACIgEQV0UNACAJLQADQSRHDQAgAUECdCAEakHAAWtBCjYCACAJQQRqIQEgCSwAAkEDdCADakGAA2soAgAMAQsgFQ0GIAlBAmohAUEAIABFDQAaIAIgAigCACIKQQRqNgIAIAooAgALIQsgCCABNgJMIAtBf3NBH3YMAQsgCCAJQQFqNgJMIAhBzABqEIkBIQsgCCgCTCEBQQELIQ8DQCAHIRFBHCEKIAEiECwAACIHQfsAa0FGSQ0JIBBBAWohASAHIBFBOmxqQf8qai0AACIHQQFrQQhJDQALIAggATYCTAJAAkAgB0EbRwRAIAdFDQsgEkEATgRAIAQgEkECdGogBzYCACAIIAMgEkEDdGopAwA3A0AMAgsgAEUNCCAIQUBrIAcgAiAGEIcBDAILIBJBAE4NCgtBACEHIABFDQcLIAxB//97cSIJIAwgDEGAwABxGyEMQQAhEkGPCSEWIBQhCgJAAkACQAJ/AkACQAJAAkACfwJAAkACQAJAAkACQAJAIBAsAAAiB0FfcSAHIAdBD3FBA0YbIAcgERsiB0HYAGsOIQQUFBQUFBQUFA4UDwYODg4UBhQUFBQCBQMUFAkUARQUBAALAkAgB0HBAGsOBw4UCxQODg4ACyAHQdMARg0JDBMLIAgpA0AhGUGPCQwFC0EAIQcCQAJAAkACQAJAAkACQCARQf8BcQ4IAAECAwQaBQYaCyAIKAJAIA42AgAMGQsgCCgCQCAONgIADBgLIAgoAkAgDqw3AwAMFwsgCCgCQCAOOwEADBYLIAgoAkAgDjoAAAwVCyAIKAJAIA42AgAMFAsgCCgCQCAOrDcDAAwTC0EIIAsgC0EITRshCyAMQQhyIQxB+AAhBwsgFCENIAgpA0AiGVBFBEAgB0EgcSEQA0AgDUEBayINIBmnQQ9xQZAvai0AACAQcjoAACAZQg9WIQkgGUIEiCEZIAkNAAsLIAxBCHFFIAgpA0BQcg0DIAdBBHZBjwlqIRZBAiESDAMLIBQhByAIKQNAIhlQRQRAA0AgB0EBayIHIBmnQQdxQTByOgAAIBlCB1YhDSAZQgOIIRkgDQ0ACwsgByENIAxBCHFFDQIgCyAUIA1rIgdBAWogByALSBshCwwCCyAIKQNAIhlCAFMEQCAIQgAgGX0iGTcDQEEBIRJBjwkMAQsgDEGAEHEEQEEBIRJBkAkMAQtBkQlBjwkgDEEBcSISGwshFiAZIBQQRyENCyAPQQAgC0EASBsNDiAMQf//e3EgDCAPGyEMIAgpA0AiGUIAUiALckUEQCAUIQ1BACELDAwLIAsgGVAgFCANa2oiByAHIAtIGyELDAsLQQAhDAJ/Qf////8HIAsgC0H/////B08bIgoiEUEARyEQAkACfwJAAkAgCCgCQCIHQY4lIAcbIg0iD0EDcUUgEUVyDQADQCAPLQAAIgxFDQIgEUEBayIRQQBHIRAgD0EBaiIPQQNxRQ0BIBENAAsLIBBFDQICQCAPLQAARSARQQRJckUEQANAIA8oAgAiB0F/cyAHQYGChAhrcUGAgYKEeHENAiAPQQRqIQ8gEUEEayIRQQNLDQALCyARRQ0DC0EADAELQQELIRADQCAQRQRAIA8tAAAhDEEBIRAMAQsgDyAMRQ0CGiAPQQFqIQ8gEUEBayIRRQ0BQQAhEAwACwALQQALIgcgDWsgCiAHGyIHIA1qIQogC0EATgRAIAkhDCAHIQsMCwsgCSEMIAchCyAKLQAADQ0MCgsgCwRAIAgoAkAMAgtBACEHIABBICATQQAgDBApDAILIAhBADYCDCAIIAgpA0A+AgggCCAIQQhqIgc2AkBBfyELIAcLIQlBACEHAkADQCAJKAIAIg1FDQEgCEEEaiANEIYBIgpBAEgiDSAKIAsgB2tLckUEQCAJQQRqIQkgCyAHIApqIgdLDQEMAgsLIA0NDQtBPSEKIAdBAEgNCyAAQSAgEyAHIAwQKSAHRQRAQQAhBwwBC0EAIQogCCgCQCEJA0AgCSgCACINRQ0BIAhBBGogDRCGASINIApqIgogB0sNASAAIAhBBGogDRAmIAlBBGohCSAHIApLDQALCyAAQSAgEyAHIAxBgMAAcxApIBMgByAHIBNIGyEHDAgLIA9BACALQQBIGw0IQT0hCiAAIAgrA0AgEyALIAwgByAFERwAIgdBAE4NBwwJCyAIIAgpA0A8ADdBASELIBchDSAJIQwMBAsgBy0AASEJIAdBAWohBwwACwALIAANByAVRQ0CQQEhBwNAIAQgB0ECdGooAgAiAARAIAMgB0EDdGogACACIAYQhwFBASEOIAdBAWoiB0EKRw0BDAkLC0EBIQ4gB0EKTw0HA0AgBCAHQQJ0aigCAA0BIAdBAWoiB0EKRw0ACwwHC0EcIQoMBAsgCyAKIA1rIhAgCyAQShsiCSASQf////8Hc0oNAkE9IQogEyAJIBJqIgsgCyATSBsiByAYSg0DIABBICAHIAsgDBApIAAgFiASECYgAEEwIAcgCyAMQYCABHMQKSAAQTAgCSAQQQAQKSAAIA0gEBAmIABBICAHIAsgDEGAwABzECkMAQsLQQAhDgwDC0E9IQoLQfw7IAo2AgALQX8hDgsgCEHQAGokACAOC9kCAQR/IwBB0AFrIgUkACAFIAI2AswBIAVBoAFqIgJBAEEoECoaIAUgBSgCzAE2AsgBAkBBACABIAVByAFqIAVB0ABqIAIgAyAEEIoBQQBIBEBBfyEEDAELQQEgBiAAKAJMQQBOGyEGIAAoAgAhByAAKAJIQQBMBEAgACAHQV9xNgIACwJ/AkACQCAAKAIwRQRAIABB0AA2AjAgAEEANgIcIABCADcDECAAKAIsIQggACAFNgIsDAELIAAoAhANAQtBfyAAEJ0BDQEaCyAAIAEgBUHIAWogBUHQAGogBUGgAWogAyAEEIoBCyECIAgEQCAAQQBBACAAKAIkEQYAGiAAQQA2AjAgACAINgIsIABBADYCHCAAKAIUIQEgAEIANwMQIAJBfyABGyECCyAAIAAoAgAiACAHQSBxcjYCAEF/IAIgAEEgcRshBCAGRQ0ACyAFQdABaiQAIAQLfwIBfwF+IAC9IgNCNIinQf8PcSICQf8PRwR8IAJFBEAgASAARAAAAAAAAAAAYQR/QQAFIABEAAAAAAAA8EOiIAEQjAEhACABKAIAQUBqCzYCACAADwsgASACQf4HazYCACADQv////////+HgH+DQoCAgICAgIDwP4S/BSAACwsVACAARQRAQQAPC0H8OyAANgIAQX8LzgECA38CfSMAQRBrIgMkAEEBIQQgA0EIaiAAQfwAaiIFIAAgAUEBdGpBxABqIgEvAQAQHwJAAkAgAyoCCCIHIAIqAgAiBlwEQCAHIAdbBEAgAi0ABCECDAILIAYgBlwhBAsgAi0ABCECIARFDQAgAy0ADCACQf8BcUYNAQsgBSABIAYgAhA5A0AgAC0AACIBQQRxDQEgACABQQRyOgAAIAAoAhAiAQRAIAAgAREAAAsgAEGAgID+BzYCnAEgACgC5AMiAA0ACwsgA0EQaiQAC9EDAEHUO0GoHBAcQdU7QYoWQQFBAUEAEBtB1jtB/RJBAUGAf0H/ABAEQdc7QfYSQQFBgH9B/wAQBEHYO0H0EkEBQQBB/wEQBEHZO0GUCkECQYCAfkH//wEQBEHaO0GLCkECQQBB//8DEARB2ztBsQpBBEGAgICAeEH/////BxAEQdw7QagKQQRBAEF/EARB3TtB+BhBBEGAgICAeEH/////BxAEQd47Qe8YQQRBAEF/EARB3ztBjxBCgICAgICAgICAf0L///////////8AEIQBQeA7QY4QQgBCfxCEAUHhO0GIEEEEEA1B4jtB9BtBCBANQeM7QaQZEA5B5DtBmSIQDkHlO0EEQZcZEAhB5jtBAkGwGRAIQec7QQRBvxkQCEHoO0GPFhAaQek7QQBB1CEQAUHqO0EAQboiEAFB6ztBAUHyIRABQew7QQJB5B4QAUHtO0EDQYMfEAFB7jtBBEGrHxABQe87QQVByB8QAUHwO0EEQd8iEAFB8TtBBUH9IhABQeo7QQBBriAQAUHrO0EBQY0gEAFB7DtBAkHwIBABQe07QQNBziAQAUHuO0EEQbMhEAFB7ztBBUGRIRABQfI7QQZB7h8QAUHzO0EHQaQjEAELJQAgAEH0JjYCACAALQAEBEAgACgCCEH9DxBmCyAAKAIIEAYgAAsDAAALJQAgAEHsJzYCACAALQAEBEAgACgCCEH9DxBmCyAAKAIIEAYgAAs3AQJ/QQQQHiICIAE2AgBBBBAeIgMgATYCAEGjOyAAQeI7QfooQcEBIAJB4jtB/ihBwgEgAxAHCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRBQALOQEBfyABIAAoAgQiBEEBdWohASAAKAIAIQAgASACIAMgBEEBcQR/IAEoAgAgAGooAgAFIAALEQMACwkAIAEgABEAAAsHACAAEQ4ACzUBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAIAEgAkEBcQR/IAEoAgAgAGooAgAFIAALEQAACzABAX8jAEEQayICJAAgAiABNgIIIAJBCGogABECACEAIAIoAggQBiACQRBqJAAgAAsMACABIAAoAgARAAALCQAgAEEBOgAEC9coAQJ/QaA7QaE7QaI7QQBBjCZBB0GPJkEAQY8mQQBB2RZBkSZBCBAFQQgQHiIAQoiAgIAQNwMAQaA7QZcbQQZBoCZBuCZBCSAAQQEQAEGkO0GlO0GmO0GgO0GMJkEKQYwmQQtBjCZBDEG4EUGRJkENEAVBBBAeIgBBDjYCAEGkO0HoFEECQcAmQcgmQQ8gAEEAEABBoDtBowxBAkHMJkHUJkEQQREQA0GgO0GAHEEDQaQnQbAnQRJBExADQbg7Qbk7Qbo7QQBBjCZBFEGPJkEAQY8mQQBB6RZBkSZBFRAFQQgQHiIAQoiAgIAQNwMAQbg7QegcQQJBuCdByCZBFiAAQQEQAEG7O0G8O0G9O0G4O0GMJkEXQYwmQRhBjCZBGUHPEUGRJkEaEAVBBBAeIgBBGzYCAEG7O0HoFEECQcAnQcgmQRwgAEEAEABBuDtBowxBAkHIJ0HUJkEdQR4QA0G4O0GAHEEDQaQnQbAnQRJBHxADQb47Qb87QcA7QQBBjCZBIEGPJkEAQY8mQQBB2hpBkSZBIRAFQb47QQFB+CdBjCZBIkEjEA9BvjtBkBtBAUH4J0GMJkEiQSMQA0G+O0HpCEECQfwnQcgmQSRBJRADQQgQHiIAQQA2AgQgAEEmNgIAQb47Qa0cQQRBkChBoChBJyAAQQAQAEEIEB4iAEEANgIEIABBKDYCAEG+O0GkEUEDQagoQbQoQSkgAEEAEABBCBAeIgBBADYCBCAAQSo2AgBBvjtByB1BA0G8KEHIKEErIABBABAAQQgQHiIAQQA2AgQgAEEsNgIAQb47QaYQQQNB0ChByChBLSAAQQAQAEEIEB4iAEEANgIEIABBLjYCAEG+O0HLHEEDQdwoQbAnQS8gAEEAEABBCBAeIgBBADYCBCAAQTA2AgBBvjtB0h1BAkHoKEHUJkExIABBABAAQQgQHiIAQQA2AgQgAEEyNgIAQb47QZcQQQJB8ChB1CZBMyAAQQAQAEHBO0GECkH4KEE0QZEmQTUQCkHiD0EAEEhB6g5BCBBIQYITQRAQSEHxFUEYEEhBgxdBIBBIQfAOQSgQSEHBOxAJQaM7Qf8aQfgoQTZBkSZBNxAKQYMXQQAQkwFB8A5BCBCTAUGjOxAJQcI7QYobQfgoQThBkSZBORAKQQQQHiIAQQg2AgBBBBAeIgFBCDYCAEHCO0GEG0HiO0H6KEE6IABB4jtB/ihBOyABEAdBBBAeIgBBADYCAEEEEB4iAUEANgIAQcI7QeUOQds7QdQmQTwgAEHbO0HIKEE9IAEQB0HCOxAJQcM7QcQ7QcU7QQBBjCZBPkGPJkEAQY8mQQBB+xtBkSZBPxAFQcM7QQFBhClBjCZBwABBwQAQD0HDO0HXDkEBQYQpQYwmQcAAQcEAEANBwztB0BpBAkGIKUHUJkHCAEHDABADQcM7QekIQQJBkClByCZBxABBxQAQA0EIEB4iAEEANgIEIABBxgA2AgBBwztB9w9BAkGQKUHIJkHHACAAQQAQAEEIEB4iAEEANgIEIABByAA2AgBBwztB6htBA0GYKUHIKEHJACAAQQAQAEEIEB4iAEEANgIEIABBygA2AgBBwztBnxtBA0GkKUHIKEHLACAAQQAQAEEIEB4iAEEANgIEIABBzAA2AgBBwztB0BRBBEGwKUHAKUHNACAAQQAQAEEIEB4iAEEANgIEIABBzgA2AgBBwztBiA1BBEGwKUHAKUHNACAAQQAQAEEIEB4iAEEANgIEIABBzwA2AgBBwztB3RNBA0GkKUHIKEHLACAAQQAQAEEIEB4iAEEANgIEIABB0AA2AgBBwztB+QtBA0GkKUHIKEHLACAAQQAQAEEIEB4iAEEANgIEIABB0QA2AgBBwztBuBBBA0GkKUHIKEHLACAAQQAQAEEIEB4iAEEANgIEIABB0gA2AgBBwztB5RpBA0GkKUHIKEHLACAAQQAQAEEIEB4iAEEANgIEIABB0wA2AgBBwztB/BRBA0GkKUHIKEHLACAAQQAQAEEIEB4iAEEANgIEIABB1AA2AgBBwztBlRNBA0GkKUHIKEHLACAAQQAQAEEIEB4iAEEANgIEIABB1QA2AgBBwztBtQpBA0GkKUHIKEHLACAAQQAQAEEIEB4iAEEANgIEIABB1gA2AgBBwztBuBVBBEGwKUHAKUHNACAAQQAQAEEIEB4iAEEANgIEIABB1wA2AgBBwztBmw1BBEGwKUHAKUHNACAAQQAQAEEIEB4iAEEANgIEIABB2AA2AgBBwztB7RNBA0GkKUHIKEHLACAAQQAQAEEIEB4iAEEANgIEIABB2QA2AgBBwztBxAlBA0GkKUHIKEHLACAAQQAQAEEIEB4iAEEANgIEIABB2gA2AgBBwztB8QhBA0GkKUHIKEHLACAAQQAQAEEIEB4iAEEANgIEIABB2wA2AgBBwztBhwlBA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB3QA2AgBBwztB1BBBA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB3gA2AgBBwztB5gxBA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB3wA2AgBBwztBzBNBAkGQKUHIJkHHACAAQQAQAEEIEB4iAEEANgIEIABB4AA2AgBBwztBrAlBA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB4QA2AgBBwztBnxZBA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB4gA2AgBBwztBoRdBA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB4wA2AgBBwztBvw1BA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB5AA2AgBBwztB+xNBAkGQKUHIJkHHACAAQQAQAEEIEB4iAEEANgIEIABB5QA2AgBBwztBkQ9BA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB5gA2AgBBwztBwQxBA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB5wA2AgBBwztBvhNBAkGQKUHIJkHHACAAQQAQAEEIEB4iAEEANgIEIABB6AA2AgBBwztBsxdBA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB6QA2AgBBwztBzw1BA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB6gA2AgBBwztBpQ9BA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB6wA2AgBBwztB0gxBA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB7AA2AgBBwztBiRdBA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB7QA2AgBBwztBrA1BA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB7gA2AgBBwztB9w5BA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB7wA2AgBBwztBrQxBA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB8AA2AgBBwztB/RhBA0GkKUHIKEHLACAAQQAQAEEIEB4iAEEANgIEIABB8QA2AgBBwztBshRBA0HIKUH+KEHcACAAQQAQAEEIEB4iAEEANgIEIABB8gA2AgBBwztBlBJBBEGwKUHAKUHNACAAQQAQAEEIEB4iAEEANgIEIABB8wA2AgBBwztBzhlBBEGwKUHAKUHNACAAQQAQAEEIEB4iAEEANgIEIABB9AA2AgBBwztB4g1BBEGwKUHAKUHNACAAQQAQAEEIEB4iAEEANgIEIABB9QA2AgBBwztBrRNBBEGwKUHAKUHNACAAQQAQAEEIEB4iAEEANgIEIABB9gA2AgBBwztB+gxBBEGwKUHAKUHNACAAQQAQAEEIEB4iAEEANgIEIABB9wA2AgBBwztBnhVBA0GkKUHIKEHLACAAQQAQAEEIEB4iAEEANgIEIABB+AA2AgBBwztBrxtBAkHUKUHUJkH5ACAAQQAQAEEIEB4iAEEANgIEIABB+gA2AgBBwztB3BRBA0HcKUGwJ0H7ACAAQQAQAEEIEB4iAEEANgIEIABB/AA2AgBBwztBiQxBAkHUKUHUJkH5ACAAQQAQAEEIEB4iAEEANgIEIABB/QA2AgBBwztBxhBBAkHUKUHUJkH5ACAAQQAQAEEIEB4iAEEANgIEIABB/gA2AgBBwztB8hpBAkHUKUHUJkH5ACAAQQAQAEEIEB4iAEEANgIEIABB/wA2AgBBwztBjRVBAkHUKUHUJkH5ACAAQQAQAEEIEB4iAEEANgIEIABBgAE2AgBBwztBoRNBAkHUKUHUJkH5ACAAQQAQAEEIEB4iAEEANgIEIABBgQE2AgBBwztBxwpBAkHUKUHUJkH5ACAAQQAQAEEIEB4iAEEANgIEIABBggE2AgBBwztBwhVBA0HcKUGwJ0H7ACAAQQAQAEEIEB4iAEEANgIEIABBgwE2AgBBwztB4RBBAkHoKUHUJkGEASAAQQAQAEEIEB4iAEEANgIEIABBhQE2AgBBwztBuAlBAkHwKUH6KEGGASAAQQAQAEEIEB4iAEEANgIEIABBhwE2AgBBwztBrRZBAkHwKUH6KEGGASAAQQAQAEEIEB4iAEEANgIEIABBiAE2AgBBwztBqhdBAkHoKUHUJkGEASAAQQAQAEEIEB4iAEEANgIEIABBiQE2AgBBwztBmw9BAkHoKUHUJkGEASAAQQAQAEEIEB4iAEEANgIEIABBigE2AgBBwztBvxdBAkHoKUHUJkGEASAAQQAQAEEIEB4iAEEANgIEIABBiwE2AgBBwztBsg9BAkHoKUHUJkGEASAAQQAQAEEIEB4iAEEANgIEIABBjAE2AgBBwztBlRdBAkHoKUHUJkGEASAAQQAQAEEIEB4iAEEANgIEIABBjQE2AgBBwztBhA9BAkHoKUHUJkGEASAAQQAQAEEIEB4iAEEANgIEIABBjgE2AgBBwztBihlBAkHUKUHUJkH5ACAAQQAQAEEIEB4iAEEANgIEIABBjwE2AgBBwztBwRRBAkHwKUH6KEGGASAAQQAQAEEIEB4iAEEANgIEIABBkAE2AgBBwztBnhJBA0H4KUGEKkGRASAAQQAQAEEIEB4iAEEANgIEIABBkgE2AgBBwztB0AlBAkHUKUHUJkH5ACAAQQAQAEEIEB4iAEEANgIEIABBkwE2AgBBwztB/AhBAkHUKUHUJkH5ACAAQQAQAEEIEB4iAEEANgIEIABBlAE2AgBBwztB2RlBA0HcKUGwJ0H7ACAAQQAQAEEIEB4iAEEANgIEIABBlQE2AgBBwztBtBNBA0GMKkGYKkGWASAAQQAQAEEIEB4iAEEANgIEIABBlwE2AgBBwztBhxxBBEGgKkGgKEGYASAAQQAQAEEIEB4iAEEANgIEIABBmQE2AgBBwztBnBxBA0GwKkHIKEGaASAAQQAQAEEIEB4iAEEANgIEIABBmwE2AgBBwztBmgpBAkG8KkHUJkGcASAAQQAQAEEIEB4iAEEANgIEIABBnQE2AgBBwztBmQxBAkHEKkHUJkGeASAAQQAQAEEIEB4iAEEANgIEIABBnwE2AgBBwztBkxxBA0HMKkGwJ0GgASAAQQAQAEEIEB4iAEEANgIEIABBoQE2AgBBwztBuxZBA0HYKkHIKEGiASAAQQAQAEEIEB4iAEEANgIEIABBowE2AgBBwztBvxtBAkHkKkHUJkGkASAAQQAQAEEIEB4iAEEANgIEIABBpQE2AgBBwztB0xtBA0HYKkHIKEGiASAAQQAQAEEIEB4iAEEANgIEIABBpgE2AgBBwztBqB1BA0HsKkHIKEGnASAAQQAQAEEIEB4iAEEANgIEIABBqAE2AgBBwztBph1BAkGQKUHIJkHHACAAQQAQAEEIEB4iAEEANgIEIABBqQE2AgBBwztBuR1BA0H4KkHIKEGqASAAQQAQAEEIEB4iAEEANgIEIABBqwE2AgBBwztBtx1BAkGQKUHIJkHHACAAQQAQAEEIEB4iAEEANgIEIABBrAE2AgBBwztB3whBAkGQKUHIJkHHACAAQQAQAEEIEB4iAEEANgIEIABBrQE2AgBBwztB1whBAkGEK0HUJkGuASAAQQAQAEEIEB4iAEEANgIEIABBrwE2AgBBwztB3hVBAkGQKUHIJkHHACAAQQAQAEEIEB4iAEEANgIEIABBsAE2AgBBwztB3AlBAkGEK0HUJkGuASAAQQAQAEEIEB4iAEEANgIEIABBsQE2AgBBwztB6QlBBUGQK0GkK0GyASAAQQAQAEEIEB4iAEEANgIEIABBswE2AgBBwztB5w9BAkHwKUH6KEGGASAAQQAQAEEIEB4iAEEANgIEIABBtAE2AgBBwztB0Q9BAkHwKUH6KEGGASAAQQAQAEEIEB4iAEEANgIEIABBtQE2AgBBwztBhhNBAkHwKUH6KEGGASAAQQAQAEEIEB4iAEEANgIEIABBtgE2AgBBwztB+BVBAkHwKUH6KEGGASAAQQAQAEEIEB4iAEEANgIEIABBtwE2AgBBwztByxdBAkHwKUH6KEGGASAAQQAQAEEIEB4iAEEANgIEIABBuAE2AgBBwztBvw9BAkHwKUH6KEGGASAAQQAQAEEIEB4iAEEANgIEIABBuQE2AgBBwztB+QlBAkGsK0HUJkG6ASAAQQAQAEEIEB4iAEEANgIEIABBuwE2AgBBwztBzBVBA0H4KUGEKkGRASAAQQAQAEEIEB4iAEEANgIEIABBvAE2AgBBwztBqBJBA0H4KUGEKkGRASAAQQAQAEEIEB4iAEEANgIEIABBvQE2AgBBwztB5BlBA0H4KUGEKkGRASAAQQAQAEEIEB4iAEEANgIEIABBvgE2AgBBwztBqxVBAkHUKUHUJkH5ACAAQQAQAAtZAQF/IAAgACgCSCIBQQFrIAFyNgJIIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAtHAAJAIAFBA00EfyAAIAFBAnRqQQRqBSABQQRrIgEgACgCGCIAKAIEIAAoAgAiAGtBAnVPDQEgACABQQJ0agsoAgAPCxACAAs4AQF/IAFBAEgEQBACAAsgAUEBa0EFdkEBaiIBQQJ0EB4hAiAAIAE2AgggAEEANgIEIAAgAjYCAAvSBQEJfyAAIAEvAQA7AQAgACABKQIENwIEIAAgASkCDDcCDCAAIAEoAhQ2AhQCQAJAIAEoAhgiA0UNAEEYEB4iBUEANgIIIAVCADcCACADKAIEIgEgAygCACICRwRAIAEgAmsiAkEASA0CIAUgAhAeIgE2AgAgBSABIAJqNgIIIAMoAgAiAiADKAIEIgZHBEADQCABIAIoAgA2AgAgAUEEaiEBIAJBBGoiAiAGRw0ACwsgBSABNgIECyAFQgA3AgwgBUEANgIUIAMoAhAiAUUNACAFQQxqIAEQnwEgAygCDCEGIAUgBSgCECIEIAMoAhAiAkEfcWogAkFgcWoiATYCEAJAAkAgBEUEQCABQQFrIQMMAQsgAUEBayIDIARBAWtzQSBJDQELIAUoAgwgA0EFdkEAIAFBIU8bQQJ0akEANgIACyAFKAIMIARBA3ZB/P///wFxaiEBIARBH3EiA0UEQCACQQBMDQEgAkEgbSEDIAJBH2pBP08EQCABIAYgA0ECdBAzGgsgAiADQQV0ayICQQBMDQEgASADQQJ0IgNqIgEgASgCAEF/QSAgAmt2IgFBf3NxIAMgBmooAgAgAXFyNgIADAELIAJBAEwNAEF/IAN0IQhBICADayEEIAJBIE4EQCAIQX9zIQkgASgCACEHA0AgASAHIAlxIAYoAgAiByADdHI2AgAgASABKAIEIAhxIAcgBHZyIgc2AgQgBkEEaiEGIAFBBGohASACQT9LIQogAkEgayECIAoNAAsgAkEATA0BCyABIAEoAgBBfyAEIAQgAiACIARKGyIEa3YgCHFBf3NxIAYoAgBBf0EgIAJrdnEiBiADdHI2AgAgAiAEayICQQBMDQAgASADIARqQQN2Qfz///8BcWoiASABKAIAQX9BICACa3ZBf3NxIAYgBHZyNgIACyAAKAIYIQEgACAFNgIYIAEEQCABEFsLDwsQAgALvQMBB38gAARAIwBBIGsiBiQAIAAoAgAiASgC5AMiAwRAIAMgARBvGiABQQA2AuQDCyABKALsAyICIAEoAugDIgNHBEBBASACIANrQQJ1IgIgAkEBTRshBEEAIQIDQCADIAJBAnRqKAIAQQA2AuQDIAJBAWoiAiAERw0ACwsgASADNgLsAwJAIAMgAUHwA2oiAigCAEYNACAGQQhqQQBBACACEEoiAigCBCABKALsAyABKALoAyIEayIFayIDIAQgBRAzIQUgASgC6AMhBCABIAU2AugDIAIgBDYCBCABKALsAyEFIAEgAigCCDYC7AMgAiAFNgIIIAEoAvADIQcgASACKAIMNgLwAyACIAQ2AgAgAiAHNgIMIAQgBUcEQCACIAUgBCAFa0EDakF8cWo2AggLIARFDQAgBBAnIAEoAugDIQMLIAMEQCABIAM2AuwDIAMQJwsgASgClAEhAyABQQA2ApQBIAMEQCADEFsLIAEQJyAAKAIIIQEgAEEANgIIIAEEQCABIAEoAgAoAgQRAAALIAAoAgQhASAAQQA2AgQgAQRAIAEgASgCACgCBBEAAAsgBkEgaiQAIAAQIwsLtQEBAX8jAEEQayICJAACfyABBEAgASgCACEBQYgEEB4gARBcIAENARogAkH3GTYCACACEHIQJAALQZQ7LQAARQRAQfg6QQM2AgBBiDtCgICAgICAgMA/NwIAQYA7QgA3AgBBlDtBAToAAEH8OkH8Oi0AAEH+AXE6AABB9DpBADYCAEGQO0EANgIAC0GIBBAeQfQ6EFwLIQEgAEIANwIEIAAgATYCACABIAA2AgQgAkEQaiQAIAALGwEBfyAABEAgACgCACIBBEAgARAjCyAAECMLC0kBAn9BBBAeIQFBIBAeIgBBADYCHCAAQoCAgICAgIDAPzcCFCAAQgA3AgwgAEEAOgAIIABBAzYCBCAAQQA2AgAgASAANgIAIAELIAAgAkEFR0EAIAIbRQRAQbgwIAMgBBBJDwsgAyAEEHALIgEBfiABIAKtIAOtQiCGhCAEIAARFQAiBUIgiKckASAFpwuoAQEFfyAAKAJUIgMoAgAhBSADKAIEIgQgACgCFCAAKAIcIgdrIgYgBCAGSRsiBgRAIAUgByAGECsaIAMgAygCACAGaiIFNgIAIAMgAygCBCAGayIENgIECyAEIAIgAiAESxsiBARAIAUgASAEECsaIAMgAygCACAEaiIFNgIAIAMgAygCBCAEazYCBAsgBUEAOgAAIAAgACgCLCIBNgIcIAAgATYCFCACCwQAQgALBABBAAuKBQIGfgJ/IAEgASgCAEEHakF4cSIBQRBqNgIAIAAhCSABKQMAIQMgASkDCCEGIwBBIGsiCCQAAkAgBkL///////////8AgyIEQoCAgICAgMCAPH0gBEKAgICAgIDA/8MAfVQEQCAGQgSGIANCPIiEIQQgA0L//////////w+DIgNCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhAgwCCyAEQoCAgICAgICAQH0hAiADQoCAgICAgICACFINASACIARCAYN8IQIMAQsgA1AgBEKAgICAgIDA//8AVCAEQoCAgICAgMD//wBRG0UEQCAGQgSGIANCPIiEQv////////8Dg0KAgICAgICA/P8AhCECDAELQoCAgICAgID4/wAhAiAEQv///////7//wwBWDQBCACECIARCMIinIgBBkfcASQ0AIAMhAiAGQv///////z+DQoCAgICAgMAAhCIFIQcCQCAAQYH3AGsiAUHAAHEEQCACIAFBQGqthiEHQgAhAgwBCyABRQ0AIAcgAa0iBIYgAkHAACABa62IhCEHIAIgBIYhAgsgCCACNwMQIAggBzcDGAJAQYH4ACAAayIAQcAAcQRAIAUgAEFAaq2IIQNCACEFDAELIABFDQAgBUHAACAAa62GIAMgAK0iAoiEIQMgBSACiCEFCyAIIAM3AwAgCCAFNwMIIAgpAwhCBIYgCCkDACIDQjyIhCECIAgpAxAgCCkDGIRCAFKtIANC//////////8Pg4QiA0KBgICAgICAgAhaBEAgAkIBfCECDAELIANCgICAgICAgIAIUg0AIAJCAYMgAnwhAgsgCEEgaiQAIAkgAiAGQoCAgICAgICAgH+DhL85AwALmRgDEn8BfAN+IwBBsARrIgwkACAMQQA2AiwCQCABvSIZQgBTBEBBASERQZkJIRMgAZoiAb0hGQwBCyAEQYAQcQRAQQEhEUGcCSETDAELQZ8JQZoJIARBAXEiERshEyARRSEVCwJAIBlCgICAgICAgPj/AINCgICAgICAgPj/AFEEQCAAQSAgAiARQQNqIgMgBEH//3txECkgACATIBEQJiAAQe0VQdweIAVBIHEiBRtB4RpB4B4gBRsgASABYhtBAxAmIABBICACIAMgBEGAwABzECkgAyACIAIgA0gbIQoMAQsgDEEQaiESAkACfwJAIAEgDEEsahCMASIBIAGgIgFEAAAAAAAAAABiBEAgDCAMKAIsIgZBAWs2AiwgBUEgciIOQeEARw0BDAMLIAVBIHIiDkHhAEYNAiAMKAIsIQlBBiADIANBAEgbDAELIAwgBkEdayIJNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyELIAxBMGpBoAJBACAJQQBOG2oiDSEHA0AgBwJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgM2AgAgB0EEaiEHIAEgA7ihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIAlBAEwEQCAJIQMgByEGIA0hCAwBCyANIQggCSEDA0BBHSADIANBHU4bIQMCQCAHQQRrIgYgCEkNACADrSEaQgAhGQNAIAYgGUL/////D4MgBjUCACAahnwiG0KAlOvcA4AiGUKA7JSjDH4gG3w+AgAgBkEEayIGIAhPDQALIBmnIgZFDQAgCEEEayIIIAY2AgALA0AgCCAHIgZJBEAgBkEEayIHKAIARQ0BCwsgDCAMKAIsIANrIgM2AiwgBiEHIANBAEoNAAsLIANBAEgEQCALQRlqQQluQQFqIQ8gDkHmAEYhEANAQQlBACADayIDIANBCU4bIQoCQCAGIAhNBEAgCCgCACEHDAELQYCU69wDIAp2IRRBfyAKdEF/cyEWQQAhAyAIIQcDQCAHIAMgBygCACIXIAp2ajYCACAWIBdxIBRsIQMgB0EEaiIHIAZJDQALIAgoAgAhByADRQ0AIAYgAzYCACAGQQRqIQYLIAwgDCgCLCAKaiIDNgIsIA0gCCAHRUECdGoiCCAQGyIHIA9BAnRqIAYgBiAHa0ECdSAPShshBiADQQBIDQALC0EAIQMCQCAGIAhNDQAgDSAIa0ECdUEJbCEDQQohByAIKAIAIgpBCkkNAANAIANBAWohAyAKIAdBCmwiB08NAAsLIAsgA0EAIA5B5gBHG2sgDkHnAEYgC0EAR3FrIgcgBiANa0ECdUEJbEEJa0gEQEEEQaQCIAlBAEgbIAxqIAdBgMgAaiIKQQltIg9BAnRqQdAfayEJQQohByAPQXdsIApqIgpBB0wEQANAIAdBCmwhByAKQQFqIgpBCEcNAAsLAkAgCSgCACIQIBAgB24iDyAHbCIKRiAJQQRqIhQgBkZxDQAgECAKayEQAkAgD0EBcUUEQEQAAAAAAABAQyEBIAdBgJTr3ANHIAggCU9yDQEgCUEEay0AAEEBcUUNAQtEAQAAAAAAQEMhAQtEAAAAAAAA4D9EAAAAAAAA8D9EAAAAAAAA+D8gBiAURhtEAAAAAAAA+D8gECAHQQF2IhRGGyAQIBRJGyEYAkAgFQ0AIBMtAABBLUcNACAYmiEYIAGaIQELIAkgCjYCACABIBigIAFhDQAgCSAHIApqIgM2AgAgA0GAlOvcA08EQANAIAlBADYCACAIIAlBBGsiCUsEQCAIQQRrIghBADYCAAsgCSAJKAIAQQFqIgM2AgAgA0H/k+vcA0sNAAsLIA0gCGtBAnVBCWwhA0EKIQcgCCgCACIKQQpJDQADQCADQQFqIQMgCiAHQQpsIgdPDQALCyAJQQRqIgcgBiAGIAdLGyEGCwNAIAYiByAITSIKRQRAIAdBBGsiBigCAEUNAQsLAkAgDkHnAEcEQCAEQQhxIQkMAQsgA0F/c0F/IAtBASALGyIGIANKIANBe0pxIgkbIAZqIQtBf0F+IAkbIAVqIQUgBEEIcSIJDQBBdyEGAkAgCg0AIAdBBGsoAgAiDkUNAEEKIQpBACEGIA5BCnANAANAIAYiCUEBaiEGIA4gCkEKbCIKcEUNAAsgCUF/cyEGCyAHIA1rQQJ1QQlsIQogBUFfcUHGAEYEQEEAIQkgCyAGIApqQQlrIgZBACAGQQBKGyIGIAYgC0obIQsMAQtBACEJIAsgAyAKaiAGakEJayIGQQAgBkEAShsiBiAGIAtKGyELC0F/IQogC0H9////B0H+////ByAJIAtyIhAbSg0BIAsgEEEAR2pBAWohDgJAIAVBX3EiFUHGAEYEQCADIA5B/////wdzSg0DIANBACADQQBKGyEGDAELIBIgAyADQR91IgZzIAZrrSASEEciBmtBAUwEQANAIAZBAWsiBkEwOgAAIBIgBmtBAkgNAAsLIAZBAmsiDyAFOgAAIAZBAWtBLUErIANBAEgbOgAAIBIgD2siBiAOQf////8Hc0oNAgsgBiAOaiIDIBFB/////wdzSg0BIABBICACIAMgEWoiBSAEECkgACATIBEQJiAAQTAgAiAFIARBgIAEcxApAkACQAJAIBVBxgBGBEAgDEEQaiIGQQhyIQMgBkEJciEJIA0gCCAIIA1LGyIKIQgDQCAINQIAIAkQRyEGAkAgCCAKRwRAIAYgDEEQak0NAQNAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsMAQsgBiAJRw0AIAxBMDoAGCADIQYLIAAgBiAJIAZrECYgCEEEaiIIIA1NDQALIBAEQCAAQYwlQQEQJgsgC0EATCAHIAhNcg0BA0AgCDUCACAJEEciBiAMQRBqSwRAA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwsgACAGQQkgCyALQQlOGxAmIAtBCWshBiAIQQRqIgggB08NAyALQQlKIQMgBiELIAMNAAsMAgsCQCALQQBIDQAgByAIQQRqIAcgCEsbIQogDEEQaiIGQQhyIQMgBkEJciENIAghBwNAIA0gBzUCACANEEciBkYEQCAMQTA6ABggAyEGCwJAIAcgCEcEQCAGIAxBEGpNDQEDQCAGQQFrIgZBMDoAACAGIAxBEGpLDQALDAELIAAgBkEBECYgBkEBaiEGIAkgC3JFDQAgAEGMJUEBECYLIAAgBiALIA0gBmsiBiAGIAtKGxAmIAsgBmshCyAHQQRqIgcgCk8NASALQQBODQALCyAAQTAgC0ESakESQQAQKSAAIA8gEiAPaxAmDAILIAshBgsgAEEwIAZBCWpBCUEAECkLIABBICACIAUgBEGAwABzECkgBSACIAIgBUgbIQoMAQsgEyAFQRp0QR91QQlxaiELAkAgA0ELSw0AQQwgA2shBkQAAAAAAAAwQCEYA0AgGEQAAAAAAAAwQKIhGCAGQQFrIgYNAAsgCy0AAEEtRgRAIBggAZogGKGgmiEBDAELIAEgGKAgGKEhAQsgEUECciEJIAVBIHEhCCASIAwoAiwiByAHQR91IgZzIAZrrSASEEciBkYEQCAMQTA6AA8gDEEPaiEGCyAGQQJrIg0gBUEPajoAACAGQQFrQS1BKyAHQQBIGzoAACAEQQhxIQYgDEEQaiEHA0AgByIFAn8gAZlEAAAAAAAA4EFjBEAgAaoMAQtBgICAgHgLIgdBkC9qLQAAIAhyOgAAIAYgA0EASnJFIAEgB7ehRAAAAAAAADBAoiIBRAAAAAAAAAAAYXEgBUEBaiIHIAxBEGprQQFHckUEQCAFQS46AAEgBUECaiEHCyABRAAAAAAAAAAAYg0AC0F/IQpB/f///wcgCSASIA1rIgVqIgZrIANIDQAgAEEgIAIgBgJ/AkAgA0UNACAHIAxBEGprIghBAmsgA04NACADQQJqDAELIAcgDEEQamsiCAsiB2oiAyAEECkgACALIAkQJiAAQTAgAiADIARBgIAEcxApIAAgDEEQaiAIECYgAEEwIAcgCGtBAEEAECkgACANIAUQJiAAQSAgAiADIARBgMAAcxApIAMgAiACIANIGyEKCyAMQbAEaiQAIAoLRgEBfyAAKAI8IQMjAEEQayIAJAAgAyABpyABQiCIpyACQf8BcSAAQQhqEBQQjQEhAiAAKQMIIQEgAEEQaiQAQn8gASACGwu+AgEHfyMAQSBrIgMkACADIAAoAhwiBDYCECAAKAIUIQUgAyACNgIcIAMgATYCGCADIAUgBGsiATYCFCABIAJqIQVBAiEGIANBEGohAQJ/A0ACQAJAAkAgACgCPCABIAYgA0EMahAYEI0BRQRAIAUgAygCDCIHRg0BIAdBAE4NAgwDCyAFQX9HDQILIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhAgAgwDCyABIAcgASgCBCIISyIJQQN0aiIEIAcgCEEAIAkbayIIIAQoAgBqNgIAIAFBDEEEIAkbaiIBIAEoAgAgCGs2AgAgBSAHayEFIAYgCWshBiAEIQEMAQsLIABBADYCHCAAQgA3AxAgACAAKAIAQSByNgIAQQAgBkECRg0AGiACIAEoAgRrCyEEIANBIGokACAECwkAIAAoAjwQGQsjAQF/Qcg7KAIAIgAEQANAIAAoAgARCQAgACgCBCIADQALCwu/AgEFfyMAQeAAayICJAAgAiAANgIAIwBBEGsiAyQAIAMgAjYCDCMAQZABayIAJAAgAEGgL0GQARArIgAgAkEQaiIFIgE2AiwgACABNgIUIABB/////wdBfiABayIEIARB/////wdPGyIENgIwIAAgASAEaiIBNgIcIAAgATYCECAAQbsTIAJBAEEAEIsBGiAEBEAgACgCFCIBIAEgACgCEEZrQQA6AAALIABBkAFqJAAgA0EQaiQAAkAgBSIAQQNxBEADQCAALQAARQ0CIABBAWoiAEEDcQ0ACwsDQCAAIgFBBGohACABKAIAIgNBf3MgA0GBgoQIa3FBgIGChHhxRQ0ACwNAIAEiAEEBaiEBIAAtAAANAAsLIAAgBWtBAWoiABBhIgEEfyABIAUgABArBUEACyEAIAJB4ABqJAAgAAvFAQICfwF8IwBBMGsiBiQAIAEoAgghBwJAQbQ7LQAAQQFxBEBBsDsoAgAhAQwBC0EFQZAnEAwhAUG0O0EBOgAAQbA7IAE2AgALIAYgBTYCKCAGIAQ4AiAgBiADNgIYIAYgAjgCEAJ/IAEgB0GXGyAGQQxqIAZBEGoQEiIIRAAAAAAAAPBBYyAIRAAAAAAAAAAAZnEEQCAIqwwBC0EACyEBIAYoAgwhAyAAIAEpAwA3AwAgACABKQMINwMIIAMQESAGQTBqJAALCQAgABCQARAjCwwAIAAoAghB6BwQZgsJACAAEJIBECMLVQECfyMAQTBrIgIkACABIAAoAgQiA0EBdWohASAAKAIAIQAgAiABIANBAXEEfyABKAIAIABqKAIABSAACxEBAEEwEB4gAkEwECshACACQTBqJAAgAAs7AQF/IAEgACgCBCIFQQF1aiEBIAAoAgAhACABIAIgAyAEIAVBAXEEfyABKAIAIABqKAIABSAACxEdAAs3AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhACABIAIgA0EBcQR/IAEoAgAgAGooAgAFIAALERIACzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRDAALNQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQAgASACQQFxBH8gASgCACAAaigCAAUgAAsRCwALYQECfyMAQRBrIgIkACABIAAoAgQiA0EBdWohASAAKAIAIQAgAiABIANBAXEEfyABKAIAIABqKAIABSAACxEBAEEQEB4iACACKQMINwMIIAAgAikDADcDACACQRBqJAAgAAtjAQJ/IwBBEGsiAyQAIAEgACgCBCIEQQF1aiEBIAAoAgAhACADIAEgAiAEQQFxBH8gASgCACAAaigCAAUgAAsRAwBBEBAeIgAgAykDCDcDCCAAIAMpAwA3AwAgA0EQaiQAIAALNwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEEAAs5AQF/IAEgACgCBCIEQQF1aiEBIAAoAgAhACABIAIgAyAEQQFxBH8gASgCACAAaigCAAUgAAsRCAALCQAgASAAEQIACwUAQcM7Cw8AIAEgACgCAGogAjYCAAsNACABIAAoAgBqKAIACxgBAX9BEBAeIgBCADcDCCAAQQA2AgAgAAsYAQF/QRAQHiIAQgA3AwAgAEIANwMIIAALDABBMBAeQQBBMBAqCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRHgALBQBBvjsLIQAgACABKAIAIAEgASwAC0EASBtBuzsgAigCABAQNgIACyoBAX9BDBAeIgFBADoABCABIAAoAgA2AgggAEEANgIAIAFB2Cc2AgAgAQsFAEG7OwsFAEG4OwshACAAIAEoAgAgASABLAALQQBIG0GkOyACKAIAEBA2AgAL2AEBBH8jAEEgayIDJAAgASgCACIEQfD///8HSQRAAkACQCAEQQtPBEAgBEEPckEBaiIFEB4hBiADIAVBgICAgHhyNgIQIAMgBjYCCCADIAQ2AgwgBCAGaiEFDAELIAMgBDoAEyADQQhqIgYgBGohBSAERQ0BCyAGIAFBBGogBBArGgsgBUEAOgAAIAMgAjYCACADQRhqIANBCGogAyAAEQMAIAMoAhgQHSADKAIYIgAQBiADKAIAEAYgAywAE0EASARAIAMoAggQIwsgA0EgaiQAIAAPCxACAAsqAQF/QQwQHiIBQQA6AAQgASAAKAIANgIIIABBADYCACABQeAmNgIAIAELBQBBpDsLaQECfyMAQRBrIgYkACABIAAoAgQiB0EBdWohASAAKAIAIQAgBiABIAIgAyAEIAUgB0EBcQR/IAEoAgAgAGooAgAFIAALERAAQRAQHiIAIAYpAwg3AwggACAGKQMANwMAIAZBEGokACAACwUAQaA7Cx0AIAAoAgAiACAALQAAQfcBcUEIQQAgARtyOgAAC6oBAgJ/AX0jAEEQayICJAAgACgCACEAIAFB/wFxIgNBBkkEQAJ/AkACQAJAIANBBGsOAgABAgsgAEHUA2ogAC0AiANBA3FBAkYNAhogAEHMA2oMAgsgAEHMA2ogAC0AiANBA3FBAkYNARogAEHUA2oMAQsgACABQf8BcUECdGpBzANqCyoCACEEIAJBEGokACAEuw8LIAJB7hA2AgAgAEEFQdglIAIQLBAkAAuqAQICfwF9IwBBEGsiAiQAIAAoAgAhACABQf8BcSIDQQZJBEACfwJAAkACQCADQQRrDgIAAQILIABBxANqIAAtAIgDQQNxQQJGDQIaIABBvANqDAILIABBvANqIAAtAIgDQQNxQQJGDQEaIABBxANqDAELIAAgAUH/AXFBAnRqQbwDagsqAgAhBCACQRBqJAAgBLsPCyACQe4QNgIAIABBBUHYJSACECwQJAALqgECAn8BfSMAQRBrIgIkACAAKAIAIQAgAUH/AXEiA0EGSQRAAn8CQAJAAkAgA0EEaw4CAAECCyAAQbQDaiAALQCIA0EDcUECRg0CGiAAQawDagwCCyAAQawDaiAALQCIA0EDcUECRg0BGiAAQbQDagwBCyAAIAFB/wFxQQJ0akGsA2oLKgIAIQQgAkEQaiQAIAS7DwsgAkHuEDYCACAAQQVB2CUgAhAsECQAC08AIAAgASgCACIBKgKcA7s5AwAgACABKgKkA7s5AwggACABKgKgA7s5AxAgACABKgKoA7s5AxggACABKgKMA7s5AyAgACABKgKQA7s5AygLDAAgACgCACoCkAO7CwwAIAAoAgAqAowDuwsMACAAKAIAKgKoA7sLDAAgACgCACoCoAO7CwwAIAAoAgAqAqQDuwsMACAAKAIAKgKcA7sL6AMCBH0FfyMAQUBqIgokACAAKAIAIQAgCkEIakEAQTgQKhpB8DpB8DooAgBBAWo2AgAgABB4IAAtABRBA3EiCCADQQEgA0H/AXEbIAgbIQkgAEEUaiEIIAG2IQQgACoC+AMhBQJ9AkACQAJAIAAtAPwDQQFrDgIBAAILIAUgBJRDCtcjPJQhBQsgBUMAAAAAYEUNACAAIAlB/wFxQQAgBCAEEDEgCEECQQEgBBAiIAhBAkEBIAQQIZKSDAELIAggCUH/AXFBACAEIAQQLSIFIAVbBEBBAiELIAggCUH/AXFBACAEIAQQLQwBCyAEIARcIQsgBAshByACtiEFIAAqAoAEIQYgACAHAn0CQAJAAkAgAC0AhARBAWsOAgEAAgsgBiAFlEMK1yM8lCEGCyAGQwAAAABgRQ0AIAAgCUH/AXFBASAFIAQQMSAIQQBBASAEECIgCEEAQQEgBBAhkpIMAQsgCCAJQf8BcSIJQQEgBSAEEC0iBiAGWwRAQQIhDCAIIAlBASAFIAQQLQwBCyAFIAVcIQwgBQsgA0H/AXEgCyAMIAQgBUEBQQAgCkEIakEAQfA6KAIAED0EQCAAIAAtAIgDQQNxIAQgBRB2IABEAAAAAAAAAABEAAAAAAAAAAAQcwsgCkFAayQACw0AIAAoAgAtAABBAXELFQAgACgCACIAIAAtAABB/gFxOgAACxAAIAAoAgAtAABBBHFBAnYLegECfyMAQRBrIgEkACAAKAIAIgAoAggEQANAIAAtAAAiAkEEcUUEQCAAIAJBBHI6AAAgACgCECICBEAgACACEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQELCyABQRBqJAAPCyABQYAINgIAIABBBUHYJSABECwQJAALLgEBfyAAKAIIIQEgAEEANgIIIAEEQCABIAEoAgAoAgQRAAALIAAoAgBBADYCEAsXACAAKAIEKAIIIgAgACgCACgCCBEAAAsuAQF/IAAoAgghAiAAIAE2AgggAgRAIAIgAigCACgCBBEAAAsgACgCAEEFNgIQCz4BAX8gACgCBCEBIABBADYCBCABBEAgASABKAIAKAIEEQAACyAAKAIAIgBBADYCCCAAIAAtAABB7wFxOgAAC0kBAX8jAEEQayIGJAAgBiABKAIEKAIEIgEgAiADIAQgBSABKAIAKAIIERAAIAAgBisDALY4AgAgACAGKwMItjgCBCAGQRBqJAALcwECfyMAQRBrIgIkACAAKAIEIQMgACABNgIEIAMEQCADIAMoAgAoAgQRAAALIAAoAgAiACgC6AMgACgC7ANHBEAgAkH5IzYCACAAQQVB2CUgAhAsECQACyAAQQQ2AgggACAALQAAQRByOgAAIAJBEGokAAs8AQF/AkAgACgCACIAKALsAyAAKALoAyIAa0ECdSABTQ0AIAAgAUECdGooAgAiAEUNACAAKAIEIQILIAILGQAgACgCACgC5AMiAEUEQEEADwsgACgCBAsXACAAKAIAIgAoAuwDIAAoAugDa0ECdQuOAwEDfyMAQdACayICJAACQCAAKAIAIgAoAuwDIAAoAugDRg0AIAEoAgAiAygC5AMhASAAIAMQb0UNACAAIAFGBEAgAkEIakEAQcQCECoaIAJBADoAGCACQgA3AxAgAkGAgID+BzYCDCACQRxqQQBBxAEQKhogAkHgAWohBCACQSBqIQEDQCABQoCAgPyLgIDAv383AhAgAUKBgICAEDcCCCABQoCAgPyLgIDAv383AgAgAUEYaiIBIARHDQALIAJCgICA/IuAgMC/fzcD8AEgAkKBgICAEDcD6AEgAkKAgID8i4CAwL9/NwPgASACQoCAgP6HgIDg/wA3AoQCIAJCgICA/oeAgOD/ADcC/AEgAiACLQD4AUH4AXE6APgBIAJBjAJqQQBBwAAQKhogA0GYAWogAkEIakHEAhArGiADQQA2AuQDCwNAIAAtAAAiAUEEcQ0BIAAgAUEEcjoAACAAKAIQIgEEQCAAIAERAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLIAJB0AJqJAAL4AcBCH8jAEHQAGsiByQAIAAoAgAhAAJAAkAgASgCACIIKALkA0UEQCAAKAIIDQEgCC0AF0EQdEGAgDBxQYCAIEYEQCAAIAAoAuADQQFqNgLgAwsgACgC6AMiASACQQJ0aiEGAkAgACgC7AMiBCAAQfADaiIDKAIAIgVJBEAgBCAGRgRAIAYgCDYCACAAIAZBBGo2AuwDDAILIAQgBCICQQRrIgFLBEADQCACIAEoAgA2AgAgAkEEaiECIAFBBGoiASAESQ0ACwsgACACNgLsAyAGQQRqIgEgBEcEQCAEIAQgAWsiAUF8cWsgBiABEDMaCyAGIAg2AgAMAQsgBCABa0ECdUEBaiIEQYCAgIAETw0DAkAgB0EgakH/////AyAFIAFrIgFBAXUiBSAEIAQgBUkbIAFB/P///wdPGyACIAMQSiIDKAIIIgIgAygCDEcNACADKAIEIgEgAygCACIESwRAIAMgASABIARrQQJ1QQFqQX5tQQJ0IgRqIAEgAiABayIBEDMgAWoiAjYCCCADIAMoAgQgBGo2AgQMAQsgB0E4akEBIAIgBGtBAXUgAiAERhsiASABQQJ2IAMoAhAQSiIFKAIIIQQCfyADKAIIIgIgAygCBCIBRgRAIAQhAiABDAELIAQgAiABa2ohAgNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJHDQALIAMoAgghASADKAIECyEEIAMoAgAhCSADIAUoAgA2AgAgBSAJNgIAIAMgBSgCBDYCBCAFIAQ2AgQgAyACNgIIIAUgATYCCCADKAIMIQogAyAFKAIMNgIMIAUgCjYCDCABIARHBEAgBSABIAQgAWtBA2pBfHFqNgIICyAJRQ0AIAkQIyADKAIIIQILIAIgCDYCACADIAMoAghBBGo2AgggAyADKAIEIAYgACgC6AMiAWsiAmsgASACEDM2AgQgAygCCCAGIAAoAuwDIAZrIgQQMyEGIAAoAugDIQEgACADKAIENgLoAyADIAE2AgQgACgC7AMhAiAAIAQgBmo2AuwDIAMgAjYCCCAAKALwAyEEIAAgAygCDDYC8AMgAyABNgIAIAMgBDYCDCABIAJHBEAgAyACIAEgAmtBA2pBfHFqNgIICyABRQ0AIAEQIwsgCCAANgLkAwNAIAAtAAAiAUEEcUUEQCAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQELCyAHQdAAaiQADwsgB0HEIzYCECAAQQVB2CUgB0EQahAsECQACyAHQckkNgIAIABBBUHYJSAHECwQJAALEAIACxAAIAAoAgAtAABBAnFBAXYLWQIBfwF9IwBBEGsiAiQAIAJBCGogACgCACIAQfwAaiAAIAFB/wFxQQF0ai8BaBAfQwAAwH8hAwJAAkAgAi0ADA4EAQAAAQALIAIqAgghAwsgAkEQaiQAIAMLTgEBfyMAQRBrIgMkACADQQhqIAEoAgAiAUH8AGogASACQf8BcUEBdGovAUQQHyADLQAMIQEgACADKgIIuzkDCCAAIAE2AgAgA0EQaiQAC14CAX8BfCMAQRBrIgIkACACQQhqIAAoAgAiAEH8AGogACABQf8BcUEBdGovAVYQH0QAAAAAAAD4fyEDAkACQCACLQAMDgQBAAABAAsgAioCCLshAwsgAkEQaiQAIAMLJAEBfUMAAMB/IAAoAgAiAEH8AGogAC8BehAgIgEgASABXBu7C0QBAX8jAEEQayICJAAgAkEIaiABKAIAIgFB/ABqIAEvAXgQHyACLQAMIQEgACACKgIIuzkDCCAAIAE2AgAgAkEQaiQAC0QBAX8jAEEQayICJAAgAkEIaiABKAIAIgFB/ABqIAEvAXYQHyACLQAMIQEgACACKgIIuzkDCCAAIAE2AgAgAkEQaiQAC0QBAX8jAEEQayICJAAgAkEIaiABKAIAIgFB/ABqIAEvAXQQHyACLQAMIQEgACACKgIIuzkDCCAAIAE2AgAgAkEQaiQAC0QBAX8jAEEQayICJAAgAkEIaiABKAIAIgFB/ABqIAEvAXIQHyACLQAMIQEgACACKgIIuzkDCCAAIAE2AgAgAkEQaiQAC0QBAX8jAEEQayICJAAgAkEIaiABKAIAIgFB/ABqIAEvAXAQHyACLQAMIQEgACACKgIIuzkDCCAAIAE2AgAgAkEQaiQAC0QBAX8jAEEQayICJAAgAkEIaiABKAIAIgFB/ABqIAEvAW4QHyACLQAMIQEgACACKgIIuzkDCCAAIAE2AgAgAkEQaiQAC0gCAX8BfQJ9IAAoAgAiAEH8AGoiASAALwEcECAiAiACXARAQwAAgD9DAAAAACAAKAL0Ay0ACEEBcRsMAQsgASAALwEcECALuws2AgF/AX0gACgCACIAQfwAaiIBIAAvARoQICICIAJcBEBEAAAAAAAAAAAPCyABIAAvARoQILsLRAEBfyMAQRBrIgIkACACQQhqIAEoAgAiAUH8AGogAS8BHhAfIAItAAwhASAAIAIqAgi7OQMIIAAgATYCACACQRBqJAALEAAgACgCAC0AF0ECdkEDcQsNACAAKAIALQAXQQNxC04BAX8jAEEQayIDJAAgA0EIaiABKAIAIgFB/ABqIAEgAkH/AXFBAXRqLwEgEB8gAy0ADCEBIAAgAyoCCLs5AwggACABNgIAIANBEGokAAsQACAAKAIALQAUQQR2QQdxCw0AIAAoAgAvABVBDnYLDQAgACgCAC0AFEEDcQsQACAAKAIALQAUQQJ2QQNxCw0AIAAoAgAvABZBD3ELEAAgACgCAC8AFUEEdkEPcQsNACAAKAIALwAVQQ9xC04BAX8jAEEQayIDJAAgA0EIaiABKAIAIgFB/ABqIAEgAkH/AXFBAXRqLwEyEB8gAy0ADCEBIAAgAyoCCLs5AwggACABNgIAIANBEGokAAsQACAAKAIALwAVQQx2QQNxCxAAIAAoAgAtABdBBHZBAXELgQECA38BfSMAQRBrIgMkACAAKAIAIQQCfSACtiIGIAZcBEBBACEAQwAAwH8MAQtBAEECIAZDAACAf1sgBkMAAID/W3IiBRshAEMAAMB/IAYgBRsLIQYgAyAAOgAMIAMgBjgCCCADIAMpAwg3AwAgBCABQf8BcSADEIgBIANBEGokAAt5AgF9An8jAEEQayIEJAAgACgCACEFIAQCfyACtiIDIANcBEBDAADAfyEDQQAMAQtDAADAfyADIANDAACAf1sgA0MAAID/W3IiABshAyAARQs6AAwgBCADOAIIIAQgBCkDCDcDACAFIAFB/wFxIAQQiAEgBEEQaiQAC3EBAX8CQCAAKAIAIgAtAAAiAkECcUEBdiABRg0AIAAgAkH9AXFBAkEAIAEbcjoAAANAIAAtAAAiAUEEcQ0BIAAgAUEEcjoAACAAKAIQIgEEQCAAIAERAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLC4EBAgN/AX0jAEEQayIDJAAgACgCACEEAn0gArYiBiAGXARAQQAhAEMAAMB/DAELQQBBAiAGQwAAgH9bIAZDAACA/1tyIgUbIQBDAADAfyAGIAUbCyEGIAMgADoADCADIAY4AgggAyADKQMINwMAIAQgAUH/AXEgAxCOASADQRBqJAALeQIBfQJ/IwBBEGsiBCQAIAAoAgAhBSAEAn8gArYiAyADXARAQwAAwH8hA0EADAELQwAAwH8gAyADQwAAgH9bIANDAACA/1tyIgAbIQMgAEULOgAMIAQgAzgCCCAEIAQpAwg3AwAgBSABQf8BcSAEEI4BIARBEGokAAv5AQICfQR/IwBBEGsiBSQAIAAoAgAhAAJ/IAK2IgMgA1wEQEMAAMB/IQNBAAwBC0MAAMB/IAMgA0MAAIB/WyADQwAAgP9bciIGGyEDIAZFCyEGQQEhByAFQQhqIABB/ABqIgggACABQf8BcUEBdGpB1gBqIgEvAQAQHwJAAkAgAyAFKgIIIgRcBH8gBCAEWw0BIAMgA1wFIAcLRQ0AIAUtAAwgBkYNAQsgCCABIAMgBhA5A0AgAC0AACIBQQRxDQEgACABQQRyOgAAIAAoAhAiAQRAIAAgAREAAAsgAEGAgID+BzYCnAEgACgC5AMiAA0ACwsgBUEQaiQAC7UBAgN/An0CQCAAKAIAIgBB/ABqIgMgAEH6AGoiAi8BABAgIgYgAbYiBVsNACAFIAVbIgRFIAYgBlxxDQACQCAEIAVDAAAAAFsgBYtDAACAf1tyRXFFBEAgAiACLwEAQfj/A3E7AQAMAQsgAyACIAVBAxBMCwNAIAAtAAAiAkEEcQ0BIAAgAkEEcjoAACAAKAIQIgIEQCAAIAIRAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLC3wCA38BfSMAQRBrIgIkACAAKAIAIQMCfSABtiIFIAVcBEBBACEAQwAAwH8MAQtBAEECIAVDAACAf1sgBUMAAID/W3IiBBshAEMAAMB/IAUgBBsLIQUgAiAAOgAMIAIgBTgCCCACIAIpAwg3AwAgA0EBIAIQVSACQRBqJAALdAIBfQJ/IwBBEGsiAyQAIAAoAgAhBCADAn8gAbYiAiACXARAQwAAwH8hAkEADAELQwAAwH8gAiACQwAAgH9bIAJDAACA/1tyIgAbIQIgAEULOgAMIAMgAjgCCCADIAMpAwg3AwAgBEEBIAMQVSADQRBqJAALfAIDfwF9IwBBEGsiAiQAIAAoAgAhAwJ9IAG2IgUgBVwEQEEAIQBDAADAfwwBC0EAQQIgBUMAAIB/WyAFQwAAgP9bciIEGyEAQwAAwH8gBSAEGwshBSACIAA6AAwgAiAFOAIIIAIgAikDCDcDACADQQAgAhBVIAJBEGokAAt0AgF9An8jAEEQayIDJAAgACgCACEEIAMCfyABtiICIAJcBEBDAADAfyECQQAMAQtDAADAfyACIAJDAACAf1sgAkMAAID/W3IiABshAiAARQs6AAwgAyACOAIIIAMgAykDCDcDACAEQQAgAxBVIANBEGokAAt8AgN/AX0jAEEQayICJAAgACgCACEDAn0gAbYiBSAFXARAQQAhAEMAAMB/DAELQQBBAiAFQwAAgH9bIAVDAACA/1tyIgQbIQBDAADAfyAFIAQbCyEFIAIgADoADCACIAU4AgggAiACKQMINwMAIANBASACEFYgAkEQaiQAC3QCAX0CfyMAQRBrIgMkACAAKAIAIQQgAwJ/IAG2IgIgAlwEQEMAAMB/IQJBAAwBC0MAAMB/IAIgAkMAAIB/WyACQwAAgP9bciIAGyECIABFCzoADCADIAI4AgggAyADKQMINwMAIARBASADEFYgA0EQaiQAC3wCA38BfSMAQRBrIgIkACAAKAIAIQMCfSABtiIFIAVcBEBBACEAQwAAwH8MAQtBAEECIAVDAACAf1sgBUMAAID/W3IiBBshAEMAAMB/IAUgBBsLIQUgAiAAOgAMIAIgBTgCCCACIAIpAwg3AwAgA0EAIAIQViACQRBqJAALdAIBfQJ/IwBBEGsiAyQAIAAoAgAhBCADAn8gAbYiAiACXARAQwAAwH8hAkEADAELQwAAwH8gAiACQwAAgH9bIAJDAACA/1tyIgAbIQIgAEULOgAMIAMgAjgCCCADIAMpAwg3AwAgBEEAIAMQViADQRBqJAALPwEBfyMAQRBrIgEkACAAKAIAIQAgAUEDOgAMIAFBgICA/gc2AgggASABKQMINwMAIABBASABEEYgAUEQaiQAC3wCA38BfSMAQRBrIgIkACAAKAIAIQMCfSABtiIFIAVcBEBBACEAQwAAwH8MAQtBAEECIAVDAACAf1sgBUMAAID/W3IiBBshAEMAAMB/IAUgBBsLIQUgAiAAOgAMIAIgBTgCCCACIAIpAwg3AwAgA0EBIAIQRiACQRBqJAALdAIBfQJ/IwBBEGsiAyQAIAAoAgAhBCADAn8gAbYiAiACXARAQwAAwH8hAkEADAELQwAAwH8gAiACQwAAgH9bIAJDAACA/1tyIgAbIQIgAEULOgAMIAMgAjgCCCADIAMpAwg3AwAgBEEBIAMQRiADQRBqJAALPwEBfyMAQRBrIgEkACAAKAIAIQAgAUEDOgAMIAFBgICA/gc2AgggASABKQMINwMAIABBACABEEYgAUEQaiQAC3wCA38BfSMAQRBrIgIkACAAKAIAIQMCfSABtiIFIAVcBEBBACEAQwAAwH8MAQtBAEECIAVDAACAf1sgBUMAAID/W3IiBBshAEMAAMB/IAUgBBsLIQUgAiAAOgAMIAIgBTgCCCACIAIpAwg3AwAgA0EAIAIQRiACQRBqJAALdAIBfQJ/IwBBEGsiAyQAIAAoAgAhBCADAn8gAbYiAiACXARAQwAAwH8hAkEADAELQwAAwH8gAiACQwAAgH9bIAJDAACA/1tyIgAbIQIgAEULOgAMIAMgAjgCCCADIAMpAwg3AwAgBEEAIAMQRiADQRBqJAALoAECA38CfQJAIAAoAgAiAEH8AGoiAyAAQRxqIgIvAQAQICIGIAG2IgVbDQAgBSAFWyIERSAGIAZccQ0AAkAgBEUEQCACIAIvAQBB+P8DcTsBAAwBCyADIAIgBUEDEEwLA0AgAC0AACICQQRxDQEgACACQQRyOgAAIAAoAhAiAgRAIAAgAhEAAAsgAEGAgID+BzYCnAEgACgC5AMiAA0ACwsLoAECA38CfQJAIAAoAgAiAEH8AGoiAyAAQRpqIgIvAQAQICIGIAG2IgVbDQAgBSAFWyIERSAGIAZccQ0AAkAgBEUEQCACIAIvAQBB+P8DcTsBAAwBCyADIAIgBUEDEEwLA0AgAC0AACICQQRxDQEgACACQQRyOgAAIAAoAhAiAgRAIAAgAhEAAAsgAEGAgID+BzYCnAEgACgC5AMiAA0ACwsLPQEBfyMAQRBrIgEkACAAKAIAIQAgAUEDOgAMIAFBgICA/gc2AgggASABKQMINwMAIAAgARBrIAFBEGokAAt6AgN/AX0jAEEQayICJAAgACgCACEDAn0gAbYiBSAFXARAQQAhAEMAAMB/DAELQQBBAiAFQwAAgH9bIAVDAACA/1tyIgQbIQBDAADAfyAFIAQbCyEFIAIgADoADCACIAU4AgggAiACKQMINwMAIAMgAhBrIAJBEGokAAtyAgF9An8jAEEQayIDJAAgACgCACEEIAMCfyABtiICIAJcBEBDAADAfyECQQAMAQtDAADAfyACIAJDAACAf1sgAkMAAID/W3IiABshAiAARQs6AAwgAyACOAIIIAMgAykDCDcDACAEIAMQayADQRBqJAALoAECA38CfQJAIAAoAgAiAEH8AGoiAyAAQRhqIgIvAQAQICIGIAG2IgVbDQAgBSAFWyIERSAGIAZccQ0AAkAgBEUEQCACIAIvAQBB+P8DcTsBAAwBCyADIAIgBUEDEEwLA0AgAC0AACICQQRxDQEgACACQQRyOgAAIAAoAhAiAgRAIAAgAhEAAAsgAEGAgID+BzYCnAEgACgC5AMiAA0ACwsLkAEBAX8CQCAAKAIAIgBBF2otAAAiAkECdkEDcSABQf8BcUYNACAAIAAvABUgAkEQdHIiAjsAFSAAIAJB///PB3EgAUEDcUESdHJBEHY6ABcDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCwuNAQEBfwJAIAAoAgAiAEEXai0AACICQQNxIAFB/wFxRg0AIAAgAC8AFSACQRB0ciICOwAVIAAgAkH///MHcSABQQNxQRB0ckEQdjoAFwNAIAAtAAAiAUEEcQ0BIAAgAUEEcjoAACAAKAIQIgEEQCAAIAERAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLC0MBAX8jAEEQayICJAAgACgCACEAIAJBAzoADCACQYCAgP4HNgIIIAIgAikDCDcDACAAIAFB/wFxIAIQZSACQRBqJAALgAECA38BfSMAQRBrIgMkACAAKAIAIQQCfSACtiIGIAZcBEBBACEAQwAAwH8MAQtBAEECIAZDAACAf1sgBkMAAID/W3IiBRshAEMAAMB/IAYgBRsLIQYgAyAAOgAMIAMgBjgCCCADIAMpAwg3AwAgBCABQf8BcSADEGUgA0EQaiQAC3gCAX0CfyMAQRBrIgQkACAAKAIAIQUgBAJ/IAK2IgMgA1wEQEMAAMB/IQNBAAwBC0MAAMB/IAMgA0MAAIB/WyADQwAAgP9bciIAGyEDIABFCzoADCAEIAM4AgggBCAEKQMINwMAIAUgAUH/AXEgBBBlIARBEGokAAt3AQF/AkAgACgCACIALQAUIgJBBHZBB3EgAUH/AXFGDQAgACACQY8BcSABQQR0QfAAcXI6ABQDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCwuJAQEBfwJAIAFB/wFxIAAoAgAiAC8AFSICQQ52Rg0AIABBF2ogAiAALQAXQRB0ciICQRB2OgAAIAAgAkH//wBxIAFBDnRyOwAVA0AgAC0AACIBQQRxDQEgACABQQRyOgAAIAAoAhAiAQRAIAAgAREAAAsgAEGAgID+BzYCnAEgACgC5AMiAA0ACwsLcAEBfwJAIAAoAgAiAC0AFCICQQNxIAFB/wFxRg0AIAAgAkH8AXEgAUEDcXI6ABQDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCwt2AQF/AkAgACgCACIALQAUIgJBAnZBA3EgAUH/AXFGDQAgACACQfMBcSABQQJ0QQxxcjoAFANAIAAtAAAiAUEEcQ0BIAAgAUEEcjoAACAAKAIQIgEEQCAAIAERAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLC48BAQF/AkAgACgCACIALwAVIgJBCHZBD3EgAUH/AXFGDQAgAEEXaiACIAAtABdBEHRyIgJBEHY6AAAgACACQf/hA3EgAUEPcUEIdHI7ABUDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCwuPAQEBfwJAIAFB/wFxIAAoAgAiAC8AFSAAQRdqLQAAQRB0ciICQfABcUEEdkYNACAAIAJBEHY6ABcgACACQY/+A3EgAUEEdEHwAXFyOwAVA0AgAC0AACIBQQRxDQEgACABQQRyOgAAIAAoAhAiAQRAIAAgAREAAAsgAEGAgID+BzYCnAEgACgC5AMiAA0ACwsLhwEBAX8CQCAAKAIAIgAvABUgAEEXai0AAEEQdHIiAkEPcSABQf8BcUYNACAAIAJBEHY6ABcgACACQfD/A3EgAUEPcXI7ABUDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCwtDAQF/IwBBEGsiAiQAIAAoAgAhACACQQM6AAwgAkGAgID+BzYCCCACIAIpAwg3AwAgACABQf8BcSACEGcgAkEQaiQAC4ABAgN/AX0jAEEQayIDJAAgACgCACEEAn0gArYiBiAGXARAQQAhAEMAAMB/DAELQQBBAiAGQwAAgH9bIAZDAACA/1tyIgUbIQBDAADAfyAGIAUbCyEGIAMgADoADCADIAY4AgggAyADKQMINwMAIAQgAUH/AXEgAxBnIANBEGokAAt4AgF9An8jAEEQayIEJAAgACgCACEFIAQCfyACtiIDIANcBEBDAADAfyEDQQAMAQtDAADAfyADIANDAACAf1sgA0MAAID/W3IiABshAyAARQs6AAwgBCADOAIIIAQgBCkDCDcDACAFIAFB/wFxIAQQZyAEQRBqJAALjwEBAX8CQCAAKAIAIgAvABUiAkEMdkEDcSABQf8BcUYNACAAQRdqIAIgAC0AF0EQdHIiAkEQdjoAACAAIAJB/58DcSABQQNxQQx0cjsAFQNAIAAtAAAiAUEEcQ0BIAAgAUEEcjoAACAAKAIQIgEEQCAAIAERAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLC5ABAQF/AkAgACgCACIAQRdqLQAAIgJBBHZBAXEgAUH/AXFGDQAgACAALwAVIAJBEHRyIgI7ABUgACACQf//vwdxIAFBAXFBFHRyQRB2OgAXA0AgAC0AACIBQQRxDQEgACABQQRyOgAAIAAoAhAiAQRAIAAgAREAAAsgAEGAgID+BzYCnAEgACgC5AMiAA0ACwsL9g0CCH8CfSMAQRBrIgIkAAJAAkAgASgCACIFLQAUIAAoAgAiAS0AFHNB/wBxDQAgBS8AFSAFLQAXQRB0ciABLwAVIAEtABdBEHRyc0H//z9xDQAgBUH8AGohByABQfwAaiEIAkAgAS8AGCIAQQdxRQRAIAUtABhBB3FFDQELIAggABAgIgogByAFLwAYECAiC1sNACAKIApbIAsgC1tyDQELAkAgAS8AGiIAQQdxRQRAIAUtABpBB3FFDQELIAggABAgIgogByAFLwAaECAiC1sNACAKIApbIAsgC1tyDQELAkAgAS8AHCIAQQdxRQRAIAUtABxBB3FFDQELIAggABAgIgogByAFLwAcECAiC1sNACAKIApbIAsgC1tyDQELAkAgAS8AHiIAQQdxRQRAIAUtAB5BB3FFDQELIAJBCGogCCAAEB8gAiAHIAUvAB4QH0EBIQAgAioCCCIKIAIqAgAiC1wEfyAKIApbDQIgCyALXAUgAAtFDQEgAi0ADCACLQAERw0BCyAFQSBqIQAgAUEgaiEGA0ACQCAGIANBAXRqLwAAIgRBB3FFBEAgAC0AAEEHcUUNAQsgAkEIaiAIIAQQHyACIAcgAC8AABAfQQEhBCACKgIIIgogAioCACILXAR/IAogClsNAyALIAtcBSAEC0UNAiACLQAMIAItAARHDQILIABBAmohACADQQFqIgNBCUcNAAsgBUEyaiEAIAFBMmohBkEAIQMDQAJAIAYgA0EBdGovAAAiBEEHcUUEQCAALQAAQQdxRQ0BCyACQQhqIAggBBAfIAIgByAALwAAEB9BASEEIAIqAggiCiACKgIAIgtcBH8gCiAKWw0DIAsgC1wFIAQLRQ0CIAItAAwgAi0ABEcNAgsgAEECaiEAIANBAWoiA0EJRw0ACyAFQcQAaiEAIAFBxABqIQZBACEDA0ACQCAGIANBAXRqLwAAIgRBB3FFBEAgAC0AAEEHcUUNAQsgAkEIaiAIIAQQHyACIAcgAC8AABAfQQEhBCACKgIIIgogAioCACILXAR/IAogClsNAyALIAtcBSAEC0UNAiACLQAMIAItAARHDQILIABBAmohACADQQFqIgNBCUcNAAsgBUHWAGohACABQdYAaiEGQQAhAwNAAkAgBiADQQF0ai8AACIEQQdxRQRAIAAtAABBB3FFDQELIAJBCGogCCAEEB8gAiAHIAAvAAAQH0EBIQQgAioCCCIKIAIqAgAiC1wEfyAKIApbDQMgCyALXAUgBAtFDQIgAi0ADCACLQAERw0CCyAAQQJqIQAgA0EBaiIDQQlHDQALIAVB6ABqIQAgAUHoAGohBkEAIQMDQAJAIAYgA0EBdGovAAAiBEEHcUUEQCAALQAAQQdxRQ0BCyACQQhqIAggBBAfIAIgByAALwAAEB9BASEEIAIqAggiCiACKgIAIgtcBH8gCiAKWw0DIAsgC1wFIAQLRQ0CIAItAAwgAi0ABEcNAgsgAEECaiEAIANBAWoiA0EDRw0ACyAFQe4AaiEAIAFB7gBqIQlBACEEQQAhAwNAAkAgCSADQQF0ai8AACIGQQdxRQRAIAAtAABBB3FFDQELIAJBCGogCCAGEB8gAiAHIAAvAAAQH0EBIQMgAioCCCIKIAIqAgAiC1wEfyAKIApbDQMgCyALXAUgAwtFDQIgAi0ADCACLQAERw0CCyAAQQJqIQBBASEDIAQhBkEBIQQgBkUNAAsgBUHyAGohACABQfIAaiEJQQAhBEEAIQMDQAJAIAkgA0EBdGovAAAiBkEHcUUEQCAALQAAQQdxRQ0BCyACQQhqIAggBhAfIAIgByAALwAAEB9BASEDIAIqAggiCiACKgIAIgtcBH8gCiAKWw0DIAsgC1wFIAMLRQ0CIAItAAwgAi0ABEcNAgsgAEECaiEAQQEhAyAEIQZBASEEIAZFDQALIAVB9gBqIQAgAUH2AGohCUEAIQRBACEDA0ACQCAJIANBAXRqLwAAIgZBB3FFBEAgAC0AAEEHcUUNAQsgAkEIaiAIIAYQHyACIAcgAC8AABAfQQEhAyACKgIIIgogAioCACILXAR/IAogClsNAyALIAtcBSADC0UNAiACLQAMIAItAARHDQILIABBAmohAEEBIQMgBCEGQQEhBCAGRQ0ACyABLwB6IgBBB3FFBEAgBS0AekEHcUUNAgsgCCAAECAiCiAHIAUvAHoQICILWw0BIAogClsNACALIAtcDQELIAFBFGogBUEUakHoABArGiABQfwAaiAFQfwAahCgAQNAIAEtAAAiAEEEcQ0BIAEgAEEEcjoAACABKAIQIgAEQCABIAARAAALIAFBgICA/gc2ApwBIAEoAuQDIgENAAsLIAJBEGokAAvGAwEEfyMAQaAEayICJAAgACgCBCEBIABBADYCBCABBEAgASABKAIAKAIEEQAACyAAKAIIIQEgAEEANgIIIAEEQCABIAEoAgAoAgQRAAALAkAgACgCACIAKALoAyAAKALsA0YEQCAAKALkAw0BIAAgAkEYaiAAKAL0AxBcIgEpAgA3AgAgACABKAIQNgIQIAAgASkCCDcCCCAAQRRqIAFBFGpB6AAQKxogACABKQKMATcCjAEgACABKQKEATcChAEgACABKQJ8NwJ8IAEoApQBIQQgAUEANgKUASAAKAKUASEDIAAgBDYClAEgAwRAIAMQWwsgAEGYAWogAUGYAWpB0AIQKxogACgC6AMiAwRAIAAgAzYC7AMgAxAjCyAAIAEoAugDNgLoAyAAIAEoAuwDNgLsAyAAIAEoAvADNgLwAyABQQA2AvADIAFCADcC6AMgACABKQL8AzcC/AMgACABKQL0AzcC9AMgACABKAKEBDYChAQgASgClAEhACABQQA2ApQBIAAEQCAAEFsLIAJBoARqJAAPCyACQfAcNgIQIABBBUHYJSACQRBqECwQJAALIAJB5hE2AgAgAEEFQdglIAIQLBAkAAsLAEEMEB4gABCiAQsLAEEMEB5BABCiAQsNACAAKAIALQAIQQFxCwoAIAAoAgAoAhQLGQAgAUH/AXEEQBACAAsgACgCACgCEEEBcQsYACAAKAIAIgAgAC0ACEH+AXEgAXI6AAgLJgAgASAAKAIAIgAoAhRHBEAgACABNgIUIAAgACgCDEEBajYCDAsLkgEBAn8jAEEQayICJAAgACgCACEAIAFDAAAAAGAEQCABIAAqAhhcBEAgACABOAIYIAAgACgCDEEBajYCDAsgAkEQaiQADwsgAkGIFDYCACMAQRBrIgMkACADIAI2AgwCQCAARQRAQbgwQdglIAIQSRoMAQsgAEEAQQVB2CUgAiAAKAIEEQ0AGgsgA0EQaiQAECQACz8AIAFB/wFxRQRAIAIgACgCACIAKAIQIgFBAXFHBEAgACABQX5xIAJyNgIQIAAgACgCDEEBajYCDAsPCxACAAsL4CYjAEGACAuBHk9ubHkgbGVhZiBub2RlcyB3aXRoIGN1c3RvbSBtZWFzdXJlIGZ1bmN0aW9ucyBzaG91bGQgbWFudWFsbHkgbWFyayB0aGVtc2VsdmVzIGFzIGRpcnR5AGlzRGlydHkAbWFya0RpcnR5AGRlc3Ryb3kAc2V0RGlzcGxheQBnZXREaXNwbGF5AHNldEZsZXgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABzZXRGbGV4R3JvdwBnZXRGbGV4R3JvdwBzZXRPdmVyZmxvdwBnZXRPdmVyZmxvdwBoYXNOZXdMYXlvdXQAY2FsY3VsYXRlTGF5b3V0AGdldENvbXB1dGVkTGF5b3V0AHVuc2lnbmVkIHNob3J0AGdldENoaWxkQ291bnQAdW5zaWduZWQgaW50AHNldEp1c3RpZnlDb250ZW50AGdldEp1c3RpZnlDb250ZW50AGF2YWlsYWJsZUhlaWdodCBpcyBpbmRlZmluaXRlIHNvIGhlaWdodFNpemluZ01vZGUgbXVzdCBiZSBTaXppbmdNb2RlOjpNYXhDb250ZW50AGF2YWlsYWJsZVdpZHRoIGlzIGluZGVmaW5pdGUgc28gd2lkdGhTaXppbmdNb2RlIG11c3QgYmUgU2l6aW5nTW9kZTo6TWF4Q29udGVudABzZXRBbGlnbkNvbnRlbnQAZ2V0QWxpZ25Db250ZW50AGdldFBhcmVudABpbXBsZW1lbnQAc2V0TWF4SGVpZ2h0UGVyY2VudABzZXRIZWlnaHRQZXJjZW50AHNldE1pbkhlaWdodFBlcmNlbnQAc2V0RmxleEJhc2lzUGVyY2VudABzZXRHYXBQZXJjZW50AHNldFBvc2l0aW9uUGVyY2VudABzZXRNYXJnaW5QZXJjZW50AHNldE1heFdpZHRoUGVyY2VudABzZXRXaWR0aFBlcmNlbnQAc2V0TWluV2lkdGhQZXJjZW50AHNldFBhZGRpbmdQZXJjZW50AGhhbmRsZS50eXBlKCkgPT0gU3R5bGVWYWx1ZUhhbmRsZTo6VHlwZTo6UG9pbnQgfHwgaGFuZGxlLnR5cGUoKSA9PSBTdHlsZVZhbHVlSGFuZGxlOjpUeXBlOjpQZXJjZW50AGNyZWF0ZURlZmF1bHQAdW5pdAByaWdodABoZWlnaHQAc2V0TWF4SGVpZ2h0AGdldE1heEhlaWdodABzZXRIZWlnaHQAZ2V0SGVpZ2h0AHNldE1pbkhlaWdodABnZXRNaW5IZWlnaHQAZ2V0Q29tcHV0ZWRIZWlnaHQAZ2V0Q29tcHV0ZWRSaWdodABsZWZ0AGdldENvbXB1dGVkTGVmdAByZXNldABfX2Rlc3RydWN0AGZsb2F0AHVpbnQ2NF90AHVzZVdlYkRlZmF1bHRzAHNldFVzZVdlYkRlZmF1bHRzAHNldEFsaWduSXRlbXMAZ2V0QWxpZ25JdGVtcwBzZXRGbGV4QmFzaXMAZ2V0RmxleEJhc2lzAENhbm5vdCBnZXQgbGF5b3V0IHByb3BlcnRpZXMgb2YgbXVsdGktZWRnZSBzaG9ydGhhbmRzAHNldFBvaW50U2NhbGVGYWN0b3IATWVhc3VyZUNhbGxiYWNrV3JhcHBlcgBEaXJ0aWVkQ2FsbGJhY2tXcmFwcGVyAENhbm5vdCByZXNldCBhIG5vZGUgc3RpbGwgYXR0YWNoZWQgdG8gYSBvd25lcgBzZXRCb3JkZXIAZ2V0Qm9yZGVyAGdldENvbXB1dGVkQm9yZGVyAGdldE51bWJlcgBoYW5kbGUudHlwZSgpID09IFN0eWxlVmFsdWVIYW5kbGU6OlR5cGU6Ok51bWJlcgB1bnNpZ25lZCBjaGFyAHRvcABnZXRDb21wdXRlZFRvcABzZXRGbGV4V3JhcABnZXRGbGV4V3JhcABzZXRHYXAAZ2V0R2FwACVwAHNldEhlaWdodEF1dG8Ac2V0RmxleEJhc2lzQXV0bwBzZXRQb3NpdGlvbkF1dG8Ac2V0TWFyZ2luQXV0bwBzZXRXaWR0aEF1dG8AU2NhbGUgZmFjdG9yIHNob3VsZCBub3QgYmUgbGVzcyB0aGFuIHplcm8Ac2V0QXNwZWN0UmF0aW8AZ2V0QXNwZWN0UmF0aW8Ac2V0UG9zaXRpb24AZ2V0UG9zaXRpb24Abm90aWZ5T25EZXN0cnVjdGlvbgBzZXRGbGV4RGlyZWN0aW9uAGdldEZsZXhEaXJlY3Rpb24Ac2V0RGlyZWN0aW9uAGdldERpcmVjdGlvbgBzZXRNYXJnaW4AZ2V0TWFyZ2luAGdldENvbXB1dGVkTWFyZ2luAG1hcmtMYXlvdXRTZWVuAG5hbgBib3R0b20AZ2V0Q29tcHV0ZWRCb3R0b20AYm9vbABlbXNjcmlwdGVuOjp2YWwAc2V0RmxleFNocmluawBnZXRGbGV4U2hyaW5rAHNldEFsd2F5c0Zvcm1zQ29udGFpbmluZ0Jsb2NrAE1lYXN1cmVDYWxsYmFjawBEaXJ0aWVkQ2FsbGJhY2sAZ2V0TGVuZ3RoAHdpZHRoAHNldE1heFdpZHRoAGdldE1heFdpZHRoAHNldFdpZHRoAGdldFdpZHRoAHNldE1pbldpZHRoAGdldE1pbldpZHRoAGdldENvbXB1dGVkV2lkdGgAcHVzaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1NtYWxsVmFsdWVCdWZmZXIuaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1N0eWxlVmFsdWVQb29sLmgAdW5zaWduZWQgbG9uZwBzZXRCb3hTaXppbmcAZ2V0Qm94U2l6aW5nAHN0ZDo6d3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBzZXRQYWRkaW5nAGdldFBhZGRpbmcAZ2V0Q29tcHV0ZWRQYWRkaW5nAFRyaWVkIHRvIGNvbnN0cnVjdCBZR05vZGUgd2l0aCBudWxsIGNvbmZpZwBBdHRlbXB0aW5nIHRvIGNvbnN0cnVjdCBOb2RlIHdpdGggbnVsbCBjb25maWcAY3JlYXRlV2l0aENvbmZpZwBpbmYAc2V0QWxpZ25TZWxmAGdldEFsaWduU2VsZgBTaXplAHZhbHVlAFZhbHVlAGNyZWF0ZQBtZWFzdXJlAHNldFBvc2l0aW9uVHlwZQBnZXRQb3NpdGlvblR5cGUAaXNSZWZlcmVuY2VCYXNlbGluZQBzZXRJc1JlZmVyZW5jZUJhc2VsaW5lAGNvcHlTdHlsZQBkb3VibGUATm9kZQBleHRlbmQAaW5zZXJ0Q2hpbGQAZ2V0Q2hpbGQAcmVtb3ZlQ2hpbGQAdm9pZABzZXRFeHBlcmltZW50YWxGZWF0dXJlRW5hYmxlZABpc0V4cGVyaW1lbnRhbEZlYXR1cmVFbmFibGVkAGRpcnRpZWQAQ2Fubm90IHJlc2V0IGEgbm9kZSB3aGljaCBzdGlsbCBoYXMgY2hpbGRyZW4gYXR0YWNoZWQAdW5zZXRNZWFzdXJlRnVuYwB1bnNldERpcnRpZWRGdW5jAHNldEVycmF0YQBnZXRFcnJhdGEATWVhc3VyZSBmdW5jdGlvbiByZXR1cm5lZCBhbiBpbnZhbGlkIGRpbWVuc2lvbiB0byBZb2dhOiBbd2lkdGg9JWYsIGhlaWdodD0lZl0ARXhwZWN0IGN1c3RvbSBiYXNlbGluZSBmdW5jdGlvbiB0byBub3QgcmV0dXJuIE5hTgBOQU4ASU5GAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AQ2hpbGQgYWxyZWFkeSBoYXMgYSBvd25lciwgaXQgbXVzdCBiZSByZW1vdmVkIGZpcnN0LgBDYW5ub3Qgc2V0IG1lYXN1cmUgZnVuY3Rpb246IE5vZGVzIHdpdGggbWVhc3VyZSBmdW5jdGlvbnMgY2Fubm90IGhhdmUgY2hpbGRyZW4uAENhbm5vdCBhZGQgY2hpbGQ6IE5vZGVzIHdpdGggbWVhc3VyZSBmdW5jdGlvbnMgY2Fubm90IGhhdmUgY2hpbGRyZW4uAChudWxsKQBpbmRleCA8IDQwOTYgJiYgIlNtYWxsVmFsdWVCdWZmZXIgY2FuIG9ubHkgaG9sZCB1cCB0byA0MDk2IGNodW5rcyIAJXMKAAEAAAADAAAAAAAAAAIAAAADAAAAAQAAAAIAAAAAAAAAAQAAAAEAQYwmCwdpaQB2AHZpAEGgJgs3ox0AAKEdAADhHQAA2x0AAOEdAADbHQAAaWlpZmlmaQDUHQAApB0AAHZpaQClHQAA6B0AAGlpaQBB4CYLCcQAAADFAAAAxgBB9CYLDsQAAADHAAAAyAAAANQdAEGQJws+ox0AAOEdAADbHQAA4R0AANsdAADoHQAA4x0AAOgdAABpaWlpAAAAANQdAAC5HQAA1B0AALsdAAC8HQAA6B0AQdgnCwnJAAAAygAAAMsAQewnCxbJAAAAzAAAAMgAAAC/HQAA1B0AAL8dAEGQKAuiA9QdAAC/HQAA2x0AANUdAAB2aWlpaQAAANQdAAC/HQAA4R0AAHZpaWYAAAAA1B0AAL8dAADbHQAAdmlpaQAAAADUHQAAvx0AANUdAADVHQAAwB0AANsdAADbHQAAwB0AANUdAADAHQAAaQBkaWkAdmlpZAAAxB0AAMQdAAC/HQAA1B0AAMQdAADUHQAAxB0AAMMdAADUHQAAxB0AANsdAADUHQAAxB0AANsdAADiHQAAdmlpaWQAAADUHQAAxB0AAOIdAADbHQAAxR0AAMIdAADFHQAA2x0AAMIdAADFHQAA4h0AAMUdAADiHQAAxR0AANsdAABkaWlpAAAAAOEdAADEHQAA2x0AAGZpaWkAAAAA1B0AAMQdAADEHQAA3B0AANQdAADEHQAAxB0AANwdAADFHQAAxB0AAMQdAADEHQAAxB0AANwdAADUHQAAxB0AANUdAADVHQAAxB0AANQdAADEHQAAoR0AANQdAADEHQAAuR0AANUdAADFHQAAAAAAANQdAADEHQAA4h0AAOIdAADbHQAAdmlpZGRpAADBHQAAxR0AQcArC0EZAAoAGRkZAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABkAEQoZGRkDCgcAAQAJCxgAAAkGCwAACwAGGQAAABkZGQBBkSwLIQ4AAAAAAAAAABkACg0ZGRkADQAAAgAJDgAAAAkADgAADgBByywLAQwAQdcsCxUTAAAAABMAAAAACQwAAAAAAAwAAAwAQYUtCwEQAEGRLQsVDwAAAAQPAAAAAAkQAAAAAAAQAAAQAEG/LQsBEgBByy0LHhEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgBBgi4LDhoAAAAaGhoAAAAAAAAJAEGzLgsBFABBvy4LFRcAAAAAFwAAAAAJFAAAAAAAFAAAFABB7S4LARYAQfkuCycVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUYAQcQvCwHSAEHsLwsI//////////8AQbAwCwkQIgEAAAAAAAUAQcQwCwHNAEHcMAsKzgAAAM8AAAD8HQBB9DALAQIAQYQxCwj//////////wBByDELAQUAQdQxCwHQAEHsMQsOzgAAANEAAAAIHgAAAAQAQYQyCwEBAEGUMgsF/////woAQdgyCwHT";
    if (!ua(H)) {
      var va = H;
      H = h.locateFile ? h.locateFile(va, q) : q + va;
    }
    function wa() {
      var a = H;
      try {
        if (a == H && w)
          return new Uint8Array(w);
        if (ua(a))
          try {
            var b = xa(a.slice(37)), c = new Uint8Array(b.length);
            for (a = 0;a < b.length; ++a)
              c[a] = b.charCodeAt(a);
            var d = c;
          } catch (f) {
            throw Error("Converting base64 string to bytes failed.");
          }
        else
          d = undefined;
        var e = d;
        if (e)
          return e;
        throw "both async and sync fetching of the wasm failed";
      } catch (f) {
        x(f);
      }
    }
    function ya() {
      return w || typeof fetch != "function" ? Promise.resolve().then(function() {
        return wa();
      }) : fetch(H, { credentials: "same-origin" }).then(function(a) {
        if (!a.ok)
          throw "failed to load wasm binary file at '" + H + "'";
        return a.arrayBuffer();
      }).catch(function() {
        return wa();
      });
    }
    function za(a) {
      for (;0 < a.length; )
        a.shift()(h);
    }
    function Aa(a) {
      if (a === undefined)
        return "_unknown";
      a = a.replace(/[^a-zA-Z0-9_]/g, "$");
      var b = a.charCodeAt(0);
      return 48 <= b && 57 >= b ? "_" + a : a;
    }
    function Ba(a, b) {
      a = Aa(a);
      return function() {
        return b.apply(this, arguments);
      };
    }
    var J = [{}, { value: undefined }, { value: null }, { value: true }, { value: false }], Ca = [];
    function Da(a) {
      var b = Error, c = Ba(a, function(d) {
        this.name = a;
        this.message = d;
        d = Error(d).stack;
        d !== undefined && (this.stack = this.toString() + `
` + d.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      c.prototype = Object.create(b.prototype);
      c.prototype.constructor = c;
      c.prototype.toString = function() {
        return this.message === undefined ? this.name : this.name + ": " + this.message;
      };
      return c;
    }
    var K = undefined;
    function L(a) {
      throw new K(a);
    }
    var M = (a) => {
      a || L("Cannot use deleted val. handle = " + a);
      return J[a].value;
    }, Ea = (a) => {
      switch (a) {
        case undefined:
          return 1;
        case null:
          return 2;
        case true:
          return 3;
        case false:
          return 4;
        default:
          var b = Ca.length ? Ca.pop() : J.length;
          J[b] = { ga: 1, value: a };
          return b;
      }
    }, Fa = undefined, Ga = undefined;
    function N(a) {
      for (var b = "";A[a]; )
        b += Ga[A[a++]];
      return b;
    }
    var O = [];
    function Ha() {
      for (;O.length; ) {
        var a = O.pop();
        a.M.$ = false;
        a["delete"]();
      }
    }
    var P = undefined, Q = {};
    function Ia(a, b) {
      for (b === undefined && L("ptr should not be undefined");a.R; )
        b = a.ba(b), a = a.R;
      return b;
    }
    var R = {};
    function Ja(a) {
      a = Ka(a);
      var b = N(a);
      S(a);
      return b;
    }
    function La(a, b) {
      var c = R[a];
      c === undefined && L(b + " has unknown type " + Ja(a));
      return c;
    }
    function Ma() {}
    var Na = false;
    function Oa(a) {
      --a.count.value;
      a.count.value === 0 && (a.T ? a.U.W(a.T) : a.P.N.W(a.O));
    }
    function Pa(a, b, c) {
      if (b === c)
        return a;
      if (c.R === undefined)
        return null;
      a = Pa(a, b, c.R);
      return a === null ? null : c.na(a);
    }
    var Qa = {};
    function Ra(a, b) {
      b = Ia(a, b);
      return Q[b];
    }
    var Sa = undefined;
    function Ta(a) {
      throw new Sa(a);
    }
    function Ua(a, b) {
      b.P && b.O || Ta("makeClassHandle requires ptr and ptrType");
      !!b.U !== !!b.T && Ta("Both smartPtrType and smartPtr must be specified");
      b.count = { value: 1 };
      return T(Object.create(a, { M: { value: b } }));
    }
    function T(a) {
      if (typeof FinalizationRegistry === "undefined")
        return T = (b) => b, a;
      Na = new FinalizationRegistry((b) => {
        Oa(b.M);
      });
      T = (b) => {
        var c = b.M;
        c.T && Na.register(b, { M: c }, b);
        return b;
      };
      Ma = (b) => {
        Na.unregister(b);
      };
      return T(a);
    }
    var Va = {};
    function Wa(a) {
      for (;a.length; ) {
        var b = a.pop();
        a.pop()(b);
      }
    }
    function Xa(a) {
      return this.fromWireType(D[a >> 2]);
    }
    var U = {}, Ya = {};
    function V(a, b, c) {
      function d(k) {
        k = c(k);
        k.length !== a.length && Ta("Mismatched type converter count");
        for (var m = 0;m < a.length; ++m)
          W(a[m], k[m]);
      }
      a.forEach(function(k) {
        Ya[k] = b;
      });
      var e = Array(b.length), f = [], g = 0;
      b.forEach((k, m) => {
        R.hasOwnProperty(k) ? e[m] = R[k] : (f.push(k), U.hasOwnProperty(k) || (U[k] = []), U[k].push(() => {
          e[m] = R[k];
          ++g;
          g === f.length && d(e);
        }));
      });
      f.length === 0 && d(e);
    }
    function Za(a) {
      switch (a) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError("Unknown type size: " + a);
      }
    }
    function W(a, b, c = {}) {
      if (!("argPackAdvance" in b))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      var d = b.name;
      a || L('type "' + d + '" must have a positive integer typeid pointer');
      if (R.hasOwnProperty(a)) {
        if (c.ua)
          return;
        L("Cannot register type '" + d + "' twice");
      }
      R[a] = b;
      delete Ya[a];
      U.hasOwnProperty(a) && (b = U[a], delete U[a], b.forEach((e) => e()));
    }
    function $a(a) {
      L(a.M.P.N.name + " instance already deleted");
    }
    function X() {}
    function ab(a, b, c) {
      if (a[b].S === undefined) {
        var d = a[b];
        a[b] = function() {
          a[b].S.hasOwnProperty(arguments.length) || L("Function '" + c + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a[b].S + ")!");
          return a[b].S[arguments.length].apply(this, arguments);
        };
        a[b].S = [];
        a[b].S[d.Z] = d;
      }
    }
    function bb(a, b) {
      h.hasOwnProperty(a) ? (L("Cannot register public name '" + a + "' twice"), ab(h, a, a), h.hasOwnProperty(undefined) && L("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), h[a].S[undefined] = b) : h[a] = b;
    }
    function cb(a, b, c, d, e, f, g, k) {
      this.name = a;
      this.constructor = b;
      this.X = c;
      this.W = d;
      this.R = e;
      this.pa = f;
      this.ba = g;
      this.na = k;
      this.ja = [];
    }
    function db(a, b, c) {
      for (;b !== c; )
        b.ba || L("Expected null or instance of " + c.name + ", got an instance of " + b.name), a = b.ba(a), b = b.R;
      return a;
    }
    function eb(a, b) {
      if (b === null)
        return this.ea && L("null is not a valid " + this.name), 0;
      b.M || L('Cannot pass "' + fb(b) + '" as a ' + this.name);
      b.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      return db(b.M.O, b.M.P.N, this.N);
    }
    function gb(a, b) {
      if (b === null) {
        this.ea && L("null is not a valid " + this.name);
        if (this.da) {
          var c = this.fa();
          a !== null && a.push(this.W, c);
          return c;
        }
        return 0;
      }
      b.M || L('Cannot pass "' + fb(b) + '" as a ' + this.name);
      b.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      !this.ca && b.M.P.ca && L("Cannot convert argument of type " + (b.M.U ? b.M.U.name : b.M.P.name) + " to parameter type " + this.name);
      c = db(b.M.O, b.M.P.N, this.N);
      if (this.da)
        switch (b.M.T === undefined && L("Passing raw pointer to smart pointer is illegal"), this.Ba) {
          case 0:
            b.M.U === this ? c = b.M.T : L("Cannot convert argument of type " + (b.M.U ? b.M.U.name : b.M.P.name) + " to parameter type " + this.name);
            break;
          case 1:
            c = b.M.T;
            break;
          case 2:
            if (b.M.U === this)
              c = b.M.T;
            else {
              var d = b.clone();
              c = this.xa(c, Ea(function() {
                d["delete"]();
              }));
              a !== null && a.push(this.W, c);
            }
            break;
          default:
            L("Unsupporting sharing policy");
        }
      return c;
    }
    function hb(a, b) {
      if (b === null)
        return this.ea && L("null is not a valid " + this.name), 0;
      b.M || L('Cannot pass "' + fb(b) + '" as a ' + this.name);
      b.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      b.M.P.ca && L("Cannot convert argument of type " + b.M.P.name + " to parameter type " + this.name);
      return db(b.M.O, b.M.P.N, this.N);
    }
    function Y(a, b, c, d) {
      this.name = a;
      this.N = b;
      this.ea = c;
      this.ca = d;
      this.da = false;
      this.W = this.xa = this.fa = this.ka = this.Ba = this.wa = undefined;
      b.R !== undefined ? this.toWireType = gb : (this.toWireType = d ? eb : hb, this.V = null);
    }
    function ib(a, b) {
      h.hasOwnProperty(a) || Ta("Replacing nonexistant public symbol");
      h[a] = b;
      h[a].Z = undefined;
    }
    function jb(a, b) {
      var c = [];
      return function() {
        c.length = 0;
        Object.assign(c, arguments);
        if (a.includes("j")) {
          var d = h["dynCall_" + a];
          d = c && c.length ? d.apply(null, [b].concat(c)) : d.call(null, b);
        } else
          d = oa.get(b).apply(null, c);
        return d;
      };
    }
    function Z(a, b) {
      a = N(a);
      var c = a.includes("j") ? jb(a, b) : oa.get(b);
      typeof c != "function" && L("unknown function pointer with signature " + a + ": " + b);
      return c;
    }
    var mb = undefined;
    function nb(a, b) {
      function c(f) {
        e[f] || R[f] || (Ya[f] ? Ya[f].forEach(c) : (d.push(f), e[f] = true));
      }
      var d = [], e = {};
      b.forEach(c);
      throw new mb(a + ": " + d.map(Ja).join([", "]));
    }
    function ob(a, b, c, d, e) {
      var f = b.length;
      2 > f && L("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var g = b[1] !== null && c !== null, k = false;
      for (c = 1;c < b.length; ++c)
        if (b[c] !== null && b[c].V === undefined) {
          k = true;
          break;
        }
      var m = b[0].name !== "void", l = f - 2, n = Array(l), p = [], r = [];
      return function() {
        arguments.length !== l && L("function " + a + " called with " + arguments.length + " arguments, expected " + l + " args!");
        r.length = 0;
        p.length = g ? 2 : 1;
        p[0] = e;
        if (g) {
          var u = b[1].toWireType(r, this);
          p[1] = u;
        }
        for (var t = 0;t < l; ++t)
          n[t] = b[t + 2].toWireType(r, arguments[t]), p.push(n[t]);
        t = d.apply(null, p);
        if (k)
          Wa(r);
        else
          for (var y = g ? 1 : 2;y < b.length; y++) {
            var B = y === 1 ? u : n[y - 2];
            b[y].V !== null && b[y].V(B);
          }
        u = m ? b[0].fromWireType(t) : undefined;
        return u;
      };
    }
    function pb(a, b) {
      for (var c = [], d = 0;d < a; d++)
        c.push(E[b + 4 * d >> 2]);
      return c;
    }
    function qb(a) {
      4 < a && --J[a].ga === 0 && (J[a] = undefined, Ca.push(a));
    }
    function fb(a) {
      if (a === null)
        return "null";
      var b = typeof a;
      return b === "object" || b === "array" || b === "function" ? a.toString() : "" + a;
    }
    function rb(a, b) {
      switch (b) {
        case 2:
          return function(c) {
            return this.fromWireType(la[c >> 2]);
          };
        case 3:
          return function(c) {
            return this.fromWireType(ma[c >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + a);
      }
    }
    function sb(a, b, c) {
      switch (b) {
        case 0:
          return c ? function(d) {
            return ja[d];
          } : function(d) {
            return A[d];
          };
        case 1:
          return c ? function(d) {
            return C[d >> 1];
          } : function(d) {
            return ka[d >> 1];
          };
        case 2:
          return c ? function(d) {
            return D[d >> 2];
          } : function(d) {
            return E[d >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + a);
      }
    }
    function tb(a, b) {
      for (var c = "", d = 0;!(d >= b / 2); ++d) {
        var e = C[a + 2 * d >> 1];
        if (e == 0)
          break;
        c += String.fromCharCode(e);
      }
      return c;
    }
    function ub(a, b, c) {
      c === undefined && (c = 2147483647);
      if (2 > c)
        return 0;
      c -= 2;
      var d = b;
      c = c < 2 * a.length ? c / 2 : a.length;
      for (var e = 0;e < c; ++e)
        C[b >> 1] = a.charCodeAt(e), b += 2;
      C[b >> 1] = 0;
      return b - d;
    }
    function vb(a) {
      return 2 * a.length;
    }
    function wb(a, b) {
      for (var c = 0, d = "";!(c >= b / 4); ) {
        var e = D[a + 4 * c >> 2];
        if (e == 0)
          break;
        ++c;
        65536 <= e ? (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023)) : d += String.fromCharCode(e);
      }
      return d;
    }
    function xb(a, b, c) {
      c === undefined && (c = 2147483647);
      if (4 > c)
        return 0;
      var d = b;
      c = d + c - 4;
      for (var e = 0;e < a.length; ++e) {
        var f = a.charCodeAt(e);
        if (55296 <= f && 57343 >= f) {
          var g = a.charCodeAt(++e);
          f = 65536 + ((f & 1023) << 10) | g & 1023;
        }
        D[b >> 2] = f;
        b += 4;
        if (b + 4 > c)
          break;
      }
      D[b >> 2] = 0;
      return b - d;
    }
    function yb(a) {
      for (var b = 0, c = 0;c < a.length; ++c) {
        var d = a.charCodeAt(c);
        55296 <= d && 57343 >= d && ++c;
        b += 4;
      }
      return b;
    }
    var zb = {};
    function Ab(a) {
      var b = zb[a];
      return b === undefined ? N(a) : b;
    }
    var Bb = [];
    function Cb(a) {
      var b = Bb.length;
      Bb.push(a);
      return b;
    }
    function Db(a, b) {
      for (var c = Array(a), d = 0;d < a; ++d)
        c[d] = La(E[b + 4 * d >> 2], "parameter " + d);
      return c;
    }
    var Eb = [], Fb = [null, [], []];
    K = h.BindingError = Da("BindingError");
    h.count_emval_handles = function() {
      for (var a = 0, b = 5;b < J.length; ++b)
        J[b] !== undefined && ++a;
      return a;
    };
    h.get_first_emval = function() {
      for (var a = 5;a < J.length; ++a)
        if (J[a] !== undefined)
          return J[a];
      return null;
    };
    Fa = h.PureVirtualError = Da("PureVirtualError");
    for (var Gb = Array(256), Hb = 0;256 > Hb; ++Hb)
      Gb[Hb] = String.fromCharCode(Hb);
    Ga = Gb;
    h.getInheritedInstanceCount = function() {
      return Object.keys(Q).length;
    };
    h.getLiveInheritedInstances = function() {
      var a = [], b;
      for (b in Q)
        Q.hasOwnProperty(b) && a.push(Q[b]);
      return a;
    };
    h.flushPendingDeletes = Ha;
    h.setDelayFunction = function(a) {
      P = a;
      O.length && P && P(Ha);
    };
    Sa = h.InternalError = Da("InternalError");
    X.prototype.isAliasOf = function(a) {
      if (!(this instanceof X && a instanceof X))
        return false;
      var b = this.M.P.N, c = this.M.O, d = a.M.P.N;
      for (a = a.M.O;b.R; )
        c = b.ba(c), b = b.R;
      for (;d.R; )
        a = d.ba(a), d = d.R;
      return b === d && c === a;
    };
    X.prototype.clone = function() {
      this.M.O || $a(this);
      if (this.M.aa)
        return this.M.count.value += 1, this;
      var a = T, b = Object, c = b.create, d = Object.getPrototypeOf(this), e = this.M;
      a = a(c.call(b, d, { M: { value: { count: e.count, $: e.$, aa: e.aa, O: e.O, P: e.P, T: e.T, U: e.U } } }));
      a.M.count.value += 1;
      a.M.$ = false;
      return a;
    };
    X.prototype["delete"] = function() {
      this.M.O || $a(this);
      this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
      Ma(this);
      Oa(this.M);
      this.M.aa || (this.M.T = undefined, this.M.O = undefined);
    };
    X.prototype.isDeleted = function() {
      return !this.M.O;
    };
    X.prototype.deleteLater = function() {
      this.M.O || $a(this);
      this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
      O.push(this);
      O.length === 1 && P && P(Ha);
      this.M.$ = true;
      return this;
    };
    Y.prototype.qa = function(a) {
      this.ka && (a = this.ka(a));
      return a;
    };
    Y.prototype.ha = function(a) {
      this.W && this.W(a);
    };
    Y.prototype.argPackAdvance = 8;
    Y.prototype.readValueFromPointer = Xa;
    Y.prototype.deleteObject = function(a) {
      if (a !== null)
        a["delete"]();
    };
    Y.prototype.fromWireType = function(a) {
      function b() {
        return this.da ? Ua(this.N.X, { P: this.wa, O: c, U: this, T: a }) : Ua(this.N.X, { P: this, O: a });
      }
      var c = this.qa(a);
      if (!c)
        return this.ha(a), null;
      var d = Ra(this.N, c);
      if (d !== undefined) {
        if (d.M.count.value === 0)
          return d.M.O = c, d.M.T = a, d.clone();
        d = d.clone();
        this.ha(a);
        return d;
      }
      d = this.N.pa(c);
      d = Qa[d];
      if (!d)
        return b.call(this);
      d = this.ca ? d.la : d.pointerType;
      var e = Pa(c, this.N, d.N);
      return e === null ? b.call(this) : this.da ? Ua(d.N.X, { P: d, O: e, U: this, T: a }) : Ua(d.N.X, { P: d, O: e });
    };
    mb = h.UnboundTypeError = Da("UnboundTypeError");
    var xa = typeof atob == "function" ? atob : function(a) {
      var b = "", c = 0;
      a = a.replace(/[^A-Za-z0-9\+\/=]/g, "");
      do {
        var d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(c++));
        var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(c++));
        var f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(c++));
        var g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(c++));
        d = d << 2 | e >> 4;
        e = (e & 15) << 4 | f >> 2;
        var k = (f & 3) << 6 | g;
        b += String.fromCharCode(d);
        f !== 64 && (b += String.fromCharCode(e));
        g !== 64 && (b += String.fromCharCode(k));
      } while (c < a.length);
      return b;
    }, Jb = {
      l: function(a, b, c, d) {
        x("Assertion failed: " + (a ? z(A, a) : "") + ", at: " + [b ? b ? z(A, b) : "" : "unknown filename", c, d ? d ? z(A, d) : "" : "unknown function"]);
      },
      q: function(a, b, c) {
        a = N(a);
        b = La(b, "wrapper");
        c = M(c);
        var d = [].slice, e = b.N, f = e.X, g = e.R.X, k = e.R.constructor;
        a = Ba(a, function() {
          e.R.ja.forEach(function(l) {
            if (this[l] === g[l])
              throw new Fa("Pure virtual function " + l + " must be implemented in JavaScript");
          }.bind(this));
          Object.defineProperty(this, "__parent", { value: f });
          this.__construct.apply(this, d.call(arguments));
        });
        f.__construct = function() {
          this === f && L("Pass correct 'this' to __construct");
          var l = k.implement.apply(undefined, [this].concat(d.call(arguments)));
          Ma(l);
          var n = l.M;
          l.notifyOnDestruction();
          n.aa = true;
          Object.defineProperties(this, { M: { value: n } });
          T(this);
          l = n.O;
          l = Ia(e, l);
          Q.hasOwnProperty(l) ? L("Tried to register registered instance: " + l) : Q[l] = this;
        };
        f.__destruct = function() {
          this === f && L("Pass correct 'this' to __destruct");
          Ma(this);
          var l = this.M.O;
          l = Ia(e, l);
          Q.hasOwnProperty(l) ? delete Q[l] : L("Tried to unregister unregistered instance: " + l);
        };
        a.prototype = Object.create(f);
        for (var m in c)
          a.prototype[m] = c[m];
        return Ea(a);
      },
      j: function(a) {
        var b = Va[a];
        delete Va[a];
        var { fa: c, W: d, ia: e } = b, f = e.map((g) => g.ta).concat(e.map((g) => g.za));
        V([a], f, (g) => {
          var k = {};
          e.forEach((m, l) => {
            var n = g[l], p = m.ra, r = m.sa, u = g[l + e.length], t = m.ya, y = m.Aa;
            k[m.oa] = { read: (B) => n.fromWireType(p(r, B)), write: (B, ba) => {
              var I = [];
              t(y, B, u.toWireType(I, ba));
              Wa(I);
            } };
          });
          return [{ name: b.name, fromWireType: function(m) {
            var l = {}, n;
            for (n in k)
              l[n] = k[n].read(m);
            d(m);
            return l;
          }, toWireType: function(m, l) {
            for (var n in k)
              if (!(n in l))
                throw new TypeError('Missing field:  "' + n + '"');
            var p = c();
            for (n in k)
              k[n].write(p, l[n]);
            m !== null && m.push(d, p);
            return p;
          }, argPackAdvance: 8, readValueFromPointer: Xa, V: d }];
        });
      },
      v: function() {},
      B: function(a, b, c, d, e) {
        var f = Za(c);
        b = N(b);
        W(a, {
          name: b,
          fromWireType: function(g) {
            return !!g;
          },
          toWireType: function(g, k) {
            return k ? d : e;
          },
          argPackAdvance: 8,
          readValueFromPointer: function(g) {
            if (c === 1)
              var k = ja;
            else if (c === 2)
              k = C;
            else if (c === 4)
              k = D;
            else
              throw new TypeError("Unknown boolean type size: " + b);
            return this.fromWireType(k[g >> f]);
          },
          V: null
        });
      },
      f: function(a, b, c, d, e, f, g, k, m, l, n, p, r) {
        n = N(n);
        f = Z(e, f);
        k && (k = Z(g, k));
        l && (l = Z(m, l));
        r = Z(p, r);
        var u = Aa(n);
        bb(u, function() {
          nb("Cannot construct " + n + " due to unbound types", [d]);
        });
        V([a, b, c], d ? [d] : [], function(t) {
          t = t[0];
          if (d) {
            var y = t.N;
            var B = y.X;
          } else
            B = X.prototype;
          t = Ba(u, function() {
            if (Object.getPrototypeOf(this) !== ba)
              throw new K("Use 'new' to construct " + n);
            if (I.Y === undefined)
              throw new K(n + " has no accessible constructor");
            var kb = I.Y[arguments.length];
            if (kb === undefined)
              throw new K("Tried to invoke ctor of " + n + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(I.Y).toString() + ") parameters instead!");
            return kb.apply(this, arguments);
          });
          var ba = Object.create(B, { constructor: { value: t } });
          t.prototype = ba;
          var I = new cb(n, t, ba, r, y, f, k, l);
          y = new Y(n, I, true, false);
          B = new Y(n + "*", I, false, false);
          var lb = new Y(n + " const*", I, false, true);
          Qa[a] = {
            pointerType: B,
            la: lb
          };
          ib(u, t);
          return [y, B, lb];
        });
      },
      d: function(a, b, c, d, e, f, g) {
        var k = pb(c, d);
        b = N(b);
        f = Z(e, f);
        V([], [a], function(m) {
          function l() {
            nb("Cannot call " + n + " due to unbound types", k);
          }
          m = m[0];
          var n = m.name + "." + b;
          b.startsWith("@@") && (b = Symbol[b.substring(2)]);
          var p = m.N.constructor;
          p[b] === undefined ? (l.Z = c - 1, p[b] = l) : (ab(p, b, n), p[b].S[c - 1] = l);
          V([], k, function(r) {
            r = ob(n, [r[0], null].concat(r.slice(1)), null, f, g);
            p[b].S === undefined ? (r.Z = c - 1, p[b] = r) : p[b].S[c - 1] = r;
            return [];
          });
          return [];
        });
      },
      p: function(a, b, c, d, e, f) {
        0 < b || x();
        var g = pb(b, c);
        e = Z(d, e);
        V([], [a], function(k) {
          k = k[0];
          var m = "constructor " + k.name;
          k.N.Y === undefined && (k.N.Y = []);
          if (k.N.Y[b - 1] !== undefined)
            throw new K("Cannot register multiple constructors with identical number of parameters (" + (b - 1) + ") for class '" + k.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          k.N.Y[b - 1] = () => {
            nb("Cannot construct " + k.name + " due to unbound types", g);
          };
          V([], g, function(l) {
            l.splice(1, 0, null);
            k.N.Y[b - 1] = ob(m, l, null, e, f);
            return [];
          });
          return [];
        });
      },
      a: function(a, b, c, d, e, f, g, k) {
        var m = pb(c, d);
        b = N(b);
        f = Z(e, f);
        V([], [a], function(l) {
          function n() {
            nb("Cannot call " + p + " due to unbound types", m);
          }
          l = l[0];
          var p = l.name + "." + b;
          b.startsWith("@@") && (b = Symbol[b.substring(2)]);
          k && l.N.ja.push(b);
          var r = l.N.X, u = r[b];
          u === undefined || u.S === undefined && u.className !== l.name && u.Z === c - 2 ? (n.Z = c - 2, n.className = l.name, r[b] = n) : (ab(r, b, p), r[b].S[c - 2] = n);
          V([], m, function(t) {
            t = ob(p, t, l, f, g);
            r[b].S === undefined ? (t.Z = c - 2, r[b] = t) : r[b].S[c - 2] = t;
            return [];
          });
          return [];
        });
      },
      A: function(a, b) {
        b = N(b);
        W(a, { name: b, fromWireType: function(c) {
          var d = M(c);
          qb(c);
          return d;
        }, toWireType: function(c, d) {
          return Ea(d);
        }, argPackAdvance: 8, readValueFromPointer: Xa, V: null });
      },
      n: function(a, b, c) {
        c = Za(c);
        b = N(b);
        W(a, { name: b, fromWireType: function(d) {
          return d;
        }, toWireType: function(d, e) {
          return e;
        }, argPackAdvance: 8, readValueFromPointer: rb(b, c), V: null });
      },
      e: function(a, b, c, d, e) {
        b = N(b);
        e === -1 && (e = 4294967295);
        e = Za(c);
        var f = (k) => k;
        if (d === 0) {
          var g = 32 - 8 * c;
          f = (k) => k << g >>> g;
        }
        c = b.includes("unsigned") ? function(k, m) {
          return m >>> 0;
        } : function(k, m) {
          return m;
        };
        W(a, { name: b, fromWireType: f, toWireType: c, argPackAdvance: 8, readValueFromPointer: sb(b, e, d !== 0), V: null });
      },
      b: function(a, b, c) {
        function d(f) {
          f >>= 2;
          var g = E;
          return new e(ia, g[f + 1], g[f]);
        }
        var e = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b];
        c = N(c);
        W(a, { name: c, fromWireType: d, argPackAdvance: 8, readValueFromPointer: d }, { ua: true });
      },
      o: function(a, b) {
        b = N(b);
        var c = b === "std::string";
        W(a, { name: b, fromWireType: function(d) {
          var e = E[d >> 2], f = d + 4;
          if (c)
            for (var g = f, k = 0;k <= e; ++k) {
              var m = f + k;
              if (k == e || A[m] == 0) {
                g = g ? z(A, g, m - g) : "";
                if (l === undefined)
                  var l = g;
                else
                  l += String.fromCharCode(0), l += g;
                g = m + 1;
              }
            }
          else {
            l = Array(e);
            for (k = 0;k < e; ++k)
              l[k] = String.fromCharCode(A[f + k]);
            l = l.join("");
          }
          S(d);
          return l;
        }, toWireType: function(d, e) {
          e instanceof ArrayBuffer && (e = new Uint8Array(e));
          var f, g = typeof e == "string";
          g || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int8Array || L("Cannot pass non-string to std::string");
          if (c && g) {
            var k = 0;
            for (f = 0;f < e.length; ++f) {
              var m = e.charCodeAt(f);
              127 >= m ? k++ : 2047 >= m ? k += 2 : 55296 <= m && 57343 >= m ? (k += 4, ++f) : k += 3;
            }
            f = k;
          } else
            f = e.length;
          k = Ib(4 + f + 1);
          m = k + 4;
          E[k >> 2] = f;
          if (c && g) {
            if (g = m, m = f + 1, f = A, 0 < m) {
              m = g + m - 1;
              for (var l = 0;l < e.length; ++l) {
                var n = e.charCodeAt(l);
                if (55296 <= n && 57343 >= n) {
                  var p = e.charCodeAt(++l);
                  n = 65536 + ((n & 1023) << 10) | p & 1023;
                }
                if (127 >= n) {
                  if (g >= m)
                    break;
                  f[g++] = n;
                } else {
                  if (2047 >= n) {
                    if (g + 1 >= m)
                      break;
                    f[g++] = 192 | n >> 6;
                  } else {
                    if (65535 >= n) {
                      if (g + 2 >= m)
                        break;
                      f[g++] = 224 | n >> 12;
                    } else {
                      if (g + 3 >= m)
                        break;
                      f[g++] = 240 | n >> 18;
                      f[g++] = 128 | n >> 12 & 63;
                    }
                    f[g++] = 128 | n >> 6 & 63;
                  }
                  f[g++] = 128 | n & 63;
                }
              }
              f[g] = 0;
            }
          } else if (g)
            for (g = 0;g < f; ++g)
              l = e.charCodeAt(g), 255 < l && (S(m), L("String has UTF-16 code units that do not fit in 8 bits")), A[m + g] = l;
          else
            for (g = 0;g < f; ++g)
              A[m + g] = e[g];
          d !== null && d.push(S, k);
          return k;
        }, argPackAdvance: 8, readValueFromPointer: Xa, V: function(d) {
          S(d);
        } });
      },
      i: function(a, b, c) {
        c = N(c);
        if (b === 2) {
          var d = tb;
          var e = ub;
          var f = vb;
          var g = () => ka;
          var k = 1;
        } else
          b === 4 && (d = wb, e = xb, f = yb, g = () => E, k = 2);
        W(a, { name: c, fromWireType: function(m) {
          for (var l = E[m >> 2], n = g(), p, r = m + 4, u = 0;u <= l; ++u) {
            var t = m + 4 + u * b;
            if (u == l || n[t >> k] == 0)
              r = d(r, t - r), p === undefined ? p = r : (p += String.fromCharCode(0), p += r), r = t + b;
          }
          S(m);
          return p;
        }, toWireType: function(m, l) {
          typeof l != "string" && L("Cannot pass non-string to C++ string type " + c);
          var n = f(l), p = Ib(4 + n + b);
          E[p >> 2] = n >> k;
          e(l, p + 4, n + b);
          m !== null && m.push(S, p);
          return p;
        }, argPackAdvance: 8, readValueFromPointer: Xa, V: function(m) {
          S(m);
        } });
      },
      k: function(a, b, c, d, e, f) {
        Va[a] = { name: N(b), fa: Z(c, d), W: Z(e, f), ia: [] };
      },
      h: function(a, b, c, d, e, f, g, k, m, l) {
        Va[a].ia.push({ oa: N(b), ta: c, ra: Z(d, e), sa: f, za: g, ya: Z(k, m), Aa: l });
      },
      C: function(a, b) {
        b = N(b);
        W(a, {
          va: true,
          name: b,
          argPackAdvance: 0,
          fromWireType: function() {},
          toWireType: function() {}
        });
      },
      s: function(a, b, c, d, e) {
        a = Bb[a];
        b = M(b);
        c = Ab(c);
        var f = [];
        E[d >> 2] = Ea(f);
        return a(b, c, f, e);
      },
      t: function(a, b, c, d) {
        a = Bb[a];
        b = M(b);
        c = Ab(c);
        a(b, c, null, d);
      },
      g: qb,
      m: function(a, b) {
        var c = Db(a, b), d = c[0];
        b = d.name + "_$" + c.slice(1).map(function(g) {
          return g.name;
        }).join("_") + "$";
        var e = Eb[b];
        if (e !== undefined)
          return e;
        var f = Array(a - 1);
        e = Cb((g, k, m, l) => {
          for (var n = 0, p = 0;p < a - 1; ++p)
            f[p] = c[p + 1].readValueFromPointer(l + n), n += c[p + 1].argPackAdvance;
          g = g[k].apply(g, f);
          for (p = 0;p < a - 1; ++p)
            c[p + 1].ma && c[p + 1].ma(f[p]);
          if (!d.va)
            return d.toWireType(m, g);
        });
        return Eb[b] = e;
      },
      D: function(a) {
        4 < a && (J[a].ga += 1);
      },
      r: function(a) {
        var b = M(a);
        Wa(b);
        qb(a);
      },
      c: function() {
        x("");
      },
      x: function(a, b, c) {
        A.copyWithin(a, b, b + c);
      },
      w: function(a) {
        var b = A.length;
        a >>>= 0;
        if (2147483648 < a)
          return false;
        for (var c = 1;4 >= c; c *= 2) {
          var d = b * (1 + 0.2 / c);
          d = Math.min(d, a + 100663296);
          var e = Math;
          d = Math.max(a, d);
          e = e.min.call(e, 2147483648, d + (65536 - d % 65536) % 65536);
          a: {
            try {
              fa.grow(e - ia.byteLength + 65535 >>> 16);
              na();
              var f = 1;
              break a;
            } catch (g) {}
            f = undefined;
          }
          if (f)
            return true;
        }
        return false;
      },
      z: function() {
        return 52;
      },
      u: function() {
        return 70;
      },
      y: function(a, b, c, d) {
        for (var e = 0, f = 0;f < c; f++) {
          var g = E[b >> 2], k = E[b + 4 >> 2];
          b += 8;
          for (var m = 0;m < k; m++) {
            var l = A[g + m], n = Fb[a];
            l === 0 || l === 10 ? ((a === 1 ? ea : v)(z(n, 0)), n.length = 0) : n.push(l);
          }
          e += k;
        }
        E[d >> 2] = e;
        return 0;
      }
    };
    (function() {
      function a(e) {
        h.asm = e.exports;
        fa = h.asm.E;
        na();
        oa = h.asm.J;
        qa.unshift(h.asm.F);
        F--;
        h.monitorRunDependencies && h.monitorRunDependencies(F);
        F == 0 && (ta !== null && (clearInterval(ta), ta = null), G && (e = G, G = null, e()));
      }
      function b(e) {
        a(e.instance);
      }
      function c(e) {
        return ya().then(function(f) {
          return WebAssembly.instantiate(f, d);
        }).then(function(f) {
          return f;
        }).then(e, function(f) {
          v("failed to asynchronously prepare wasm: " + f);
          x(f);
        });
      }
      var d = { a: Jb };
      F++;
      h.monitorRunDependencies && h.monitorRunDependencies(F);
      if (h.instantiateWasm)
        try {
          return h.instantiateWasm(d, a);
        } catch (e) {
          v("Module.instantiateWasm callback failed with error: " + e), ca(e);
        }
      (function() {
        return w || typeof WebAssembly.instantiateStreaming != "function" || ua(H) || typeof fetch != "function" ? c(b) : fetch(H, { credentials: "same-origin" }).then(function(e) {
          return WebAssembly.instantiateStreaming(e, d).then(b, function(f) {
            v("wasm streaming compile failed: " + f);
            v("falling back to ArrayBuffer instantiation");
            return c(b);
          });
        });
      })().catch(ca);
      return {};
    })();
    h.___wasm_call_ctors = function() {
      return (h.___wasm_call_ctors = h.asm.F).apply(null, arguments);
    };
    var Ka = h.___getTypeName = function() {
      return (Ka = h.___getTypeName = h.asm.G).apply(null, arguments);
    };
    h.__embind_initialize_bindings = function() {
      return (h.__embind_initialize_bindings = h.asm.H).apply(null, arguments);
    };
    var Ib = h._malloc = function() {
      return (Ib = h._malloc = h.asm.I).apply(null, arguments);
    }, S = h._free = function() {
      return (S = h._free = h.asm.K).apply(null, arguments);
    };
    h.dynCall_jiji = function() {
      return (h.dynCall_jiji = h.asm.L).apply(null, arguments);
    };
    var Kb;
    G = function Lb() {
      Kb || Mb();
      Kb || (G = Lb);
    };
    function Mb() {
      function a() {
        if (!Kb && (Kb = true, h.calledRun = true, !ha)) {
          za(qa);
          aa(h);
          if (h.onRuntimeInitialized)
            h.onRuntimeInitialized();
          if (h.postRun)
            for (typeof h.postRun == "function" && (h.postRun = [h.postRun]);h.postRun.length; ) {
              var b = h.postRun.shift();
              ra.unshift(b);
            }
          za(ra);
        }
      }
      if (!(0 < F)) {
        if (h.preRun)
          for (typeof h.preRun == "function" && (h.preRun = [h.preRun]);h.preRun.length; )
            sa();
        za(pa);
        0 < F || (h.setStatus ? (h.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            h.setStatus("");
          }, 1);
          a();
        }, 1)) : a());
      }
    }
    if (h.preInit)
      for (typeof h.preInit == "function" && (h.preInit = [h.preInit]);0 < h.preInit.length; )
        h.preInit.pop()();
    Mb();
    return loadYoga2.ready;
  };
})();
var yoga_wasm_base64_esm_default = loadYoga;

// node_modules/yoga-layout/dist/src/generated/YGEnums.js
var Align = /* @__PURE__ */ function(Align2) {
  Align2[Align2["Auto"] = 0] = "Auto";
  Align2[Align2["FlexStart"] = 1] = "FlexStart";
  Align2[Align2["Center"] = 2] = "Center";
  Align2[Align2["FlexEnd"] = 3] = "FlexEnd";
  Align2[Align2["Stretch"] = 4] = "Stretch";
  Align2[Align2["Baseline"] = 5] = "Baseline";
  Align2[Align2["SpaceBetween"] = 6] = "SpaceBetween";
  Align2[Align2["SpaceAround"] = 7] = "SpaceAround";
  Align2[Align2["SpaceEvenly"] = 8] = "SpaceEvenly";
  return Align2;
}({});
var BoxSizing = /* @__PURE__ */ function(BoxSizing2) {
  BoxSizing2[BoxSizing2["BorderBox"] = 0] = "BorderBox";
  BoxSizing2[BoxSizing2["ContentBox"] = 1] = "ContentBox";
  return BoxSizing2;
}({});
var Dimension = /* @__PURE__ */ function(Dimension2) {
  Dimension2[Dimension2["Width"] = 0] = "Width";
  Dimension2[Dimension2["Height"] = 1] = "Height";
  return Dimension2;
}({});
var Direction = /* @__PURE__ */ function(Direction2) {
  Direction2[Direction2["Inherit"] = 0] = "Inherit";
  Direction2[Direction2["LTR"] = 1] = "LTR";
  Direction2[Direction2["RTL"] = 2] = "RTL";
  return Direction2;
}({});
var Display = /* @__PURE__ */ function(Display2) {
  Display2[Display2["Flex"] = 0] = "Flex";
  Display2[Display2["None"] = 1] = "None";
  Display2[Display2["Contents"] = 2] = "Contents";
  return Display2;
}({});
var Edge = /* @__PURE__ */ function(Edge2) {
  Edge2[Edge2["Left"] = 0] = "Left";
  Edge2[Edge2["Top"] = 1] = "Top";
  Edge2[Edge2["Right"] = 2] = "Right";
  Edge2[Edge2["Bottom"] = 3] = "Bottom";
  Edge2[Edge2["Start"] = 4] = "Start";
  Edge2[Edge2["End"] = 5] = "End";
  Edge2[Edge2["Horizontal"] = 6] = "Horizontal";
  Edge2[Edge2["Vertical"] = 7] = "Vertical";
  Edge2[Edge2["All"] = 8] = "All";
  return Edge2;
}({});
var Errata = /* @__PURE__ */ function(Errata2) {
  Errata2[Errata2["None"] = 0] = "None";
  Errata2[Errata2["StretchFlexBasis"] = 1] = "StretchFlexBasis";
  Errata2[Errata2["AbsolutePositionWithoutInsetsExcludesPadding"] = 2] = "AbsolutePositionWithoutInsetsExcludesPadding";
  Errata2[Errata2["AbsolutePercentAgainstInnerSize"] = 4] = "AbsolutePercentAgainstInnerSize";
  Errata2[Errata2["All"] = 2147483647] = "All";
  Errata2[Errata2["Classic"] = 2147483646] = "Classic";
  return Errata2;
}({});
var ExperimentalFeature = /* @__PURE__ */ function(ExperimentalFeature2) {
  ExperimentalFeature2[ExperimentalFeature2["WebFlexBasis"] = 0] = "WebFlexBasis";
  return ExperimentalFeature2;
}({});
var FlexDirection = /* @__PURE__ */ function(FlexDirection2) {
  FlexDirection2[FlexDirection2["Column"] = 0] = "Column";
  FlexDirection2[FlexDirection2["ColumnReverse"] = 1] = "ColumnReverse";
  FlexDirection2[FlexDirection2["Row"] = 2] = "Row";
  FlexDirection2[FlexDirection2["RowReverse"] = 3] = "RowReverse";
  return FlexDirection2;
}({});
var Gutter = /* @__PURE__ */ function(Gutter2) {
  Gutter2[Gutter2["Column"] = 0] = "Column";
  Gutter2[Gutter2["Row"] = 1] = "Row";
  Gutter2[Gutter2["All"] = 2] = "All";
  return Gutter2;
}({});
var Justify = /* @__PURE__ */ function(Justify2) {
  Justify2[Justify2["FlexStart"] = 0] = "FlexStart";
  Justify2[Justify2["Center"] = 1] = "Center";
  Justify2[Justify2["FlexEnd"] = 2] = "FlexEnd";
  Justify2[Justify2["SpaceBetween"] = 3] = "SpaceBetween";
  Justify2[Justify2["SpaceAround"] = 4] = "SpaceAround";
  Justify2[Justify2["SpaceEvenly"] = 5] = "SpaceEvenly";
  return Justify2;
}({});
var LogLevel = /* @__PURE__ */ function(LogLevel2) {
  LogLevel2[LogLevel2["Error"] = 0] = "Error";
  LogLevel2[LogLevel2["Warn"] = 1] = "Warn";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Debug"] = 3] = "Debug";
  LogLevel2[LogLevel2["Verbose"] = 4] = "Verbose";
  LogLevel2[LogLevel2["Fatal"] = 5] = "Fatal";
  return LogLevel2;
}({});
var MeasureMode = /* @__PURE__ */ function(MeasureMode2) {
  MeasureMode2[MeasureMode2["Undefined"] = 0] = "Undefined";
  MeasureMode2[MeasureMode2["Exactly"] = 1] = "Exactly";
  MeasureMode2[MeasureMode2["AtMost"] = 2] = "AtMost";
  return MeasureMode2;
}({});
var NodeType = /* @__PURE__ */ function(NodeType2) {
  NodeType2[NodeType2["Default"] = 0] = "Default";
  NodeType2[NodeType2["Text"] = 1] = "Text";
  return NodeType2;
}({});
var Overflow = /* @__PURE__ */ function(Overflow2) {
  Overflow2[Overflow2["Visible"] = 0] = "Visible";
  Overflow2[Overflow2["Hidden"] = 1] = "Hidden";
  Overflow2[Overflow2["Scroll"] = 2] = "Scroll";
  return Overflow2;
}({});
var PositionType = /* @__PURE__ */ function(PositionType2) {
  PositionType2[PositionType2["Static"] = 0] = "Static";
  PositionType2[PositionType2["Relative"] = 1] = "Relative";
  PositionType2[PositionType2["Absolute"] = 2] = "Absolute";
  return PositionType2;
}({});
var Unit = /* @__PURE__ */ function(Unit2) {
  Unit2[Unit2["Undefined"] = 0] = "Undefined";
  Unit2[Unit2["Point"] = 1] = "Point";
  Unit2[Unit2["Percent"] = 2] = "Percent";
  Unit2[Unit2["Auto"] = 3] = "Auto";
  return Unit2;
}({});
var Wrap = /* @__PURE__ */ function(Wrap2) {
  Wrap2[Wrap2["NoWrap"] = 0] = "NoWrap";
  Wrap2[Wrap2["Wrap"] = 1] = "Wrap";
  Wrap2[Wrap2["WrapReverse"] = 2] = "WrapReverse";
  return Wrap2;
}({});
var constants2 = {
  ALIGN_AUTO: Align.Auto,
  ALIGN_FLEX_START: Align.FlexStart,
  ALIGN_CENTER: Align.Center,
  ALIGN_FLEX_END: Align.FlexEnd,
  ALIGN_STRETCH: Align.Stretch,
  ALIGN_BASELINE: Align.Baseline,
  ALIGN_SPACE_BETWEEN: Align.SpaceBetween,
  ALIGN_SPACE_AROUND: Align.SpaceAround,
  ALIGN_SPACE_EVENLY: Align.SpaceEvenly,
  BOX_SIZING_BORDER_BOX: BoxSizing.BorderBox,
  BOX_SIZING_CONTENT_BOX: BoxSizing.ContentBox,
  DIMENSION_WIDTH: Dimension.Width,
  DIMENSION_HEIGHT: Dimension.Height,
  DIRECTION_INHERIT: Direction.Inherit,
  DIRECTION_LTR: Direction.LTR,
  DIRECTION_RTL: Direction.RTL,
  DISPLAY_FLEX: Display.Flex,
  DISPLAY_NONE: Display.None,
  DISPLAY_CONTENTS: Display.Contents,
  EDGE_LEFT: Edge.Left,
  EDGE_TOP: Edge.Top,
  EDGE_RIGHT: Edge.Right,
  EDGE_BOTTOM: Edge.Bottom,
  EDGE_START: Edge.Start,
  EDGE_END: Edge.End,
  EDGE_HORIZONTAL: Edge.Horizontal,
  EDGE_VERTICAL: Edge.Vertical,
  EDGE_ALL: Edge.All,
  ERRATA_NONE: Errata.None,
  ERRATA_STRETCH_FLEX_BASIS: Errata.StretchFlexBasis,
  ERRATA_ABSOLUTE_POSITION_WITHOUT_INSETS_EXCLUDES_PADDING: Errata.AbsolutePositionWithoutInsetsExcludesPadding,
  ERRATA_ABSOLUTE_PERCENT_AGAINST_INNER_SIZE: Errata.AbsolutePercentAgainstInnerSize,
  ERRATA_ALL: Errata.All,
  ERRATA_CLASSIC: Errata.Classic,
  EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS: ExperimentalFeature.WebFlexBasis,
  FLEX_DIRECTION_COLUMN: FlexDirection.Column,
  FLEX_DIRECTION_COLUMN_REVERSE: FlexDirection.ColumnReverse,
  FLEX_DIRECTION_ROW: FlexDirection.Row,
  FLEX_DIRECTION_ROW_REVERSE: FlexDirection.RowReverse,
  GUTTER_COLUMN: Gutter.Column,
  GUTTER_ROW: Gutter.Row,
  GUTTER_ALL: Gutter.All,
  JUSTIFY_FLEX_START: Justify.FlexStart,
  JUSTIFY_CENTER: Justify.Center,
  JUSTIFY_FLEX_END: Justify.FlexEnd,
  JUSTIFY_SPACE_BETWEEN: Justify.SpaceBetween,
  JUSTIFY_SPACE_AROUND: Justify.SpaceAround,
  JUSTIFY_SPACE_EVENLY: Justify.SpaceEvenly,
  LOG_LEVEL_ERROR: LogLevel.Error,
  LOG_LEVEL_WARN: LogLevel.Warn,
  LOG_LEVEL_INFO: LogLevel.Info,
  LOG_LEVEL_DEBUG: LogLevel.Debug,
  LOG_LEVEL_VERBOSE: LogLevel.Verbose,
  LOG_LEVEL_FATAL: LogLevel.Fatal,
  MEASURE_MODE_UNDEFINED: MeasureMode.Undefined,
  MEASURE_MODE_EXACTLY: MeasureMode.Exactly,
  MEASURE_MODE_AT_MOST: MeasureMode.AtMost,
  NODE_TYPE_DEFAULT: NodeType.Default,
  NODE_TYPE_TEXT: NodeType.Text,
  OVERFLOW_VISIBLE: Overflow.Visible,
  OVERFLOW_HIDDEN: Overflow.Hidden,
  OVERFLOW_SCROLL: Overflow.Scroll,
  POSITION_TYPE_STATIC: PositionType.Static,
  POSITION_TYPE_RELATIVE: PositionType.Relative,
  POSITION_TYPE_ABSOLUTE: PositionType.Absolute,
  UNIT_UNDEFINED: Unit.Undefined,
  UNIT_POINT: Unit.Point,
  UNIT_PERCENT: Unit.Percent,
  UNIT_AUTO: Unit.Auto,
  WRAP_NO_WRAP: Wrap.NoWrap,
  WRAP_WRAP: Wrap.Wrap,
  WRAP_WRAP_REVERSE: Wrap.WrapReverse
};
var YGEnums_default = constants2;

// node_modules/yoga-layout/dist/src/wrapAssembly.js
function wrapAssembly(lib) {
  function patch(prototype, name, fn) {
    const original = prototype[name];
    prototype[name] = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return fn.call(this, original, ...args);
    };
  }
  for (const fnName of ["setPosition", "setMargin", "setFlexBasis", "setWidth", "setHeight", "setMinWidth", "setMinHeight", "setMaxWidth", "setMaxHeight", "setPadding", "setGap"]) {
    const methods = {
      [Unit.Point]: lib.Node.prototype[fnName],
      [Unit.Percent]: lib.Node.prototype[`${fnName}Percent`],
      [Unit.Auto]: lib.Node.prototype[`${fnName}Auto`]
    };
    patch(lib.Node.prototype, fnName, function(original) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      const value = args.pop();
      let unit, asNumber;
      if (value === "auto") {
        unit = Unit.Auto;
        asNumber = undefined;
      } else if (typeof value === "object") {
        unit = value.unit;
        asNumber = value.valueOf();
      } else {
        unit = typeof value === "string" && value.endsWith("%") ? Unit.Percent : Unit.Point;
        asNumber = parseFloat(value);
        if (value !== undefined && !Number.isNaN(value) && Number.isNaN(asNumber)) {
          throw new Error(`Invalid value ${value} for ${fnName}`);
        }
      }
      if (!methods[unit])
        throw new Error(`Failed to execute "${fnName}": Unsupported unit '${value}'`);
      if (asNumber !== undefined) {
        return methods[unit].call(this, ...args, asNumber);
      } else {
        return methods[unit].call(this, ...args);
      }
    });
  }
  function wrapMeasureFunction(measureFunction) {
    return lib.MeasureCallback.implement({
      measure: function() {
        const {
          width,
          height
        } = measureFunction(...arguments);
        return {
          width: width ?? NaN,
          height: height ?? NaN
        };
      }
    });
  }
  patch(lib.Node.prototype, "setMeasureFunc", function(original, measureFunc) {
    if (measureFunc) {
      return original.call(this, wrapMeasureFunction(measureFunc));
    } else {
      return this.unsetMeasureFunc();
    }
  });
  function wrapDirtiedFunc(dirtiedFunction) {
    return lib.DirtiedCallback.implement({
      dirtied: dirtiedFunction
    });
  }
  patch(lib.Node.prototype, "setDirtiedFunc", function(original, dirtiedFunc) {
    original.call(this, wrapDirtiedFunc(dirtiedFunc));
  });
  patch(lib.Config.prototype, "free", function() {
    lib.Config.destroy(this);
  });
  patch(lib.Node, "create", (_, config) => {
    return config ? lib.Node.createWithConfig(config) : lib.Node.createDefault();
  });
  patch(lib.Node.prototype, "free", function() {
    lib.Node.destroy(this);
  });
  patch(lib.Node.prototype, "freeRecursive", function() {
    for (let t = 0, T = this.getChildCount();t < T; ++t) {
      this.getChild(0).freeRecursive();
    }
    this.free();
  });
  patch(lib.Node.prototype, "calculateLayout", function(original) {
    let width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;
    let height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;
    let direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Direction.LTR;
    return original.call(this, width, height, direction);
  });
  return {
    Config: lib.Config,
    Node: lib.Node,
    ...YGEnums_default
  };
}

// node_modules/yoga-layout/dist/src/index.js
var Yoga = wrapAssembly(await yoga_wasm_base64_esm_default());
var src_default = Yoga;

// node_modules/ansi-regex/index.js
function ansiRegex({ onlyFirst = false } = {}) {
  const ST = "(?:\\u0007|\\u001B\\u005C|\\u009C)";
  const osc = `(?:\\u001B\\][\\s\\S]*?${ST})`;
  const csi = "[\\u001B\\u009B][[\\]()#;?]*(?:\\d{1,4}(?:[;:]\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]";
  const pattern = `${osc}|${csi}`;
  return new RegExp(pattern, onlyFirst ? undefined : "g");
}

// node_modules/strip-ansi/index.js
var regex = ansiRegex();
function stripAnsi(string) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  }
  return string.replace(regex, "");
}

// node_modules/get-east-asian-width/lookup.js
function isAmbiguous(x) {
  return x === 161 || x === 164 || x === 167 || x === 168 || x === 170 || x === 173 || x === 174 || x >= 176 && x <= 180 || x >= 182 && x <= 186 || x >= 188 && x <= 191 || x === 198 || x === 208 || x === 215 || x === 216 || x >= 222 && x <= 225 || x === 230 || x >= 232 && x <= 234 || x === 236 || x === 237 || x === 240 || x === 242 || x === 243 || x >= 247 && x <= 250 || x === 252 || x === 254 || x === 257 || x === 273 || x === 275 || x === 283 || x === 294 || x === 295 || x === 299 || x >= 305 && x <= 307 || x === 312 || x >= 319 && x <= 322 || x === 324 || x >= 328 && x <= 331 || x === 333 || x === 338 || x === 339 || x === 358 || x === 359 || x === 363 || x === 462 || x === 464 || x === 466 || x === 468 || x === 470 || x === 472 || x === 474 || x === 476 || x === 593 || x === 609 || x === 708 || x === 711 || x >= 713 && x <= 715 || x === 717 || x === 720 || x >= 728 && x <= 731 || x === 733 || x === 735 || x >= 768 && x <= 879 || x >= 913 && x <= 929 || x >= 931 && x <= 937 || x >= 945 && x <= 961 || x >= 963 && x <= 969 || x === 1025 || x >= 1040 && x <= 1103 || x === 1105 || x === 8208 || x >= 8211 && x <= 8214 || x === 8216 || x === 8217 || x === 8220 || x === 8221 || x >= 8224 && x <= 8226 || x >= 8228 && x <= 8231 || x === 8240 || x === 8242 || x === 8243 || x === 8245 || x === 8251 || x === 8254 || x === 8308 || x === 8319 || x >= 8321 && x <= 8324 || x === 8364 || x === 8451 || x === 8453 || x === 8457 || x === 8467 || x === 8470 || x === 8481 || x === 8482 || x === 8486 || x === 8491 || x === 8531 || x === 8532 || x >= 8539 && x <= 8542 || x >= 8544 && x <= 8555 || x >= 8560 && x <= 8569 || x === 8585 || x >= 8592 && x <= 8601 || x === 8632 || x === 8633 || x === 8658 || x === 8660 || x === 8679 || x === 8704 || x === 8706 || x === 8707 || x === 8711 || x === 8712 || x === 8715 || x === 8719 || x === 8721 || x === 8725 || x === 8730 || x >= 8733 && x <= 8736 || x === 8739 || x === 8741 || x >= 8743 && x <= 8748 || x === 8750 || x >= 8756 && x <= 8759 || x === 8764 || x === 8765 || x === 8776 || x === 8780 || x === 8786 || x === 8800 || x === 8801 || x >= 8804 && x <= 8807 || x === 8810 || x === 8811 || x === 8814 || x === 8815 || x === 8834 || x === 8835 || x === 8838 || x === 8839 || x === 8853 || x === 8857 || x === 8869 || x === 8895 || x === 8978 || x >= 9312 && x <= 9449 || x >= 9451 && x <= 9547 || x >= 9552 && x <= 9587 || x >= 9600 && x <= 9615 || x >= 9618 && x <= 9621 || x === 9632 || x === 9633 || x >= 9635 && x <= 9641 || x === 9650 || x === 9651 || x === 9654 || x === 9655 || x === 9660 || x === 9661 || x === 9664 || x === 9665 || x >= 9670 && x <= 9672 || x === 9675 || x >= 9678 && x <= 9681 || x >= 9698 && x <= 9701 || x === 9711 || x === 9733 || x === 9734 || x === 9737 || x === 9742 || x === 9743 || x === 9756 || x === 9758 || x === 9792 || x === 9794 || x === 9824 || x === 9825 || x >= 9827 && x <= 9829 || x >= 9831 && x <= 9834 || x === 9836 || x === 9837 || x === 9839 || x === 9886 || x === 9887 || x === 9919 || x >= 9926 && x <= 9933 || x >= 9935 && x <= 9939 || x >= 9941 && x <= 9953 || x === 9955 || x === 9960 || x === 9961 || x >= 9963 && x <= 9969 || x === 9972 || x >= 9974 && x <= 9977 || x === 9979 || x === 9980 || x === 9982 || x === 9983 || x === 10045 || x >= 10102 && x <= 10111 || x >= 11094 && x <= 11097 || x >= 12872 && x <= 12879 || x >= 57344 && x <= 63743 || x >= 65024 && x <= 65039 || x === 65533 || x >= 127232 && x <= 127242 || x >= 127248 && x <= 127277 || x >= 127280 && x <= 127337 || x >= 127344 && x <= 127373 || x === 127375 || x === 127376 || x >= 127387 && x <= 127404 || x >= 917760 && x <= 917999 || x >= 983040 && x <= 1048573 || x >= 1048576 && x <= 1114109;
}
function isFullWidth(x) {
  return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
}
function isWide(x) {
  return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9776 && x <= 9783 || x >= 9800 && x <= 9811 || x === 9855 || x >= 9866 && x <= 9871 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12773 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x >= 94192 && x <= 94198 || x >= 94208 && x <= 101589 || x >= 101631 && x <= 101662 || x >= 101760 && x <= 101874 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x >= 119552 && x <= 119638 || x >= 119648 && x <= 119670 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128728 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129674 || x >= 129678 && x <= 129734 || x === 129736 || x >= 129741 && x <= 129756 || x >= 129759 && x <= 129770 || x >= 129775 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
}

// node_modules/get-east-asian-width/index.js
function validate(codePoint) {
  if (!Number.isSafeInteger(codePoint)) {
    throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
  }
}
function eastAsianWidth(codePoint, { ambiguousAsWide = false } = {}) {
  validate(codePoint);
  if (isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint)) {
    return 2;
  }
  return 1;
}

// node_modules/wrap-ansi/node_modules/string-width/index.js
var import_emoji_regex = __toESM(require_emoji_regex(), 1);
var segmenter = new Intl.Segmenter;
var defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;
function stringWidth(string, options = {}) {
  if (typeof string !== "string" || string.length === 0) {
    return 0;
  }
  const {
    ambiguousIsNarrow = true,
    countAnsiEscapeCodes = false
  } = options;
  if (!countAnsiEscapeCodes) {
    string = stripAnsi(string);
  }
  if (string.length === 0) {
    return 0;
  }
  let width = 0;
  const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
  for (const { segment: character } of segmenter.segment(string)) {
    const codePoint = character.codePointAt(0);
    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
      continue;
    }
    if (codePoint >= 8203 && codePoint <= 8207 || codePoint === 65279) {
      continue;
    }
    if (codePoint >= 768 && codePoint <= 879 || codePoint >= 6832 && codePoint <= 6911 || codePoint >= 7616 && codePoint <= 7679 || codePoint >= 8400 && codePoint <= 8447 || codePoint >= 65056 && codePoint <= 65071) {
      continue;
    }
    if (codePoint >= 55296 && codePoint <= 57343) {
      continue;
    }
    if (codePoint >= 65024 && codePoint <= 65039) {
      continue;
    }
    if (defaultIgnorableCodePointRegex.test(character)) {
      continue;
    }
    if (import_emoji_regex.default().test(character)) {
      width += 2;
      continue;
    }
    width += eastAsianWidth(codePoint, eastAsianWidthOptions);
  }
  return width;
}

// node_modules/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    blackBright: [90, 39],
    gray: [90, 39],
    grey: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = new Map;
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// node_modules/wrap-ansi/index.js
var ESCAPES = new Set([
  "\x1B",
  ""
]);
var END_CODE = 39;
var ANSI_ESCAPE_BELL = "\x07";
var ANSI_CSI = "[";
var ANSI_OSC = "]";
var ANSI_SGR_TERMINATOR = "m";
var ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
var wrapAnsiCode = (code) => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
var wrapAnsiHyperlink = (url) => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${url}${ANSI_ESCAPE_BELL}`;
var wordLengths = (string) => string.split(" ").map((character) => stringWidth(character));
var wrapWord = (rows, word, columns) => {
  const characters = [...word];
  let isInsideEscape = false;
  let isInsideLinkEscape = false;
  let visible = stringWidth(stripAnsi(rows.at(-1)));
  for (const [index, character] of characters.entries()) {
    const characterLength = stringWidth(character);
    if (visible + characterLength <= columns) {
      rows[rows.length - 1] += character;
    } else {
      rows.push(character);
      visible = 0;
    }
    if (ESCAPES.has(character)) {
      isInsideEscape = true;
      const ansiEscapeLinkCandidate = characters.slice(index + 1, index + 1 + ANSI_ESCAPE_LINK.length).join("");
      isInsideLinkEscape = ansiEscapeLinkCandidate === ANSI_ESCAPE_LINK;
    }
    if (isInsideEscape) {
      if (isInsideLinkEscape) {
        if (character === ANSI_ESCAPE_BELL) {
          isInsideEscape = false;
          isInsideLinkEscape = false;
        }
      } else if (character === ANSI_SGR_TERMINATOR) {
        isInsideEscape = false;
      }
      continue;
    }
    visible += characterLength;
    if (visible === columns && index < characters.length - 1) {
      rows.push("");
      visible = 0;
    }
  }
  if (!visible && rows.at(-1).length > 0 && rows.length > 1) {
    rows[rows.length - 2] += rows.pop();
  }
};
var stringVisibleTrimSpacesRight = (string) => {
  const words = string.split(" ");
  let last = words.length;
  while (last > 0) {
    if (stringWidth(words[last - 1]) > 0) {
      break;
    }
    last--;
  }
  if (last === words.length) {
    return string;
  }
  return words.slice(0, last).join(" ") + words.slice(last).join("");
};
var exec = (string, columns, options = {}) => {
  if (options.trim !== false && string.trim() === "") {
    return "";
  }
  let returnValue = "";
  let escapeCode;
  let escapeUrl;
  const lengths = wordLengths(string);
  let rows = [""];
  for (const [index, word] of string.split(" ").entries()) {
    if (options.trim !== false) {
      rows[rows.length - 1] = rows.at(-1).trimStart();
    }
    let rowLength = stringWidth(rows.at(-1));
    if (index !== 0) {
      if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
        rows.push("");
        rowLength = 0;
      }
      if (rowLength > 0 || options.trim === false) {
        rows[rows.length - 1] += " ";
        rowLength++;
      }
    }
    if (options.hard && lengths[index] > columns) {
      const remainingColumns = columns - rowLength;
      const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
      const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
      if (breaksStartingNextLine < breaksStartingThisLine) {
        rows.push("");
      }
      wrapWord(rows, word, columns);
      continue;
    }
    if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
      if (options.wordWrap === false && rowLength < columns) {
        wrapWord(rows, word, columns);
        continue;
      }
      rows.push("");
    }
    if (rowLength + lengths[index] > columns && options.wordWrap === false) {
      wrapWord(rows, word, columns);
      continue;
    }
    rows[rows.length - 1] += word;
  }
  if (options.trim !== false) {
    rows = rows.map((row) => stringVisibleTrimSpacesRight(row));
  }
  const preString = rows.join(`
`);
  const pre = [...preString];
  let preStringIndex = 0;
  for (const [index, character] of pre.entries()) {
    returnValue += character;
    if (ESCAPES.has(character)) {
      const { groups } = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(preString.slice(preStringIndex)) || { groups: {} };
      if (groups.code !== undefined) {
        const code2 = Number.parseFloat(groups.code);
        escapeCode = code2 === END_CODE ? undefined : code2;
      } else if (groups.uri !== undefined) {
        escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
      }
    }
    const code = ansi_styles_default.codes.get(Number(escapeCode));
    if (pre[index + 1] === `
`) {
      if (escapeUrl) {
        returnValue += wrapAnsiHyperlink("");
      }
      if (escapeCode && code) {
        returnValue += wrapAnsiCode(code);
      }
    } else if (character === `
`) {
      if (escapeCode && code) {
        returnValue += wrapAnsiCode(escapeCode);
      }
      if (escapeUrl) {
        returnValue += wrapAnsiHyperlink(escapeUrl);
      }
    }
    preStringIndex += character.length;
  }
  return returnValue;
};
function wrapAnsi(string, columns, options) {
  return String(string).normalize().replaceAll(`\r
`, `
`).split(`
`).map((line) => exec(line, columns, options)).join(`
`);
}

// node_modules/ink/build/reconciler.js
var import_react_reconciler = __toESM(require_react_reconciler(), 1);
var import_constants = __toESM(require_constants(), 1);
import process3 from "node:process";
var import_react = __toESM(require_react(), 1);

// node_modules/widest-line/node_modules/string-width/index.js
var import_emoji_regex2 = __toESM(require_emoji_regex(), 1);
var segmenter2 = new Intl.Segmenter;
var defaultIgnorableCodePointRegex2 = /^\p{Default_Ignorable_Code_Point}$/u;
function stringWidth2(string, options = {}) {
  if (typeof string !== "string" || string.length === 0) {
    return 0;
  }
  const {
    ambiguousIsNarrow = true,
    countAnsiEscapeCodes = false
  } = options;
  if (!countAnsiEscapeCodes) {
    string = stripAnsi(string);
  }
  if (string.length === 0) {
    return 0;
  }
  let width = 0;
  const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
  for (const { segment: character } of segmenter2.segment(string)) {
    const codePoint = character.codePointAt(0);
    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
      continue;
    }
    if (codePoint >= 8203 && codePoint <= 8207 || codePoint === 65279) {
      continue;
    }
    if (codePoint >= 768 && codePoint <= 879 || codePoint >= 6832 && codePoint <= 6911 || codePoint >= 7616 && codePoint <= 7679 || codePoint >= 8400 && codePoint <= 8447 || codePoint >= 65056 && codePoint <= 65071) {
      continue;
    }
    if (codePoint >= 55296 && codePoint <= 57343) {
      continue;
    }
    if (codePoint >= 65024 && codePoint <= 65039) {
      continue;
    }
    if (defaultIgnorableCodePointRegex2.test(character)) {
      continue;
    }
    if (import_emoji_regex2.default().test(character)) {
      width += 2;
      continue;
    }
    width += eastAsianWidth(codePoint, eastAsianWidthOptions);
  }
  return width;
}

// node_modules/widest-line/index.js
function widestLine(string) {
  let lineWidth = 0;
  for (const line of string.split(`
`)) {
    lineWidth = Math.max(lineWidth, stringWidth2(line));
  }
  return lineWidth;
}

// node_modules/ink/build/measure-text.js
var cache = new Map;
var measureText = (text) => {
  if (text.length === 0) {
    return {
      width: 0,
      height: 0
    };
  }
  const cachedDimensions = cache.get(text);
  if (cachedDimensions) {
    return cachedDimensions;
  }
  const width = widestLine(text);
  const height = text.split(`
`).length;
  const dimensions = { width, height };
  cache.set(text, dimensions);
  return dimensions;
};
var measure_text_default = measureText;

// node_modules/is-fullwidth-code-point/index.js
function isFullwidthCodePoint(codePoint) {
  if (!Number.isInteger(codePoint)) {
    return false;
  }
  return isFullWidth(codePoint) || isWide(codePoint);
}

// node_modules/slice-ansi/index.js
var ESCAPES2 = new Set([27, 155]);
var CODE_POINT_0 = "0".codePointAt(0);
var CODE_POINT_9 = "9".codePointAt(0);
var MAX_ANSI_SEQUENCE_LENGTH = 19;
var endCodesSet = new Set;
var endCodesMap = new Map;
for (const [start, end] of ansi_styles_default.codes) {
  endCodesSet.add(ansi_styles_default.color.ansi(end));
  endCodesMap.set(ansi_styles_default.color.ansi(start), ansi_styles_default.color.ansi(end));
}
function getEndCode(code) {
  if (endCodesSet.has(code)) {
    return code;
  }
  if (endCodesMap.has(code)) {
    return endCodesMap.get(code);
  }
  code = code.slice(2);
  if (code.includes(";")) {
    code = code[0] + "0";
  }
  const returnValue = ansi_styles_default.codes.get(Number.parseInt(code, 10));
  if (returnValue) {
    return ansi_styles_default.color.ansi(returnValue);
  }
  return ansi_styles_default.reset.open;
}
function findNumberIndex(string) {
  for (let index = 0;index < string.length; index++) {
    const codePoint = string.codePointAt(index);
    if (codePoint >= CODE_POINT_0 && codePoint <= CODE_POINT_9) {
      return index;
    }
  }
  return -1;
}
function parseAnsiCode(string, offset) {
  string = string.slice(offset, offset + MAX_ANSI_SEQUENCE_LENGTH);
  const startIndex = findNumberIndex(string);
  if (startIndex !== -1) {
    let endIndex = string.indexOf("m", startIndex);
    if (endIndex === -1) {
      endIndex = string.length;
    }
    return string.slice(0, endIndex + 1);
  }
}
function tokenize(string, endCharacter = Number.POSITIVE_INFINITY) {
  const returnValue = [];
  let index = 0;
  let visibleCount = 0;
  while (index < string.length) {
    const codePoint = string.codePointAt(index);
    if (ESCAPES2.has(codePoint)) {
      const code = parseAnsiCode(string, index);
      if (code) {
        returnValue.push({
          type: "ansi",
          code,
          endCode: getEndCode(code)
        });
        index += code.length;
        continue;
      }
    }
    const isFullWidth2 = isFullwidthCodePoint(codePoint);
    const character = String.fromCodePoint(codePoint);
    returnValue.push({
      type: "character",
      value: character,
      isFullWidth: isFullWidth2
    });
    index += character.length;
    visibleCount += isFullWidth2 ? 2 : character.length;
    if (visibleCount >= endCharacter) {
      break;
    }
  }
  return returnValue;
}
function reduceAnsiCodes(codes) {
  let returnValue = [];
  for (const code of codes) {
    if (code.code === ansi_styles_default.reset.open) {
      returnValue = [];
    } else if (endCodesSet.has(code.code)) {
      returnValue = returnValue.filter((returnValueCode) => returnValueCode.endCode !== code.code);
    } else {
      returnValue = returnValue.filter((returnValueCode) => returnValueCode.endCode !== code.endCode);
      returnValue.push(code);
    }
  }
  return returnValue;
}
function undoAnsiCodes(codes) {
  const reduced = reduceAnsiCodes(codes);
  const endCodes = reduced.map(({ endCode }) => endCode);
  return endCodes.reverse().join("");
}
function sliceAnsi(string, start, end) {
  const tokens = tokenize(string, end);
  let activeCodes = [];
  let position = 0;
  let returnValue = "";
  let include = false;
  for (const token of tokens) {
    if (end !== undefined && position >= end) {
      break;
    }
    if (token.type === "ansi") {
      activeCodes.push(token);
      if (include) {
        returnValue += token.code;
      }
    } else {
      if (!include && position >= start) {
        include = true;
        activeCodes = reduceAnsiCodes(activeCodes);
        returnValue = activeCodes.map(({ code }) => code).join("");
      }
      if (include) {
        returnValue += token.value;
      }
      position += token.isFullWidth ? 2 : token.value.length;
    }
  }
  returnValue += undoAnsiCodes(activeCodes);
  return returnValue;
}

// node_modules/string-width/index.js
var segmenter3 = new Intl.Segmenter;
var zeroWidthClusterRegex = /^(?:\p{Default_Ignorable_Code_Point}|\p{Control}|\p{Mark}|\p{Surrogate})+$/v;
var leadingNonPrintingRegex = /^[\p{Default_Ignorable_Code_Point}\p{Control}\p{Format}\p{Mark}\p{Surrogate}]+/v;
var rgiEmojiRegex = /^\p{RGI_Emoji}$/v;
function baseVisible(segment) {
  return segment.replace(leadingNonPrintingRegex, "");
}
function isZeroWidthCluster(segment) {
  return zeroWidthClusterRegex.test(segment);
}
function trailingHalfwidthWidth(segment, eastAsianWidthOptions) {
  let extra = 0;
  if (segment.length > 1) {
    for (const char of segment.slice(1)) {
      if (char >= "" && char <= "") {
        extra += eastAsianWidth(char.codePointAt(0), eastAsianWidthOptions);
      }
    }
  }
  return extra;
}
function stringWidth3(input, options = {}) {
  if (typeof input !== "string" || input.length === 0) {
    return 0;
  }
  const {
    ambiguousIsNarrow = true,
    countAnsiEscapeCodes = false
  } = options;
  let string = input;
  if (!countAnsiEscapeCodes) {
    string = stripAnsi(string);
  }
  if (string.length === 0) {
    return 0;
  }
  let width = 0;
  const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
  for (const { segment } of segmenter3.segment(string)) {
    if (isZeroWidthCluster(segment)) {
      continue;
    }
    if (rgiEmojiRegex.test(segment)) {
      width += 2;
      continue;
    }
    const codePoint = baseVisible(segment).codePointAt(0);
    width += eastAsianWidth(codePoint, eastAsianWidthOptions);
    width += trailingHalfwidthWidth(segment, eastAsianWidthOptions);
  }
  return width;
}

// node_modules/cli-truncate/index.js
function getIndexOfNearestSpace(string, wantedIndex, shouldSearchRight) {
  if (string.charAt(wantedIndex) === " ") {
    return wantedIndex;
  }
  const direction = shouldSearchRight ? 1 : -1;
  for (let index = 0;index <= 3; index++) {
    const finalIndex = wantedIndex + index * direction;
    if (string.charAt(finalIndex) === " ") {
      return finalIndex;
    }
  }
  return wantedIndex;
}
function cliTruncate(text, columns, options = {}) {
  const {
    position = "end",
    space = false,
    preferTruncationOnSpace = false
  } = options;
  let { truncationCharacter = "" } = options;
  if (typeof text !== "string") {
    throw new TypeError(`Expected \`input\` to be a string, got ${typeof text}`);
  }
  if (typeof columns !== "number") {
    throw new TypeError(`Expected \`columns\` to be a number, got ${typeof columns}`);
  }
  if (columns < 1) {
    return "";
  }
  const length = stringWidth3(text);
  if (length <= columns) {
    return text;
  }
  if (columns === 1) {
    return truncationCharacter;
  }
  const ANSI = {
    ESC: 27,
    LEFT_BRACKET: 91,
    LETTER_M: 109
  };
  const isSgrParameter = (code) => code >= 48 && code <= 57 || code === 59;
  function leadingSgrSpanEndIndex(string) {
    let index = 0;
    while (index + 2 < string.length && string.codePointAt(index) === ANSI.ESC && string.codePointAt(index + 1) === ANSI.LEFT_BRACKET) {
      let j = index + 2;
      while (j < string.length && isSgrParameter(string.codePointAt(j))) {
        j++;
      }
      if (j < string.length && string.codePointAt(j) === ANSI.LETTER_M) {
        index = j + 1;
        continue;
      }
      break;
    }
    return index;
  }
  function trailingSgrSpanStartIndex(string) {
    let start = string.length;
    while (start > 1 && string.codePointAt(start - 1) === ANSI.LETTER_M) {
      let j = start - 2;
      while (j >= 0 && isSgrParameter(string.codePointAt(j))) {
        j--;
      }
      if (j >= 1 && string.codePointAt(j - 1) === ANSI.ESC && string.codePointAt(j) === ANSI.LEFT_BRACKET) {
        start = j - 1;
        continue;
      }
      break;
    }
    return start;
  }
  function appendWithInheritedStyleFromEnd(visible, suffix) {
    const start = trailingSgrSpanStartIndex(visible);
    if (start === visible.length) {
      return visible + suffix;
    }
    return visible.slice(0, start) + suffix + visible.slice(start);
  }
  function prependWithInheritedStyleFromStart(prefix, visible) {
    const end = leadingSgrSpanEndIndex(visible);
    if (end === 0) {
      return prefix + visible;
    }
    return visible.slice(0, end) + prefix + visible.slice(end);
  }
  if (position === "start") {
    if (preferTruncationOnSpace) {
      const nearestSpace = getIndexOfNearestSpace(text, length - columns + 1, true);
      const right2 = sliceAnsi(text, nearestSpace, length).trim();
      return prependWithInheritedStyleFromStart(truncationCharacter, right2);
    }
    if (space) {
      truncationCharacter += " ";
    }
    const right = sliceAnsi(text, length - columns + stringWidth3(truncationCharacter), length);
    return prependWithInheritedStyleFromStart(truncationCharacter, right);
  }
  if (position === "middle") {
    if (space) {
      truncationCharacter = ` ${truncationCharacter} `;
    }
    const half = Math.floor(columns / 2);
    if (preferTruncationOnSpace) {
      const spaceNearFirstBreakPoint = getIndexOfNearestSpace(text, half);
      const spaceNearSecondBreakPoint = getIndexOfNearestSpace(text, length - (columns - half) + 1, true);
      return sliceAnsi(text, 0, spaceNearFirstBreakPoint) + truncationCharacter + sliceAnsi(text, spaceNearSecondBreakPoint, length).trim();
    }
    return sliceAnsi(text, 0, half) + truncationCharacter + sliceAnsi(text, length - (columns - half) + stringWidth3(truncationCharacter), length);
  }
  if (position === "end") {
    if (preferTruncationOnSpace) {
      const nearestSpace = getIndexOfNearestSpace(text, columns - 1);
      const left2 = sliceAnsi(text, 0, nearestSpace);
      return appendWithInheritedStyleFromEnd(left2, truncationCharacter);
    }
    if (space) {
      truncationCharacter = ` ${truncationCharacter}`;
    }
    const left = sliceAnsi(text, 0, columns - stringWidth3(truncationCharacter));
    return appendWithInheritedStyleFromEnd(left, truncationCharacter);
  }
  throw new Error(`Expected \`options.position\` to be either \`start\`, \`middle\` or \`end\`, got ${position}`);
}

// node_modules/ink/build/wrap-text.js
var cache2 = {};
var wrapText = (text, maxWidth, wrapType) => {
  const cacheKey = text + String(maxWidth) + String(wrapType);
  const cachedText = cache2[cacheKey];
  if (cachedText) {
    return cachedText;
  }
  let wrappedText = text;
  if (wrapType === "wrap") {
    wrappedText = wrapAnsi(text, maxWidth, {
      trim: false,
      hard: true
    });
  }
  if (wrapType.startsWith("truncate")) {
    let position = "end";
    if (wrapType === "truncate-middle") {
      position = "middle";
    }
    if (wrapType === "truncate-start") {
      position = "start";
    }
    wrappedText = cliTruncate(text, maxWidth, { position });
  }
  cache2[cacheKey] = wrappedText;
  return wrappedText;
};
var wrap_text_default = wrapText;

// node_modules/ink/build/squash-text-nodes.js
var squashTextNodes = (node) => {
  let text = "";
  for (let index = 0;index < node.childNodes.length; index++) {
    const childNode = node.childNodes[index];
    if (childNode === undefined) {
      continue;
    }
    let nodeText = "";
    if (childNode.nodeName === "#text") {
      nodeText = childNode.nodeValue;
    } else {
      if (childNode.nodeName === "ink-text" || childNode.nodeName === "ink-virtual-text") {
        nodeText = squashTextNodes(childNode);
      }
      if (nodeText.length > 0 && typeof childNode.internal_transform === "function") {
        nodeText = childNode.internal_transform(nodeText, index);
      }
    }
    text += nodeText;
  }
  return text;
};
var squash_text_nodes_default = squashTextNodes;

// node_modules/ink/build/dom.js
var createNode = (nodeName) => {
  const node = {
    nodeName,
    style: {},
    attributes: {},
    childNodes: [],
    parentNode: undefined,
    yogaNode: nodeName === "ink-virtual-text" ? undefined : src_default.Node.create(),
    internal_accessibility: {}
  };
  if (nodeName === "ink-text") {
    node.yogaNode?.setMeasureFunc(measureTextNode.bind(null, node));
  }
  return node;
};
var appendChildNode = (node, childNode) => {
  if (childNode.parentNode) {
    removeChildNode(childNode.parentNode, childNode);
  }
  childNode.parentNode = node;
  node.childNodes.push(childNode);
  if (childNode.yogaNode) {
    node.yogaNode?.insertChild(childNode.yogaNode, node.yogaNode.getChildCount());
  }
  if (node.nodeName === "ink-text" || node.nodeName === "ink-virtual-text") {
    markNodeAsDirty(node);
  }
};
var insertBeforeNode = (node, newChildNode, beforeChildNode) => {
  if (newChildNode.parentNode) {
    removeChildNode(newChildNode.parentNode, newChildNode);
  }
  newChildNode.parentNode = node;
  const index = node.childNodes.indexOf(beforeChildNode);
  if (index >= 0) {
    node.childNodes.splice(index, 0, newChildNode);
    if (newChildNode.yogaNode) {
      node.yogaNode?.insertChild(newChildNode.yogaNode, index);
    }
    return;
  }
  node.childNodes.push(newChildNode);
  if (newChildNode.yogaNode) {
    node.yogaNode?.insertChild(newChildNode.yogaNode, node.yogaNode.getChildCount());
  }
  if (node.nodeName === "ink-text" || node.nodeName === "ink-virtual-text") {
    markNodeAsDirty(node);
  }
};
var removeChildNode = (node, removeNode) => {
  if (removeNode.yogaNode) {
    removeNode.parentNode?.yogaNode?.removeChild(removeNode.yogaNode);
  }
  removeNode.parentNode = undefined;
  const index = node.childNodes.indexOf(removeNode);
  if (index >= 0) {
    node.childNodes.splice(index, 1);
  }
  if (node.nodeName === "ink-text" || node.nodeName === "ink-virtual-text") {
    markNodeAsDirty(node);
  }
};
var setAttribute = (node, key, value) => {
  if (key === "internal_accessibility") {
    node.internal_accessibility = value;
    return;
  }
  node.attributes[key] = value;
};
var setStyle = (node, style) => {
  node.style = style;
};
var createTextNode = (text) => {
  const node = {
    nodeName: "#text",
    nodeValue: text,
    yogaNode: undefined,
    parentNode: undefined,
    style: {}
  };
  setTextNodeValue(node, text);
  return node;
};
var measureTextNode = function(node, width) {
  const text = node.nodeName === "#text" ? node.nodeValue : squash_text_nodes_default(node);
  const dimensions = measure_text_default(text);
  if (dimensions.width <= width) {
    return dimensions;
  }
  if (dimensions.width >= 1 && width > 0 && width < 1) {
    return dimensions;
  }
  const textWrap = node.style?.textWrap ?? "wrap";
  const wrappedText = wrap_text_default(text, width, textWrap);
  return measure_text_default(wrappedText);
};
var findClosestYogaNode = (node) => {
  if (!node?.parentNode) {
    return;
  }
  return node.yogaNode ?? findClosestYogaNode(node.parentNode);
};
var markNodeAsDirty = (node) => {
  const yogaNode = findClosestYogaNode(node);
  yogaNode?.markDirty();
};
var setTextNodeValue = (node, text) => {
  if (typeof text !== "string") {
    text = String(text);
  }
  node.nodeValue = text;
  markNodeAsDirty(node);
};

// node_modules/ink/build/styles.js
var applyPositionStyles = (node, style) => {
  if ("position" in style) {
    node.setPositionType(style.position === "absolute" ? src_default.POSITION_TYPE_ABSOLUTE : src_default.POSITION_TYPE_RELATIVE);
  }
};
var applyMarginStyles = (node, style) => {
  if ("margin" in style) {
    node.setMargin(src_default.EDGE_ALL, style.margin ?? 0);
  }
  if ("marginX" in style) {
    node.setMargin(src_default.EDGE_HORIZONTAL, style.marginX ?? 0);
  }
  if ("marginY" in style) {
    node.setMargin(src_default.EDGE_VERTICAL, style.marginY ?? 0);
  }
  if ("marginLeft" in style) {
    node.setMargin(src_default.EDGE_START, style.marginLeft || 0);
  }
  if ("marginRight" in style) {
    node.setMargin(src_default.EDGE_END, style.marginRight || 0);
  }
  if ("marginTop" in style) {
    node.setMargin(src_default.EDGE_TOP, style.marginTop || 0);
  }
  if ("marginBottom" in style) {
    node.setMargin(src_default.EDGE_BOTTOM, style.marginBottom || 0);
  }
};
var applyPaddingStyles = (node, style) => {
  if ("padding" in style) {
    node.setPadding(src_default.EDGE_ALL, style.padding ?? 0);
  }
  if ("paddingX" in style) {
    node.setPadding(src_default.EDGE_HORIZONTAL, style.paddingX ?? 0);
  }
  if ("paddingY" in style) {
    node.setPadding(src_default.EDGE_VERTICAL, style.paddingY ?? 0);
  }
  if ("paddingLeft" in style) {
    node.setPadding(src_default.EDGE_LEFT, style.paddingLeft || 0);
  }
  if ("paddingRight" in style) {
    node.setPadding(src_default.EDGE_RIGHT, style.paddingRight || 0);
  }
  if ("paddingTop" in style) {
    node.setPadding(src_default.EDGE_TOP, style.paddingTop || 0);
  }
  if ("paddingBottom" in style) {
    node.setPadding(src_default.EDGE_BOTTOM, style.paddingBottom || 0);
  }
};
var applyFlexStyles = (node, style) => {
  if ("flexGrow" in style) {
    node.setFlexGrow(style.flexGrow ?? 0);
  }
  if ("flexShrink" in style) {
    node.setFlexShrink(typeof style.flexShrink === "number" ? style.flexShrink : 1);
  }
  if ("flexWrap" in style) {
    if (style.flexWrap === "nowrap") {
      node.setFlexWrap(src_default.WRAP_NO_WRAP);
    }
    if (style.flexWrap === "wrap") {
      node.setFlexWrap(src_default.WRAP_WRAP);
    }
    if (style.flexWrap === "wrap-reverse") {
      node.setFlexWrap(src_default.WRAP_WRAP_REVERSE);
    }
  }
  if ("flexDirection" in style) {
    if (style.flexDirection === "row") {
      node.setFlexDirection(src_default.FLEX_DIRECTION_ROW);
    }
    if (style.flexDirection === "row-reverse") {
      node.setFlexDirection(src_default.FLEX_DIRECTION_ROW_REVERSE);
    }
    if (style.flexDirection === "column") {
      node.setFlexDirection(src_default.FLEX_DIRECTION_COLUMN);
    }
    if (style.flexDirection === "column-reverse") {
      node.setFlexDirection(src_default.FLEX_DIRECTION_COLUMN_REVERSE);
    }
  }
  if ("flexBasis" in style) {
    if (typeof style.flexBasis === "number") {
      node.setFlexBasis(style.flexBasis);
    } else if (typeof style.flexBasis === "string") {
      node.setFlexBasisPercent(Number.parseInt(style.flexBasis, 10));
    } else {
      node.setFlexBasis(Number.NaN);
    }
  }
  if ("alignItems" in style) {
    if (style.alignItems === "stretch" || !style.alignItems) {
      node.setAlignItems(src_default.ALIGN_STRETCH);
    }
    if (style.alignItems === "flex-start") {
      node.setAlignItems(src_default.ALIGN_FLEX_START);
    }
    if (style.alignItems === "center") {
      node.setAlignItems(src_default.ALIGN_CENTER);
    }
    if (style.alignItems === "flex-end") {
      node.setAlignItems(src_default.ALIGN_FLEX_END);
    }
  }
  if ("alignSelf" in style) {
    if (style.alignSelf === "auto" || !style.alignSelf) {
      node.setAlignSelf(src_default.ALIGN_AUTO);
    }
    if (style.alignSelf === "flex-start") {
      node.setAlignSelf(src_default.ALIGN_FLEX_START);
    }
    if (style.alignSelf === "center") {
      node.setAlignSelf(src_default.ALIGN_CENTER);
    }
    if (style.alignSelf === "flex-end") {
      node.setAlignSelf(src_default.ALIGN_FLEX_END);
    }
  }
  if ("justifyContent" in style) {
    if (style.justifyContent === "flex-start" || !style.justifyContent) {
      node.setJustifyContent(src_default.JUSTIFY_FLEX_START);
    }
    if (style.justifyContent === "center") {
      node.setJustifyContent(src_default.JUSTIFY_CENTER);
    }
    if (style.justifyContent === "flex-end") {
      node.setJustifyContent(src_default.JUSTIFY_FLEX_END);
    }
    if (style.justifyContent === "space-between") {
      node.setJustifyContent(src_default.JUSTIFY_SPACE_BETWEEN);
    }
    if (style.justifyContent === "space-around") {
      node.setJustifyContent(src_default.JUSTIFY_SPACE_AROUND);
    }
    if (style.justifyContent === "space-evenly") {
      node.setJustifyContent(src_default.JUSTIFY_SPACE_EVENLY);
    }
  }
};
var applyDimensionStyles = (node, style) => {
  if ("width" in style) {
    if (typeof style.width === "number") {
      node.setWidth(style.width);
    } else if (typeof style.width === "string") {
      node.setWidthPercent(Number.parseInt(style.width, 10));
    } else {
      node.setWidthAuto();
    }
  }
  if ("height" in style) {
    if (typeof style.height === "number") {
      node.setHeight(style.height);
    } else if (typeof style.height === "string") {
      node.setHeightPercent(Number.parseInt(style.height, 10));
    } else {
      node.setHeightAuto();
    }
  }
  if ("minWidth" in style) {
    if (typeof style.minWidth === "string") {
      node.setMinWidthPercent(Number.parseInt(style.minWidth, 10));
    } else {
      node.setMinWidth(style.minWidth ?? 0);
    }
  }
  if ("minHeight" in style) {
    if (typeof style.minHeight === "string") {
      node.setMinHeightPercent(Number.parseInt(style.minHeight, 10));
    } else {
      node.setMinHeight(style.minHeight ?? 0);
    }
  }
};
var applyDisplayStyles = (node, style) => {
  if ("display" in style) {
    node.setDisplay(style.display === "flex" ? src_default.DISPLAY_FLEX : src_default.DISPLAY_NONE);
  }
};
var applyBorderStyles = (node, style) => {
  if ("borderStyle" in style) {
    const borderWidth = style.borderStyle ? 1 : 0;
    if (style.borderTop !== false) {
      node.setBorder(src_default.EDGE_TOP, borderWidth);
    }
    if (style.borderBottom !== false) {
      node.setBorder(src_default.EDGE_BOTTOM, borderWidth);
    }
    if (style.borderLeft !== false) {
      node.setBorder(src_default.EDGE_LEFT, borderWidth);
    }
    if (style.borderRight !== false) {
      node.setBorder(src_default.EDGE_RIGHT, borderWidth);
    }
  }
};
var applyGapStyles = (node, style) => {
  if ("gap" in style) {
    node.setGap(src_default.GUTTER_ALL, style.gap ?? 0);
  }
  if ("columnGap" in style) {
    node.setGap(src_default.GUTTER_COLUMN, style.columnGap ?? 0);
  }
  if ("rowGap" in style) {
    node.setGap(src_default.GUTTER_ROW, style.rowGap ?? 0);
  }
};
var styles2 = (node, style = {}) => {
  applyPositionStyles(node, style);
  applyMarginStyles(node, style);
  applyPaddingStyles(node, style);
  applyFlexStyles(node, style);
  applyDimensionStyles(node, style);
  applyDisplayStyles(node, style);
  applyBorderStyles(node, style);
  applyGapStyles(node, style);
};
var styles_default = styles2;

// node_modules/ink/build/reconciler.js
if (process3.env["DEV"] === "true") {
  try {
    await Promise.resolve().then(() => (init_devtools(), exports_devtools));
  } catch (error) {
    if (error.code === "ERR_MODULE_NOT_FOUND") {
      console.warn(`
The environment variable DEV is set to true, so Ink tried to import \`react-devtools-core\`,
but this failed as it was not installed. Debugging with React Devtools requires it.

To install use this command:

$ npm install --save-dev react-devtools-core
				`.trim() + `
`);
    } else {
      throw error;
    }
  }
}
var diff = (before, after) => {
  if (before === after) {
    return;
  }
  if (!before) {
    return after;
  }
  const changed = {};
  let isChanged = false;
  for (const key of Object.keys(before)) {
    const isDeleted = after ? !Object.hasOwn(after, key) : true;
    if (isDeleted) {
      changed[key] = undefined;
      isChanged = true;
    }
  }
  if (after) {
    for (const key of Object.keys(after)) {
      if (after[key] !== before[key]) {
        changed[key] = after[key];
        isChanged = true;
      }
    }
  }
  return isChanged ? changed : undefined;
};
var cleanupYogaNode = (node) => {
  node?.unsetMeasureFunc();
  node?.freeRecursive();
};
var currentUpdatePriority = import_constants.NoEventPriority;
var currentRootNode;
var reconciler_default = import_react_reconciler.default({
  getRootHostContext: () => ({
    isInsideText: false
  }),
  prepareForCommit: () => null,
  preparePortalMount: () => null,
  clearContainer: () => false,
  resetAfterCommit(rootNode) {
    if (typeof rootNode.onComputeLayout === "function") {
      rootNode.onComputeLayout();
    }
    if (rootNode.isStaticDirty) {
      rootNode.isStaticDirty = false;
      if (typeof rootNode.onImmediateRender === "function") {
        rootNode.onImmediateRender();
      }
      return;
    }
    if (typeof rootNode.onRender === "function") {
      rootNode.onRender();
    }
  },
  getChildHostContext(parentHostContext, type) {
    const previousIsInsideText = parentHostContext.isInsideText;
    const isInsideText = type === "ink-text" || type === "ink-virtual-text";
    if (previousIsInsideText === isInsideText) {
      return parentHostContext;
    }
    return { isInsideText };
  },
  shouldSetTextContent: () => false,
  createInstance(originalType, newProps, rootNode, hostContext) {
    if (hostContext.isInsideText && originalType === "ink-box") {
      throw new Error(`<Box> cant be nested inside <Text> component`);
    }
    const type = originalType === "ink-text" && hostContext.isInsideText ? "ink-virtual-text" : originalType;
    const node = createNode(type);
    for (const [key, value] of Object.entries(newProps)) {
      if (key === "children") {
        continue;
      }
      if (key === "style") {
        setStyle(node, value);
        if (node.yogaNode) {
          styles_default(node.yogaNode, value);
        }
        continue;
      }
      if (key === "internal_transform") {
        node.internal_transform = value;
        continue;
      }
      if (key === "internal_static") {
        currentRootNode = rootNode;
        node.internal_static = true;
        rootNode.isStaticDirty = true;
        rootNode.staticNode = node;
        continue;
      }
      setAttribute(node, key, value);
    }
    return node;
  },
  createTextInstance(text, _root, hostContext) {
    if (!hostContext.isInsideText) {
      throw new Error(`Text string "${text}" must be rendered inside <Text> component`);
    }
    return createTextNode(text);
  },
  resetTextContent() {},
  hideTextInstance(node) {
    setTextNodeValue(node, "");
  },
  unhideTextInstance(node, text) {
    setTextNodeValue(node, text);
  },
  getPublicInstance: (instance) => instance,
  hideInstance(node) {
    node.yogaNode?.setDisplay(src_default.DISPLAY_NONE);
  },
  unhideInstance(node) {
    node.yogaNode?.setDisplay(src_default.DISPLAY_FLEX);
  },
  appendInitialChild: appendChildNode,
  appendChild: appendChildNode,
  insertBefore: insertBeforeNode,
  finalizeInitialChildren() {
    return false;
  },
  isPrimaryRenderer: true,
  supportsMutation: true,
  supportsPersistence: false,
  supportsHydration: false,
  scheduleTimeout: setTimeout,
  cancelTimeout: clearTimeout,
  noTimeout: -1,
  beforeActiveInstanceBlur() {},
  afterActiveInstanceBlur() {},
  detachDeletedInstance() {},
  getInstanceFromNode: () => null,
  prepareScopeUpdate() {},
  getInstanceFromScope: () => null,
  appendChildToContainer: appendChildNode,
  insertInContainerBefore: insertBeforeNode,
  removeChildFromContainer(node, removeNode) {
    removeChildNode(node, removeNode);
    cleanupYogaNode(removeNode.yogaNode);
  },
  commitUpdate(node, _type, oldProps, newProps) {
    if (currentRootNode && node.internal_static) {
      currentRootNode.isStaticDirty = true;
    }
    const props = diff(oldProps, newProps);
    const style = diff(oldProps["style"], newProps["style"]);
    if (!props && !style) {
      return;
    }
    if (props) {
      for (const [key, value] of Object.entries(props)) {
        if (key === "style") {
          setStyle(node, value);
          continue;
        }
        if (key === "internal_transform") {
          node.internal_transform = value;
          continue;
        }
        if (key === "internal_static") {
          node.internal_static = true;
          continue;
        }
        setAttribute(node, key, value);
      }
    }
    if (style && node.yogaNode) {
      styles_default(node.yogaNode, style);
    }
  },
  commitTextUpdate(node, _oldText, newText) {
    setTextNodeValue(node, newText);
  },
  removeChild(node, removeNode) {
    removeChildNode(node, removeNode);
    cleanupYogaNode(removeNode.yogaNode);
  },
  setCurrentUpdatePriority(newPriority) {
    currentUpdatePriority = newPriority;
  },
  getCurrentUpdatePriority: () => currentUpdatePriority,
  resolveUpdatePriority() {
    if (currentUpdatePriority !== import_constants.NoEventPriority) {
      return currentUpdatePriority;
    }
    return import_constants.DefaultEventPriority;
  },
  maySuspendCommit() {
    return false;
  },
  NotPendingTransition: undefined,
  HostTransitionContext: import_react.createContext(null),
  resetFormInstance() {},
  requestPostPaintCallback() {},
  shouldAttemptEagerTransition() {
    return false;
  },
  trackSchedulerEvent() {},
  resolveEventType() {
    return null;
  },
  resolveEventTimeStamp() {
    return -1.1;
  },
  preloadInstance() {
    return true;
  },
  startSuspendingCommit() {},
  suspendInstance() {},
  waitForCommitToBeReady() {
    return null;
  }
});

// node_modules/indent-string/index.js
function indentString(string, count = 1, options = {}) {
  const {
    indent = " ",
    includeEmptyLines = false
  } = options;
  if (typeof string !== "string") {
    throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
  }
  if (typeof count !== "number") {
    throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
  }
  if (count < 0) {
    throw new RangeError(`Expected \`count\` to be at least 0, got \`${count}\``);
  }
  if (typeof indent !== "string") {
    throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof indent}\``);
  }
  if (count === 0) {
    return string;
  }
  const regex2 = includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
  return string.replace(regex2, indent.repeat(count));
}

// node_modules/ink/build/get-max-width.js
var getMaxWidth = (yogaNode) => {
  return yogaNode.getComputedWidth() - yogaNode.getComputedPadding(src_default.EDGE_LEFT) - yogaNode.getComputedPadding(src_default.EDGE_RIGHT) - yogaNode.getComputedBorder(src_default.EDGE_LEFT) - yogaNode.getComputedBorder(src_default.EDGE_RIGHT);
};
var get_max_width_default = getMaxWidth;

// node_modules/ink/build/render-border.js
var import_cli_boxes = __toESM(require_cli_boxes(), 1);

// node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET2 = 10;
var wrapAnsi162 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi2562 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m2 = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles3 = {
  modifier: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    blackBright: [90, 39],
    gray: [90, 39],
    grey: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames2 = Object.keys(styles3.modifier);
var foregroundColorNames2 = Object.keys(styles3.color);
var backgroundColorNames2 = Object.keys(styles3.bgColor);
var colorNames2 = [...foregroundColorNames2, ...backgroundColorNames2];
function assembleStyles2() {
  const codes = new Map;
  for (const [groupName, group] of Object.entries(styles3)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles3[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles3[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles3, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles3, "codes", {
    value: codes,
    enumerable: false
  });
  styles3.color.close = "\x1B[39m";
  styles3.bgColor.close = "\x1B[49m";
  styles3.color.ansi = wrapAnsi162();
  styles3.color.ansi256 = wrapAnsi2562();
  styles3.color.ansi16m = wrapAnsi16m2();
  styles3.bgColor.ansi = wrapAnsi162(ANSI_BACKGROUND_OFFSET2);
  styles3.bgColor.ansi256 = wrapAnsi2562(ANSI_BACKGROUND_OFFSET2);
  styles3.bgColor.ansi16m = wrapAnsi16m2(ANSI_BACKGROUND_OFFSET2);
  Object.defineProperties(styles3, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles3.rgbToAnsi256(...styles3.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles3.ansi256ToAnsi(styles3.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles3.ansi256ToAnsi(styles3.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles3;
}
var ansiStyles2 = assembleStyles2();
var ansi_styles_default2 = ansiStyles2;

// node_modules/chalk/source/vendor/supports-color/index.js
import process4 from "node:process";
import os2 from "node:os";
import tty from "node:tty";
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process4.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env: env2 } = process4;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env2) {
    if (env2.FORCE_COLOR === "true") {
      return 1;
    }
    if (env2.FORCE_COLOR === "false") {
      return 0;
    }
    return env2.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env2.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== undefined) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env2 && "AGENT_NAME" in env2) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }
  const min = forceColor || 0;
  if (env2.TERM === "dumb") {
    return min;
  }
  if (process4.platform === "win32") {
    const osRelease = os2.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env2) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => (key in env2))) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => (sign in env2)) || env2.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env2) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env2.COLORTERM === "truecolor") {
    return 3;
  }
  if (env2.TERM === "xterm-kitty") {
    return 3;
  }
  if (env2.TERM === "xterm-ghostty") {
    return 3;
  }
  if (env2.TERM === "wezterm") {
    return 3;
  }
  if ("TERM_PROGRAM" in env2) {
    const version = Number.parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env2.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env2.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env2) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream2, options = {}) {
  const level = _supportsColor(stream2, {
    streamIsTTY: stream2 && stream2.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? `\r
` : `
`) + postfix;
    endIndex = index + 1;
    index = string.indexOf(`
`, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles4 = Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === undefined ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk = (...strings) => strings.join(" ");
  applyOptions(chalk, options);
  Object.setPrototypeOf(chalk, createChalk.prototype);
  return chalk;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default2)) {
  styles4[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles4.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default2[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default2[type].ansi256(ansi_styles_default2.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default2[type].ansi(ansi_styles_default2.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default2.hexToRgb(...arguments_));
  }
  return ansi_styles_default2[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles4[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default2.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles4[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default2.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {}, {
  ...styles4,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === undefined) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== undefined) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf(`
`);
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles4);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// node_modules/ink/build/colorize.js
var rgbRegex = /^rgb\(\s?(\d+),\s?(\d+),\s?(\d+)\s?\)$/;
var ansiRegex2 = /^ansi256\(\s?(\d+)\s?\)$/;
var isNamedColor = (color) => {
  return color in source_default;
};
var colorize = (str, color, type) => {
  if (!color) {
    return str;
  }
  if (isNamedColor(color)) {
    if (type === "foreground") {
      return source_default[color](str);
    }
    const methodName = `bg${color[0].toUpperCase() + color.slice(1)}`;
    return source_default[methodName](str);
  }
  if (color.startsWith("#")) {
    return type === "foreground" ? source_default.hex(color)(str) : source_default.bgHex(color)(str);
  }
  if (color.startsWith("ansi256")) {
    const matches = ansiRegex2.exec(color);
    if (!matches) {
      return str;
    }
    const value = Number(matches[1]);
    return type === "foreground" ? source_default.ansi256(value)(str) : source_default.bgAnsi256(value)(str);
  }
  if (color.startsWith("rgb")) {
    const matches = rgbRegex.exec(color);
    if (!matches) {
      return str;
    }
    const firstValue = Number(matches[1]);
    const secondValue = Number(matches[2]);
    const thirdValue = Number(matches[3]);
    return type === "foreground" ? source_default.rgb(firstValue, secondValue, thirdValue)(str) : source_default.bgRgb(firstValue, secondValue, thirdValue)(str);
  }
  return str;
};
var colorize_default = colorize;

// node_modules/ink/build/render-border.js
var renderBorder = (x, y, node, output) => {
  if (node.style.borderStyle) {
    const width = node.yogaNode.getComputedWidth();
    const height = node.yogaNode.getComputedHeight();
    const box = typeof node.style.borderStyle === "string" ? import_cli_boxes.default[node.style.borderStyle] : node.style.borderStyle;
    const topBorderColor = node.style.borderTopColor ?? node.style.borderColor;
    const bottomBorderColor = node.style.borderBottomColor ?? node.style.borderColor;
    const leftBorderColor = node.style.borderLeftColor ?? node.style.borderColor;
    const rightBorderColor = node.style.borderRightColor ?? node.style.borderColor;
    const dimTopBorderColor = node.style.borderTopDimColor ?? node.style.borderDimColor;
    const dimBottomBorderColor = node.style.borderBottomDimColor ?? node.style.borderDimColor;
    const dimLeftBorderColor = node.style.borderLeftDimColor ?? node.style.borderDimColor;
    const dimRightBorderColor = node.style.borderRightDimColor ?? node.style.borderDimColor;
    const showTopBorder = node.style.borderTop !== false;
    const showBottomBorder = node.style.borderBottom !== false;
    const showLeftBorder = node.style.borderLeft !== false;
    const showRightBorder = node.style.borderRight !== false;
    const contentWidth = width - (showLeftBorder ? 1 : 0) - (showRightBorder ? 1 : 0);
    let topBorder = showTopBorder ? colorize_default((showLeftBorder ? box.topLeft : "") + box.top.repeat(contentWidth) + (showRightBorder ? box.topRight : ""), topBorderColor, "foreground") : undefined;
    if (showTopBorder && dimTopBorderColor) {
      topBorder = source_default.dim(topBorder);
    }
    let verticalBorderHeight = height;
    if (showTopBorder) {
      verticalBorderHeight -= 1;
    }
    if (showBottomBorder) {
      verticalBorderHeight -= 1;
    }
    let leftBorder = (colorize_default(box.left, leftBorderColor, "foreground") + `
`).repeat(verticalBorderHeight);
    if (dimLeftBorderColor) {
      leftBorder = source_default.dim(leftBorder);
    }
    let rightBorder = (colorize_default(box.right, rightBorderColor, "foreground") + `
`).repeat(verticalBorderHeight);
    if (dimRightBorderColor) {
      rightBorder = source_default.dim(rightBorder);
    }
    let bottomBorder = showBottomBorder ? colorize_default((showLeftBorder ? box.bottomLeft : "") + box.bottom.repeat(contentWidth) + (showRightBorder ? box.bottomRight : ""), bottomBorderColor, "foreground") : undefined;
    if (showBottomBorder && dimBottomBorderColor) {
      bottomBorder = source_default.dim(bottomBorder);
    }
    const offsetY = showTopBorder ? 1 : 0;
    if (topBorder) {
      output.write(x, y, topBorder, { transformers: [] });
    }
    if (showLeftBorder) {
      output.write(x, y + offsetY, leftBorder, { transformers: [] });
    }
    if (showRightBorder) {
      output.write(x + width - 1, y + offsetY, rightBorder, {
        transformers: []
      });
    }
    if (bottomBorder) {
      output.write(x, y + height - 1, bottomBorder, { transformers: [] });
    }
  }
};
var render_border_default = renderBorder;

// node_modules/ink/build/render-background.js
var renderBackground = (x, y, node, output) => {
  if (!node.style.backgroundColor) {
    return;
  }
  const width = node.yogaNode.getComputedWidth();
  const height = node.yogaNode.getComputedHeight();
  const leftBorderWidth = node.style.borderStyle && node.style.borderLeft !== false ? 1 : 0;
  const rightBorderWidth = node.style.borderStyle && node.style.borderRight !== false ? 1 : 0;
  const topBorderHeight = node.style.borderStyle && node.style.borderTop !== false ? 1 : 0;
  const bottomBorderHeight = node.style.borderStyle && node.style.borderBottom !== false ? 1 : 0;
  const contentWidth = width - leftBorderWidth - rightBorderWidth;
  const contentHeight = height - topBorderHeight - bottomBorderHeight;
  if (!(contentWidth > 0 && contentHeight > 0)) {
    return;
  }
  const backgroundLine = colorize_default(" ".repeat(contentWidth), node.style.backgroundColor, "background");
  for (let row = 0;row < contentHeight; row++) {
    output.write(x + leftBorderWidth, y + topBorderHeight + row, backgroundLine, { transformers: [] });
  }
};
var render_background_default = renderBackground;

// node_modules/ink/build/render-node-to-output.js
var applyPaddingToText = (node, text) => {
  const yogaNode = node.childNodes[0]?.yogaNode;
  if (yogaNode) {
    const offsetX = yogaNode.getComputedLeft();
    const offsetY = yogaNode.getComputedTop();
    text = `
`.repeat(offsetY) + indentString(text, offsetX);
  }
  return text;
};
var renderNodeToScreenReaderOutput = (node, options = {}) => {
  if (options.skipStaticElements && node.internal_static) {
    return "";
  }
  if (node.yogaNode?.getDisplay() === src_default.DISPLAY_NONE) {
    return "";
  }
  let output = "";
  if (node.nodeName === "ink-text") {
    output = squash_text_nodes_default(node);
  } else if (node.nodeName === "ink-box" || node.nodeName === "ink-root") {
    const separator = node.style.flexDirection === "row" || node.style.flexDirection === "row-reverse" ? " " : `
`;
    const childNodes = node.style.flexDirection === "row-reverse" || node.style.flexDirection === "column-reverse" ? [...node.childNodes].reverse() : [...node.childNodes];
    output = childNodes.map((childNode) => {
      const screenReaderOutput = renderNodeToScreenReaderOutput(childNode, {
        parentRole: node.internal_accessibility?.role,
        skipStaticElements: options.skipStaticElements
      });
      return screenReaderOutput;
    }).filter(Boolean).join(separator);
  }
  if (node.internal_accessibility) {
    const { role, state } = node.internal_accessibility;
    if (state) {
      const stateKeys = Object.keys(state);
      const stateDescription = stateKeys.filter((key) => state[key]).join(", ");
      if (stateDescription) {
        output = `(${stateDescription}) ${output}`;
      }
    }
    if (role && role !== options.parentRole) {
      output = `${role}: ${output}`;
    }
  }
  return output;
};
var renderNodeToOutput = (node, output, options) => {
  const { offsetX = 0, offsetY = 0, transformers = [], skipStaticElements } = options;
  if (skipStaticElements && node.internal_static) {
    return;
  }
  const { yogaNode } = node;
  if (yogaNode) {
    if (yogaNode.getDisplay() === src_default.DISPLAY_NONE) {
      return;
    }
    const x = offsetX + yogaNode.getComputedLeft();
    const y = offsetY + yogaNode.getComputedTop();
    let newTransformers = transformers;
    if (typeof node.internal_transform === "function") {
      newTransformers = [node.internal_transform, ...transformers];
    }
    if (node.nodeName === "ink-text") {
      let text = squash_text_nodes_default(node);
      if (text.length > 0) {
        const currentWidth = widestLine(text);
        const maxWidth = get_max_width_default(yogaNode);
        if (currentWidth > maxWidth) {
          const textWrap = node.style.textWrap ?? "wrap";
          text = wrap_text_default(text, maxWidth, textWrap);
        }
        text = applyPaddingToText(node, text);
        output.write(x, y, text, { transformers: newTransformers });
      }
      return;
    }
    let clipped = false;
    if (node.nodeName === "ink-box") {
      render_background_default(x, y, node, output);
      render_border_default(x, y, node, output);
      const clipHorizontally = node.style.overflowX === "hidden" || node.style.overflow === "hidden";
      const clipVertically = node.style.overflowY === "hidden" || node.style.overflow === "hidden";
      if (clipHorizontally || clipVertically) {
        const x1 = clipHorizontally ? x + yogaNode.getComputedBorder(src_default.EDGE_LEFT) : undefined;
        const x2 = clipHorizontally ? x + yogaNode.getComputedWidth() - yogaNode.getComputedBorder(src_default.EDGE_RIGHT) : undefined;
        const y1 = clipVertically ? y + yogaNode.getComputedBorder(src_default.EDGE_TOP) : undefined;
        const y2 = clipVertically ? y + yogaNode.getComputedHeight() - yogaNode.getComputedBorder(src_default.EDGE_BOTTOM) : undefined;
        output.clip({ x1, x2, y1, y2 });
        clipped = true;
      }
    }
    if (node.nodeName === "ink-root" || node.nodeName === "ink-box") {
      for (const childNode of node.childNodes) {
        renderNodeToOutput(childNode, output, {
          offsetX: x,
          offsetY: y,
          transformers: newTransformers,
          skipStaticElements
        });
      }
      if (clipped) {
        output.unclip();
      }
    }
  }
};
var render_node_to_output_default = renderNodeToOutput;

// node_modules/@alcalzone/ansi-tokenize/build/ansiCodes.js
var ESCAPES3 = new Set([27, 155]);
var CSI = "[".codePointAt(0);
var OSC2 = "]".codePointAt(0);
var endCodesSet2 = new Set;
var endCodesMap2 = new Map;
for (const [start, end] of ansi_styles_default.codes) {
  endCodesSet2.add(ansi_styles_default.color.ansi(end));
  endCodesMap2.set(ansi_styles_default.color.ansi(start), ansi_styles_default.color.ansi(end));
}
var linkStartCodePrefix = "\x1B]8;;";
var linkStartCodePrefixCharCodes = linkStartCodePrefix.split("").map((char) => char.charCodeAt(0));
var linkCodeSuffix = "\x07";
var linkCodeSuffixCharCode = linkCodeSuffix.charCodeAt(0);
var linkEndCode = `\x1B]8;;${linkCodeSuffix}`;
function getEndCode2(code) {
  if (endCodesSet2.has(code))
    return code;
  if (endCodesMap2.has(code))
    return endCodesMap2.get(code);
  if (code.startsWith(linkStartCodePrefix))
    return linkEndCode;
  code = code.slice(2);
  if (code.startsWith("38")) {
    return ansi_styles_default.color.close;
  } else if (code.startsWith("48")) {
    return ansi_styles_default.bgColor.close;
  }
  const ret = ansi_styles_default.codes.get(parseInt(code, 10));
  if (ret) {
    return ansi_styles_default.color.ansi(ret);
  } else {
    return ansi_styles_default.reset.open;
  }
}
function ansiCodesToString(codes) {
  return codes.map((code) => code.code).join("");
}
// node_modules/@alcalzone/ansi-tokenize/build/reduce.js
function reduceAnsiCodes2(codes) {
  return reduceAnsiCodesIncremental([], codes);
}
function reduceAnsiCodesIncremental(codes, newCodes) {
  let ret = [...codes];
  for (const code of newCodes) {
    if (code.code === ansi_styles_default.reset.open) {
      ret = [];
    } else if (endCodesSet2.has(code.code)) {
      ret = ret.filter((retCode) => retCode.endCode !== code.code);
    } else {
      const isIntensityCode = code.code === ansi_styles_default.bold.open || code.code === ansi_styles_default.dim.open;
      if (isIntensityCode) {
        if (!ret.find((retCode) => retCode.code === code.code && retCode.endCode === code.endCode)) {
          ret.push(code);
        }
      } else {
        ret = ret.filter((retCode) => retCode.endCode !== code.endCode);
        ret.push(code);
      }
    }
  }
  return ret;
}

// node_modules/@alcalzone/ansi-tokenize/build/undo.js
function undoAnsiCodes2(codes) {
  return reduceAnsiCodes2(codes).reverse().map((code) => ({
    ...code,
    code: code.endCode
  }));
}

// node_modules/@alcalzone/ansi-tokenize/build/diff.js
function diffAnsiCodes(from, to) {
  const endCodesInTo = new Set(to.map((code) => code.endCode));
  const startCodesInFrom = new Set(from.map((code) => code.code));
  return [
    ...undoAnsiCodes2(from.filter((code) => !endCodesInTo.has(code.endCode))),
    ...to.filter((code) => !startCodesInFrom.has(code.code))
  ];
}
// node_modules/@alcalzone/ansi-tokenize/build/styledChars.js
function styledCharsFromTokens(tokens) {
  let codes = [];
  const ret = [];
  for (const token of tokens) {
    if (token.type === "ansi") {
      codes = reduceAnsiCodesIncremental(codes, [token]);
    } else if (token.type === "char") {
      ret.push({
        ...token,
        styles: [...codes]
      });
    }
  }
  return ret;
}
function styledCharsToString(chars) {
  let ret = "";
  for (let i = 0;i < chars.length; i++) {
    const char = chars[i];
    if (i === 0) {
      ret += ansiCodesToString(char.styles);
    } else {
      ret += ansiCodesToString(diffAnsiCodes(chars[i - 1].styles, char.styles));
    }
    ret += char.value;
    if (i === chars.length - 1) {
      ret += ansiCodesToString(diffAnsiCodes(char.styles, []));
    }
  }
  return ret;
}
// node_modules/@alcalzone/ansi-tokenize/build/tokenize.js
function parseLinkCode(string, offset) {
  string = string.slice(offset);
  for (let index = 1;index < linkStartCodePrefixCharCodes.length; index++) {
    if (string.charCodeAt(index) !== linkStartCodePrefixCharCodes[index]) {
      return;
    }
  }
  const endIndex = string.indexOf("\x07", linkStartCodePrefix.length);
  if (endIndex === -1)
    return;
  return string.slice(0, endIndex + 1);
}
var CC_0 = 48;
var CC_9 = 57;
var CC_SEMI = 59;
var CC_M = 109;
function findSGRSequenceEndIndex(str) {
  for (let index = 2;index < str.length; index++) {
    const charCode = str.charCodeAt(index);
    if (charCode === CC_M)
      return index;
    if (charCode === CC_SEMI)
      continue;
    if (charCode >= CC_0 && charCode <= CC_9)
      continue;
    break;
  }
  return -1;
}
function parseSGRSequence(string, offset) {
  string = string.slice(offset);
  const endIndex = findSGRSequenceEndIndex(string);
  if (endIndex === -1)
    return;
  return string.slice(0, endIndex + 1);
}
function splitCompoundSGRSequences(code) {
  if (!code.includes(";")) {
    return [code];
  }
  const codeParts = code.slice(2, -1).split(";");
  const ret = [];
  for (let i = 0;i < codeParts.length; i++) {
    const rawCode = codeParts[i];
    if (rawCode === "38" || rawCode === "48") {
      if (i + 2 < codeParts.length && codeParts[i + 1] === "5") {
        ret.push(codeParts.slice(i, i + 3).join(";"));
        i += 2;
        continue;
      } else if (i + 4 < codeParts.length && codeParts[i + 1] === "2") {
        ret.push(codeParts.slice(i, i + 5).join(";"));
        i += 4;
        continue;
      }
    }
    ret.push(rawCode);
  }
  return ret.map((part) => `\x1B[${part}m`);
}
function tokenize2(str, endChar = Number.POSITIVE_INFINITY) {
  const ret = [];
  let index = 0;
  let visible = 0;
  while (index < str.length) {
    const codePoint = str.codePointAt(index);
    if (ESCAPES3.has(codePoint)) {
      let code;
      const nextCodePoint = str.codePointAt(index + 1);
      if (nextCodePoint === OSC2) {
        code = parseLinkCode(str, index);
        if (code) {
          ret.push({
            type: "ansi",
            code,
            endCode: getEndCode2(code)
          });
        }
      } else if (nextCodePoint === CSI) {
        code = parseSGRSequence(str, index);
        if (code) {
          const codes = splitCompoundSGRSequences(code);
          for (const individualCode of codes) {
            ret.push({
              type: "ansi",
              code: individualCode,
              endCode: getEndCode2(individualCode)
            });
          }
        }
      }
      if (code) {
        index += code.length;
        continue;
      }
    }
    const fullWidth = isFullwidthCodePoint(codePoint);
    const character = String.fromCodePoint(codePoint);
    ret.push({
      type: "char",
      value: character,
      fullWidth
    });
    index += character.length;
    visible += fullWidth ? 2 : character.length;
    if (visible >= endChar) {
      break;
    }
  }
  return ret;
}
// node_modules/ink/build/output.js
class Output {
  width;
  height;
  operations = [];
  constructor(options) {
    const { width, height } = options;
    this.width = width;
    this.height = height;
  }
  write(x, y, text, options) {
    const { transformers } = options;
    if (!text) {
      return;
    }
    this.operations.push({
      type: "write",
      x,
      y,
      text,
      transformers
    });
  }
  clip(clip) {
    this.operations.push({
      type: "clip",
      clip
    });
  }
  unclip() {
    this.operations.push({
      type: "unclip"
    });
  }
  get() {
    const output = [];
    for (let y = 0;y < this.height; y++) {
      const row = [];
      for (let x = 0;x < this.width; x++) {
        row.push({
          type: "char",
          value: " ",
          fullWidth: false,
          styles: []
        });
      }
      output.push(row);
    }
    const clips = [];
    for (const operation of this.operations) {
      if (operation.type === "clip") {
        clips.push(operation.clip);
      }
      if (operation.type === "unclip") {
        clips.pop();
      }
      if (operation.type === "write") {
        const { text, transformers } = operation;
        let { x, y } = operation;
        let lines = text.split(`
`);
        const clip = clips.at(-1);
        if (clip) {
          const clipHorizontally = typeof clip?.x1 === "number" && typeof clip?.x2 === "number";
          const clipVertically = typeof clip?.y1 === "number" && typeof clip?.y2 === "number";
          if (clipHorizontally) {
            const width = widestLine(text);
            if (x + width < clip.x1 || x > clip.x2) {
              continue;
            }
          }
          if (clipVertically) {
            const height = lines.length;
            if (y + height < clip.y1 || y > clip.y2) {
              continue;
            }
          }
          if (clipHorizontally) {
            lines = lines.map((line) => {
              const from = x < clip.x1 ? clip.x1 - x : 0;
              const width = stringWidth3(line);
              const to = x + width > clip.x2 ? clip.x2 - x : width;
              return sliceAnsi(line, from, to);
            });
            if (x < clip.x1) {
              x = clip.x1;
            }
          }
          if (clipVertically) {
            const from = y < clip.y1 ? clip.y1 - y : 0;
            const height = lines.length;
            const to = y + height > clip.y2 ? clip.y2 - y : height;
            lines = lines.slice(from, to);
            if (y < clip.y1) {
              y = clip.y1;
            }
          }
        }
        let offsetY = 0;
        for (let [index, line] of lines.entries()) {
          const currentLine = output[y + offsetY];
          if (!currentLine) {
            continue;
          }
          for (const transformer of transformers) {
            line = transformer(line, index);
          }
          const characters = styledCharsFromTokens(tokenize2(line));
          let offsetX = x;
          for (const character of characters) {
            currentLine[offsetX] = character;
            const characterWidth = Math.max(1, stringWidth3(character.value));
            if (characterWidth > 1) {
              for (let index2 = 1;index2 < characterWidth; index2++) {
                currentLine[offsetX + index2] = {
                  type: "char",
                  value: "",
                  fullWidth: false,
                  styles: character.styles
                };
              }
            }
            offsetX += characterWidth;
          }
          offsetY++;
        }
      }
    }
    const generatedOutput = output.map((line) => {
      const lineWithoutEmptyItems = line.filter((item) => item !== undefined);
      return styledCharsToString(lineWithoutEmptyItems).trimEnd();
    }).join(`
`);
    return {
      output: generatedOutput,
      height: output.length
    };
  }
}

// node_modules/ink/build/renderer.js
var renderer = (node, isScreenReaderEnabled) => {
  if (node.yogaNode) {
    if (isScreenReaderEnabled) {
      const output2 = renderNodeToScreenReaderOutput(node, {
        skipStaticElements: true
      });
      const outputHeight2 = output2 === "" ? 0 : output2.split(`
`).length;
      let staticOutput2 = "";
      if (node.staticNode) {
        staticOutput2 = renderNodeToScreenReaderOutput(node.staticNode, {
          skipStaticElements: false
        });
      }
      return {
        output: output2,
        outputHeight: outputHeight2,
        staticOutput: staticOutput2 ? `${staticOutput2}
` : ""
      };
    }
    const output = new Output({
      width: node.yogaNode.getComputedWidth(),
      height: node.yogaNode.getComputedHeight()
    });
    render_node_to_output_default(node, output, {
      skipStaticElements: true
    });
    let staticOutput;
    if (node.staticNode?.yogaNode) {
      staticOutput = new Output({
        width: node.staticNode.yogaNode.getComputedWidth(),
        height: node.staticNode.yogaNode.getComputedHeight()
      });
      render_node_to_output_default(node.staticNode, staticOutput, {
        skipStaticElements: false
      });
    }
    const { output: generatedOutput, height: outputHeight } = output.get();
    return {
      output: generatedOutput,
      outputHeight,
      staticOutput: staticOutput ? `${staticOutput.get().output}
` : ""
    };
  }
  return {
    output: "",
    outputHeight: 0,
    staticOutput: ""
  };
};
var renderer_default = renderer;

// node_modules/cli-cursor/index.js
import process6 from "node:process";

// node_modules/restore-cursor/index.js
var import_onetime = __toESM(require_onetime(), 1);
var import_signal_exit = __toESM(require_signal_exit(), 1);
import process5 from "node:process";
var restoreCursor = import_onetime.default(() => {
  import_signal_exit.default(() => {
    process5.stderr.write("\x1B[?25h");
  }, { alwaysLast: true });
});
var restore_cursor_default = restoreCursor;

// node_modules/cli-cursor/index.js
var isHidden = false;
var cliCursor = {};
cliCursor.show = (writableStream = process6.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  isHidden = false;
  writableStream.write("\x1B[?25h");
};
cliCursor.hide = (writableStream = process6.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  restore_cursor_default();
  isHidden = true;
  writableStream.write("\x1B[?25l");
};
cliCursor.toggle = (force, writableStream) => {
  if (force !== undefined) {
    isHidden = force;
  }
  if (isHidden) {
    cliCursor.show(writableStream);
  } else {
    cliCursor.hide(writableStream);
  }
};
var cli_cursor_default = cliCursor;

// node_modules/ink/build/log-update.js
var createStandard = (stream2, { showCursor = false } = {}) => {
  let previousLineCount = 0;
  let previousOutput = "";
  let hasHiddenCursor = false;
  const render = (str) => {
    if (!showCursor && !hasHiddenCursor) {
      cli_cursor_default.hide();
      hasHiddenCursor = true;
    }
    const output = str + `
`;
    if (output === previousOutput) {
      return;
    }
    previousOutput = output;
    stream2.write(exports_base.eraseLines(previousLineCount) + output);
    previousLineCount = output.split(`
`).length;
  };
  render.clear = () => {
    stream2.write(exports_base.eraseLines(previousLineCount));
    previousOutput = "";
    previousLineCount = 0;
  };
  render.done = () => {
    previousOutput = "";
    previousLineCount = 0;
    if (!showCursor) {
      cli_cursor_default.show();
      hasHiddenCursor = false;
    }
  };
  render.sync = (str) => {
    const output = str + `
`;
    previousOutput = output;
    previousLineCount = output.split(`
`).length;
  };
  return render;
};
var createIncremental = (stream2, { showCursor = false } = {}) => {
  let previousLines = [];
  let previousOutput = "";
  let hasHiddenCursor = false;
  const render = (str) => {
    if (!showCursor && !hasHiddenCursor) {
      cli_cursor_default.hide();
      hasHiddenCursor = true;
    }
    const output = str + `
`;
    if (output === previousOutput) {
      return;
    }
    const previousCount = previousLines.length;
    const nextLines = output.split(`
`);
    const nextCount = nextLines.length;
    const visibleCount = nextCount - 1;
    if (output === `
` || previousOutput.length === 0) {
      stream2.write(exports_base.eraseLines(previousCount) + output);
      previousOutput = output;
      previousLines = nextLines;
      return;
    }
    const buffer = [];
    if (nextCount < previousCount) {
      buffer.push(exports_base.eraseLines(previousCount - nextCount + 1), exports_base.cursorUp(visibleCount));
    } else {
      buffer.push(exports_base.cursorUp(previousCount - 1));
    }
    for (let i = 0;i < visibleCount; i++) {
      if (nextLines[i] === previousLines[i]) {
        buffer.push(exports_base.cursorNextLine);
        continue;
      }
      buffer.push(exports_base.eraseLine + nextLines[i] + `
`);
    }
    stream2.write(buffer.join(""));
    previousOutput = output;
    previousLines = nextLines;
  };
  render.clear = () => {
    stream2.write(exports_base.eraseLines(previousLines.length));
    previousOutput = "";
    previousLines = [];
  };
  render.done = () => {
    previousOutput = "";
    previousLines = [];
    if (!showCursor) {
      cli_cursor_default.show();
      hasHiddenCursor = false;
    }
  };
  render.sync = (str) => {
    const output = str + `
`;
    previousOutput = output;
    previousLines = output.split(`
`);
  };
  return render;
};
var create = (stream2, { showCursor = false, incremental = false } = {}) => {
  if (incremental) {
    return createIncremental(stream2, { showCursor });
  }
  return createStandard(stream2, { showCursor });
};
var logUpdate = { create };
var log_update_default = logUpdate;

// node_modules/ink/build/instances.js
var instances = new WeakMap;
var instances_default = instances;

// node_modules/ink/build/components/App.js
var import_react12 = __toESM(require_react(), 1);
import { EventEmitter as EventEmitter2 } from "node:events";
import process10 from "node:process";

// node_modules/ink/build/components/AppContext.js
var import_react2 = __toESM(require_react(), 1);
var AppContext = import_react2.createContext({
  exit() {}
});
AppContext.displayName = "InternalAppContext";
var AppContext_default = AppContext;

// node_modules/ink/build/components/StdinContext.js
var import_react3 = __toESM(require_react(), 1);
import { EventEmitter } from "node:events";
import process7 from "node:process";
var StdinContext = import_react3.createContext({
  stdin: process7.stdin,
  internal_eventEmitter: new EventEmitter,
  setRawMode() {},
  isRawModeSupported: false,
  internal_exitOnCtrlC: true
});
StdinContext.displayName = "InternalStdinContext";
var StdinContext_default = StdinContext;

// node_modules/ink/build/components/StdoutContext.js
var import_react4 = __toESM(require_react(), 1);
import process8 from "node:process";
var StdoutContext = import_react4.createContext({
  stdout: process8.stdout,
  write() {}
});
StdoutContext.displayName = "InternalStdoutContext";
var StdoutContext_default = StdoutContext;

// node_modules/ink/build/components/StderrContext.js
var import_react5 = __toESM(require_react(), 1);
import process9 from "node:process";
var StderrContext = import_react5.createContext({
  stderr: process9.stderr,
  write() {}
});
StderrContext.displayName = "InternalStderrContext";
var StderrContext_default = StderrContext;

// node_modules/ink/build/components/FocusContext.js
var import_react6 = __toESM(require_react(), 1);
var FocusContext = import_react6.createContext({
  activeId: undefined,
  add() {},
  remove() {},
  activate() {},
  deactivate() {},
  enableFocus() {},
  disableFocus() {},
  focusNext() {},
  focusPrevious() {},
  focus() {}
});
FocusContext.displayName = "InternalFocusContext";
var FocusContext_default = FocusContext;

// node_modules/ink/build/components/ErrorOverview.js
var import_react11 = __toESM(require_react(), 1);
var import_stack_utils = __toESM(require_stack_utils(), 1);
import * as fs from "node:fs";
import { cwd } from "node:process";

// node_modules/convert-to-spaces/dist/index.js
var convertToSpaces = (input, spaces = 2) => {
  return input.replace(/^\t+/gm, ($1) => " ".repeat($1.length * spaces));
};
var dist_default2 = convertToSpaces;

// node_modules/code-excerpt/dist/index.js
var generateLineNumbers = (line, around) => {
  const lineNumbers = [];
  const min = line - around;
  const max = line + around;
  for (let lineNumber = min;lineNumber <= max; lineNumber++) {
    lineNumbers.push(lineNumber);
  }
  return lineNumbers;
};
var codeExcerpt = (source, line, options = {}) => {
  var _a;
  if (typeof source !== "string") {
    throw new TypeError("Source code is missing.");
  }
  if (!line || line < 1) {
    throw new TypeError("Line number must start from `1`.");
  }
  const lines = dist_default2(source).split(/\r?\n/);
  if (line > lines.length) {
    return;
  }
  return generateLineNumbers(line, (_a = options.around) !== null && _a !== undefined ? _a : 3).filter((line2) => lines[line2 - 1] !== undefined).map((line2) => ({ line: line2, value: lines[line2 - 1] }));
};
var dist_default3 = codeExcerpt;

// node_modules/ink/build/components/Box.js
var import_react9 = __toESM(require_react(), 1);

// node_modules/ink/build/components/AccessibilityContext.js
var import_react7 = __toESM(require_react(), 1);
var accessibilityContext = import_react7.createContext({
  isScreenReaderEnabled: false
});

// node_modules/ink/build/components/BackgroundContext.js
var import_react8 = __toESM(require_react(), 1);
var backgroundContext = import_react8.createContext(undefined);

// node_modules/ink/build/components/Box.js
var Box = import_react9.forwardRef(({ children, backgroundColor, "aria-label": ariaLabel, "aria-hidden": ariaHidden, "aria-role": role, "aria-state": ariaState, ...style }, ref) => {
  const { isScreenReaderEnabled } = import_react9.useContext(accessibilityContext);
  const label = ariaLabel ? import_react9.default.createElement("ink-text", null, ariaLabel) : undefined;
  if (isScreenReaderEnabled && ariaHidden) {
    return null;
  }
  const boxElement = import_react9.default.createElement("ink-box", { ref, style: {
    flexWrap: "nowrap",
    flexDirection: "row",
    flexGrow: 0,
    flexShrink: 1,
    ...style,
    backgroundColor,
    overflowX: style.overflowX ?? style.overflow ?? "visible",
    overflowY: style.overflowY ?? style.overflow ?? "visible"
  }, internal_accessibility: {
    role,
    state: ariaState
  } }, isScreenReaderEnabled && label ? label : children);
  if (backgroundColor) {
    return import_react9.default.createElement(backgroundContext.Provider, { value: backgroundColor }, boxElement);
  }
  return boxElement;
});
Box.displayName = "Box";
var Box_default = Box;

// node_modules/ink/build/components/Text.js
var import_react10 = __toESM(require_react(), 1);
function Text({ color, backgroundColor, dimColor = false, bold = false, italic = false, underline = false, strikethrough = false, inverse = false, wrap = "wrap", children, "aria-label": ariaLabel, "aria-hidden": ariaHidden = false }) {
  const { isScreenReaderEnabled } = import_react10.useContext(accessibilityContext);
  const inheritedBackgroundColor = import_react10.useContext(backgroundContext);
  const childrenOrAriaLabel = isScreenReaderEnabled && ariaLabel ? ariaLabel : children;
  if (childrenOrAriaLabel === undefined || childrenOrAriaLabel === null) {
    return null;
  }
  const transform = (children2) => {
    if (dimColor) {
      children2 = source_default.dim(children2);
    }
    if (color) {
      children2 = colorize_default(children2, color, "foreground");
    }
    const effectiveBackgroundColor = backgroundColor ?? inheritedBackgroundColor;
    if (effectiveBackgroundColor) {
      children2 = colorize_default(children2, effectiveBackgroundColor, "background");
    }
    if (bold) {
      children2 = source_default.bold(children2);
    }
    if (italic) {
      children2 = source_default.italic(children2);
    }
    if (underline) {
      children2 = source_default.underline(children2);
    }
    if (strikethrough) {
      children2 = source_default.strikethrough(children2);
    }
    if (inverse) {
      children2 = source_default.inverse(children2);
    }
    return children2;
  };
  if (isScreenReaderEnabled && ariaHidden) {
    return null;
  }
  return import_react10.default.createElement("ink-text", { style: { flexGrow: 0, flexShrink: 1, flexDirection: "row", textWrap: wrap }, internal_transform: transform }, isScreenReaderEnabled && ariaLabel ? ariaLabel : children);
}

// node_modules/ink/build/components/ErrorOverview.js
var cleanupPath = (path) => {
  return path?.replace(`file://${cwd()}/`, "");
};
var stackUtils = new import_stack_utils.default({
  cwd: cwd(),
  internals: import_stack_utils.default.nodeInternals()
});
function ErrorOverview({ error }) {
  const stack = error.stack ? error.stack.split(`
`).slice(1) : undefined;
  const origin = stack ? stackUtils.parseLine(stack[0]) : undefined;
  const filePath = cleanupPath(origin?.file);
  let excerpt;
  let lineWidth = 0;
  if (filePath && origin?.line && fs.existsSync(filePath)) {
    const sourceCode = fs.readFileSync(filePath, "utf8");
    excerpt = dist_default3(sourceCode, origin.line);
    if (excerpt) {
      for (const { line } of excerpt) {
        lineWidth = Math.max(lineWidth, String(line).length);
      }
    }
  }
  return import_react11.default.createElement(Box_default, { flexDirection: "column", padding: 1 }, import_react11.default.createElement(Box_default, null, import_react11.default.createElement(Text, { backgroundColor: "red", color: "white" }, " ", "ERROR", " "), import_react11.default.createElement(Text, null, " ", error.message)), origin && filePath && import_react11.default.createElement(Box_default, { marginTop: 1 }, import_react11.default.createElement(Text, { dimColor: true }, filePath, ":", origin.line, ":", origin.column)), origin && excerpt && import_react11.default.createElement(Box_default, { marginTop: 1, flexDirection: "column" }, excerpt.map(({ line, value }) => import_react11.default.createElement(Box_default, { key: line }, import_react11.default.createElement(Box_default, { width: lineWidth + 1 }, import_react11.default.createElement(Text, { dimColor: line !== origin.line, backgroundColor: line === origin.line ? "red" : undefined, color: line === origin.line ? "white" : undefined, "aria-label": line === origin.line ? `Line ${line}, error` : `Line ${line}` }, String(line).padStart(lineWidth, " "), ":")), import_react11.default.createElement(Text, { key: line, backgroundColor: line === origin.line ? "red" : undefined, color: line === origin.line ? "white" : undefined }, " " + value)))), error.stack && import_react11.default.createElement(Box_default, { marginTop: 1, flexDirection: "column" }, error.stack.split(`
`).slice(1).map((line) => {
    const parsedLine = stackUtils.parseLine(line);
    if (!parsedLine) {
      return import_react11.default.createElement(Box_default, { key: line }, import_react11.default.createElement(Text, { dimColor: true }, "- "), import_react11.default.createElement(Text, { dimColor: true, bold: true }, line, "\\t", " "));
    }
    return import_react11.default.createElement(Box_default, { key: line }, import_react11.default.createElement(Text, { dimColor: true }, "- "), import_react11.default.createElement(Text, { dimColor: true, bold: true }, parsedLine.function), import_react11.default.createElement(Text, { dimColor: true, color: "gray", "aria-label": `at ${cleanupPath(parsedLine.file) ?? ""} line ${parsedLine.line} column ${parsedLine.column}` }, " ", "(", cleanupPath(parsedLine.file) ?? "", ":", parsedLine.line, ":", parsedLine.column, ")"));
  })));
}

// node_modules/ink/build/components/App.js
var tab = "\t";
var shiftTab = "\x1B[Z";
var escape = "\x1B";

class App extends import_react12.PureComponent {
  static displayName = "InternalApp";
  static getDerivedStateFromError(error) {
    return { error };
  }
  state = {
    isFocusEnabled: true,
    activeFocusId: undefined,
    focusables: [],
    error: undefined
  };
  rawModeEnabledCount = 0;
  internal_eventEmitter = new EventEmitter2;
  isRawModeSupported() {
    return this.props.stdin.isTTY;
  }
  render() {
    return import_react12.default.createElement(AppContext_default.Provider, {
      value: {
        exit: this.handleExit
      }
    }, import_react12.default.createElement(StdinContext_default.Provider, {
      value: {
        stdin: this.props.stdin,
        setRawMode: this.handleSetRawMode,
        isRawModeSupported: this.isRawModeSupported(),
        internal_exitOnCtrlC: this.props.exitOnCtrlC,
        internal_eventEmitter: this.internal_eventEmitter
      }
    }, import_react12.default.createElement(StdoutContext_default.Provider, {
      value: {
        stdout: this.props.stdout,
        write: this.props.writeToStdout
      }
    }, import_react12.default.createElement(StderrContext_default.Provider, {
      value: {
        stderr: this.props.stderr,
        write: this.props.writeToStderr
      }
    }, import_react12.default.createElement(FocusContext_default.Provider, {
      value: {
        activeId: this.state.activeFocusId,
        add: this.addFocusable,
        remove: this.removeFocusable,
        activate: this.activateFocusable,
        deactivate: this.deactivateFocusable,
        enableFocus: this.enableFocus,
        disableFocus: this.disableFocus,
        focusNext: this.focusNext,
        focusPrevious: this.focusPrevious,
        focus: this.focus
      }
    }, this.state.error ? import_react12.default.createElement(ErrorOverview, { error: this.state.error }) : this.props.children)))));
  }
  componentDidMount() {
    cli_cursor_default.hide(this.props.stdout);
  }
  componentWillUnmount() {
    cli_cursor_default.show(this.props.stdout);
    if (this.isRawModeSupported()) {
      this.handleSetRawMode(false);
    }
  }
  componentDidCatch(error) {
    this.handleExit(error);
  }
  handleSetRawMode = (isEnabled) => {
    const { stdin } = this.props;
    if (!this.isRawModeSupported()) {
      if (stdin === process10.stdin) {
        throw new Error(`Raw mode is not supported on the current process.stdin, which Ink uses as input stream by default.
Read about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported`);
      } else {
        throw new Error(`Raw mode is not supported on the stdin provided to Ink.
Read about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported`);
      }
    }
    stdin.setEncoding("utf8");
    if (isEnabled) {
      if (this.rawModeEnabledCount === 0) {
        stdin.ref();
        stdin.setRawMode(true);
        stdin.addListener("readable", this.handleReadable);
      }
      this.rawModeEnabledCount++;
      return;
    }
    if (--this.rawModeEnabledCount === 0) {
      stdin.setRawMode(false);
      stdin.removeListener("readable", this.handleReadable);
      stdin.unref();
    }
  };
  handleReadable = () => {
    let chunk;
    while ((chunk = this.props.stdin.read()) !== null) {
      this.handleInput(chunk);
      this.internal_eventEmitter.emit("input", chunk);
    }
  };
  handleInput = (input) => {
    if (input === "\x03" && this.props.exitOnCtrlC) {
      this.handleExit();
    }
    if (input === escape && this.state.activeFocusId) {
      this.setState({
        activeFocusId: undefined
      });
    }
    if (this.state.isFocusEnabled && this.state.focusables.length > 0) {
      if (input === tab) {
        this.focusNext();
      }
      if (input === shiftTab) {
        this.focusPrevious();
      }
    }
  };
  handleExit = (error) => {
    if (this.isRawModeSupported()) {
      this.handleSetRawMode(false);
    }
    this.props.onExit(error);
  };
  enableFocus = () => {
    this.setState({
      isFocusEnabled: true
    });
  };
  disableFocus = () => {
    this.setState({
      isFocusEnabled: false
    });
  };
  focus = (id) => {
    this.setState((previousState) => {
      const hasFocusableId = previousState.focusables.some((focusable) => focusable?.id === id);
      if (!hasFocusableId) {
        return previousState;
      }
      return { activeFocusId: id };
    });
  };
  focusNext = () => {
    this.setState((previousState) => {
      const firstFocusableId = previousState.focusables.find((focusable) => focusable.isActive)?.id;
      const nextFocusableId = this.findNextFocusable(previousState);
      return {
        activeFocusId: nextFocusableId ?? firstFocusableId
      };
    });
  };
  focusPrevious = () => {
    this.setState((previousState) => {
      const lastFocusableId = previousState.focusables.findLast((focusable) => focusable.isActive)?.id;
      const previousFocusableId = this.findPreviousFocusable(previousState);
      return {
        activeFocusId: previousFocusableId ?? lastFocusableId
      };
    });
  };
  addFocusable = (id, { autoFocus }) => {
    this.setState((previousState) => {
      let nextFocusId = previousState.activeFocusId;
      if (!nextFocusId && autoFocus) {
        nextFocusId = id;
      }
      return {
        activeFocusId: nextFocusId,
        focusables: [
          ...previousState.focusables,
          {
            id,
            isActive: true
          }
        ]
      };
    });
  };
  removeFocusable = (id) => {
    this.setState((previousState) => ({
      activeFocusId: previousState.activeFocusId === id ? undefined : previousState.activeFocusId,
      focusables: previousState.focusables.filter((focusable) => {
        return focusable.id !== id;
      })
    }));
  };
  activateFocusable = (id) => {
    this.setState((previousState) => ({
      focusables: previousState.focusables.map((focusable) => {
        if (focusable.id !== id) {
          return focusable;
        }
        return {
          id,
          isActive: true
        };
      })
    }));
  };
  deactivateFocusable = (id) => {
    this.setState((previousState) => ({
      activeFocusId: previousState.activeFocusId === id ? undefined : previousState.activeFocusId,
      focusables: previousState.focusables.map((focusable) => {
        if (focusable.id !== id) {
          return focusable;
        }
        return {
          id,
          isActive: false
        };
      })
    }));
  };
  findNextFocusable = (state) => {
    const activeIndex = state.focusables.findIndex((focusable) => {
      return focusable.id === state.activeFocusId;
    });
    for (let index = activeIndex + 1;index < state.focusables.length; index++) {
      const focusable = state.focusables[index];
      if (focusable?.isActive) {
        return focusable.id;
      }
    }
    return;
  };
  findPreviousFocusable = (state) => {
    const activeIndex = state.focusables.findIndex((focusable) => {
      return focusable.id === state.activeFocusId;
    });
    for (let index = activeIndex - 1;index >= 0; index--) {
      const focusable = state.focusables[index];
      if (focusable?.isActive) {
        return focusable.id;
      }
    }
    return;
  };
}

// node_modules/ink/build/ink.js
var noop = () => {};

class Ink {
  options;
  log;
  throttledLog;
  isScreenReaderEnabled;
  isUnmounted;
  lastOutput;
  lastOutputHeight;
  lastTerminalWidth;
  container;
  rootNode;
  fullStaticOutput;
  exitPromise;
  restoreConsole;
  unsubscribeResize;
  constructor(options) {
    autoBind(this);
    this.options = options;
    this.rootNode = createNode("ink-root");
    this.rootNode.onComputeLayout = this.calculateLayout;
    this.isScreenReaderEnabled = options.isScreenReaderEnabled ?? process11.env["INK_SCREEN_READER"] === "true";
    const unthrottled = options.debug || this.isScreenReaderEnabled;
    const maxFps = options.maxFps ?? 30;
    const renderThrottleMs = maxFps > 0 ? Math.max(1, Math.ceil(1000 / maxFps)) : 0;
    this.rootNode.onRender = unthrottled ? this.onRender : throttle(this.onRender, renderThrottleMs, {
      leading: true,
      trailing: true
    });
    this.rootNode.onImmediateRender = this.onRender;
    this.log = log_update_default.create(options.stdout, {
      incremental: options.incrementalRendering
    });
    this.throttledLog = unthrottled ? this.log : throttle(this.log, undefined, {
      leading: true,
      trailing: true
    });
    this.isUnmounted = false;
    this.lastOutput = "";
    this.lastOutputHeight = 0;
    this.lastTerminalWidth = this.getTerminalWidth();
    this.fullStaticOutput = "";
    this.container = reconciler_default.createContainer(this.rootNode, import_constants2.LegacyRoot, null, false, null, "id", () => {}, () => {}, () => {}, () => {}, null);
    this.unsubscribeExit = import_signal_exit2.default(this.unmount, { alwaysLast: false });
    if (process11.env["DEV"] === "true") {
      reconciler_default.injectIntoDevTools({
        bundleType: 0,
        version: "16.13.1",
        rendererPackageName: "ink"
      });
    }
    if (options.patchConsole) {
      this.patchConsole();
    }
    if (!is_in_ci_default) {
      options.stdout.on("resize", this.resized);
      this.unsubscribeResize = () => {
        options.stdout.off("resize", this.resized);
      };
    }
  }
  getTerminalWidth = () => {
    return this.options.stdout.columns || 80;
  };
  resized = () => {
    const currentWidth = this.getTerminalWidth();
    if (currentWidth < this.lastTerminalWidth) {
      this.log.clear();
      this.lastOutput = "";
    }
    this.calculateLayout();
    this.onRender();
    this.lastTerminalWidth = currentWidth;
  };
  resolveExitPromise = () => {};
  rejectExitPromise = () => {};
  unsubscribeExit = () => {};
  calculateLayout = () => {
    const terminalWidth = this.getTerminalWidth();
    this.rootNode.yogaNode.setWidth(terminalWidth);
    this.rootNode.yogaNode.calculateLayout(undefined, undefined, src_default.DIRECTION_LTR);
  };
  onRender = () => {
    if (this.isUnmounted) {
      return;
    }
    const startTime = performance.now();
    const { output, outputHeight, staticOutput } = renderer_default(this.rootNode, this.isScreenReaderEnabled);
    this.options.onRender?.({ renderTime: performance.now() - startTime });
    const hasStaticOutput = staticOutput && staticOutput !== `
`;
    if (this.options.debug) {
      if (hasStaticOutput) {
        this.fullStaticOutput += staticOutput;
      }
      this.options.stdout.write(this.fullStaticOutput + output);
      return;
    }
    if (is_in_ci_default) {
      if (hasStaticOutput) {
        this.options.stdout.write(staticOutput);
      }
      this.lastOutput = output;
      this.lastOutputHeight = outputHeight;
      return;
    }
    if (this.isScreenReaderEnabled) {
      if (hasStaticOutput) {
        const erase = this.lastOutputHeight > 0 ? exports_base.eraseLines(this.lastOutputHeight) : "";
        this.options.stdout.write(erase + staticOutput);
        this.lastOutputHeight = 0;
      }
      if (output === this.lastOutput && !hasStaticOutput) {
        return;
      }
      const terminalWidth = this.options.stdout.columns || 80;
      const wrappedOutput = wrapAnsi(output, terminalWidth, {
        trim: false,
        hard: true
      });
      if (hasStaticOutput) {
        this.options.stdout.write(wrappedOutput);
      } else {
        const erase = this.lastOutputHeight > 0 ? exports_base.eraseLines(this.lastOutputHeight) : "";
        this.options.stdout.write(erase + wrappedOutput);
      }
      this.lastOutput = output;
      this.lastOutputHeight = wrappedOutput === "" ? 0 : wrappedOutput.split(`
`).length;
      return;
    }
    if (hasStaticOutput) {
      this.fullStaticOutput += staticOutput;
    }
    if (this.lastOutputHeight >= this.options.stdout.rows) {
      this.options.stdout.write(exports_base.clearTerminal + this.fullStaticOutput + output);
      this.lastOutput = output;
      this.lastOutputHeight = outputHeight;
      this.log.sync(output);
      return;
    }
    if (hasStaticOutput) {
      this.log.clear();
      this.options.stdout.write(staticOutput);
      this.log(output);
    }
    if (!hasStaticOutput && output !== this.lastOutput) {
      this.throttledLog(output);
    }
    this.lastOutput = output;
    this.lastOutputHeight = outputHeight;
  };
  render(node) {
    const tree = import_react13.default.createElement(accessibilityContext.Provider, { value: { isScreenReaderEnabled: this.isScreenReaderEnabled } }, import_react13.default.createElement(App, { stdin: this.options.stdin, stdout: this.options.stdout, stderr: this.options.stderr, writeToStdout: this.writeToStdout, writeToStderr: this.writeToStderr, exitOnCtrlC: this.options.exitOnCtrlC, onExit: this.unmount }, node));
    reconciler_default.updateContainerSync(tree, this.container, null, noop);
    reconciler_default.flushSyncWork();
  }
  writeToStdout(data) {
    if (this.isUnmounted) {
      return;
    }
    if (this.options.debug) {
      this.options.stdout.write(data + this.fullStaticOutput + this.lastOutput);
      return;
    }
    if (is_in_ci_default) {
      this.options.stdout.write(data);
      return;
    }
    this.log.clear();
    this.options.stdout.write(data);
    this.log(this.lastOutput);
  }
  writeToStderr(data) {
    if (this.isUnmounted) {
      return;
    }
    if (this.options.debug) {
      this.options.stderr.write(data);
      this.options.stdout.write(this.fullStaticOutput + this.lastOutput);
      return;
    }
    if (is_in_ci_default) {
      this.options.stderr.write(data);
      return;
    }
    this.log.clear();
    this.options.stderr.write(data);
    this.log(this.lastOutput);
  }
  unmount(error) {
    if (this.isUnmounted) {
      return;
    }
    this.calculateLayout();
    this.onRender();
    this.unsubscribeExit();
    if (typeof this.restoreConsole === "function") {
      this.restoreConsole();
    }
    if (typeof this.unsubscribeResize === "function") {
      this.unsubscribeResize();
    }
    if (is_in_ci_default) {
      this.options.stdout.write(this.lastOutput + `
`);
    } else if (!this.options.debug) {
      this.log.done();
    }
    this.isUnmounted = true;
    reconciler_default.updateContainerSync(null, this.container, null, noop);
    reconciler_default.flushSyncWork();
    instances_default.delete(this.options.stdout);
    if (error instanceof Error) {
      this.rejectExitPromise(error);
    } else {
      this.resolveExitPromise();
    }
  }
  async waitUntilExit() {
    this.exitPromise ||= new Promise((resolve2, reject2) => {
      this.resolveExitPromise = resolve2;
      this.rejectExitPromise = reject2;
    });
    return this.exitPromise;
  }
  clear() {
    if (!is_in_ci_default && !this.options.debug) {
      this.log.clear();
    }
  }
  patchConsole() {
    if (this.options.debug) {
      return;
    }
    this.restoreConsole = dist_default((stream2, data) => {
      if (stream2 === "stdout") {
        this.writeToStdout(data);
      }
      if (stream2 === "stderr") {
        const isReactMessage = data.startsWith("The above error occurred");
        if (!isReactMessage) {
          this.writeToStderr(data);
        }
      }
    });
  }
}

// node_modules/ink/build/render.js
var render = (node, options) => {
  const inkOptions = {
    stdout: process12.stdout,
    stdin: process12.stdin,
    stderr: process12.stderr,
    debug: false,
    exitOnCtrlC: true,
    patchConsole: true,
    maxFps: 30,
    incrementalRendering: false,
    ...getOptions(options)
  };
  const instance = getInstance(inkOptions.stdout, () => new Ink(inkOptions));
  instance.render(node);
  return {
    rerender: instance.render,
    unmount() {
      instance.unmount();
    },
    waitUntilExit: instance.waitUntilExit,
    cleanup: () => instances_default.delete(inkOptions.stdout),
    clear: instance.clear
  };
};
var render_default = render;
var getOptions = (stdout = {}) => {
  if (stdout instanceof Stream) {
    return {
      stdout,
      stdin: process12.stdin
    };
  }
  return stdout;
};
var getInstance = (stdout, createInstance) => {
  let instance = instances_default.get(stdout);
  if (!instance) {
    instance = createInstance();
    instances_default.set(stdout, instance);
  }
  return instance;
};
// node_modules/ink/build/components/Static.js
var import_react14 = __toESM(require_react(), 1);
// node_modules/ink/build/components/Transform.js
var import_react15 = __toESM(require_react(), 1);
// node_modules/ink/build/components/Newline.js
var import_react16 = __toESM(require_react(), 1);
// node_modules/ink/build/components/Spacer.js
var import_react17 = __toESM(require_react(), 1);
// node_modules/ink/build/hooks/use-input.js
var import_react19 = __toESM(require_react(), 1);

// node_modules/ink/build/parse-keypress.js
import { Buffer as Buffer2 } from "node:buffer";
var metaKeyCodeRe = /^(?:\x1b)([a-zA-Z0-9])$/;
var fnKeyRe = /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/;
var keyName = {
  OP: "f1",
  OQ: "f2",
  OR: "f3",
  OS: "f4",
  "[11~": "f1",
  "[12~": "f2",
  "[13~": "f3",
  "[14~": "f4",
  "[[A": "f1",
  "[[B": "f2",
  "[[C": "f3",
  "[[D": "f4",
  "[[E": "f5",
  "[15~": "f5",
  "[17~": "f6",
  "[18~": "f7",
  "[19~": "f8",
  "[20~": "f9",
  "[21~": "f10",
  "[23~": "f11",
  "[24~": "f12",
  "[A": "up",
  "[B": "down",
  "[C": "right",
  "[D": "left",
  "[E": "clear",
  "[F": "end",
  "[H": "home",
  OA: "up",
  OB: "down",
  OC: "right",
  OD: "left",
  OE: "clear",
  OF: "end",
  OH: "home",
  "[1~": "home",
  "[2~": "insert",
  "[3~": "delete",
  "[4~": "end",
  "[5~": "pageup",
  "[6~": "pagedown",
  "[[5~": "pageup",
  "[[6~": "pagedown",
  "[7~": "home",
  "[8~": "end",
  "[a": "up",
  "[b": "down",
  "[c": "right",
  "[d": "left",
  "[e": "clear",
  "[2$": "insert",
  "[3$": "delete",
  "[5$": "pageup",
  "[6$": "pagedown",
  "[7$": "home",
  "[8$": "end",
  Oa: "up",
  Ob: "down",
  Oc: "right",
  Od: "left",
  Oe: "clear",
  "[2^": "insert",
  "[3^": "delete",
  "[5^": "pageup",
  "[6^": "pagedown",
  "[7^": "home",
  "[8^": "end",
  "[Z": "tab"
};
var nonAlphanumericKeys = [...Object.values(keyName), "backspace"];
var isShiftKey = (code) => {
  return [
    "[a",
    "[b",
    "[c",
    "[d",
    "[e",
    "[2$",
    "[3$",
    "[5$",
    "[6$",
    "[7$",
    "[8$",
    "[Z"
  ].includes(code);
};
var isCtrlKey = (code) => {
  return [
    "Oa",
    "Ob",
    "Oc",
    "Od",
    "Oe",
    "[2^",
    "[3^",
    "[5^",
    "[6^",
    "[7^",
    "[8^"
  ].includes(code);
};
var parseKeypress = (s = "") => {
  let parts;
  if (Buffer2.isBuffer(s)) {
    if (s[0] > 127 && s[1] === undefined) {
      s[0] -= 128;
      s = "\x1B" + String(s);
    } else {
      s = String(s);
    }
  } else if (s !== undefined && typeof s !== "string") {
    s = String(s);
  } else if (!s) {
    s = "";
  }
  const key = {
    name: "",
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    sequence: s,
    raw: s
  };
  key.sequence = key.sequence || s || key.name;
  if (s === "\r") {
    key.raw = undefined;
    key.name = "return";
  } else if (s === `
`) {
    key.name = "enter";
  } else if (s === "\t") {
    key.name = "tab";
  } else if (s === "\b" || s === "\x1B\b") {
    key.name = "backspace";
    key.meta = s.charAt(0) === "\x1B";
  } else if (s === "" || s === "\x1B") {
    key.name = "delete";
    key.meta = s.charAt(0) === "\x1B";
  } else if (s === "\x1B" || s === "\x1B\x1B") {
    key.name = "escape";
    key.meta = s.length === 2;
  } else if (s === " " || s === "\x1B ") {
    key.name = "space";
    key.meta = s.length === 2;
  } else if (s.length === 1 && s <= "\x1A") {
    key.name = String.fromCharCode(s.charCodeAt(0) + 97 - 1);
    key.ctrl = true;
  } else if (s.length === 1 && s >= "0" && s <= "9") {
    key.name = "number";
  } else if (s.length === 1 && s >= "a" && s <= "z") {
    key.name = s;
  } else if (s.length === 1 && s >= "A" && s <= "Z") {
    key.name = s.toLowerCase();
    key.shift = true;
  } else if (parts = metaKeyCodeRe.exec(s)) {
    key.meta = true;
    key.shift = /^[A-Z]$/.test(parts[1]);
  } else if (parts = fnKeyRe.exec(s)) {
    const segs = [...s];
    if (segs[0] === "\x1B" && segs[1] === "\x1B") {
      key.option = true;
    }
    const code = [parts[1], parts[2], parts[4], parts[6]].filter(Boolean).join("");
    const modifier = (parts[3] || parts[5] || 1) - 1;
    key.ctrl = !!(modifier & 4);
    key.meta = !!(modifier & 10);
    key.shift = !!(modifier & 1);
    key.code = code;
    key.name = keyName[code];
    key.shift = isShiftKey(code) || key.shift;
    key.ctrl = isCtrlKey(code) || key.ctrl;
  }
  return key;
};
var parse_keypress_default = parseKeypress;

// node_modules/ink/build/hooks/use-stdin.js
var import_react18 = __toESM(require_react(), 1);
var useStdin = () => import_react18.useContext(StdinContext_default);
var use_stdin_default = useStdin;

// node_modules/ink/build/hooks/use-input.js
var useInput = (inputHandler, options = {}) => {
  const { stdin, setRawMode, internal_exitOnCtrlC, internal_eventEmitter } = use_stdin_default();
  import_react19.useEffect(() => {
    if (options.isActive === false) {
      return;
    }
    setRawMode(true);
    return () => {
      setRawMode(false);
    };
  }, [options.isActive, setRawMode]);
  import_react19.useEffect(() => {
    if (options.isActive === false) {
      return;
    }
    const handleData = (data) => {
      const keypress = parse_keypress_default(data);
      const key = {
        upArrow: keypress.name === "up",
        downArrow: keypress.name === "down",
        leftArrow: keypress.name === "left",
        rightArrow: keypress.name === "right",
        pageDown: keypress.name === "pagedown",
        pageUp: keypress.name === "pageup",
        return: keypress.name === "return",
        escape: keypress.name === "escape",
        ctrl: keypress.ctrl,
        shift: keypress.shift,
        tab: keypress.name === "tab",
        backspace: keypress.name === "backspace",
        delete: keypress.name === "delete",
        meta: keypress.meta || keypress.name === "escape" || keypress.option
      };
      let input = keypress.ctrl ? keypress.name : keypress.sequence;
      if (nonAlphanumericKeys.includes(keypress.name)) {
        input = "";
      }
      if (input.startsWith("\x1B")) {
        input = input.slice(1);
      }
      if (input.length === 1 && typeof input[0] === "string" && /[A-Z]/.test(input[0])) {
        key.shift = true;
      }
      if (!(input === "c" && key.ctrl) || !internal_exitOnCtrlC) {
        reconciler_default.batchedUpdates(() => {
          inputHandler(input, key);
        });
      }
    };
    internal_eventEmitter?.on("input", handleData);
    return () => {
      internal_eventEmitter?.removeListener("input", handleData);
    };
  }, [options.isActive, stdin, internal_exitOnCtrlC, inputHandler]);
};
var use_input_default = useInput;
// node_modules/ink/build/hooks/use-app.js
var import_react20 = __toESM(require_react(), 1);
var useApp = () => import_react20.useContext(AppContext_default);
var use_app_default = useApp;
// node_modules/ink/build/hooks/use-stdout.js
var import_react21 = __toESM(require_react(), 1);
// node_modules/ink/build/hooks/use-stderr.js
var import_react22 = __toESM(require_react(), 1);
// node_modules/ink/build/hooks/use-focus.js
var import_react23 = __toESM(require_react(), 1);
// node_modules/ink/build/hooks/use-focus-manager.js
var import_react24 = __toESM(require_react(), 1);
// node_modules/ink/build/hooks/use-is-screen-reader-enabled.js
var import_react25 = __toESM(require_react(), 1);
// node_modules/ink-text-input/build/index.js
var import_react26 = __toESM(require_react(), 1);
function TextInput({ value: originalValue, placeholder = "", focus = true, mask, highlightPastedText = false, showCursor = true, onChange, onSubmit }) {
  const [state, setState] = import_react26.useState({
    cursorOffset: (originalValue || "").length,
    cursorWidth: 0
  });
  const { cursorOffset, cursorWidth } = state;
  import_react26.useEffect(() => {
    setState((previousState) => {
      if (!focus || !showCursor) {
        return previousState;
      }
      const newValue = originalValue || "";
      if (previousState.cursorOffset > newValue.length - 1) {
        return {
          cursorOffset: newValue.length,
          cursorWidth: 0
        };
      }
      return previousState;
    });
  }, [originalValue, focus, showCursor]);
  const cursorActualWidth = highlightPastedText ? cursorWidth : 0;
  const value = mask ? mask.repeat(originalValue.length) : originalValue;
  let renderedValue = value;
  let renderedPlaceholder = placeholder ? source_default.grey(placeholder) : undefined;
  if (showCursor && focus) {
    renderedPlaceholder = placeholder.length > 0 ? source_default.inverse(placeholder[0]) + source_default.grey(placeholder.slice(1)) : source_default.inverse(" ");
    renderedValue = value.length > 0 ? "" : source_default.inverse(" ");
    let i = 0;
    for (const char of value) {
      renderedValue += i >= cursorOffset - cursorActualWidth && i <= cursorOffset ? source_default.inverse(char) : char;
      i++;
    }
    if (value.length > 0 && cursorOffset === value.length) {
      renderedValue += source_default.inverse(" ");
    }
  }
  use_input_default((input, key) => {
    if (key.upArrow || key.downArrow || key.ctrl && input === "c" || key.tab || key.shift && key.tab) {
      return;
    }
    if (key.return) {
      if (onSubmit) {
        onSubmit(originalValue);
      }
      return;
    }
    let nextCursorOffset = cursorOffset;
    let nextValue = originalValue;
    let nextCursorWidth = 0;
    if (key.leftArrow) {
      if (showCursor) {
        nextCursorOffset--;
      }
    } else if (key.rightArrow) {
      if (showCursor) {
        nextCursorOffset++;
      }
    } else if (key.backspace || key.delete) {
      if (cursorOffset > 0) {
        nextValue = originalValue.slice(0, cursorOffset - 1) + originalValue.slice(cursorOffset, originalValue.length);
        nextCursorOffset--;
      }
    } else {
      nextValue = originalValue.slice(0, cursorOffset) + input + originalValue.slice(cursorOffset, originalValue.length);
      nextCursorOffset += input.length;
      if (input.length > 1) {
        nextCursorWidth = input.length;
      }
    }
    if (cursorOffset < 0) {
      nextCursorOffset = 0;
    }
    if (cursorOffset > originalValue.length) {
      nextCursorOffset = originalValue.length;
    }
    setState({
      cursorOffset: nextCursorOffset,
      cursorWidth: nextCursorWidth
    });
    if (nextValue !== originalValue) {
      onChange(nextValue);
    }
  }, { isActive: focus });
  return import_react26.default.createElement(Text, null, placeholder ? value.length > 0 ? renderedValue : renderedPlaceholder : renderedValue);
}
var build_default = TextInput;

// node_modules/clipboardy/index.js
import process24 from "node:process";

// node_modules/is-wsl/index.js
import process13 from "node:process";
import os3 from "node:os";
import fs4 from "node:fs";

// node_modules/is-inside-container/index.js
import fs3 from "node:fs";

// node_modules/is-docker/index.js
import fs2 from "node:fs";
var isDockerCached;
function hasDockerEnv() {
  try {
    fs2.statSync("/.dockerenv");
    return true;
  } catch {
    return false;
  }
}
function hasDockerCGroup() {
  try {
    return fs2.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch {
    return false;
  }
}
function isDocker() {
  if (isDockerCached === undefined) {
    isDockerCached = hasDockerEnv() || hasDockerCGroup();
  }
  return isDockerCached;
}

// node_modules/is-inside-container/index.js
var cachedResult;
var hasContainerEnv = () => {
  try {
    fs3.statSync("/run/.containerenv");
    return true;
  } catch {
    return false;
  }
};
function isInsideContainer() {
  if (cachedResult === undefined) {
    cachedResult = hasContainerEnv() || isDocker();
  }
  return cachedResult;
}

// node_modules/is-wsl/index.js
var isWsl = () => {
  if (process13.platform !== "linux") {
    return false;
  }
  if (os3.release().toLowerCase().includes("microsoft")) {
    if (isInsideContainer()) {
      return false;
    }
    return true;
  }
  try {
    return fs4.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isInsideContainer() : false;
  } catch {
    return false;
  }
};
var is_wsl_default = process13.env.__IS_WSL_TEST__ ? isWsl : isWsl();

// node_modules/is-wayland/index.js
import process14 from "node:process";
function isWayland() {
  if (process14.platform !== "linux") {
    return false;
  }
  if (process14.env.WAYLAND_DISPLAY) {
    return true;
  }
  if (process14.env.XDG_SESSION_TYPE === "wayland") {
    return true;
  }
  return false;
}

// node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/execa/lib/arguments/file-url.js
import { fileURLToPath } from "node:url";
var safeNormalizeFileUrl = (file, name) => {
  const fileString = normalizeFileUrl(normalizeDenoExecPath(file));
  if (typeof fileString !== "string") {
    throw new TypeError(`${name} must be a string or a file URL: ${fileString}.`);
  }
  return fileString;
};
var normalizeDenoExecPath = (file) => isDenoExecPath(file) ? file.toString() : file;
var isDenoExecPath = (file) => typeof file !== "string" && file && Object.getPrototypeOf(file) === String.prototype;
var normalizeFileUrl = (file) => file instanceof URL ? fileURLToPath(file) : file;

// node_modules/execa/lib/methods/parameters.js
var normalizeParameters = (rawFile, rawArguments = [], rawOptions = {}) => {
  const filePath = safeNormalizeFileUrl(rawFile, "First argument");
  const [commandArguments, options] = isPlainObject(rawArguments) ? [[], rawArguments] : [rawArguments, rawOptions];
  if (!Array.isArray(commandArguments)) {
    throw new TypeError(`Second argument must be either an array of arguments or an options object: ${commandArguments}`);
  }
  if (commandArguments.some((commandArgument) => typeof commandArgument === "object" && commandArgument !== null)) {
    throw new TypeError(`Second argument must be an array of strings: ${commandArguments}`);
  }
  const normalizedArguments = commandArguments.map(String);
  const nullByteArgument = normalizedArguments.find((normalizedArgument) => normalizedArgument.includes("\x00"));
  if (nullByteArgument !== undefined) {
    throw new TypeError(`Arguments cannot contain null bytes ("\\0"): ${nullByteArgument}`);
  }
  if (!isPlainObject(options)) {
    throw new TypeError(`Last argument must be an options object: ${options}`);
  }
  return [filePath, normalizedArguments, options];
};

// node_modules/execa/lib/methods/template.js
import { ChildProcess } from "node:child_process";

// node_modules/execa/lib/utils/uint-array.js
import { StringDecoder } from "node:string_decoder";
var { toString: objectToString } = Object.prototype;
var isArrayBuffer = (value) => objectToString.call(value) === "[object ArrayBuffer]";
var isUint8Array = (value) => objectToString.call(value) === "[object Uint8Array]";
var bufferToUint8Array = (buffer) => new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
var textEncoder = new TextEncoder;
var stringToUint8Array = (string) => textEncoder.encode(string);
var textDecoder = new TextDecoder;
var uint8ArrayToString = (uint8Array) => textDecoder.decode(uint8Array);
var joinToString = (uint8ArraysOrStrings, encoding) => {
  const strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);
  return strings.join("");
};
var uint8ArraysToStrings = (uint8ArraysOrStrings, encoding) => {
  if (encoding === "utf8" && uint8ArraysOrStrings.every((uint8ArrayOrString) => typeof uint8ArrayOrString === "string")) {
    return uint8ArraysOrStrings;
  }
  const decoder = new StringDecoder(encoding);
  const strings = uint8ArraysOrStrings.map((uint8ArrayOrString) => typeof uint8ArrayOrString === "string" ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString).map((uint8Array) => decoder.write(uint8Array));
  const finalString = decoder.end();
  return finalString === "" ? strings : [...strings, finalString];
};
var joinToUint8Array = (uint8ArraysOrStrings) => {
  if (uint8ArraysOrStrings.length === 1 && isUint8Array(uint8ArraysOrStrings[0])) {
    return uint8ArraysOrStrings[0];
  }
  return concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));
};
var stringsToUint8Arrays = (uint8ArraysOrStrings) => uint8ArraysOrStrings.map((uint8ArrayOrString) => typeof uint8ArrayOrString === "string" ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString);
var concatUint8Arrays = (uint8Arrays) => {
  const result = new Uint8Array(getJoinLength(uint8Arrays));
  let index = 0;
  for (const uint8Array of uint8Arrays) {
    result.set(uint8Array, index);
    index += uint8Array.length;
  }
  return result;
};
var getJoinLength = (uint8Arrays) => {
  let joinLength = 0;
  for (const uint8Array of uint8Arrays) {
    joinLength += uint8Array.length;
  }
  return joinLength;
};

// node_modules/execa/lib/methods/template.js
var isTemplateString = (templates) => Array.isArray(templates) && Array.isArray(templates.raw);
var parseTemplates = (templates, expressions) => {
  let tokens = [];
  for (const [index, template] of templates.entries()) {
    tokens = parseTemplate({
      templates,
      expressions,
      tokens,
      index,
      template
    });
  }
  if (tokens.length === 0) {
    throw new TypeError("Template script must not be empty");
  }
  const [file, ...commandArguments] = tokens;
  return [file, commandArguments, {}];
};
var parseTemplate = ({ templates, expressions, tokens, index, template }) => {
  if (template === undefined) {
    throw new TypeError(`Invalid backslash sequence: ${templates.raw[index]}`);
  }
  const { nextTokens, leadingWhitespaces, trailingWhitespaces } = splitByWhitespaces(template, templates.raw[index]);
  const newTokens = concatTokens(tokens, nextTokens, leadingWhitespaces);
  if (index === expressions.length) {
    return newTokens;
  }
  const expression = expressions[index];
  const expressionTokens = Array.isArray(expression) ? expression.map((expression2) => parseExpression(expression2)) : [parseExpression(expression)];
  return concatTokens(newTokens, expressionTokens, trailingWhitespaces);
};
var splitByWhitespaces = (template, rawTemplate) => {
  if (rawTemplate.length === 0) {
    return { nextTokens: [], leadingWhitespaces: false, trailingWhitespaces: false };
  }
  const nextTokens = [];
  let templateStart = 0;
  const leadingWhitespaces = DELIMITERS.has(rawTemplate[0]);
  for (let templateIndex = 0, rawIndex = 0;templateIndex < template.length; templateIndex += 1, rawIndex += 1) {
    const rawCharacter = rawTemplate[rawIndex];
    if (DELIMITERS.has(rawCharacter)) {
      if (templateStart !== templateIndex) {
        nextTokens.push(template.slice(templateStart, templateIndex));
      }
      templateStart = templateIndex + 1;
    } else if (rawCharacter === "\\") {
      const nextRawCharacter = rawTemplate[rawIndex + 1];
      if (nextRawCharacter === `
`) {
        templateIndex -= 1;
        rawIndex += 1;
      } else if (nextRawCharacter === "u" && rawTemplate[rawIndex + 2] === "{") {
        rawIndex = rawTemplate.indexOf("}", rawIndex + 3);
      } else {
        rawIndex += ESCAPE_LENGTH[nextRawCharacter] ?? 1;
      }
    }
  }
  const trailingWhitespaces = templateStart === template.length;
  if (!trailingWhitespaces) {
    nextTokens.push(template.slice(templateStart));
  }
  return { nextTokens, leadingWhitespaces, trailingWhitespaces };
};
var DELIMITERS = new Set([" ", "\t", "\r", `
`]);
var ESCAPE_LENGTH = { x: 3, u: 5 };
var concatTokens = (tokens, nextTokens, isSeparated) => isSeparated || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [
  ...tokens.slice(0, -1),
  `${tokens.at(-1)}${nextTokens[0]}`,
  ...nextTokens.slice(1)
];
var parseExpression = (expression) => {
  const typeOfExpression = typeof expression;
  if (typeOfExpression === "string") {
    return expression;
  }
  if (typeOfExpression === "number") {
    return String(expression);
  }
  if (isPlainObject(expression) && (("stdout" in expression) || ("isMaxBuffer" in expression))) {
    return getSubprocessResult(expression);
  }
  if (expression instanceof ChildProcess || Object.prototype.toString.call(expression) === "[object Promise]") {
    throw new TypeError("Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.");
  }
  throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
};
var getSubprocessResult = ({ stdout }) => {
  if (typeof stdout === "string") {
    return stdout;
  }
  if (isUint8Array(stdout)) {
    return uint8ArrayToString(stdout);
  }
  if (stdout === undefined) {
    throw new TypeError(`Missing result.stdout in template expression. This is probably due to the previous subprocess' "stdout" option.`);
  }
  throw new TypeError(`Unexpected "${typeof stdout}" stdout in template expression`);
};

// node_modules/execa/lib/methods/main-sync.js
import { spawnSync } from "node:child_process";

// node_modules/execa/lib/arguments/specific.js
import { debuglog } from "node:util";

// node_modules/execa/lib/utils/standard-stream.js
import process15 from "node:process";
var isStandardStream = (stream2) => STANDARD_STREAMS.includes(stream2);
var STANDARD_STREAMS = [process15.stdin, process15.stdout, process15.stderr];
var STANDARD_STREAMS_ALIASES = ["stdin", "stdout", "stderr"];
var getStreamName = (fdNumber) => STANDARD_STREAMS_ALIASES[fdNumber] ?? `stdio[${fdNumber}]`;

// node_modules/execa/lib/arguments/specific.js
var normalizeFdSpecificOptions = (options) => {
  const optionsCopy = { ...options };
  for (const optionName of FD_SPECIFIC_OPTIONS) {
    optionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);
  }
  return optionsCopy;
};
var normalizeFdSpecificOption = (options, optionName) => {
  const optionBaseArray = Array.from({ length: getStdioLength(options) + 1 });
  const optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);
  return addDefaultValue(optionArray, optionName);
};
var getStdioLength = ({ stdio }) => Array.isArray(stdio) ? Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length) : STANDARD_STREAMS_ALIASES.length;
var normalizeFdSpecificValue = (optionValue, optionArray, optionName) => isPlainObject(optionValue) ? normalizeOptionObject(optionValue, optionArray, optionName) : optionArray.fill(optionValue);
var normalizeOptionObject = (optionValue, optionArray, optionName) => {
  for (const fdName of Object.keys(optionValue).sort(compareFdName)) {
    for (const fdNumber of parseFdName(fdName, optionName, optionArray)) {
      optionArray[fdNumber] = optionValue[fdName];
    }
  }
  return optionArray;
};
var compareFdName = (fdNameA, fdNameB) => getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1;
var getFdNameOrder = (fdName) => {
  if (fdName === "stdout" || fdName === "stderr") {
    return 0;
  }
  return fdName === "all" ? 2 : 1;
};
var parseFdName = (fdName, optionName, optionArray) => {
  if (fdName === "ipc") {
    return [optionArray.length - 1];
  }
  const fdNumber = parseFd(fdName);
  if (fdNumber === undefined || fdNumber === 0) {
    throw new TypeError(`"${optionName}.${fdName}" is invalid.
It must be "${optionName}.stdout", "${optionName}.stderr", "${optionName}.all", "${optionName}.ipc", or "${optionName}.fd3", "${optionName}.fd4" (and so on).`);
  }
  if (fdNumber >= optionArray.length) {
    throw new TypeError(`"${optionName}.${fdName}" is invalid: that file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
  }
  return fdNumber === "all" ? [1, 2] : [fdNumber];
};
var parseFd = (fdName) => {
  if (fdName === "all") {
    return fdName;
  }
  if (STANDARD_STREAMS_ALIASES.includes(fdName)) {
    return STANDARD_STREAMS_ALIASES.indexOf(fdName);
  }
  const regexpResult = FD_REGEXP.exec(fdName);
  if (regexpResult !== null) {
    return Number(regexpResult[1]);
  }
};
var FD_REGEXP = /^fd(\d+)$/;
var addDefaultValue = (optionArray, optionName) => optionArray.map((optionValue) => optionValue === undefined ? DEFAULT_OPTIONS[optionName] : optionValue);
var verboseDefault = debuglog("execa").enabled ? "full" : "none";
var DEFAULT_OPTIONS = {
  lines: false,
  buffer: true,
  maxBuffer: 1000 * 1000 * 100,
  verbose: verboseDefault,
  stripFinalNewline: true
};
var FD_SPECIFIC_OPTIONS = ["lines", "buffer", "maxBuffer", "verbose", "stripFinalNewline"];
var getFdSpecificValue = (optionArray, fdNumber) => fdNumber === "ipc" ? optionArray.at(-1) : optionArray[fdNumber];

// node_modules/execa/lib/verbose/values.js
var isVerbose = ({ verbose }, fdNumber) => getFdVerbose(verbose, fdNumber) !== "none";
var isFullVerbose = ({ verbose }, fdNumber) => !["none", "short"].includes(getFdVerbose(verbose, fdNumber));
var getVerboseFunction = ({ verbose }, fdNumber) => {
  const fdVerbose = getFdVerbose(verbose, fdNumber);
  return isVerboseFunction(fdVerbose) ? fdVerbose : undefined;
};
var getFdVerbose = (verbose, fdNumber) => fdNumber === undefined ? getFdGenericVerbose(verbose) : getFdSpecificValue(verbose, fdNumber);
var getFdGenericVerbose = (verbose) => verbose.find((fdVerbose) => isVerboseFunction(fdVerbose)) ?? VERBOSE_VALUES.findLast((fdVerbose) => verbose.includes(fdVerbose));
var isVerboseFunction = (fdVerbose) => typeof fdVerbose === "function";
var VERBOSE_VALUES = ["none", "short", "full"];

// node_modules/execa/lib/verbose/log.js
import { inspect } from "node:util";

// node_modules/execa/lib/arguments/escape.js
import { platform as platform2 } from "node:process";
import { stripVTControlCharacters } from "node:util";
var joinCommand = (filePath, rawArguments) => {
  const fileAndArguments = [filePath, ...rawArguments];
  const command = fileAndArguments.join(" ");
  const escapedCommand = fileAndArguments.map((fileAndArgument) => quoteString(escapeControlCharacters(fileAndArgument))).join(" ");
  return { command, escapedCommand };
};
var escapeLines = (lines) => stripVTControlCharacters(lines).split(`
`).map((line) => escapeControlCharacters(line)).join(`
`);
var escapeControlCharacters = (line) => line.replaceAll(SPECIAL_CHAR_REGEXP, (character) => escapeControlCharacter(character));
var escapeControlCharacter = (character) => {
  const commonEscape = COMMON_ESCAPES[character];
  if (commonEscape !== undefined) {
    return commonEscape;
  }
  const codepoint = character.codePointAt(0);
  const codepointHex = codepoint.toString(16);
  return codepoint <= ASTRAL_START ? `\\u${codepointHex.padStart(4, "0")}` : `\\U${codepointHex}`;
};
var getSpecialCharRegExp = () => {
  try {
    return new RegExp("\\p{Separator}|\\p{Other}", "gu");
  } catch {
    return /[\s\u0000-\u001F\u007F-\u009F\u00AD]/g;
  }
};
var SPECIAL_CHAR_REGEXP = getSpecialCharRegExp();
var COMMON_ESCAPES = {
  " ": " ",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "\t": "\\t"
};
var ASTRAL_START = 65535;
var quoteString = (escapedArgument) => {
  if (NO_ESCAPE_REGEXP.test(escapedArgument)) {
    return escapedArgument;
  }
  return platform2 === "win32" ? `"${escapedArgument.replaceAll('"', '""')}"` : `'${escapedArgument.replaceAll("'", "'\\''")}'`;
};
var NO_ESCAPE_REGEXP = /^[\w./-]+$/;

// node_modules/is-unicode-supported/index.js
import process16 from "node:process";
function isUnicodeSupported() {
  const { env: env3 } = process16;
  const { TERM, TERM_PROGRAM } = env3;
  if (process16.platform !== "win32") {
    return TERM !== "linux";
  }
  return Boolean(env3.WT_SESSION) || Boolean(env3.TERMINUS_SUBLIME) || env3.ConEmuTask === "{cmd::Cmder}" || TERM_PROGRAM === "Terminus-Sublime" || TERM_PROGRAM === "vscode" || TERM === "xterm-256color" || TERM === "alacritty" || TERM === "rxvt-unicode" || TERM === "rxvt-unicode-256color" || env3.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// node_modules/figures/index.js
var common = {
  circleQuestionMark: "(?)",
  questionMarkPrefix: "(?)",
  square: "",
  squareDarkShade: "",
  squareMediumShade: "",
  squareLightShade: "",
  squareTop: "",
  squareBottom: "",
  squareLeft: "",
  squareRight: "",
  squareCenter: "",
  bullet: "",
  dot: "",
  ellipsis: "",
  pointerSmall: "",
  triangleUp: "",
  triangleUpSmall: "",
  triangleDown: "",
  triangleDownSmall: "",
  triangleLeftSmall: "",
  triangleRightSmall: "",
  home: "",
  heart: "",
  musicNote: "",
  musicNoteBeamed: "",
  arrowUp: "",
  arrowDown: "",
  arrowLeft: "",
  arrowRight: "",
  arrowLeftRight: "",
  arrowUpDown: "",
  almostEqual: "",
  notEqual: "",
  lessOrEqual: "",
  greaterOrEqual: "",
  identical: "",
  infinity: "",
  subscriptZero: "",
  subscriptOne: "",
  subscriptTwo: "",
  subscriptThree: "",
  subscriptFour: "",
  subscriptFive: "",
  subscriptSix: "",
  subscriptSeven: "",
  subscriptEight: "",
  subscriptNine: "",
  oneHalf: "",
  oneThird: "",
  oneQuarter: "",
  oneFifth: "",
  oneSixth: "",
  oneEighth: "",
  twoThirds: "",
  twoFifths: "",
  threeQuarters: "",
  threeFifths: "",
  threeEighths: "",
  fourFifths: "",
  fiveSixths: "",
  fiveEighths: "",
  sevenEighths: "",
  line: "",
  lineBold: "",
  lineDouble: "",
  lineDashed0: "",
  lineDashed1: "",
  lineDashed2: "",
  lineDashed3: "",
  lineDashed4: "",
  lineDashed5: "",
  lineDashed6: "",
  lineDashed7: "",
  lineDashed8: "",
  lineDashed9: "",
  lineDashed10: "",
  lineDashed11: "",
  lineDashed12: "",
  lineDashed13: "",
  lineDashed14: "",
  lineDashed15: "",
  lineVertical: "",
  lineVerticalBold: "",
  lineVerticalDouble: "",
  lineVerticalDashed0: "",
  lineVerticalDashed1: "",
  lineVerticalDashed2: "",
  lineVerticalDashed3: "",
  lineVerticalDashed4: "",
  lineVerticalDashed5: "",
  lineVerticalDashed6: "",
  lineVerticalDashed7: "",
  lineVerticalDashed8: "",
  lineVerticalDashed9: "",
  lineVerticalDashed10: "",
  lineVerticalDashed11: "",
  lineDownLeft: "",
  lineDownLeftArc: "",
  lineDownBoldLeftBold: "",
  lineDownBoldLeft: "",
  lineDownLeftBold: "",
  lineDownDoubleLeftDouble: "",
  lineDownDoubleLeft: "",
  lineDownLeftDouble: "",
  lineDownRight: "",
  lineDownRightArc: "",
  lineDownBoldRightBold: "",
  lineDownBoldRight: "",
  lineDownRightBold: "",
  lineDownDoubleRightDouble: "",
  lineDownDoubleRight: "",
  lineDownRightDouble: "",
  lineUpLeft: "",
  lineUpLeftArc: "",
  lineUpBoldLeftBold: "",
  lineUpBoldLeft: "",
  lineUpLeftBold: "",
  lineUpDoubleLeftDouble: "",
  lineUpDoubleLeft: "",
  lineUpLeftDouble: "",
  lineUpRight: "",
  lineUpRightArc: "",
  lineUpBoldRightBold: "",
  lineUpBoldRight: "",
  lineUpRightBold: "",
  lineUpDoubleRightDouble: "",
  lineUpDoubleRight: "",
  lineUpRightDouble: "",
  lineUpDownLeft: "",
  lineUpBoldDownBoldLeftBold: "",
  lineUpBoldDownBoldLeft: "",
  lineUpDownLeftBold: "",
  lineUpBoldDownLeftBold: "",
  lineUpDownBoldLeftBold: "",
  lineUpDownBoldLeft: "",
  lineUpBoldDownLeft: "",
  lineUpDoubleDownDoubleLeftDouble: "",
  lineUpDoubleDownDoubleLeft: "",
  lineUpDownLeftDouble: "",
  lineUpDownRight: "",
  lineUpBoldDownBoldRightBold: "",
  lineUpBoldDownBoldRight: "",
  lineUpDownRightBold: "",
  lineUpBoldDownRightBold: "",
  lineUpDownBoldRightBold: "",
  lineUpDownBoldRight: "",
  lineUpBoldDownRight: "",
  lineUpDoubleDownDoubleRightDouble: "",
  lineUpDoubleDownDoubleRight: "",
  lineUpDownRightDouble: "",
  lineDownLeftRight: "",
  lineDownBoldLeftBoldRightBold: "",
  lineDownLeftBoldRightBold: "",
  lineDownBoldLeftRight: "",
  lineDownBoldLeftBoldRight: "",
  lineDownBoldLeftRightBold: "",
  lineDownLeftRightBold: "",
  lineDownLeftBoldRight: "",
  lineDownDoubleLeftDoubleRightDouble: "",
  lineDownDoubleLeftRight: "",
  lineDownLeftDoubleRightDouble: "",
  lineUpLeftRight: "",
  lineUpBoldLeftBoldRightBold: "",
  lineUpLeftBoldRightBold: "",
  lineUpBoldLeftRight: "",
  lineUpBoldLeftBoldRight: "",
  lineUpBoldLeftRightBold: "",
  lineUpLeftRightBold: "",
  lineUpLeftBoldRight: "",
  lineUpDoubleLeftDoubleRightDouble: "",
  lineUpDoubleLeftRight: "",
  lineUpLeftDoubleRightDouble: "",
  lineUpDownLeftRight: "",
  lineUpBoldDownBoldLeftBoldRightBold: "",
  lineUpDownBoldLeftBoldRightBold: "",
  lineUpBoldDownLeftBoldRightBold: "",
  lineUpBoldDownBoldLeftRightBold: "",
  lineUpBoldDownBoldLeftBoldRight: "",
  lineUpBoldDownLeftRight: "",
  lineUpDownBoldLeftRight: "",
  lineUpDownLeftBoldRight: "",
  lineUpDownLeftRightBold: "",
  lineUpBoldDownBoldLeftRight: "",
  lineUpDownLeftBoldRightBold: "",
  lineUpBoldDownLeftBoldRight: "",
  lineUpBoldDownLeftRightBold: "",
  lineUpDownBoldLeftBoldRight: "",
  lineUpDownBoldLeftRightBold: "",
  lineUpDoubleDownDoubleLeftDoubleRightDouble: "",
  lineUpDoubleDownDoubleLeftRight: "",
  lineUpDownLeftDoubleRightDouble: "",
  lineCross: "",
  lineBackslash: "",
  lineSlash: ""
};
var specialMainSymbols = {
  tick: "",
  info: "",
  warning: "",
  cross: "",
  squareSmall: "",
  squareSmallFilled: "",
  circle: "",
  circleFilled: "",
  circleDotted: "",
  circleDouble: "",
  circleCircle: "",
  circleCross: "",
  circlePipe: "",
  radioOn: "",
  radioOff: "",
  checkboxOn: "",
  checkboxOff: "",
  checkboxCircleOn: "",
  checkboxCircleOff: "",
  pointer: "",
  triangleUpOutline: "",
  triangleLeft: "",
  triangleRight: "",
  lozenge: "",
  lozengeOutline: "",
  hamburger: "",
  smiley: "",
  mustache: "",
  star: "",
  play: "",
  nodejs: "",
  oneSeventh: "",
  oneNinth: "",
  oneTenth: ""
};
var specialFallbackSymbols = {
  tick: "",
  info: "i",
  warning: "",
  cross: "",
  squareSmall: "",
  squareSmallFilled: "",
  circle: "( )",
  circleFilled: "(*)",
  circleDotted: "( )",
  circleDouble: "( )",
  circleCircle: "()",
  circleCross: "()",
  circlePipe: "()",
  radioOn: "(*)",
  radioOff: "( )",
  checkboxOn: "[]",
  checkboxOff: "[ ]",
  checkboxCircleOn: "()",
  checkboxCircleOff: "( )",
  pointer: ">",
  triangleUpOutline: "",
  triangleLeft: "",
  triangleRight: "",
  lozenge: "",
  lozengeOutline: "",
  hamburger: "",
  smiley: "",
  mustache: "",
  star: "",
  play: "",
  nodejs: "",
  oneSeventh: "1/7",
  oneNinth: "1/9",
  oneTenth: "1/10"
};
var mainSymbols = { ...common, ...specialMainSymbols };
var fallbackSymbols = { ...common, ...specialFallbackSymbols };
var shouldUseMain = isUnicodeSupported();
var figures = shouldUseMain ? mainSymbols : fallbackSymbols;
var figures_default = figures;
var replacements = Object.entries(specialMainSymbols);

// node_modules/yoctocolors/base.js
import tty2 from "node:tty";
var hasColors = tty2?.WriteStream?.prototype?.hasColors?.() ?? false;
var format = (open, close) => {
  if (!hasColors) {
    return (input) => input;
  }
  const openCode = `\x1B[${open}m`;
  const closeCode = `\x1B[${close}m`;
  return (input) => {
    const string = input + "";
    let index = string.indexOf(closeCode);
    if (index === -1) {
      return openCode + string + closeCode;
    }
    let result = openCode;
    let lastIndex = 0;
    const reopenOnNestedClose = close === 22;
    const replaceCode = (reopenOnNestedClose ? closeCode : "") + openCode;
    while (index !== -1) {
      result += string.slice(lastIndex, index) + replaceCode;
      lastIndex = index + closeCode.length;
      index = string.indexOf(closeCode, lastIndex);
    }
    result += string.slice(lastIndex) + closeCode;
    return result;
  };
};
var reset = format(0, 0);
var bold = format(1, 22);
var dim = format(2, 22);
var italic = format(3, 23);
var underline = format(4, 24);
var overline = format(53, 55);
var inverse = format(7, 27);
var hidden = format(8, 28);
var strikethrough = format(9, 29);
var black = format(30, 39);
var red = format(31, 39);
var green = format(32, 39);
var yellow = format(33, 39);
var blue = format(34, 39);
var magenta = format(35, 39);
var cyan = format(36, 39);
var white = format(37, 39);
var gray = format(90, 39);
var bgBlack = format(40, 49);
var bgRed = format(41, 49);
var bgGreen = format(42, 49);
var bgYellow = format(43, 49);
var bgBlue = format(44, 49);
var bgMagenta = format(45, 49);
var bgCyan = format(46, 49);
var bgWhite = format(47, 49);
var bgGray = format(100, 49);
var redBright = format(91, 39);
var greenBright = format(92, 39);
var yellowBright = format(93, 39);
var blueBright = format(94, 39);
var magentaBright = format(95, 39);
var cyanBright = format(96, 39);
var whiteBright = format(97, 39);
var bgRedBright = format(101, 49);
var bgGreenBright = format(102, 49);
var bgYellowBright = format(103, 49);
var bgBlueBright = format(104, 49);
var bgMagentaBright = format(105, 49);
var bgCyanBright = format(106, 49);
var bgWhiteBright = format(107, 49);

// node_modules/execa/lib/verbose/default.js
var defaultVerboseFunction = ({
  type,
  message,
  timestamp,
  piped,
  commandId,
  result: { failed = false } = {},
  options: { reject: reject2 = true }
}) => {
  const timestampString = serializeTimestamp(timestamp);
  const icon = ICONS[type]({ failed, reject: reject2, piped });
  const color = COLORS[type]({ reject: reject2 });
  return `${gray(`[${timestampString}]`)} ${gray(`[${commandId}]`)} ${color(icon)} ${color(message)}`;
};
var serializeTimestamp = (timestamp) => `${padField(timestamp.getHours(), 2)}:${padField(timestamp.getMinutes(), 2)}:${padField(timestamp.getSeconds(), 2)}.${padField(timestamp.getMilliseconds(), 3)}`;
var padField = (field, padding) => String(field).padStart(padding, "0");
var getFinalIcon = ({ failed, reject: reject2 }) => {
  if (!failed) {
    return figures_default.tick;
  }
  return reject2 ? figures_default.cross : figures_default.warning;
};
var ICONS = {
  command: ({ piped }) => piped ? "|" : "$",
  output: () => " ",
  ipc: () => "*",
  error: getFinalIcon,
  duration: getFinalIcon
};
var identity = (string) => string;
var COLORS = {
  command: () => bold,
  output: () => identity,
  ipc: () => identity,
  error: ({ reject: reject2 }) => reject2 ? redBright : yellowBright,
  duration: () => gray
};

// node_modules/execa/lib/verbose/custom.js
var applyVerboseOnLines = (printedLines, verboseInfo, fdNumber) => {
  const verboseFunction = getVerboseFunction(verboseInfo, fdNumber);
  return printedLines.map(({ verboseLine, verboseObject }) => applyVerboseFunction(verboseLine, verboseObject, verboseFunction)).filter((printedLine) => printedLine !== undefined).map((printedLine) => appendNewline(printedLine)).join("");
};
var applyVerboseFunction = (verboseLine, verboseObject, verboseFunction) => {
  if (verboseFunction === undefined) {
    return verboseLine;
  }
  const printedLine = verboseFunction(verboseLine, verboseObject);
  if (typeof printedLine === "string") {
    return printedLine;
  }
};
var appendNewline = (printedLine) => printedLine.endsWith(`
`) ? printedLine : `${printedLine}
`;

// node_modules/execa/lib/verbose/log.js
var verboseLog = ({ type, verboseMessage, fdNumber, verboseInfo, result }) => {
  const verboseObject = getVerboseObject({ type, result, verboseInfo });
  const printedLines = getPrintedLines(verboseMessage, verboseObject);
  const finalLines = applyVerboseOnLines(printedLines, verboseInfo, fdNumber);
  if (finalLines !== "") {
    console.warn(finalLines.slice(0, -1));
  }
};
var getVerboseObject = ({
  type,
  result,
  verboseInfo: { escapedCommand, commandId, rawOptions: { piped = false, ...options } }
}) => ({
  type,
  escapedCommand,
  commandId: `${commandId}`,
  timestamp: new Date,
  piped,
  result,
  options
});
var getPrintedLines = (verboseMessage, verboseObject) => verboseMessage.split(`
`).map((message) => getPrintedLine({ ...verboseObject, message }));
var getPrintedLine = (verboseObject) => {
  const verboseLine = defaultVerboseFunction(verboseObject);
  return { verboseLine, verboseObject };
};
var serializeVerboseMessage = (message) => {
  const messageString = typeof message === "string" ? message : inspect(message);
  const escapedMessage = escapeLines(messageString);
  return escapedMessage.replaceAll("\t", " ".repeat(TAB_SIZE));
};
var TAB_SIZE = 2;

// node_modules/execa/lib/verbose/start.js
var logCommand = (escapedCommand, verboseInfo) => {
  if (!isVerbose(verboseInfo)) {
    return;
  }
  verboseLog({
    type: "command",
    verboseMessage: escapedCommand,
    verboseInfo
  });
};

// node_modules/execa/lib/verbose/info.js
var getVerboseInfo = (verbose, escapedCommand, rawOptions) => {
  validateVerbose(verbose);
  const commandId = getCommandId(verbose);
  return {
    verbose,
    escapedCommand,
    commandId,
    rawOptions
  };
};
var getCommandId = (verbose) => isVerbose({ verbose }) ? COMMAND_ID++ : undefined;
var COMMAND_ID = 0n;
var validateVerbose = (verbose) => {
  for (const fdVerbose of verbose) {
    if (fdVerbose === false) {
      throw new TypeError(`The "verbose: false" option was renamed to "verbose: 'none'".`);
    }
    if (fdVerbose === true) {
      throw new TypeError(`The "verbose: true" option was renamed to "verbose: 'short'".`);
    }
    if (!VERBOSE_VALUES.includes(fdVerbose) && !isVerboseFunction(fdVerbose)) {
      const allowedValues = VERBOSE_VALUES.map((allowedValue) => `'${allowedValue}'`).join(", ");
      throw new TypeError(`The "verbose" option must not be ${fdVerbose}. Allowed values are: ${allowedValues} or a function.`);
    }
  }
};

// node_modules/execa/lib/return/duration.js
import { hrtime } from "node:process";
var getStartTime = () => hrtime.bigint();
var getDurationMs = (startTime) => Number(hrtime.bigint() - startTime) / 1e6;

// node_modules/execa/lib/arguments/command.js
var handleCommand = (filePath, rawArguments, rawOptions) => {
  const startTime = getStartTime();
  const { command, escapedCommand } = joinCommand(filePath, rawArguments);
  const verbose = normalizeFdSpecificOption(rawOptions, "verbose");
  const verboseInfo = getVerboseInfo(verbose, escapedCommand, { ...rawOptions });
  logCommand(escapedCommand, verboseInfo);
  return {
    command,
    escapedCommand,
    startTime,
    verboseInfo
  };
};

// node_modules/execa/lib/arguments/options.js
var import_cross_spawn = __toESM(require_cross_spawn(), 1);
import path5 from "node:path";
import process19 from "node:process";

// node_modules/npm-run-path/index.js
import process17 from "node:process";
import path2 from "node:path";

// node_modules/npm-run-path/node_modules/path-key/index.js
function pathKey(options = {}) {
  const {
    env: env3 = process.env,
    platform: platform3 = process.platform
  } = options;
  if (platform3 !== "win32") {
    return "PATH";
  }
  return Object.keys(env3).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
}

// node_modules/unicorn-magic/node.js
import { promisify } from "node:util";
import { execFile as execFileCallback, execFileSync as execFileSyncOriginal } from "node:child_process";
import path from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";
var execFileOriginal = promisify(execFileCallback);
function toPath(urlOrPath) {
  return urlOrPath instanceof URL ? fileURLToPath2(urlOrPath) : urlOrPath;
}
function traversePathUp(startPath) {
  return {
    *[Symbol.iterator]() {
      let currentPath = path.resolve(toPath(startPath));
      let previousPath;
      while (previousPath !== currentPath) {
        yield currentPath;
        previousPath = currentPath;
        currentPath = path.resolve(currentPath, "..");
      }
    }
  };
}
var TEN_MEGABYTES_IN_BYTES = 10 * 1024 * 1024;

// node_modules/npm-run-path/index.js
var npmRunPath = ({
  cwd: cwd2 = process17.cwd(),
  path: pathOption = process17.env[pathKey()],
  preferLocal = true,
  execPath = process17.execPath,
  addExecPath = true
} = {}) => {
  const cwdPath = path2.resolve(toPath(cwd2));
  const result = [];
  const pathParts = pathOption.split(path2.delimiter);
  if (preferLocal) {
    applyPreferLocal(result, pathParts, cwdPath);
  }
  if (addExecPath) {
    applyExecPath(result, pathParts, execPath, cwdPath);
  }
  return pathOption === "" || pathOption === path2.delimiter ? `${result.join(path2.delimiter)}${pathOption}` : [...result, pathOption].join(path2.delimiter);
};
var applyPreferLocal = (result, pathParts, cwdPath) => {
  for (const directory of traversePathUp(cwdPath)) {
    const pathPart = path2.join(directory, "node_modules/.bin");
    if (!pathParts.includes(pathPart)) {
      result.push(pathPart);
    }
  }
};
var applyExecPath = (result, pathParts, execPath, cwdPath) => {
  const pathPart = path2.resolve(cwdPath, toPath(execPath), "..");
  if (!pathParts.includes(pathPart)) {
    result.push(pathPart);
  }
};
var npmRunPathEnv = ({ env: env3 = process17.env, ...options } = {}) => {
  env3 = { ...env3 };
  const pathName = pathKey({ env: env3 });
  options.path = env3[pathName];
  env3[pathName] = npmRunPath(options);
  return env3;
};

// node_modules/execa/lib/terminate/kill.js
import { setTimeout as setTimeout2 } from "node:timers/promises";

// node_modules/execa/lib/return/final-error.js
var getFinalError = (originalError, message, isSync) => {
  const ErrorClass = isSync ? ExecaSyncError : ExecaError;
  const options = originalError instanceof DiscardedError ? {} : { cause: originalError };
  return new ErrorClass(message, options);
};

class DiscardedError extends Error {
}
var setErrorName = (ErrorClass, value) => {
  Object.defineProperty(ErrorClass.prototype, "name", {
    value,
    writable: true,
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ErrorClass.prototype, execaErrorSymbol, {
    value: true,
    writable: false,
    enumerable: false,
    configurable: false
  });
};
var isExecaError = (error) => isErrorInstance(error) && (execaErrorSymbol in error);
var execaErrorSymbol = Symbol("isExecaError");
var isErrorInstance = (value) => Object.prototype.toString.call(value) === "[object Error]";

class ExecaError extends Error {
}
setErrorName(ExecaError, ExecaError.name);

class ExecaSyncError extends Error {
}
setErrorName(ExecaSyncError, ExecaSyncError.name);

// node_modules/execa/lib/terminate/signal.js
import { constants as constants5 } from "node:os";

// node_modules/human-signals/build/src/main.js
import { constants as constants4 } from "node:os";

// node_modules/human-signals/build/src/realtime.js
var getRealtimeSignals = () => {
  const length = SIGRTMAX - SIGRTMIN + 1;
  return Array.from({ length }, getRealtimeSignal);
};
var getRealtimeSignal = (value, index) => ({
  name: `SIGRT${index + 1}`,
  number: SIGRTMIN + index,
  action: "terminate",
  description: "Application-specific signal (realtime)",
  standard: "posix"
});
var SIGRTMIN = 34;
var SIGRTMAX = 64;

// node_modules/human-signals/build/src/signals.js
import { constants as constants3 } from "node:os";

// node_modules/human-signals/build/src/core.js
var SIGNALS = [
  {
    name: "SIGHUP",
    number: 1,
    action: "terminate",
    description: "Terminal closed",
    standard: "posix"
  },
  {
    name: "SIGINT",
    number: 2,
    action: "terminate",
    description: "User interruption with CTRL-C",
    standard: "ansi"
  },
  {
    name: "SIGQUIT",
    number: 3,
    action: "core",
    description: "User interruption with CTRL-\\",
    standard: "posix"
  },
  {
    name: "SIGILL",
    number: 4,
    action: "core",
    description: "Invalid machine instruction",
    standard: "ansi"
  },
  {
    name: "SIGTRAP",
    number: 5,
    action: "core",
    description: "Debugger breakpoint",
    standard: "posix"
  },
  {
    name: "SIGABRT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "ansi"
  },
  {
    name: "SIGIOT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "bsd"
  },
  {
    name: "SIGBUS",
    number: 7,
    action: "core",
    description: "Bus error due to misaligned, non-existing address or paging error",
    standard: "bsd"
  },
  {
    name: "SIGEMT",
    number: 7,
    action: "terminate",
    description: "Command should be emulated but is not implemented",
    standard: "other"
  },
  {
    name: "SIGFPE",
    number: 8,
    action: "core",
    description: "Floating point arithmetic error",
    standard: "ansi"
  },
  {
    name: "SIGKILL",
    number: 9,
    action: "terminate",
    description: "Forced termination",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGUSR1",
    number: 10,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGSEGV",
    number: 11,
    action: "core",
    description: "Segmentation fault",
    standard: "ansi"
  },
  {
    name: "SIGUSR2",
    number: 12,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGPIPE",
    number: 13,
    action: "terminate",
    description: "Broken pipe or socket",
    standard: "posix"
  },
  {
    name: "SIGALRM",
    number: 14,
    action: "terminate",
    description: "Timeout or timer",
    standard: "posix"
  },
  {
    name: "SIGTERM",
    number: 15,
    action: "terminate",
    description: "Termination",
    standard: "ansi"
  },
  {
    name: "SIGSTKFLT",
    number: 16,
    action: "terminate",
    description: "Stack is empty or overflowed",
    standard: "other"
  },
  {
    name: "SIGCHLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "posix"
  },
  {
    name: "SIGCLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "other"
  },
  {
    name: "SIGCONT",
    number: 18,
    action: "unpause",
    description: "Unpaused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGSTOP",
    number: 19,
    action: "pause",
    description: "Paused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGTSTP",
    number: 20,
    action: "pause",
    description: 'Paused using CTRL-Z or "suspend"',
    standard: "posix"
  },
  {
    name: "SIGTTIN",
    number: 21,
    action: "pause",
    description: "Background process cannot read terminal input",
    standard: "posix"
  },
  {
    name: "SIGBREAK",
    number: 21,
    action: "terminate",
    description: "User interruption with CTRL-BREAK",
    standard: "other"
  },
  {
    name: "SIGTTOU",
    number: 22,
    action: "pause",
    description: "Background process cannot write to terminal output",
    standard: "posix"
  },
  {
    name: "SIGURG",
    number: 23,
    action: "ignore",
    description: "Socket received out-of-band data",
    standard: "bsd"
  },
  {
    name: "SIGXCPU",
    number: 24,
    action: "core",
    description: "Process timed out",
    standard: "bsd"
  },
  {
    name: "SIGXFSZ",
    number: 25,
    action: "core",
    description: "File too big",
    standard: "bsd"
  },
  {
    name: "SIGVTALRM",
    number: 26,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGPROF",
    number: 27,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGWINCH",
    number: 28,
    action: "ignore",
    description: "Terminal window size changed",
    standard: "bsd"
  },
  {
    name: "SIGIO",
    number: 29,
    action: "terminate",
    description: "I/O is available",
    standard: "other"
  },
  {
    name: "SIGPOLL",
    number: 29,
    action: "terminate",
    description: "Watched event",
    standard: "other"
  },
  {
    name: "SIGINFO",
    number: 29,
    action: "ignore",
    description: "Request for process information",
    standard: "other"
  },
  {
    name: "SIGPWR",
    number: 30,
    action: "terminate",
    description: "Device running out of power",
    standard: "systemv"
  },
  {
    name: "SIGSYS",
    number: 31,
    action: "core",
    description: "Invalid system call",
    standard: "other"
  },
  {
    name: "SIGUNUSED",
    number: 31,
    action: "terminate",
    description: "Invalid system call",
    standard: "other"
  }
];

// node_modules/human-signals/build/src/signals.js
var getSignals = () => {
  const realtimeSignals = getRealtimeSignals();
  const signals = [...SIGNALS, ...realtimeSignals].map(normalizeSignal);
  return signals;
};
var normalizeSignal = ({
  name,
  number: defaultNumber,
  description,
  action,
  forced = false,
  standard
}) => {
  const {
    signals: { [name]: constantSignal }
  } = constants3;
  const supported = constantSignal !== undefined;
  const number = supported ? constantSignal : defaultNumber;
  return { name, number, description, supported, action, forced, standard };
};

// node_modules/human-signals/build/src/main.js
var getSignalsByName = () => {
  const signals = getSignals();
  return Object.fromEntries(signals.map(getSignalByName));
};
var getSignalByName = ({
  name,
  number,
  description,
  supported,
  action,
  forced,
  standard
}) => [name, { name, number, description, supported, action, forced, standard }];
var signalsByName = getSignalsByName();
var getSignalsByNumber = () => {
  const signals = getSignals();
  const length = SIGRTMAX + 1;
  const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));
  return Object.assign({}, ...signalsA);
};
var getSignalByNumber = (number, signals) => {
  const signal = findSignalByNumber(number, signals);
  if (signal === undefined) {
    return {};
  }
  const { name, description, supported, action, forced, standard } = signal;
  return {
    [number]: {
      name,
      number,
      description,
      supported,
      action,
      forced,
      standard
    }
  };
};
var findSignalByNumber = (number, signals) => {
  const signal = signals.find(({ name }) => constants4.signals[name] === number);
  if (signal !== undefined) {
    return signal;
  }
  return signals.find((signalA) => signalA.number === number);
};
var signalsByNumber = getSignalsByNumber();

// node_modules/execa/lib/terminate/signal.js
var normalizeKillSignal = (killSignal) => {
  const optionName = "option `killSignal`";
  if (killSignal === 0) {
    throw new TypeError(`Invalid ${optionName}: 0 cannot be used.`);
  }
  return normalizeSignal2(killSignal, optionName);
};
var normalizeSignalArgument = (signal) => signal === 0 ? signal : normalizeSignal2(signal, "`subprocess.kill()`'s argument");
var normalizeSignal2 = (signalNameOrInteger, optionName) => {
  if (Number.isInteger(signalNameOrInteger)) {
    return normalizeSignalInteger(signalNameOrInteger, optionName);
  }
  if (typeof signalNameOrInteger === "string") {
    return normalizeSignalName(signalNameOrInteger, optionName);
  }
  throw new TypeError(`Invalid ${optionName} ${String(signalNameOrInteger)}: it must be a string or an integer.
${getAvailableSignals()}`);
};
var normalizeSignalInteger = (signalInteger, optionName) => {
  if (signalsIntegerToName.has(signalInteger)) {
    return signalsIntegerToName.get(signalInteger);
  }
  throw new TypeError(`Invalid ${optionName} ${signalInteger}: this signal integer does not exist.
${getAvailableSignals()}`);
};
var getSignalsIntegerToName = () => new Map(Object.entries(constants5.signals).reverse().map(([signalName, signalInteger]) => [signalInteger, signalName]));
var signalsIntegerToName = getSignalsIntegerToName();
var normalizeSignalName = (signalName, optionName) => {
  if (signalName in constants5.signals) {
    return signalName;
  }
  if (signalName.toUpperCase() in constants5.signals) {
    throw new TypeError(`Invalid ${optionName} '${signalName}': please rename it to '${signalName.toUpperCase()}'.`);
  }
  throw new TypeError(`Invalid ${optionName} '${signalName}': this signal name does not exist.
${getAvailableSignals()}`);
};
var getAvailableSignals = () => `Available signal names: ${getAvailableSignalNames()}.
Available signal numbers: ${getAvailableSignalIntegers()}.`;
var getAvailableSignalNames = () => Object.keys(constants5.signals).sort().map((signalName) => `'${signalName}'`).join(", ");
var getAvailableSignalIntegers = () => [...new Set(Object.values(constants5.signals).sort((signalInteger, signalIntegerTwo) => signalInteger - signalIntegerTwo))].join(", ");
var getSignalDescription = (signal) => signalsByName[signal].description;

// node_modules/execa/lib/terminate/kill.js
var normalizeForceKillAfterDelay = (forceKillAfterDelay) => {
  if (forceKillAfterDelay === false) {
    return forceKillAfterDelay;
  }
  if (forceKillAfterDelay === true) {
    return DEFAULT_FORCE_KILL_TIMEOUT;
  }
  if (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) {
    throw new TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${forceKillAfterDelay}\` (${typeof forceKillAfterDelay})`);
  }
  return forceKillAfterDelay;
};
var DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;
var subprocessKill = ({ kill, options: { forceKillAfterDelay, killSignal }, onInternalError, context, controller }, signalOrError, errorArgument) => {
  const { signal, error } = parseKillArguments(signalOrError, errorArgument, killSignal);
  emitKillError(error, onInternalError);
  const killResult = kill(signal);
  setKillTimeout({
    kill,
    signal,
    forceKillAfterDelay,
    killSignal,
    killResult,
    context,
    controller
  });
  return killResult;
};
var parseKillArguments = (signalOrError, errorArgument, killSignal) => {
  const [signal = killSignal, error] = isErrorInstance(signalOrError) ? [undefined, signalOrError] : [signalOrError, errorArgument];
  if (typeof signal !== "string" && !Number.isInteger(signal)) {
    throw new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(signal)}`);
  }
  if (error !== undefined && !isErrorInstance(error)) {
    throw new TypeError(`The second argument is optional. If specified, it must be an error instance: ${error}`);
  }
  return { signal: normalizeSignalArgument(signal), error };
};
var emitKillError = (error, onInternalError) => {
  if (error !== undefined) {
    onInternalError.reject(error);
  }
};
var setKillTimeout = async ({ kill, signal, forceKillAfterDelay, killSignal, killResult, context, controller }) => {
  if (signal === killSignal && killResult) {
    killOnTimeout({
      kill,
      forceKillAfterDelay,
      context,
      controllerSignal: controller.signal
    });
  }
};
var killOnTimeout = async ({ kill, forceKillAfterDelay, context, controllerSignal }) => {
  if (forceKillAfterDelay === false) {
    return;
  }
  try {
    await setTimeout2(forceKillAfterDelay, undefined, { signal: controllerSignal });
    if (kill("SIGKILL")) {
      context.isForcefullyTerminated ??= true;
    }
  } catch {}
};

// node_modules/execa/lib/utils/abort-signal.js
import { once } from "node:events";
var onAbortedSignal = async (mainSignal, stopSignal) => {
  if (!mainSignal.aborted) {
    await once(mainSignal, "abort", { signal: stopSignal });
  }
};

// node_modules/execa/lib/terminate/cancel.js
var validateCancelSignal = ({ cancelSignal }) => {
  if (cancelSignal !== undefined && Object.prototype.toString.call(cancelSignal) !== "[object AbortSignal]") {
    throw new Error(`The \`cancelSignal\` option must be an AbortSignal: ${String(cancelSignal)}`);
  }
};
var throwOnCancel = ({ subprocess, cancelSignal, gracefulCancel, context, controller }) => cancelSignal === undefined || gracefulCancel ? [] : [terminateOnCancel(subprocess, cancelSignal, context, controller)];
var terminateOnCancel = async (subprocess, cancelSignal, context, { signal }) => {
  await onAbortedSignal(cancelSignal, signal);
  context.terminationReason ??= "cancel";
  subprocess.kill();
  throw cancelSignal.reason;
};

// node_modules/execa/lib/ipc/graceful.js
import { scheduler as scheduler2 } from "node:timers/promises";

// node_modules/execa/lib/ipc/send.js
import { promisify as promisify2 } from "node:util";

// node_modules/execa/lib/ipc/validation.js
var validateIpcMethod = ({ methodName, isSubprocess, ipc, isConnected }) => {
  validateIpcOption(methodName, isSubprocess, ipc);
  validateConnection(methodName, isSubprocess, isConnected);
};
var validateIpcOption = (methodName, isSubprocess, ipc) => {
  if (!ipc) {
    throw new Error(`${getMethodName(methodName, isSubprocess)} can only be used if the \`ipc\` option is \`true\`.`);
  }
};
var validateConnection = (methodName, isSubprocess, isConnected) => {
  if (!isConnected) {
    throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} has already exited or disconnected.`);
  }
};
var throwOnEarlyDisconnect = (isSubprocess) => {
  throw new Error(`${getMethodName("getOneMessage", isSubprocess)} could not complete: the ${getOtherProcessName(isSubprocess)} exited or disconnected.`);
};
var throwOnStrictDeadlockError = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is sending a message too, instead of listening to incoming messages.
This can be fixed by both sending a message and listening to incoming messages at the same time:

const [receivedMessage] = await Promise.all([
	${getMethodName("getOneMessage", isSubprocess)},
	${getMethodName("sendMessage", isSubprocess, "message, {strict: true}")},
]);`);
};
var getStrictResponseError = (error, isSubprocess) => new Error(`${getMethodName("sendMessage", isSubprocess)} failed when sending an acknowledgment response to the ${getOtherProcessName(isSubprocess)}.`, { cause: error });
var throwOnMissingStrict = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is not listening to incoming messages.`);
};
var throwOnStrictDisconnect = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} exited without listening to incoming messages.`);
};
var getAbortDisconnectError = () => new Error(`\`cancelSignal\` aborted: the ${getOtherProcessName(true)} disconnected.`);
var throwOnMissingParent = () => {
  throw new Error("`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.");
};
var handleEpipeError = ({ error, methodName, isSubprocess }) => {
  if (error.code === "EPIPE") {
    throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} is disconnecting.`, { cause: error });
  }
};
var handleSerializationError = ({ error, methodName, isSubprocess, message }) => {
  if (isSerializationError(error)) {
    throw new Error(`${getMethodName(methodName, isSubprocess)}'s argument type is invalid: the message cannot be serialized: ${String(message)}.`, { cause: error });
  }
};
var isSerializationError = ({ code, message }) => SERIALIZATION_ERROR_CODES.has(code) || SERIALIZATION_ERROR_MESSAGES.some((serializationErrorMessage) => message.includes(serializationErrorMessage));
var SERIALIZATION_ERROR_CODES = new Set([
  "ERR_MISSING_ARGS",
  "ERR_INVALID_ARG_TYPE"
]);
var SERIALIZATION_ERROR_MESSAGES = [
  "could not be cloned",
  "circular structure",
  "call stack size exceeded"
];
var getMethodName = (methodName, isSubprocess, parameters = "") => methodName === "cancelSignal" ? "`cancelSignal`'s `controller.abort()`" : `${getNamespaceName(isSubprocess)}${methodName}(${parameters})`;
var getNamespaceName = (isSubprocess) => isSubprocess ? "" : "subprocess.";
var getOtherProcessName = (isSubprocess) => isSubprocess ? "parent process" : "subprocess";
var disconnect = (anyProcess) => {
  if (anyProcess.connected) {
    anyProcess.disconnect();
  }
};

// node_modules/execa/lib/utils/deferred.js
var createDeferred = () => {
  const methods = {};
  const promise = new Promise((resolve2, reject2) => {
    Object.assign(methods, { resolve: resolve2, reject: reject2 });
  });
  return Object.assign(promise, methods);
};

// node_modules/execa/lib/arguments/fd-options.js
var getToStream = (destination, to = "stdin") => {
  const isWritable = true;
  const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(destination);
  const fdNumber = getFdNumber(fileDescriptors, to, isWritable);
  const destinationStream = destination.stdio[fdNumber];
  if (destinationStream === null) {
    throw new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable));
  }
  return destinationStream;
};
var getFromStream = (source, from = "stdout") => {
  const isWritable = false;
  const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
  const fdNumber = getFdNumber(fileDescriptors, from, isWritable);
  const sourceStream = fdNumber === "all" ? source.all : source.stdio[fdNumber];
  if (sourceStream === null || sourceStream === undefined) {
    throw new TypeError(getInvalidStdioOptionMessage(fdNumber, from, options, isWritable));
  }
  return sourceStream;
};
var SUBPROCESS_OPTIONS = new WeakMap;
var getFdNumber = (fileDescriptors, fdName, isWritable) => {
  const fdNumber = parseFdNumber(fdName, isWritable);
  validateFdNumber(fdNumber, fdName, isWritable, fileDescriptors);
  return fdNumber;
};
var parseFdNumber = (fdName, isWritable) => {
  const fdNumber = parseFd(fdName);
  if (fdNumber !== undefined) {
    return fdNumber;
  }
  const { validOptions, defaultValue } = isWritable ? { validOptions: '"stdin"', defaultValue: "stdin" } : { validOptions: '"stdout", "stderr", "all"', defaultValue: "stdout" };
  throw new TypeError(`"${getOptionName(isWritable)}" must not be "${fdName}".
It must be ${validOptions} or "fd3", "fd4" (and so on).
It is optional and defaults to "${defaultValue}".`);
};
var validateFdNumber = (fdNumber, fdName, isWritable, fileDescriptors) => {
  const fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];
  if (fileDescriptor === undefined) {
    throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. That file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
  }
  if (fileDescriptor.direction === "input" && !isWritable) {
    throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a readable stream, not writable.`);
  }
  if (fileDescriptor.direction !== "input" && isWritable) {
    throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a writable stream, not readable.`);
  }
};
var getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable) => {
  if (fdNumber === "all" && !options.all) {
    return `The "all" option must be true to use "from: 'all'".`;
  }
  const { optionName, optionValue } = getInvalidStdioOption(fdNumber, options);
  return `The "${optionName}: ${serializeOptionValue(optionValue)}" option is incompatible with using "${getOptionName(isWritable)}: ${serializeOptionValue(fdName)}".
Please set this option with "pipe" instead.`;
};
var getInvalidStdioOption = (fdNumber, { stdin, stdout, stderr, stdio }) => {
  const usedDescriptor = getUsedDescriptor(fdNumber);
  if (usedDescriptor === 0 && stdin !== undefined) {
    return { optionName: "stdin", optionValue: stdin };
  }
  if (usedDescriptor === 1 && stdout !== undefined) {
    return { optionName: "stdout", optionValue: stdout };
  }
  if (usedDescriptor === 2 && stderr !== undefined) {
    return { optionName: "stderr", optionValue: stderr };
  }
  return { optionName: `stdio[${usedDescriptor}]`, optionValue: stdio[usedDescriptor] };
};
var getUsedDescriptor = (fdNumber) => fdNumber === "all" ? 1 : fdNumber;
var getOptionName = (isWritable) => isWritable ? "to" : "from";
var serializeOptionValue = (value) => {
  if (typeof value === "string") {
    return `'${value}'`;
  }
  return typeof value === "number" ? `${value}` : "Stream";
};

// node_modules/execa/lib/ipc/strict.js
import { once as once3 } from "node:events";

// node_modules/execa/lib/utils/max-listeners.js
import { addAbortListener } from "node:events";
var incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal) => {
  const maxListeners = eventEmitter.getMaxListeners();
  if (maxListeners === 0 || maxListeners === Number.POSITIVE_INFINITY) {
    return;
  }
  eventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);
  addAbortListener(signal, () => {
    eventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);
  });
};

// node_modules/execa/lib/ipc/forward.js
import { EventEmitter as EventEmitter3 } from "node:events";

// node_modules/execa/lib/ipc/incoming.js
import { once as once2 } from "node:events";
import { scheduler } from "node:timers/promises";

// node_modules/execa/lib/ipc/reference.js
var addReference = (channel, reference) => {
  if (reference) {
    addReferenceCount(channel);
  }
};
var addReferenceCount = (channel) => {
  channel.refCounted();
};
var removeReference = (channel, reference) => {
  if (reference) {
    removeReferenceCount(channel);
  }
};
var removeReferenceCount = (channel) => {
  channel.unrefCounted();
};
var undoAddedReferences = (channel, isSubprocess) => {
  if (isSubprocess) {
    removeReferenceCount(channel);
    removeReferenceCount(channel);
  }
};
var redoAddedReferences = (channel, isSubprocess) => {
  if (isSubprocess) {
    addReferenceCount(channel);
    addReferenceCount(channel);
  }
};

// node_modules/execa/lib/ipc/incoming.js
var onMessage = async ({ anyProcess, channel, isSubprocess, ipcEmitter }, wrappedMessage) => {
  if (handleStrictResponse(wrappedMessage) || handleAbort(wrappedMessage)) {
    return;
  }
  if (!INCOMING_MESSAGES.has(anyProcess)) {
    INCOMING_MESSAGES.set(anyProcess, []);
  }
  const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
  incomingMessages.push(wrappedMessage);
  if (incomingMessages.length > 1) {
    return;
  }
  while (incomingMessages.length > 0) {
    await waitForOutgoingMessages(anyProcess, ipcEmitter, wrappedMessage);
    await scheduler.yield();
    const message = await handleStrictRequest({
      wrappedMessage: incomingMessages[0],
      anyProcess,
      channel,
      isSubprocess,
      ipcEmitter
    });
    incomingMessages.shift();
    ipcEmitter.emit("message", message);
    ipcEmitter.emit("message:done");
  }
};
var onDisconnect = async ({ anyProcess, channel, isSubprocess, ipcEmitter, boundOnMessage }) => {
  abortOnDisconnect();
  const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
  while (incomingMessages?.length > 0) {
    await once2(ipcEmitter, "message:done");
  }
  anyProcess.removeListener("message", boundOnMessage);
  redoAddedReferences(channel, isSubprocess);
  ipcEmitter.connected = false;
  ipcEmitter.emit("disconnect");
};
var INCOMING_MESSAGES = new WeakMap;

// node_modules/execa/lib/ipc/forward.js
var getIpcEmitter = (anyProcess, channel, isSubprocess) => {
  if (IPC_EMITTERS.has(anyProcess)) {
    return IPC_EMITTERS.get(anyProcess);
  }
  const ipcEmitter = new EventEmitter3;
  ipcEmitter.connected = true;
  IPC_EMITTERS.set(anyProcess, ipcEmitter);
  forwardEvents({
    ipcEmitter,
    anyProcess,
    channel,
    isSubprocess
  });
  return ipcEmitter;
};
var IPC_EMITTERS = new WeakMap;
var forwardEvents = ({ ipcEmitter, anyProcess, channel, isSubprocess }) => {
  const boundOnMessage = onMessage.bind(undefined, {
    anyProcess,
    channel,
    isSubprocess,
    ipcEmitter
  });
  anyProcess.on("message", boundOnMessage);
  anyProcess.once("disconnect", onDisconnect.bind(undefined, {
    anyProcess,
    channel,
    isSubprocess,
    ipcEmitter,
    boundOnMessage
  }));
  undoAddedReferences(channel, isSubprocess);
};
var isConnected = (anyProcess) => {
  const ipcEmitter = IPC_EMITTERS.get(anyProcess);
  return ipcEmitter === undefined ? anyProcess.channel !== null : ipcEmitter.connected;
};

// node_modules/execa/lib/ipc/strict.js
var handleSendStrict = ({ anyProcess, channel, isSubprocess, message, strict }) => {
  if (!strict) {
    return message;
  }
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const hasListeners = hasMessageListeners(anyProcess, ipcEmitter);
  return {
    id: count++,
    type: REQUEST_TYPE,
    message,
    hasListeners
  };
};
var count = 0n;
var validateStrictDeadlock = (outgoingMessages, wrappedMessage) => {
  if (wrappedMessage?.type !== REQUEST_TYPE || wrappedMessage.hasListeners) {
    return;
  }
  for (const { id } of outgoingMessages) {
    if (id !== undefined) {
      STRICT_RESPONSES[id].resolve({ isDeadlock: true, hasListeners: false });
    }
  }
};
var handleStrictRequest = async ({ wrappedMessage, anyProcess, channel, isSubprocess, ipcEmitter }) => {
  if (wrappedMessage?.type !== REQUEST_TYPE || !anyProcess.connected) {
    return wrappedMessage;
  }
  const { id, message } = wrappedMessage;
  const response = { id, type: RESPONSE_TYPE, message: hasMessageListeners(anyProcess, ipcEmitter) };
  try {
    await sendMessage({
      anyProcess,
      channel,
      isSubprocess,
      ipc: true
    }, response);
  } catch (error) {
    ipcEmitter.emit("strict:error", error);
  }
  return message;
};
var handleStrictResponse = (wrappedMessage) => {
  if (wrappedMessage?.type !== RESPONSE_TYPE) {
    return false;
  }
  const { id, message: hasListeners } = wrappedMessage;
  STRICT_RESPONSES[id]?.resolve({ isDeadlock: false, hasListeners });
  return true;
};
var waitForStrictResponse = async (wrappedMessage, anyProcess, isSubprocess) => {
  if (wrappedMessage?.type !== REQUEST_TYPE) {
    return;
  }
  const deferred = createDeferred();
  STRICT_RESPONSES[wrappedMessage.id] = deferred;
  const controller = new AbortController;
  try {
    const { isDeadlock, hasListeners } = await Promise.race([
      deferred,
      throwOnDisconnect(anyProcess, isSubprocess, controller)
    ]);
    if (isDeadlock) {
      throwOnStrictDeadlockError(isSubprocess);
    }
    if (!hasListeners) {
      throwOnMissingStrict(isSubprocess);
    }
  } finally {
    controller.abort();
    delete STRICT_RESPONSES[wrappedMessage.id];
  }
};
var STRICT_RESPONSES = {};
var throwOnDisconnect = async (anyProcess, isSubprocess, { signal }) => {
  incrementMaxListeners(anyProcess, 1, signal);
  await once3(anyProcess, "disconnect", { signal });
  throwOnStrictDisconnect(isSubprocess);
};
var REQUEST_TYPE = "execa:ipc:request";
var RESPONSE_TYPE = "execa:ipc:response";

// node_modules/execa/lib/ipc/outgoing.js
var startSendMessage = (anyProcess, wrappedMessage, strict) => {
  if (!OUTGOING_MESSAGES.has(anyProcess)) {
    OUTGOING_MESSAGES.set(anyProcess, new Set);
  }
  const outgoingMessages = OUTGOING_MESSAGES.get(anyProcess);
  const onMessageSent = createDeferred();
  const id = strict ? wrappedMessage.id : undefined;
  const outgoingMessage = { onMessageSent, id };
  outgoingMessages.add(outgoingMessage);
  return { outgoingMessages, outgoingMessage };
};
var endSendMessage = ({ outgoingMessages, outgoingMessage }) => {
  outgoingMessages.delete(outgoingMessage);
  outgoingMessage.onMessageSent.resolve();
};
var waitForOutgoingMessages = async (anyProcess, ipcEmitter, wrappedMessage) => {
  while (!hasMessageListeners(anyProcess, ipcEmitter) && OUTGOING_MESSAGES.get(anyProcess)?.size > 0) {
    const outgoingMessages = [...OUTGOING_MESSAGES.get(anyProcess)];
    validateStrictDeadlock(outgoingMessages, wrappedMessage);
    await Promise.all(outgoingMessages.map(({ onMessageSent }) => onMessageSent));
  }
};
var OUTGOING_MESSAGES = new WeakMap;
var hasMessageListeners = (anyProcess, ipcEmitter) => ipcEmitter.listenerCount("message") > getMinListenerCount(anyProcess);
var getMinListenerCount = (anyProcess) => SUBPROCESS_OPTIONS.has(anyProcess) && !getFdSpecificValue(SUBPROCESS_OPTIONS.get(anyProcess).options.buffer, "ipc") ? 1 : 0;

// node_modules/execa/lib/ipc/send.js
var sendMessage = ({ anyProcess, channel, isSubprocess, ipc }, message, { strict = false } = {}) => {
  const methodName = "sendMessage";
  validateIpcMethod({
    methodName,
    isSubprocess,
    ipc,
    isConnected: anyProcess.connected
  });
  return sendMessageAsync({
    anyProcess,
    channel,
    methodName,
    isSubprocess,
    message,
    strict
  });
};
var sendMessageAsync = async ({ anyProcess, channel, methodName, isSubprocess, message, strict }) => {
  const wrappedMessage = handleSendStrict({
    anyProcess,
    channel,
    isSubprocess,
    message,
    strict
  });
  const outgoingMessagesState = startSendMessage(anyProcess, wrappedMessage, strict);
  try {
    await sendOneMessage({
      anyProcess,
      methodName,
      isSubprocess,
      wrappedMessage,
      message
    });
  } catch (error) {
    disconnect(anyProcess);
    throw error;
  } finally {
    endSendMessage(outgoingMessagesState);
  }
};
var sendOneMessage = async ({ anyProcess, methodName, isSubprocess, wrappedMessage, message }) => {
  const sendMethod = getSendMethod(anyProcess);
  try {
    await Promise.all([
      waitForStrictResponse(wrappedMessage, anyProcess, isSubprocess),
      sendMethod(wrappedMessage)
    ]);
  } catch (error) {
    handleEpipeError({ error, methodName, isSubprocess });
    handleSerializationError({
      error,
      methodName,
      isSubprocess,
      message
    });
    throw error;
  }
};
var getSendMethod = (anyProcess) => {
  if (PROCESS_SEND_METHODS.has(anyProcess)) {
    return PROCESS_SEND_METHODS.get(anyProcess);
  }
  const sendMethod = promisify2(anyProcess.send.bind(anyProcess));
  PROCESS_SEND_METHODS.set(anyProcess, sendMethod);
  return sendMethod;
};
var PROCESS_SEND_METHODS = new WeakMap;

// node_modules/execa/lib/ipc/graceful.js
var sendAbort = (subprocess, message) => {
  const methodName = "cancelSignal";
  validateConnection(methodName, false, subprocess.connected);
  return sendOneMessage({
    anyProcess: subprocess,
    methodName,
    isSubprocess: false,
    wrappedMessage: { type: GRACEFUL_CANCEL_TYPE, message },
    message
  });
};
var getCancelSignal = async ({ anyProcess, channel, isSubprocess, ipc }) => {
  await startIpc({
    anyProcess,
    channel,
    isSubprocess,
    ipc
  });
  return cancelController.signal;
};
var startIpc = async ({ anyProcess, channel, isSubprocess, ipc }) => {
  if (cancelListening) {
    return;
  }
  cancelListening = true;
  if (!ipc) {
    throwOnMissingParent();
    return;
  }
  if (channel === null) {
    abortOnDisconnect();
    return;
  }
  getIpcEmitter(anyProcess, channel, isSubprocess);
  await scheduler2.yield();
};
var cancelListening = false;
var handleAbort = (wrappedMessage) => {
  if (wrappedMessage?.type !== GRACEFUL_CANCEL_TYPE) {
    return false;
  }
  cancelController.abort(wrappedMessage.message);
  return true;
};
var GRACEFUL_CANCEL_TYPE = "execa:ipc:cancel";
var abortOnDisconnect = () => {
  cancelController.abort(getAbortDisconnectError());
};
var cancelController = new AbortController;

// node_modules/execa/lib/terminate/graceful.js
var validateGracefulCancel = ({ gracefulCancel, cancelSignal, ipc, serialization }) => {
  if (!gracefulCancel) {
    return;
  }
  if (cancelSignal === undefined) {
    throw new Error("The `cancelSignal` option must be defined when setting the `gracefulCancel` option.");
  }
  if (!ipc) {
    throw new Error("The `ipc` option cannot be false when setting the `gracefulCancel` option.");
  }
  if (serialization === "json") {
    throw new Error("The `serialization` option cannot be 'json' when setting the `gracefulCancel` option.");
  }
};
var throwOnGracefulCancel = ({
  subprocess,
  cancelSignal,
  gracefulCancel,
  forceKillAfterDelay,
  context,
  controller
}) => gracefulCancel ? [sendOnAbort({
  subprocess,
  cancelSignal,
  forceKillAfterDelay,
  context,
  controller
})] : [];
var sendOnAbort = async ({ subprocess, cancelSignal, forceKillAfterDelay, context, controller: { signal } }) => {
  await onAbortedSignal(cancelSignal, signal);
  const reason = getReason(cancelSignal);
  await sendAbort(subprocess, reason);
  killOnTimeout({
    kill: subprocess.kill,
    forceKillAfterDelay,
    context,
    controllerSignal: signal
  });
  context.terminationReason ??= "gracefulCancel";
  throw cancelSignal.reason;
};
var getReason = ({ reason }) => {
  if (!(reason instanceof DOMException)) {
    return reason;
  }
  const error = new Error(reason.message);
  Object.defineProperty(error, "stack", {
    value: reason.stack,
    enumerable: false,
    configurable: true,
    writable: true
  });
  return error;
};

// node_modules/execa/lib/terminate/timeout.js
import { setTimeout as setTimeout3 } from "node:timers/promises";
var validateTimeout = ({ timeout }) => {
  if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
    throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
  }
};
var throwOnTimeout = (subprocess, timeout, context, controller) => timeout === 0 || timeout === undefined ? [] : [killAfterTimeout(subprocess, timeout, context, controller)];
var killAfterTimeout = async (subprocess, timeout, context, { signal }) => {
  await setTimeout3(timeout, undefined, { signal });
  context.terminationReason ??= "timeout";
  subprocess.kill();
  throw new DiscardedError;
};

// node_modules/execa/lib/methods/node.js
import { execPath, execArgv } from "node:process";
import path3 from "node:path";
var mapNode = ({ options }) => {
  if (options.node === false) {
    throw new TypeError('The "node" option cannot be false with `execaNode()`.');
  }
  return { options: { ...options, node: true } };
};
var handleNodeOption = (file, commandArguments, {
  node: shouldHandleNode = false,
  nodePath = execPath,
  nodeOptions = execArgv.filter((nodeOption) => !nodeOption.startsWith("--inspect")),
  cwd: cwd2,
  execPath: formerNodePath,
  ...options
}) => {
  if (formerNodePath !== undefined) {
    throw new TypeError('The "execPath" option has been removed. Please use the "nodePath" option instead.');
  }
  const normalizedNodePath = safeNormalizeFileUrl(nodePath, 'The "nodePath" option');
  const resolvedNodePath = path3.resolve(cwd2, normalizedNodePath);
  const newOptions = {
    ...options,
    nodePath: resolvedNodePath,
    node: shouldHandleNode,
    cwd: cwd2
  };
  if (!shouldHandleNode) {
    return [file, commandArguments, newOptions];
  }
  if (path3.basename(file, ".exe") === "node") {
    throw new TypeError('When the "node" option is true, the first argument does not need to be "node".');
  }
  return [
    resolvedNodePath,
    [...nodeOptions, file, ...commandArguments],
    { ipc: true, ...newOptions, shell: false }
  ];
};

// node_modules/execa/lib/ipc/ipc-input.js
import { serialize } from "node:v8";
var validateIpcInputOption = ({ ipcInput, ipc, serialization }) => {
  if (ipcInput === undefined) {
    return;
  }
  if (!ipc) {
    throw new Error("The `ipcInput` option cannot be set unless the `ipc` option is `true`.");
  }
  validateIpcInput[serialization](ipcInput);
};
var validateAdvancedInput = (ipcInput) => {
  try {
    serialize(ipcInput);
  } catch (error) {
    throw new Error("The `ipcInput` option is not serializable with a structured clone.", { cause: error });
  }
};
var validateJsonInput = (ipcInput) => {
  try {
    JSON.stringify(ipcInput);
  } catch (error) {
    throw new Error("The `ipcInput` option is not serializable with JSON.", { cause: error });
  }
};
var validateIpcInput = {
  advanced: validateAdvancedInput,
  json: validateJsonInput
};
var sendIpcInput = async (subprocess, ipcInput) => {
  if (ipcInput === undefined) {
    return;
  }
  await subprocess.sendMessage(ipcInput);
};

// node_modules/execa/lib/arguments/encoding-option.js
var validateEncoding = ({ encoding }) => {
  if (ENCODINGS.has(encoding)) {
    return;
  }
  const correctEncoding = getCorrectEncoding(encoding);
  if (correctEncoding !== undefined) {
    throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to ${serializeEncoding(correctEncoding)}.`);
  }
  const correctEncodings = [...ENCODINGS].map((correctEncoding2) => serializeEncoding(correctEncoding2)).join(", ");
  throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to one of: ${correctEncodings}.`);
};
var TEXT_ENCODINGS = new Set(["utf8", "utf16le"]);
var BINARY_ENCODINGS = new Set(["buffer", "hex", "base64", "base64url", "latin1", "ascii"]);
var ENCODINGS = new Set([...TEXT_ENCODINGS, ...BINARY_ENCODINGS]);
var getCorrectEncoding = (encoding) => {
  if (encoding === null) {
    return "buffer";
  }
  if (typeof encoding !== "string") {
    return;
  }
  const lowerEncoding = encoding.toLowerCase();
  if (lowerEncoding in ENCODING_ALIASES) {
    return ENCODING_ALIASES[lowerEncoding];
  }
  if (ENCODINGS.has(lowerEncoding)) {
    return lowerEncoding;
  }
};
var ENCODING_ALIASES = {
  "utf-8": "utf8",
  "utf-16le": "utf16le",
  "ucs-2": "utf16le",
  ucs2: "utf16le",
  binary: "latin1"
};
var serializeEncoding = (encoding) => typeof encoding === "string" ? `"${encoding}"` : String(encoding);

// node_modules/execa/lib/arguments/cwd.js
import { statSync } from "node:fs";
import path4 from "node:path";
import process18 from "node:process";
var normalizeCwd = (cwd2 = getDefaultCwd()) => {
  const cwdString = safeNormalizeFileUrl(cwd2, 'The "cwd" option');
  return path4.resolve(cwdString);
};
var getDefaultCwd = () => {
  try {
    return process18.cwd();
  } catch (error) {
    error.message = `The current directory does not exist.
${error.message}`;
    throw error;
  }
};
var fixCwdError = (originalMessage, cwd2) => {
  if (cwd2 === getDefaultCwd()) {
    return originalMessage;
  }
  let cwdStat;
  try {
    cwdStat = statSync(cwd2);
  } catch (error) {
    return `The "cwd" option is invalid: ${cwd2}.
${error.message}
${originalMessage}`;
  }
  if (!cwdStat.isDirectory()) {
    return `The "cwd" option is not a directory: ${cwd2}.
${originalMessage}`;
  }
  return originalMessage;
};

// node_modules/execa/lib/arguments/options.js
var normalizeOptions = (filePath, rawArguments, rawOptions) => {
  rawOptions.cwd = normalizeCwd(rawOptions.cwd);
  const [processedFile, processedArguments, processedOptions] = handleNodeOption(filePath, rawArguments, rawOptions);
  const { command: file, args: commandArguments, options: initialOptions } = import_cross_spawn.default._parse(processedFile, processedArguments, processedOptions);
  const fdOptions = normalizeFdSpecificOptions(initialOptions);
  const options = addDefaultOptions(fdOptions);
  validateTimeout(options);
  validateEncoding(options);
  validateIpcInputOption(options);
  validateCancelSignal(options);
  validateGracefulCancel(options);
  options.shell = normalizeFileUrl(options.shell);
  options.env = getEnv(options);
  options.killSignal = normalizeKillSignal(options.killSignal);
  options.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);
  options.lines = options.lines.map((lines, fdNumber) => lines && !BINARY_ENCODINGS.has(options.encoding) && options.buffer[fdNumber]);
  if (process19.platform === "win32" && path5.basename(file, ".exe") === "cmd") {
    commandArguments.unshift("/q");
  }
  return { file, commandArguments, options };
};
var addDefaultOptions = ({
  extendEnv = true,
  preferLocal = false,
  cwd: cwd2,
  localDir: localDirectory = cwd2,
  encoding = "utf8",
  reject: reject2 = true,
  cleanup = true,
  all = false,
  windowsHide = true,
  killSignal = "SIGTERM",
  forceKillAfterDelay = true,
  gracefulCancel = false,
  ipcInput,
  ipc = ipcInput !== undefined || gracefulCancel,
  serialization = "advanced",
  ...options
}) => ({
  ...options,
  extendEnv,
  preferLocal,
  cwd: cwd2,
  localDirectory,
  encoding,
  reject: reject2,
  cleanup,
  all,
  windowsHide,
  killSignal,
  forceKillAfterDelay,
  gracefulCancel,
  ipcInput,
  ipc,
  serialization
});
var getEnv = ({ env: envOption, extendEnv, preferLocal, node, localDirectory, nodePath }) => {
  const env3 = extendEnv ? { ...process19.env, ...envOption } : envOption;
  if (preferLocal || node) {
    return npmRunPathEnv({
      env: env3,
      cwd: localDirectory,
      execPath: nodePath,
      preferLocal,
      addExecPath: node
    });
  }
  return env3;
};

// node_modules/execa/lib/arguments/shell.js
var concatenateShell = (file, commandArguments, options) => options.shell && commandArguments.length > 0 ? [[file, ...commandArguments].join(" "), [], options] : [file, commandArguments, options];

// node_modules/execa/lib/return/message.js
import { inspect as inspect2 } from "node:util";

// node_modules/strip-final-newline/index.js
function stripFinalNewline(input) {
  if (typeof input === "string") {
    return stripFinalNewlineString(input);
  }
  if (!(ArrayBuffer.isView(input) && input.BYTES_PER_ELEMENT === 1)) {
    throw new Error("Input must be a string or a Uint8Array");
  }
  return stripFinalNewlineBinary(input);
}
var stripFinalNewlineString = (input) => input.at(-1) === LF ? input.slice(0, input.at(-2) === CR ? -2 : -1) : input;
var stripFinalNewlineBinary = (input) => input.at(-1) === LF_BINARY ? input.subarray(0, input.at(-2) === CR_BINARY ? -2 : -1) : input;
var LF = `
`;
var LF_BINARY = LF.codePointAt(0);
var CR = "\r";
var CR_BINARY = CR.codePointAt(0);

// node_modules/get-stream/source/index.js
import { on } from "node:events";
import { finished } from "node:stream/promises";

// node_modules/is-stream/index.js
function isStream(stream2, { checkOpen = true } = {}) {
  return stream2 !== null && typeof stream2 === "object" && (stream2.writable || stream2.readable || !checkOpen || stream2.writable === undefined && stream2.readable === undefined) && typeof stream2.pipe === "function";
}
function isWritableStream(stream2, { checkOpen = true } = {}) {
  return isStream(stream2, { checkOpen }) && (stream2.writable || !checkOpen) && typeof stream2.write === "function" && typeof stream2.end === "function" && typeof stream2.writable === "boolean" && typeof stream2.writableObjectMode === "boolean" && typeof stream2.destroy === "function" && typeof stream2.destroyed === "boolean";
}
function isReadableStream(stream2, { checkOpen = true } = {}) {
  return isStream(stream2, { checkOpen }) && (stream2.readable || !checkOpen) && typeof stream2.read === "function" && typeof stream2.readable === "boolean" && typeof stream2.readableObjectMode === "boolean" && typeof stream2.destroy === "function" && typeof stream2.destroyed === "boolean";
}
function isDuplexStream(stream2, options) {
  return isWritableStream(stream2, options) && isReadableStream(stream2, options);
}

// node_modules/@sec-ant/readable-stream/dist/ponyfill/asyncIterator.js
var a = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {}).prototype);

class c {
  #t;
  #n;
  #r = false;
  #e = undefined;
  constructor(e, t) {
    this.#t = e, this.#n = t;
  }
  next() {
    const e = () => this.#s();
    return this.#e = this.#e ? this.#e.then(e, e) : e(), this.#e;
  }
  return(e) {
    const t = () => this.#i(e);
    return this.#e ? this.#e.then(t, t) : t();
  }
  async#s() {
    if (this.#r)
      return {
        done: true,
        value: undefined
      };
    let e;
    try {
      e = await this.#t.read();
    } catch (t) {
      throw this.#e = undefined, this.#r = true, this.#t.releaseLock(), t;
    }
    return e.done && (this.#e = undefined, this.#r = true, this.#t.releaseLock()), e;
  }
  async#i(e) {
    if (this.#r)
      return {
        done: true,
        value: e
      };
    if (this.#r = true, !this.#n) {
      const t = this.#t.cancel(e);
      return this.#t.releaseLock(), await t, {
        done: true,
        value: e
      };
    }
    return this.#t.releaseLock(), {
      done: true,
      value: e
    };
  }
}
var n = Symbol();
function i() {
  return this[n].next();
}
Object.defineProperty(i, "name", { value: "next" });
function o(r) {
  return this[n].return(r);
}
Object.defineProperty(o, "name", { value: "return" });
var u = Object.create(a, {
  next: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: i
  },
  return: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: o
  }
});
function h({ preventCancel: r = false } = {}) {
  const e = this.getReader(), t = new c(e, r), s = Object.create(u);
  return s[n] = t, s;
}

// node_modules/get-stream/source/stream.js
var getAsyncIterable = (stream2) => {
  if (isReadableStream(stream2, { checkOpen: false }) && nodeImports.on !== undefined) {
    return getStreamIterable(stream2);
  }
  if (typeof stream2?.[Symbol.asyncIterator] === "function") {
    return stream2;
  }
  if (toString.call(stream2) === "[object ReadableStream]") {
    return h.call(stream2);
  }
  throw new TypeError("The first argument must be a Readable, a ReadableStream, or an async iterable.");
};
var { toString } = Object.prototype;
var getStreamIterable = async function* (stream2) {
  const controller = new AbortController;
  const state = {};
  handleStreamEnd(stream2, controller, state);
  try {
    for await (const [chunk] of nodeImports.on(stream2, "data", { signal: controller.signal })) {
      yield chunk;
    }
  } catch (error) {
    if (state.error !== undefined) {
      throw state.error;
    } else if (!controller.signal.aborted) {
      throw error;
    }
  } finally {
    stream2.destroy();
  }
};
var handleStreamEnd = async (stream2, controller, state) => {
  try {
    await nodeImports.finished(stream2, {
      cleanup: true,
      readable: true,
      writable: false,
      error: false
    });
  } catch (error) {
    state.error = error;
  } finally {
    controller.abort();
  }
};
var nodeImports = {};

// node_modules/get-stream/source/contents.js
var getStreamContents = async (stream2, { init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize }, { maxBuffer = Number.POSITIVE_INFINITY } = {}) => {
  const asyncIterable = getAsyncIterable(stream2);
  const state = init();
  state.length = 0;
  try {
    for await (const chunk of asyncIterable) {
      const chunkType = getChunkType(chunk);
      const convertedChunk = convertChunk[chunkType](chunk, state);
      appendChunk({
        convertedChunk,
        state,
        getSize,
        truncateChunk,
        addChunk,
        maxBuffer
      });
    }
    appendFinalChunk({
      state,
      convertChunk,
      getSize,
      truncateChunk,
      addChunk,
      getFinalChunk,
      maxBuffer
    });
    return finalize(state);
  } catch (error) {
    const normalizedError = typeof error === "object" && error !== null ? error : new Error(error);
    normalizedError.bufferedData = finalize(state);
    throw normalizedError;
  }
};
var appendFinalChunk = ({ state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer }) => {
  const convertedChunk = getFinalChunk(state);
  if (convertedChunk !== undefined) {
    appendChunk({
      convertedChunk,
      state,
      getSize,
      truncateChunk,
      addChunk,
      maxBuffer
    });
  }
};
var appendChunk = ({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer }) => {
  const chunkSize = getSize(convertedChunk);
  const newLength = state.length + chunkSize;
  if (newLength <= maxBuffer) {
    addNewChunk(convertedChunk, state, addChunk, newLength);
    return;
  }
  const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);
  if (truncatedChunk !== undefined) {
    addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
  }
  throw new MaxBufferError;
};
var addNewChunk = (convertedChunk, state, addChunk, newLength) => {
  state.contents = addChunk(convertedChunk, state, newLength);
  state.length = newLength;
};
var getChunkType = (chunk) => {
  const typeOfChunk = typeof chunk;
  if (typeOfChunk === "string") {
    return "string";
  }
  if (typeOfChunk !== "object" || chunk === null) {
    return "others";
  }
  if (globalThis.Buffer?.isBuffer(chunk)) {
    return "buffer";
  }
  const prototypeName = objectToString2.call(chunk);
  if (prototypeName === "[object ArrayBuffer]") {
    return "arrayBuffer";
  }
  if (prototypeName === "[object DataView]") {
    return "dataView";
  }
  if (Number.isInteger(chunk.byteLength) && Number.isInteger(chunk.byteOffset) && objectToString2.call(chunk.buffer) === "[object ArrayBuffer]") {
    return "typedArray";
  }
  return "others";
};
var { toString: objectToString2 } = Object.prototype;

class MaxBufferError extends Error {
  name = "MaxBufferError";
  constructor() {
    super("maxBuffer exceeded");
  }
}

// node_modules/get-stream/source/utils.js
var identity2 = (value) => value;
var noop2 = () => {
  return;
};
var getContentsProperty = ({ contents }) => contents;
var throwObjectStream = (chunk) => {
  throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
};
var getLengthProperty = (convertedChunk) => convertedChunk.length;

// node_modules/get-stream/source/array.js
async function getStreamAsArray(stream2, options) {
  return getStreamContents(stream2, arrayMethods, options);
}
var initArray = () => ({ contents: [] });
var increment = () => 1;
var addArrayChunk = (convertedChunk, { contents }) => {
  contents.push(convertedChunk);
  return contents;
};
var arrayMethods = {
  init: initArray,
  convertChunk: {
    string: identity2,
    buffer: identity2,
    arrayBuffer: identity2,
    dataView: identity2,
    typedArray: identity2,
    others: identity2
  },
  getSize: increment,
  truncateChunk: noop2,
  addChunk: addArrayChunk,
  getFinalChunk: noop2,
  finalize: getContentsProperty
};
// node_modules/get-stream/source/array-buffer.js
async function getStreamAsArrayBuffer(stream2, options) {
  return getStreamContents(stream2, arrayBufferMethods, options);
}
var initArrayBuffer = () => ({ contents: new ArrayBuffer(0) });
var useTextEncoder = (chunk) => textEncoder2.encode(chunk);
var textEncoder2 = new TextEncoder;
var useUint8Array = (chunk) => new Uint8Array(chunk);
var useUint8ArrayWithOffset = (chunk) => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
var truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
var addArrayBufferChunk = (convertedChunk, { contents, length: previousLength }, length) => {
  const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
  new Uint8Array(newContents).set(convertedChunk, previousLength);
  return newContents;
};
var resizeArrayBufferSlow = (contents, length) => {
  if (length <= contents.byteLength) {
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
};
var resizeArrayBuffer = (contents, length) => {
  if (length <= contents.maxByteLength) {
    contents.resize(length);
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(length, { maxByteLength: getNewContentsLength(length) });
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
};
var getNewContentsLength = (length) => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));
var SCALE_FACTOR = 2;
var finalizeArrayBuffer = ({ contents, length }) => hasArrayBufferResize() ? contents : contents.slice(0, length);
var hasArrayBufferResize = () => ("resize" in ArrayBuffer.prototype);
var arrayBufferMethods = {
  init: initArrayBuffer,
  convertChunk: {
    string: useTextEncoder,
    buffer: useUint8Array,
    arrayBuffer: useUint8Array,
    dataView: useUint8ArrayWithOffset,
    typedArray: useUint8ArrayWithOffset,
    others: throwObjectStream
  },
  getSize: getLengthProperty,
  truncateChunk: truncateArrayBufferChunk,
  addChunk: addArrayBufferChunk,
  getFinalChunk: noop2,
  finalize: finalizeArrayBuffer
};
// node_modules/get-stream/source/string.js
async function getStreamAsString(stream2, options) {
  return getStreamContents(stream2, stringMethods, options);
}
var initString = () => ({ contents: "", textDecoder: new TextDecoder });
var useTextDecoder = (chunk, { textDecoder: textDecoder2 }) => textDecoder2.decode(chunk, { stream: true });
var addStringChunk = (convertedChunk, { contents }) => contents + convertedChunk;
var truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
var getFinalStringChunk = ({ textDecoder: textDecoder2 }) => {
  const finalChunk = textDecoder2.decode();
  return finalChunk === "" ? undefined : finalChunk;
};
var stringMethods = {
  init: initString,
  convertChunk: {
    string: identity2,
    buffer: useTextDecoder,
    arrayBuffer: useTextDecoder,
    dataView: useTextDecoder,
    typedArray: useTextDecoder,
    others: throwObjectStream
  },
  getSize: getLengthProperty,
  truncateChunk: truncateStringChunk,
  addChunk: addStringChunk,
  getFinalChunk: getFinalStringChunk,
  finalize: getContentsProperty
};
// node_modules/get-stream/source/index.js
Object.assign(nodeImports, { on, finished });

// node_modules/execa/lib/io/max-buffer.js
var handleMaxBuffer = ({ error, stream: stream2, readableObjectMode, lines, encoding, fdNumber }) => {
  if (!(error instanceof MaxBufferError)) {
    throw error;
  }
  if (fdNumber === "all") {
    return error;
  }
  const unit = getMaxBufferUnit(readableObjectMode, lines, encoding);
  error.maxBufferInfo = { fdNumber, unit };
  stream2.destroy();
  throw error;
};
var getMaxBufferUnit = (readableObjectMode, lines, encoding) => {
  if (readableObjectMode) {
    return "objects";
  }
  if (lines) {
    return "lines";
  }
  if (encoding === "buffer") {
    return "bytes";
  }
  return "characters";
};
var checkIpcMaxBuffer = (subprocess, ipcOutput, maxBuffer) => {
  if (ipcOutput.length !== maxBuffer) {
    return;
  }
  const error = new MaxBufferError;
  error.maxBufferInfo = { fdNumber: "ipc" };
  throw error;
};
var getMaxBufferMessage = (error, maxBuffer) => {
  const { streamName, threshold, unit } = getMaxBufferInfo(error, maxBuffer);
  return `Command's ${streamName} was larger than ${threshold} ${unit}`;
};
var getMaxBufferInfo = (error, maxBuffer) => {
  if (error?.maxBufferInfo === undefined) {
    return { streamName: "output", threshold: maxBuffer[1], unit: "bytes" };
  }
  const { maxBufferInfo: { fdNumber, unit } } = error;
  delete error.maxBufferInfo;
  const threshold = getFdSpecificValue(maxBuffer, fdNumber);
  if (fdNumber === "ipc") {
    return { streamName: "IPC output", threshold, unit: "messages" };
  }
  return { streamName: getStreamName(fdNumber), threshold, unit };
};
var isMaxBufferSync = (resultError, output, maxBuffer) => resultError?.code === "ENOBUFS" && output !== null && output.some((result) => result !== null && result.length > getMaxBufferSync(maxBuffer));
var truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer) => {
  if (!isMaxBuffer) {
    return result;
  }
  const maxBufferValue = getMaxBufferSync(maxBuffer);
  return result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;
};
var getMaxBufferSync = ([, stdoutMaxBuffer]) => stdoutMaxBuffer;

// node_modules/execa/lib/return/message.js
var createMessages = ({
  stdio,
  all,
  ipcOutput,
  originalError,
  signal,
  signalDescription,
  exitCode,
  escapedCommand,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  forceKillAfterDelay,
  killSignal,
  maxBuffer,
  timeout,
  cwd: cwd2
}) => {
  const errorCode = originalError?.code;
  const prefix = getErrorPrefix({
    originalError,
    timedOut,
    timeout,
    isMaxBuffer,
    maxBuffer,
    errorCode,
    signal,
    signalDescription,
    exitCode,
    isCanceled,
    isGracefullyCanceled,
    isForcefullyTerminated,
    forceKillAfterDelay,
    killSignal
  });
  const originalMessage = getOriginalMessage(originalError, cwd2);
  const suffix = originalMessage === undefined ? "" : `
${originalMessage}`;
  const shortMessage = `${prefix}: ${escapedCommand}${suffix}`;
  const messageStdio = all === undefined ? [stdio[2], stdio[1]] : [all];
  const message = [
    shortMessage,
    ...messageStdio,
    ...stdio.slice(3),
    ipcOutput.map((ipcMessage) => serializeIpcMessage(ipcMessage)).join(`
`)
  ].map((messagePart) => escapeLines(stripFinalNewline(serializeMessagePart(messagePart)))).filter(Boolean).join(`

`);
  return { originalMessage, shortMessage, message };
};
var getErrorPrefix = ({
  originalError,
  timedOut,
  timeout,
  isMaxBuffer,
  maxBuffer,
  errorCode,
  signal,
  signalDescription,
  exitCode,
  isCanceled,
  isGracefullyCanceled,
  isForcefullyTerminated,
  forceKillAfterDelay,
  killSignal
}) => {
  const forcefulSuffix = getForcefulSuffix(isForcefullyTerminated, forceKillAfterDelay);
  if (timedOut) {
    return `Command timed out after ${timeout} milliseconds${forcefulSuffix}`;
  }
  if (isGracefullyCanceled) {
    if (signal === undefined) {
      return `Command was gracefully canceled with exit code ${exitCode}`;
    }
    return isForcefullyTerminated ? `Command was gracefully canceled${forcefulSuffix}` : `Command was gracefully canceled with ${signal} (${signalDescription})`;
  }
  if (isCanceled) {
    return `Command was canceled${forcefulSuffix}`;
  }
  if (isMaxBuffer) {
    return `${getMaxBufferMessage(originalError, maxBuffer)}${forcefulSuffix}`;
  }
  if (errorCode !== undefined) {
    return `Command failed with ${errorCode}${forcefulSuffix}`;
  }
  if (isForcefullyTerminated) {
    return `Command was killed with ${killSignal} (${getSignalDescription(killSignal)})${forcefulSuffix}`;
  }
  if (signal !== undefined) {
    return `Command was killed with ${signal} (${signalDescription})`;
  }
  if (exitCode !== undefined) {
    return `Command failed with exit code ${exitCode}`;
  }
  return "Command failed";
};
var getForcefulSuffix = (isForcefullyTerminated, forceKillAfterDelay) => isForcefullyTerminated ? ` and was forcefully terminated after ${forceKillAfterDelay} milliseconds` : "";
var getOriginalMessage = (originalError, cwd2) => {
  if (originalError instanceof DiscardedError) {
    return;
  }
  const originalMessage = isExecaError(originalError) ? originalError.originalMessage : String(originalError?.message ?? originalError);
  const escapedOriginalMessage = escapeLines(fixCwdError(originalMessage, cwd2));
  return escapedOriginalMessage === "" ? undefined : escapedOriginalMessage;
};
var serializeIpcMessage = (ipcMessage) => typeof ipcMessage === "string" ? ipcMessage : inspect2(ipcMessage);
var serializeMessagePart = (messagePart) => Array.isArray(messagePart) ? messagePart.map((messageItem) => stripFinalNewline(serializeMessageItem(messageItem))).filter(Boolean).join(`
`) : serializeMessageItem(messagePart);
var serializeMessageItem = (messageItem) => {
  if (typeof messageItem === "string") {
    return messageItem;
  }
  if (isUint8Array(messageItem)) {
    return uint8ArrayToString(messageItem);
  }
  return "";
};

// node_modules/execa/lib/return/result.js
var makeSuccessResult = ({
  command,
  escapedCommand,
  stdio,
  all,
  ipcOutput,
  options: { cwd: cwd2 },
  startTime
}) => omitUndefinedProperties({
  command,
  escapedCommand,
  cwd: cwd2,
  durationMs: getDurationMs(startTime),
  failed: false,
  timedOut: false,
  isCanceled: false,
  isGracefullyCanceled: false,
  isTerminated: false,
  isMaxBuffer: false,
  isForcefullyTerminated: false,
  exitCode: 0,
  stdout: stdio[1],
  stderr: stdio[2],
  all,
  stdio,
  ipcOutput,
  pipedFrom: []
});
var makeEarlyError = ({
  error,
  command,
  escapedCommand,
  fileDescriptors,
  options,
  startTime,
  isSync
}) => makeError({
  error,
  command,
  escapedCommand,
  startTime,
  timedOut: false,
  isCanceled: false,
  isGracefullyCanceled: false,
  isMaxBuffer: false,
  isForcefullyTerminated: false,
  stdio: Array.from({ length: fileDescriptors.length }),
  ipcOutput: [],
  options,
  isSync
});
var makeError = ({
  error: originalError,
  command,
  escapedCommand,
  startTime,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode: rawExitCode,
  signal: rawSignal,
  stdio,
  all,
  ipcOutput,
  options: {
    timeoutDuration,
    timeout = timeoutDuration,
    forceKillAfterDelay,
    killSignal,
    cwd: cwd2,
    maxBuffer
  },
  isSync
}) => {
  const { exitCode, signal, signalDescription } = normalizeExitPayload(rawExitCode, rawSignal);
  const { originalMessage, shortMessage, message } = createMessages({
    stdio,
    all,
    ipcOutput,
    originalError,
    signal,
    signalDescription,
    exitCode,
    escapedCommand,
    timedOut,
    isCanceled,
    isGracefullyCanceled,
    isMaxBuffer,
    isForcefullyTerminated,
    forceKillAfterDelay,
    killSignal,
    maxBuffer,
    timeout,
    cwd: cwd2
  });
  const error = getFinalError(originalError, message, isSync);
  Object.assign(error, getErrorProperties({
    error,
    command,
    escapedCommand,
    startTime,
    timedOut,
    isCanceled,
    isGracefullyCanceled,
    isMaxBuffer,
    isForcefullyTerminated,
    exitCode,
    signal,
    signalDescription,
    stdio,
    all,
    ipcOutput,
    cwd: cwd2,
    originalMessage,
    shortMessage
  }));
  return error;
};
var getErrorProperties = ({
  error,
  command,
  escapedCommand,
  startTime,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode,
  signal,
  signalDescription,
  stdio,
  all,
  ipcOutput,
  cwd: cwd2,
  originalMessage,
  shortMessage
}) => omitUndefinedProperties({
  shortMessage,
  originalMessage,
  command,
  escapedCommand,
  cwd: cwd2,
  durationMs: getDurationMs(startTime),
  failed: true,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isTerminated: signal !== undefined,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode,
  signal,
  signalDescription,
  code: error.cause?.code,
  stdout: stdio[1],
  stderr: stdio[2],
  all,
  stdio,
  ipcOutput,
  pipedFrom: []
});
var omitUndefinedProperties = (result) => Object.fromEntries(Object.entries(result).filter(([, value]) => value !== undefined));
var normalizeExitPayload = (rawExitCode, rawSignal) => {
  const exitCode = rawExitCode === null ? undefined : rawExitCode;
  const signal = rawSignal === null ? undefined : rawSignal;
  const signalDescription = signal === undefined ? undefined : getSignalDescription(rawSignal);
  return { exitCode, signal, signalDescription };
};

// node_modules/parse-ms/index.js
var toZeroIfInfinity = (value) => Number.isFinite(value) ? value : 0;
function parseNumber(milliseconds) {
  return {
    days: Math.trunc(milliseconds / 86400000),
    hours: Math.trunc(milliseconds / 3600000 % 24),
    minutes: Math.trunc(milliseconds / 60000 % 60),
    seconds: Math.trunc(milliseconds / 1000 % 60),
    milliseconds: Math.trunc(milliseconds % 1000),
    microseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1000) % 1000),
    nanoseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e6) % 1000)
  };
}
function parseBigint(milliseconds) {
  return {
    days: milliseconds / 86400000n,
    hours: milliseconds / 3600000n % 24n,
    minutes: milliseconds / 60000n % 60n,
    seconds: milliseconds / 1000n % 60n,
    milliseconds: milliseconds % 1000n,
    microseconds: 0n,
    nanoseconds: 0n
  };
}
function parseMilliseconds(milliseconds) {
  switch (typeof milliseconds) {
    case "number": {
      if (Number.isFinite(milliseconds)) {
        return parseNumber(milliseconds);
      }
      break;
    }
    case "bigint": {
      return parseBigint(milliseconds);
    }
  }
  throw new TypeError("Expected a finite number or bigint");
}

// node_modules/pretty-ms/index.js
var isZero = (value) => value === 0 || value === 0n;
var pluralize = (word, count2) => count2 === 1 || count2 === 1n ? word : `${word}s`;
var SECOND_ROUNDING_EPSILON = 0.0000001;
var ONE_DAY_IN_MILLISECONDS = 24n * 60n * 60n * 1000n;
function prettyMilliseconds(milliseconds, options) {
  const isBigInt = typeof milliseconds === "bigint";
  if (!isBigInt && !Number.isFinite(milliseconds)) {
    throw new TypeError("Expected a finite number or bigint");
  }
  options = { ...options };
  const sign = milliseconds < 0 ? "-" : "";
  milliseconds = milliseconds < 0 ? -milliseconds : milliseconds;
  if (options.colonNotation) {
    options.compact = false;
    options.formatSubMilliseconds = false;
    options.separateMilliseconds = false;
    options.verbose = false;
  }
  if (options.compact) {
    options.unitCount = 1;
    options.secondsDecimalDigits = 0;
    options.millisecondsDecimalDigits = 0;
  }
  let result = [];
  const floorDecimals = (value, decimalDigits) => {
    const flooredInterimValue = Math.floor(value * 10 ** decimalDigits + SECOND_ROUNDING_EPSILON);
    const flooredValue = Math.round(flooredInterimValue) / 10 ** decimalDigits;
    return flooredValue.toFixed(decimalDigits);
  };
  const add = (value, long, short, valueString) => {
    if ((result.length === 0 || !options.colonNotation) && isZero(value) && !(options.colonNotation && short === "m")) {
      return;
    }
    valueString ??= String(value);
    if (options.colonNotation) {
      const wholeDigits = valueString.includes(".") ? valueString.split(".")[0].length : valueString.length;
      const minLength = result.length > 0 ? 2 : 1;
      valueString = "0".repeat(Math.max(0, minLength - wholeDigits)) + valueString;
    } else {
      valueString += options.verbose ? " " + pluralize(long, value) : short;
    }
    result.push(valueString);
  };
  const parsed = parseMilliseconds(milliseconds);
  const days = BigInt(parsed.days);
  if (options.hideYearAndDays) {
    add(BigInt(days) * 24n + BigInt(parsed.hours), "hour", "h");
  } else {
    if (options.hideYear) {
      add(days, "day", "d");
    } else {
      add(days / 365n, "year", "y");
      add(days % 365n, "day", "d");
    }
    add(Number(parsed.hours), "hour", "h");
  }
  add(Number(parsed.minutes), "minute", "m");
  if (!options.hideSeconds) {
    if (options.separateMilliseconds || options.formatSubMilliseconds || !options.colonNotation && milliseconds < 1000 && !options.subSecondsAsDecimals) {
      const seconds = Number(parsed.seconds);
      const milliseconds2 = Number(parsed.milliseconds);
      const microseconds = Number(parsed.microseconds);
      const nanoseconds = Number(parsed.nanoseconds);
      add(seconds, "second", "s");
      if (options.formatSubMilliseconds) {
        add(milliseconds2, "millisecond", "ms");
        add(microseconds, "microsecond", "s");
        add(nanoseconds, "nanosecond", "ns");
      } else {
        const millisecondsAndBelow = milliseconds2 + microseconds / 1000 + nanoseconds / 1e6;
        const millisecondsDecimalDigits = typeof options.millisecondsDecimalDigits === "number" ? options.millisecondsDecimalDigits : 0;
        const roundedMilliseconds = millisecondsAndBelow >= 1 ? Math.round(millisecondsAndBelow) : Math.ceil(millisecondsAndBelow);
        const millisecondsString = millisecondsDecimalDigits ? millisecondsAndBelow.toFixed(millisecondsDecimalDigits) : roundedMilliseconds;
        add(Number.parseFloat(millisecondsString), "millisecond", "ms", millisecondsString);
      }
    } else {
      const seconds = (isBigInt ? Number(milliseconds % ONE_DAY_IN_MILLISECONDS) : milliseconds) / 1000 % 60;
      const secondsDecimalDigits = typeof options.secondsDecimalDigits === "number" ? options.secondsDecimalDigits : 1;
      const secondsFixed = floorDecimals(seconds, secondsDecimalDigits);
      const secondsString = options.keepDecimalsOnWholeSeconds ? secondsFixed : secondsFixed.replace(/\.0+$/, "");
      add(Number.parseFloat(secondsString), "second", "s", secondsString);
    }
  }
  if (result.length === 0) {
    return sign + "0" + (options.verbose ? " milliseconds" : "ms");
  }
  const separator = options.colonNotation ? ":" : " ";
  if (typeof options.unitCount === "number") {
    result = result.slice(0, Math.max(options.unitCount, 1));
  }
  return sign + result.join(separator);
}

// node_modules/execa/lib/verbose/error.js
var logError = (result, verboseInfo) => {
  if (result.failed) {
    verboseLog({
      type: "error",
      verboseMessage: result.shortMessage,
      verboseInfo,
      result
    });
  }
};

// node_modules/execa/lib/verbose/complete.js
var logResult = (result, verboseInfo) => {
  if (!isVerbose(verboseInfo)) {
    return;
  }
  logError(result, verboseInfo);
  logDuration(result, verboseInfo);
};
var logDuration = (result, verboseInfo) => {
  const verboseMessage = `(done in ${prettyMilliseconds(result.durationMs)})`;
  verboseLog({
    type: "duration",
    verboseMessage,
    verboseInfo,
    result
  });
};

// node_modules/execa/lib/return/reject.js
var handleResult = (result, verboseInfo, { reject: reject2 }) => {
  logResult(result, verboseInfo);
  if (result.failed && reject2) {
    throw result;
  }
  return result;
};

// node_modules/execa/lib/stdio/handle-sync.js
import { readFileSync as readFileSync3 } from "node:fs";

// node_modules/execa/lib/stdio/type.js
var getStdioItemType = (value, optionName) => {
  if (isAsyncGenerator(value)) {
    return "asyncGenerator";
  }
  if (isSyncGenerator(value)) {
    return "generator";
  }
  if (isUrl(value)) {
    return "fileUrl";
  }
  if (isFilePathObject(value)) {
    return "filePath";
  }
  if (isWebStream(value)) {
    return "webStream";
  }
  if (isStream(value, { checkOpen: false })) {
    return "native";
  }
  if (isUint8Array(value)) {
    return "uint8Array";
  }
  if (isAsyncIterableObject(value)) {
    return "asyncIterable";
  }
  if (isIterableObject(value)) {
    return "iterable";
  }
  if (isTransformStream(value)) {
    return getTransformStreamType({ transform: value }, optionName);
  }
  if (isTransformOptions(value)) {
    return getTransformObjectType(value, optionName);
  }
  return "native";
};
var getTransformObjectType = (value, optionName) => {
  if (isDuplexStream(value.transform, { checkOpen: false })) {
    return getDuplexType(value, optionName);
  }
  if (isTransformStream(value.transform)) {
    return getTransformStreamType(value, optionName);
  }
  return getGeneratorObjectType(value, optionName);
};
var getDuplexType = (value, optionName) => {
  validateNonGeneratorType(value, optionName, "Duplex stream");
  return "duplex";
};
var getTransformStreamType = (value, optionName) => {
  validateNonGeneratorType(value, optionName, "web TransformStream");
  return "webTransform";
};
var validateNonGeneratorType = ({ final, binary, objectMode }, optionName, typeName) => {
  checkUndefinedOption(final, `${optionName}.final`, typeName);
  checkUndefinedOption(binary, `${optionName}.binary`, typeName);
  checkBooleanOption(objectMode, `${optionName}.objectMode`);
};
var checkUndefinedOption = (value, optionName, typeName) => {
  if (value !== undefined) {
    throw new TypeError(`The \`${optionName}\` option can only be defined when using a generator, not a ${typeName}.`);
  }
};
var getGeneratorObjectType = ({ transform, final, binary, objectMode }, optionName) => {
  if (transform !== undefined && !isGenerator(transform)) {
    throw new TypeError(`The \`${optionName}.transform\` option must be a generator, a Duplex stream or a web TransformStream.`);
  }
  if (isDuplexStream(final, { checkOpen: false })) {
    throw new TypeError(`The \`${optionName}.final\` option must not be a Duplex stream.`);
  }
  if (isTransformStream(final)) {
    throw new TypeError(`The \`${optionName}.final\` option must not be a web TransformStream.`);
  }
  if (final !== undefined && !isGenerator(final)) {
    throw new TypeError(`The \`${optionName}.final\` option must be a generator.`);
  }
  checkBooleanOption(binary, `${optionName}.binary`);
  checkBooleanOption(objectMode, `${optionName}.objectMode`);
  return isAsyncGenerator(transform) || isAsyncGenerator(final) ? "asyncGenerator" : "generator";
};
var checkBooleanOption = (value, optionName) => {
  if (value !== undefined && typeof value !== "boolean") {
    throw new TypeError(`The \`${optionName}\` option must use a boolean.`);
  }
};
var isGenerator = (value) => isAsyncGenerator(value) || isSyncGenerator(value);
var isAsyncGenerator = (value) => Object.prototype.toString.call(value) === "[object AsyncGeneratorFunction]";
var isSyncGenerator = (value) => Object.prototype.toString.call(value) === "[object GeneratorFunction]";
var isTransformOptions = (value) => isPlainObject(value) && (value.transform !== undefined || value.final !== undefined);
var isUrl = (value) => Object.prototype.toString.call(value) === "[object URL]";
var isRegularUrl = (value) => isUrl(value) && value.protocol !== "file:";
var isFilePathObject = (value) => isPlainObject(value) && Object.keys(value).length > 0 && Object.keys(value).every((key) => FILE_PATH_KEYS.has(key)) && isFilePathString(value.file);
var FILE_PATH_KEYS = new Set(["file", "append"]);
var isFilePathString = (file) => typeof file === "string";
var isUnknownStdioString = (type, value) => type === "native" && typeof value === "string" && !KNOWN_STDIO_STRINGS.has(value);
var KNOWN_STDIO_STRINGS = new Set(["ipc", "ignore", "inherit", "overlapped", "pipe"]);
var isReadableStream2 = (value) => Object.prototype.toString.call(value) === "[object ReadableStream]";
var isWritableStream2 = (value) => Object.prototype.toString.call(value) === "[object WritableStream]";
var isWebStream = (value) => isReadableStream2(value) || isWritableStream2(value);
var isTransformStream = (value) => isReadableStream2(value?.readable) && isWritableStream2(value?.writable);
var isAsyncIterableObject = (value) => isObject(value) && typeof value[Symbol.asyncIterator] === "function";
var isIterableObject = (value) => isObject(value) && typeof value[Symbol.iterator] === "function";
var isObject = (value) => typeof value === "object" && value !== null;
var TRANSFORM_TYPES = new Set(["generator", "asyncGenerator", "duplex", "webTransform"]);
var FILE_TYPES = new Set(["fileUrl", "filePath", "fileNumber"]);
var SPECIAL_DUPLICATE_TYPES_SYNC = new Set(["fileUrl", "filePath"]);
var SPECIAL_DUPLICATE_TYPES = new Set([...SPECIAL_DUPLICATE_TYPES_SYNC, "webStream", "nodeStream"]);
var FORBID_DUPLICATE_TYPES = new Set(["webTransform", "duplex"]);
var TYPE_TO_MESSAGE = {
  generator: "a generator",
  asyncGenerator: "an async generator",
  fileUrl: "a file URL",
  filePath: "a file path string",
  fileNumber: "a file descriptor number",
  webStream: "a web stream",
  nodeStream: "a Node.js stream",
  webTransform: "a web TransformStream",
  duplex: "a Duplex stream",
  native: "any value",
  iterable: "an iterable",
  asyncIterable: "an async iterable",
  string: "a string",
  uint8Array: "a Uint8Array"
};

// node_modules/execa/lib/transform/object-mode.js
var getTransformObjectModes = (objectMode, index, newTransforms, direction) => direction === "output" ? getOutputObjectModes(objectMode, index, newTransforms) : getInputObjectModes(objectMode, index, newTransforms);
var getOutputObjectModes = (objectMode, index, newTransforms) => {
  const writableObjectMode = index !== 0 && newTransforms[index - 1].value.readableObjectMode;
  const readableObjectMode = objectMode ?? writableObjectMode;
  return { writableObjectMode, readableObjectMode };
};
var getInputObjectModes = (objectMode, index, newTransforms) => {
  const writableObjectMode = index === 0 ? objectMode === true : newTransforms[index - 1].value.readableObjectMode;
  const readableObjectMode = index !== newTransforms.length - 1 && (objectMode ?? writableObjectMode);
  return { writableObjectMode, readableObjectMode };
};
var getFdObjectMode = (stdioItems, direction) => {
  const lastTransform = stdioItems.findLast(({ type }) => TRANSFORM_TYPES.has(type));
  if (lastTransform === undefined) {
    return false;
  }
  return direction === "input" ? lastTransform.value.writableObjectMode : lastTransform.value.readableObjectMode;
};

// node_modules/execa/lib/transform/normalize.js
var normalizeTransforms = (stdioItems, optionName, direction, options) => [
  ...stdioItems.filter(({ type }) => !TRANSFORM_TYPES.has(type)),
  ...getTransforms(stdioItems, optionName, direction, options)
];
var getTransforms = (stdioItems, optionName, direction, { encoding }) => {
  const transforms = stdioItems.filter(({ type }) => TRANSFORM_TYPES.has(type));
  const newTransforms = Array.from({ length: transforms.length });
  for (const [index, stdioItem] of Object.entries(transforms)) {
    newTransforms[index] = normalizeTransform({
      stdioItem,
      index: Number(index),
      newTransforms,
      optionName,
      direction,
      encoding
    });
  }
  return sortTransforms(newTransforms, direction);
};
var normalizeTransform = ({ stdioItem, stdioItem: { type }, index, newTransforms, optionName, direction, encoding }) => {
  if (type === "duplex") {
    return normalizeDuplex({ stdioItem, optionName });
  }
  if (type === "webTransform") {
    return normalizeTransformStream({
      stdioItem,
      index,
      newTransforms,
      direction
    });
  }
  return normalizeGenerator({
    stdioItem,
    index,
    newTransforms,
    direction,
    encoding
  });
};
var normalizeDuplex = ({
  stdioItem,
  stdioItem: {
    value: {
      transform,
      transform: { writableObjectMode, readableObjectMode },
      objectMode = readableObjectMode
    }
  },
  optionName
}) => {
  if (objectMode && !readableObjectMode) {
    throw new TypeError(`The \`${optionName}.objectMode\` option can only be \`true\` if \`new Duplex({objectMode: true})\` is used.`);
  }
  if (!objectMode && readableObjectMode) {
    throw new TypeError(`The \`${optionName}.objectMode\` option cannot be \`false\` if \`new Duplex({objectMode: true})\` is used.`);
  }
  return {
    ...stdioItem,
    value: { transform, writableObjectMode, readableObjectMode }
  };
};
var normalizeTransformStream = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction }) => {
  const { transform, objectMode } = isPlainObject(value) ? value : { transform: value };
  const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
  return {
    ...stdioItem,
    value: { transform, writableObjectMode, readableObjectMode }
  };
};
var normalizeGenerator = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction, encoding }) => {
  const {
    transform,
    final,
    binary: binaryOption = false,
    preserveNewlines = false,
    objectMode
  } = isPlainObject(value) ? value : { transform: value };
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
  return {
    ...stdioItem,
    value: {
      transform,
      final,
      binary,
      preserveNewlines,
      writableObjectMode,
      readableObjectMode
    }
  };
};
var sortTransforms = (newTransforms, direction) => direction === "input" ? newTransforms.reverse() : newTransforms;

// node_modules/execa/lib/stdio/direction.js
import process20 from "node:process";
var getStreamDirection = (stdioItems, fdNumber, optionName) => {
  const directions = stdioItems.map((stdioItem) => getStdioItemDirection(stdioItem, fdNumber));
  if (directions.includes("input") && directions.includes("output")) {
    throw new TypeError(`The \`${optionName}\` option must not be an array of both readable and writable values.`);
  }
  return directions.find(Boolean) ?? DEFAULT_DIRECTION;
};
var getStdioItemDirection = ({ type, value }, fdNumber) => KNOWN_DIRECTIONS[fdNumber] ?? guessStreamDirection[type](value);
var KNOWN_DIRECTIONS = ["input", "output", "output"];
var anyDirection = () => {
  return;
};
var alwaysInput = () => "input";
var guessStreamDirection = {
  generator: anyDirection,
  asyncGenerator: anyDirection,
  fileUrl: anyDirection,
  filePath: anyDirection,
  iterable: alwaysInput,
  asyncIterable: alwaysInput,
  uint8Array: alwaysInput,
  webStream: (value) => isWritableStream2(value) ? "output" : "input",
  nodeStream(value) {
    if (!isReadableStream(value, { checkOpen: false })) {
      return "output";
    }
    return isWritableStream(value, { checkOpen: false }) ? undefined : "input";
  },
  webTransform: anyDirection,
  duplex: anyDirection,
  native(value) {
    const standardStreamDirection = getStandardStreamDirection(value);
    if (standardStreamDirection !== undefined) {
      return standardStreamDirection;
    }
    if (isStream(value, { checkOpen: false })) {
      return guessStreamDirection.nodeStream(value);
    }
  }
};
var getStandardStreamDirection = (value) => {
  if ([0, process20.stdin].includes(value)) {
    return "input";
  }
  if ([1, 2, process20.stdout, process20.stderr].includes(value)) {
    return "output";
  }
};
var DEFAULT_DIRECTION = "output";

// node_modules/execa/lib/ipc/array.js
var normalizeIpcStdioArray = (stdioArray, ipc) => ipc && !stdioArray.includes("ipc") ? [...stdioArray, "ipc"] : stdioArray;

// node_modules/execa/lib/stdio/stdio-option.js
var normalizeStdioOption = ({ stdio, ipc, buffer, ...options }, verboseInfo, isSync) => {
  const stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber) => addDefaultValue2(stdioOption, fdNumber));
  return isSync ? normalizeStdioSync(stdioArray, buffer, verboseInfo) : normalizeIpcStdioArray(stdioArray, ipc);
};
var getStdioArray = (stdio, options) => {
  if (stdio === undefined) {
    return STANDARD_STREAMS_ALIASES.map((alias) => options[alias]);
  }
  if (hasAlias(options)) {
    throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${STANDARD_STREAMS_ALIASES.map((alias) => `\`${alias}\``).join(", ")}`);
  }
  if (typeof stdio === "string") {
    return [stdio, stdio, stdio];
  }
  if (!Array.isArray(stdio)) {
    throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
  }
  const length = Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length);
  return Array.from({ length }, (_, fdNumber) => stdio[fdNumber]);
};
var hasAlias = (options) => STANDARD_STREAMS_ALIASES.some((alias) => options[alias] !== undefined);
var addDefaultValue2 = (stdioOption, fdNumber) => {
  if (Array.isArray(stdioOption)) {
    return stdioOption.map((item) => addDefaultValue2(item, fdNumber));
  }
  if (stdioOption === null || stdioOption === undefined) {
    return fdNumber >= STANDARD_STREAMS_ALIASES.length ? "ignore" : "pipe";
  }
  return stdioOption;
};
var normalizeStdioSync = (stdioArray, buffer, verboseInfo) => stdioArray.map((stdioOption, fdNumber) => !buffer[fdNumber] && fdNumber !== 0 && !isFullVerbose(verboseInfo, fdNumber) && isOutputPipeOnly(stdioOption) ? "ignore" : stdioOption);
var isOutputPipeOnly = (stdioOption) => stdioOption === "pipe" || Array.isArray(stdioOption) && stdioOption.every((item) => item === "pipe");

// node_modules/execa/lib/stdio/native.js
import { readFileSync as readFileSync2 } from "node:fs";
import tty3 from "node:tty";
var handleNativeStream = ({ stdioItem, stdioItem: { type }, isStdioArray, fdNumber, direction, isSync }) => {
  if (!isStdioArray || type !== "native") {
    return stdioItem;
  }
  return isSync ? handleNativeStreamSync({ stdioItem, fdNumber, direction }) : handleNativeStreamAsync({ stdioItem, fdNumber });
};
var handleNativeStreamSync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber, direction }) => {
  const targetFd = getTargetFd({
    value,
    optionName,
    fdNumber,
    direction
  });
  if (targetFd !== undefined) {
    return targetFd;
  }
  if (isStream(value, { checkOpen: false })) {
    throw new TypeError(`The \`${optionName}: Stream\` option cannot both be an array and include a stream with synchronous methods.`);
  }
  return stdioItem;
};
var getTargetFd = ({ value, optionName, fdNumber, direction }) => {
  const targetFdNumber = getTargetFdNumber(value, fdNumber);
  if (targetFdNumber === undefined) {
    return;
  }
  if (direction === "output") {
    return { type: "fileNumber", value: targetFdNumber, optionName };
  }
  if (tty3.isatty(targetFdNumber)) {
    throw new TypeError(`The \`${optionName}: ${serializeOptionValue(value)}\` option is invalid: it cannot be a TTY with synchronous methods.`);
  }
  return { type: "uint8Array", value: bufferToUint8Array(readFileSync2(targetFdNumber)), optionName };
};
var getTargetFdNumber = (value, fdNumber) => {
  if (value === "inherit") {
    return fdNumber;
  }
  if (typeof value === "number") {
    return value;
  }
  const standardStreamIndex = STANDARD_STREAMS.indexOf(value);
  if (standardStreamIndex !== -1) {
    return standardStreamIndex;
  }
};
var handleNativeStreamAsync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber }) => {
  if (value === "inherit") {
    return { type: "nodeStream", value: getStandardStream(fdNumber, value, optionName), optionName };
  }
  if (typeof value === "number") {
    return { type: "nodeStream", value: getStandardStream(value, value, optionName), optionName };
  }
  if (isStream(value, { checkOpen: false })) {
    return { type: "nodeStream", value, optionName };
  }
  return stdioItem;
};
var getStandardStream = (fdNumber, value, optionName) => {
  const standardStream = STANDARD_STREAMS[fdNumber];
  if (standardStream === undefined) {
    throw new TypeError(`The \`${optionName}: ${value}\` option is invalid: no such standard stream.`);
  }
  return standardStream;
};

// node_modules/execa/lib/stdio/input-option.js
var handleInputOptions = ({ input, inputFile }, fdNumber) => fdNumber === 0 ? [
  ...handleInputOption(input),
  ...handleInputFileOption(inputFile)
] : [];
var handleInputOption = (input) => input === undefined ? [] : [{
  type: getInputType(input),
  value: input,
  optionName: "input"
}];
var getInputType = (input) => {
  if (isReadableStream(input, { checkOpen: false })) {
    return "nodeStream";
  }
  if (typeof input === "string") {
    return "string";
  }
  if (isUint8Array(input)) {
    return "uint8Array";
  }
  throw new Error("The `input` option must be a string, a Uint8Array or a Node.js Readable stream.");
};
var handleInputFileOption = (inputFile) => inputFile === undefined ? [] : [{
  ...getInputFileType(inputFile),
  optionName: "inputFile"
}];
var getInputFileType = (inputFile) => {
  if (isUrl(inputFile)) {
    return { type: "fileUrl", value: inputFile };
  }
  if (isFilePathString(inputFile)) {
    return { type: "filePath", value: { file: inputFile } };
  }
  throw new Error("The `inputFile` option must be a file path string or a file URL.");
};

// node_modules/execa/lib/stdio/duplicate.js
var filterDuplicates = (stdioItems) => stdioItems.filter((stdioItemOne, indexOne) => stdioItems.every((stdioItemTwo, indexTwo) => stdioItemOne.value !== stdioItemTwo.value || indexOne >= indexTwo || stdioItemOne.type === "generator" || stdioItemOne.type === "asyncGenerator"));
var getDuplicateStream = ({ stdioItem: { type, value, optionName }, direction, fileDescriptors, isSync }) => {
  const otherStdioItems = getOtherStdioItems(fileDescriptors, type);
  if (otherStdioItems.length === 0) {
    return;
  }
  if (isSync) {
    validateDuplicateStreamSync({
      otherStdioItems,
      type,
      value,
      optionName,
      direction
    });
    return;
  }
  if (SPECIAL_DUPLICATE_TYPES.has(type)) {
    return getDuplicateStreamInstance({
      otherStdioItems,
      type,
      value,
      optionName,
      direction
    });
  }
  if (FORBID_DUPLICATE_TYPES.has(type)) {
    validateDuplicateTransform({
      otherStdioItems,
      type,
      value,
      optionName
    });
  }
};
var getOtherStdioItems = (fileDescriptors, type) => fileDescriptors.flatMap(({ direction, stdioItems }) => stdioItems.filter((stdioItem) => stdioItem.type === type).map((stdioItem) => ({ ...stdioItem, direction })));
var validateDuplicateStreamSync = ({ otherStdioItems, type, value, optionName, direction }) => {
  if (SPECIAL_DUPLICATE_TYPES_SYNC.has(type)) {
    getDuplicateStreamInstance({
      otherStdioItems,
      type,
      value,
      optionName,
      direction
    });
  }
};
var getDuplicateStreamInstance = ({ otherStdioItems, type, value, optionName, direction }) => {
  const duplicateStdioItems = otherStdioItems.filter((stdioItem) => hasSameValue(stdioItem, value));
  if (duplicateStdioItems.length === 0) {
    return;
  }
  const differentStdioItem = duplicateStdioItems.find((stdioItem) => stdioItem.direction !== direction);
  throwOnDuplicateStream(differentStdioItem, optionName, type);
  return direction === "output" ? duplicateStdioItems[0].stream : undefined;
};
var hasSameValue = ({ type, value }, secondValue) => {
  if (type === "filePath") {
    return value.file === secondValue.file;
  }
  if (type === "fileUrl") {
    return value.href === secondValue.href;
  }
  return value === secondValue;
};
var validateDuplicateTransform = ({ otherStdioItems, type, value, optionName }) => {
  const duplicateStdioItem = otherStdioItems.find(({ value: { transform } }) => transform === value.transform);
  throwOnDuplicateStream(duplicateStdioItem, optionName, type);
};
var throwOnDuplicateStream = (stdioItem, optionName, type) => {
  if (stdioItem !== undefined) {
    throw new TypeError(`The \`${stdioItem.optionName}\` and \`${optionName}\` options must not target ${TYPE_TO_MESSAGE[type]} that is the same.`);
  }
};

// node_modules/execa/lib/stdio/handle.js
var handleStdio = (addProperties, options, verboseInfo, isSync) => {
  const stdio = normalizeStdioOption(options, verboseInfo, isSync);
  const initialFileDescriptors = stdio.map((stdioOption, fdNumber) => getFileDescriptor({
    stdioOption,
    fdNumber,
    options,
    isSync
  }));
  const fileDescriptors = getFinalFileDescriptors({
    initialFileDescriptors,
    addProperties,
    options,
    isSync
  });
  options.stdio = fileDescriptors.map(({ stdioItems }) => forwardStdio(stdioItems));
  return fileDescriptors;
};
var getFileDescriptor = ({ stdioOption, fdNumber, options, isSync }) => {
  const optionName = getStreamName(fdNumber);
  const { stdioItems: initialStdioItems, isStdioArray } = initializeStdioItems({
    stdioOption,
    fdNumber,
    options,
    optionName
  });
  const direction = getStreamDirection(initialStdioItems, fdNumber, optionName);
  const stdioItems = initialStdioItems.map((stdioItem) => handleNativeStream({
    stdioItem,
    isStdioArray,
    fdNumber,
    direction,
    isSync
  }));
  const normalizedStdioItems = normalizeTransforms(stdioItems, optionName, direction, options);
  const objectMode = getFdObjectMode(normalizedStdioItems, direction);
  validateFileObjectMode(normalizedStdioItems, objectMode);
  return { direction, objectMode, stdioItems: normalizedStdioItems };
};
var initializeStdioItems = ({ stdioOption, fdNumber, options, optionName }) => {
  const values = Array.isArray(stdioOption) ? stdioOption : [stdioOption];
  const initialStdioItems = [
    ...values.map((value) => initializeStdioItem(value, optionName)),
    ...handleInputOptions(options, fdNumber)
  ];
  const stdioItems = filterDuplicates(initialStdioItems);
  const isStdioArray = stdioItems.length > 1;
  validateStdioArray(stdioItems, isStdioArray, optionName);
  validateStreams(stdioItems);
  return { stdioItems, isStdioArray };
};
var initializeStdioItem = (value, optionName) => ({
  type: getStdioItemType(value, optionName),
  value,
  optionName
});
var validateStdioArray = (stdioItems, isStdioArray, optionName) => {
  if (stdioItems.length === 0) {
    throw new TypeError(`The \`${optionName}\` option must not be an empty array.`);
  }
  if (!isStdioArray) {
    return;
  }
  for (const { value, optionName: optionName2 } of stdioItems) {
    if (INVALID_STDIO_ARRAY_OPTIONS.has(value)) {
      throw new Error(`The \`${optionName2}\` option must not include \`${value}\`.`);
    }
  }
};
var INVALID_STDIO_ARRAY_OPTIONS = new Set(["ignore", "ipc"]);
var validateStreams = (stdioItems) => {
  for (const stdioItem of stdioItems) {
    validateFileStdio(stdioItem);
  }
};
var validateFileStdio = ({ type, value, optionName }) => {
  if (isRegularUrl(value)) {
    throw new TypeError(`The \`${optionName}: URL\` option must use the \`file:\` scheme.
For example, you can use the \`pathToFileURL()\` method of the \`url\` core module.`);
  }
  if (isUnknownStdioString(type, value)) {
    throw new TypeError(`The \`${optionName}: { file: '...' }\` option must be used instead of \`${optionName}: '...'\`.`);
  }
};
var validateFileObjectMode = (stdioItems, objectMode) => {
  if (!objectMode) {
    return;
  }
  const fileStdioItem = stdioItems.find(({ type }) => FILE_TYPES.has(type));
  if (fileStdioItem !== undefined) {
    throw new TypeError(`The \`${fileStdioItem.optionName}\` option cannot use both files and transforms in objectMode.`);
  }
};
var getFinalFileDescriptors = ({ initialFileDescriptors, addProperties, options, isSync }) => {
  const fileDescriptors = [];
  try {
    for (const fileDescriptor of initialFileDescriptors) {
      fileDescriptors.push(getFinalFileDescriptor({
        fileDescriptor,
        fileDescriptors,
        addProperties,
        options,
        isSync
      }));
    }
    return fileDescriptors;
  } catch (error) {
    cleanupCustomStreams(fileDescriptors);
    throw error;
  }
};
var getFinalFileDescriptor = ({
  fileDescriptor: { direction, objectMode, stdioItems },
  fileDescriptors,
  addProperties,
  options,
  isSync
}) => {
  const finalStdioItems = stdioItems.map((stdioItem) => addStreamProperties({
    stdioItem,
    addProperties,
    direction,
    options,
    fileDescriptors,
    isSync
  }));
  return { direction, objectMode, stdioItems: finalStdioItems };
};
var addStreamProperties = ({ stdioItem, addProperties, direction, options, fileDescriptors, isSync }) => {
  const duplicateStream = getDuplicateStream({
    stdioItem,
    direction,
    fileDescriptors,
    isSync
  });
  if (duplicateStream !== undefined) {
    return { ...stdioItem, stream: duplicateStream };
  }
  return {
    ...stdioItem,
    ...addProperties[direction][stdioItem.type](stdioItem, options)
  };
};
var cleanupCustomStreams = (fileDescriptors) => {
  for (const { stdioItems } of fileDescriptors) {
    for (const { stream: stream2 } of stdioItems) {
      if (stream2 !== undefined && !isStandardStream(stream2)) {
        stream2.destroy();
      }
    }
  }
};
var forwardStdio = (stdioItems) => {
  if (stdioItems.length > 1) {
    return stdioItems.some(({ value: value2 }) => value2 === "overlapped") ? "overlapped" : "pipe";
  }
  const [{ type, value }] = stdioItems;
  return type === "native" ? value : "pipe";
};

// node_modules/execa/lib/stdio/handle-sync.js
var handleStdioSync = (options, verboseInfo) => handleStdio(addPropertiesSync, options, verboseInfo, true);
var forbiddenIfSync = ({ type, optionName }) => {
  throwInvalidSyncValue(optionName, TYPE_TO_MESSAGE[type]);
};
var forbiddenNativeIfSync = ({ optionName, value }) => {
  if (value === "ipc" || value === "overlapped") {
    throwInvalidSyncValue(optionName, `"${value}"`);
  }
  return {};
};
var throwInvalidSyncValue = (optionName, value) => {
  throw new TypeError(`The \`${optionName}\` option cannot be ${value} with synchronous methods.`);
};
var addProperties = {
  generator() {},
  asyncGenerator: forbiddenIfSync,
  webStream: forbiddenIfSync,
  nodeStream: forbiddenIfSync,
  webTransform: forbiddenIfSync,
  duplex: forbiddenIfSync,
  asyncIterable: forbiddenIfSync,
  native: forbiddenNativeIfSync
};
var addPropertiesSync = {
  input: {
    ...addProperties,
    fileUrl: ({ value }) => ({ contents: [bufferToUint8Array(readFileSync3(value))] }),
    filePath: ({ value: { file } }) => ({ contents: [bufferToUint8Array(readFileSync3(file))] }),
    fileNumber: forbiddenIfSync,
    iterable: ({ value }) => ({ contents: [...value] }),
    string: ({ value }) => ({ contents: [value] }),
    uint8Array: ({ value }) => ({ contents: [value] })
  },
  output: {
    ...addProperties,
    fileUrl: ({ value }) => ({ path: value }),
    filePath: ({ value: { file, append } }) => ({ path: file, append }),
    fileNumber: ({ value }) => ({ path: value }),
    iterable: forbiddenIfSync,
    string: forbiddenIfSync,
    uint8Array: forbiddenIfSync
  }
};

// node_modules/execa/lib/io/strip-newline.js
var stripNewline = (value, { stripFinalNewline: stripFinalNewline2 }, fdNumber) => getStripFinalNewline(stripFinalNewline2, fdNumber) && value !== undefined && !Array.isArray(value) ? stripFinalNewline(value) : value;
var getStripFinalNewline = (stripFinalNewline2, fdNumber) => fdNumber === "all" ? stripFinalNewline2[1] || stripFinalNewline2[2] : stripFinalNewline2[fdNumber];

// node_modules/execa/lib/transform/generator.js
import { Transform as Transform2, getDefaultHighWaterMark } from "node:stream";

// node_modules/execa/lib/transform/split.js
var getSplitLinesGenerator = (binary, preserveNewlines, skipped, state) => binary || skipped ? undefined : initializeSplitLines(preserveNewlines, state);
var splitLinesSync = (chunk, preserveNewlines, objectMode) => objectMode ? chunk.flatMap((item) => splitLinesItemSync(item, preserveNewlines)) : splitLinesItemSync(chunk, preserveNewlines);
var splitLinesItemSync = (chunk, preserveNewlines) => {
  const { transform, final } = initializeSplitLines(preserveNewlines, {});
  return [...transform(chunk), ...final()];
};
var initializeSplitLines = (preserveNewlines, state) => {
  state.previousChunks = "";
  return {
    transform: splitGenerator.bind(undefined, state, preserveNewlines),
    final: linesFinal.bind(undefined, state)
  };
};
var splitGenerator = function* (state, preserveNewlines, chunk) {
  if (typeof chunk !== "string") {
    yield chunk;
    return;
  }
  let { previousChunks } = state;
  let start = -1;
  for (let end = 0;end < chunk.length; end += 1) {
    if (chunk[end] === `
`) {
      const newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);
      let line = chunk.slice(start + 1, end + 1 - newlineLength);
      if (previousChunks.length > 0) {
        line = concatString(previousChunks, line);
        previousChunks = "";
      }
      yield line;
      start = end;
    }
  }
  if (start !== chunk.length - 1) {
    previousChunks = concatString(previousChunks, chunk.slice(start + 1));
  }
  state.previousChunks = previousChunks;
};
var getNewlineLength = (chunk, end, preserveNewlines, state) => {
  if (preserveNewlines) {
    return 0;
  }
  state.isWindowsNewline = end !== 0 && chunk[end - 1] === "\r";
  return state.isWindowsNewline ? 2 : 1;
};
var linesFinal = function* ({ previousChunks }) {
  if (previousChunks.length > 0) {
    yield previousChunks;
  }
};
var getAppendNewlineGenerator = ({ binary, preserveNewlines, readableObjectMode, state }) => binary || preserveNewlines || readableObjectMode ? undefined : { transform: appendNewlineGenerator.bind(undefined, state) };
var appendNewlineGenerator = function* ({ isWindowsNewline = false }, chunk) {
  const { unixNewline, windowsNewline, LF: LF2, concatBytes } = typeof chunk === "string" ? linesStringInfo : linesUint8ArrayInfo;
  if (chunk.at(-1) === LF2) {
    yield chunk;
    return;
  }
  const newline = isWindowsNewline ? windowsNewline : unixNewline;
  yield concatBytes(chunk, newline);
};
var concatString = (firstChunk, secondChunk) => `${firstChunk}${secondChunk}`;
var linesStringInfo = {
  windowsNewline: `\r
`,
  unixNewline: `
`,
  LF: `
`,
  concatBytes: concatString
};
var concatUint8Array = (firstChunk, secondChunk) => {
  const chunk = new Uint8Array(firstChunk.length + secondChunk.length);
  chunk.set(firstChunk, 0);
  chunk.set(secondChunk, firstChunk.length);
  return chunk;
};
var linesUint8ArrayInfo = {
  windowsNewline: new Uint8Array([13, 10]),
  unixNewline: new Uint8Array([10]),
  LF: 10,
  concatBytes: concatUint8Array
};

// node_modules/execa/lib/transform/validate.js
import { Buffer as Buffer3 } from "node:buffer";
var getValidateTransformInput = (writableObjectMode, optionName) => writableObjectMode ? undefined : validateStringTransformInput.bind(undefined, optionName);
var validateStringTransformInput = function* (optionName, chunk) {
  if (typeof chunk !== "string" && !isUint8Array(chunk) && !Buffer3.isBuffer(chunk)) {
    throw new TypeError(`The \`${optionName}\` option's transform must use "objectMode: true" to receive as input: ${typeof chunk}.`);
  }
  yield chunk;
};
var getValidateTransformReturn = (readableObjectMode, optionName) => readableObjectMode ? validateObjectTransformReturn.bind(undefined, optionName) : validateStringTransformReturn.bind(undefined, optionName);
var validateObjectTransformReturn = function* (optionName, chunk) {
  validateEmptyReturn(optionName, chunk);
  yield chunk;
};
var validateStringTransformReturn = function* (optionName, chunk) {
  validateEmptyReturn(optionName, chunk);
  if (typeof chunk !== "string" && !isUint8Array(chunk)) {
    throw new TypeError(`The \`${optionName}\` option's function must yield a string or an Uint8Array, not ${typeof chunk}.`);
  }
  yield chunk;
};
var validateEmptyReturn = (optionName, chunk) => {
  if (chunk === null || chunk === undefined) {
    throw new TypeError(`The \`${optionName}\` option's function must not call \`yield ${chunk}\`.
Instead, \`yield\` should either be called with a value, or not be called at all. For example:
  if (condition) { yield value; }`);
  }
};

// node_modules/execa/lib/transform/encoding-transform.js
import { Buffer as Buffer4 } from "node:buffer";
import { StringDecoder as StringDecoder2 } from "node:string_decoder";
var getEncodingTransformGenerator = (binary, encoding, skipped) => {
  if (skipped) {
    return;
  }
  if (binary) {
    return { transform: encodingUint8ArrayGenerator.bind(undefined, new TextEncoder) };
  }
  const stringDecoder = new StringDecoder2(encoding);
  return {
    transform: encodingStringGenerator.bind(undefined, stringDecoder),
    final: encodingStringFinal.bind(undefined, stringDecoder)
  };
};
var encodingUint8ArrayGenerator = function* (textEncoder3, chunk) {
  if (Buffer4.isBuffer(chunk)) {
    yield bufferToUint8Array(chunk);
  } else if (typeof chunk === "string") {
    yield textEncoder3.encode(chunk);
  } else {
    yield chunk;
  }
};
var encodingStringGenerator = function* (stringDecoder, chunk) {
  yield isUint8Array(chunk) ? stringDecoder.write(chunk) : chunk;
};
var encodingStringFinal = function* (stringDecoder) {
  const lastChunk = stringDecoder.end();
  if (lastChunk !== "") {
    yield lastChunk;
  }
};

// node_modules/execa/lib/transform/run-async.js
import { callbackify } from "node:util";
var pushChunks = callbackify(async (getChunks, state, getChunksArguments, transformStream) => {
  state.currentIterable = getChunks(...getChunksArguments);
  try {
    for await (const chunk of state.currentIterable) {
      transformStream.push(chunk);
    }
  } finally {
    delete state.currentIterable;
  }
});
var transformChunk = async function* (chunk, generators, index) {
  if (index === generators.length) {
    yield chunk;
    return;
  }
  const { transform = identityGenerator } = generators[index];
  for await (const transformedChunk of transform(chunk)) {
    yield* transformChunk(transformedChunk, generators, index + 1);
  }
};
var finalChunks = async function* (generators) {
  for (const [index, { final }] of Object.entries(generators)) {
    yield* generatorFinalChunks(final, Number(index), generators);
  }
};
var generatorFinalChunks = async function* (final, index, generators) {
  if (final === undefined) {
    return;
  }
  for await (const finalChunk of final()) {
    yield* transformChunk(finalChunk, generators, index + 1);
  }
};
var destroyTransform = callbackify(async ({ currentIterable }, error) => {
  if (currentIterable !== undefined) {
    await (error ? currentIterable.throw(error) : currentIterable.return());
    return;
  }
  if (error) {
    throw error;
  }
});
var identityGenerator = function* (chunk) {
  yield chunk;
};

// node_modules/execa/lib/transform/run-sync.js
var pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done) => {
  try {
    for (const chunk of getChunksSync(...getChunksArguments)) {
      transformStream.push(chunk);
    }
    done();
  } catch (error) {
    done(error);
  }
};
var runTransformSync = (generators, chunks) => [
  ...chunks.flatMap((chunk) => [...transformChunkSync(chunk, generators, 0)]),
  ...finalChunksSync(generators)
];
var transformChunkSync = function* (chunk, generators, index) {
  if (index === generators.length) {
    yield chunk;
    return;
  }
  const { transform = identityGenerator2 } = generators[index];
  for (const transformedChunk of transform(chunk)) {
    yield* transformChunkSync(transformedChunk, generators, index + 1);
  }
};
var finalChunksSync = function* (generators) {
  for (const [index, { final }] of Object.entries(generators)) {
    yield* generatorFinalChunksSync(final, Number(index), generators);
  }
};
var generatorFinalChunksSync = function* (final, index, generators) {
  if (final === undefined) {
    return;
  }
  for (const finalChunk of final()) {
    yield* transformChunkSync(finalChunk, generators, index + 1);
  }
};
var identityGenerator2 = function* (chunk) {
  yield chunk;
};

// node_modules/execa/lib/transform/generator.js
var generatorToStream = ({
  value,
  value: { transform, final, writableObjectMode, readableObjectMode },
  optionName
}, { encoding }) => {
  const state = {};
  const generators = addInternalGenerators(value, encoding, optionName);
  const transformAsync = isAsyncGenerator(transform);
  const finalAsync = isAsyncGenerator(final);
  const transformMethod = transformAsync ? pushChunks.bind(undefined, transformChunk, state) : pushChunksSync.bind(undefined, transformChunkSync);
  const finalMethod = transformAsync || finalAsync ? pushChunks.bind(undefined, finalChunks, state) : pushChunksSync.bind(undefined, finalChunksSync);
  const destroyMethod = transformAsync || finalAsync ? destroyTransform.bind(undefined, state) : undefined;
  const stream2 = new Transform2({
    writableObjectMode,
    writableHighWaterMark: getDefaultHighWaterMark(writableObjectMode),
    readableObjectMode,
    readableHighWaterMark: getDefaultHighWaterMark(readableObjectMode),
    transform(chunk, encoding2, done) {
      transformMethod([chunk, generators, 0], this, done);
    },
    flush(done) {
      finalMethod([generators], this, done);
    },
    destroy: destroyMethod
  });
  return { stream: stream2 };
};
var runGeneratorsSync = (chunks, stdioItems, encoding, isInput) => {
  const generators = stdioItems.filter(({ type }) => type === "generator");
  const reversedGenerators = isInput ? generators.reverse() : generators;
  for (const { value, optionName } of reversedGenerators) {
    const generators2 = addInternalGenerators(value, encoding, optionName);
    chunks = runTransformSync(generators2, chunks);
  }
  return chunks;
};
var addInternalGenerators = ({ transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines }, encoding, optionName) => {
  const state = {};
  return [
    { transform: getValidateTransformInput(writableObjectMode, optionName) },
    getEncodingTransformGenerator(binary, encoding, writableObjectMode),
    getSplitLinesGenerator(binary, preserveNewlines, writableObjectMode, state),
    { transform, final },
    { transform: getValidateTransformReturn(readableObjectMode, optionName) },
    getAppendNewlineGenerator({
      binary,
      preserveNewlines,
      readableObjectMode,
      state
    })
  ].filter(Boolean);
};

// node_modules/execa/lib/io/input-sync.js
var addInputOptionsSync = (fileDescriptors, options) => {
  for (const fdNumber of getInputFdNumbers(fileDescriptors)) {
    addInputOptionSync(fileDescriptors, fdNumber, options);
  }
};
var getInputFdNumbers = (fileDescriptors) => new Set(Object.entries(fileDescriptors).filter(([, { direction }]) => direction === "input").map(([fdNumber]) => Number(fdNumber)));
var addInputOptionSync = (fileDescriptors, fdNumber, options) => {
  const { stdioItems } = fileDescriptors[fdNumber];
  const allStdioItems = stdioItems.filter(({ contents }) => contents !== undefined);
  if (allStdioItems.length === 0) {
    return;
  }
  if (fdNumber !== 0) {
    const [{ type, optionName }] = allStdioItems;
    throw new TypeError(`Only the \`stdin\` option, not \`${optionName}\`, can be ${TYPE_TO_MESSAGE[type]} with synchronous methods.`);
  }
  const allContents = allStdioItems.map(({ contents }) => contents);
  const transformedContents = allContents.map((contents) => applySingleInputGeneratorsSync(contents, stdioItems));
  options.input = joinToUint8Array(transformedContents);
};
var applySingleInputGeneratorsSync = (contents, stdioItems) => {
  const newContents = runGeneratorsSync(contents, stdioItems, "utf8", true);
  validateSerializable(newContents);
  return joinToUint8Array(newContents);
};
var validateSerializable = (newContents) => {
  const invalidItem = newContents.find((item) => typeof item !== "string" && !isUint8Array(item));
  if (invalidItem !== undefined) {
    throw new TypeError(`The \`stdin\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${invalidItem}.`);
  }
};

// node_modules/execa/lib/io/output-sync.js
import { writeFileSync, appendFileSync } from "node:fs";

// node_modules/execa/lib/verbose/output.js
var shouldLogOutput = ({ stdioItems, encoding, verboseInfo, fdNumber }) => fdNumber !== "all" && isFullVerbose(verboseInfo, fdNumber) && !BINARY_ENCODINGS.has(encoding) && fdUsesVerbose(fdNumber) && (stdioItems.some(({ type, value }) => type === "native" && PIPED_STDIO_VALUES.has(value)) || stdioItems.every(({ type }) => TRANSFORM_TYPES.has(type)));
var fdUsesVerbose = (fdNumber) => fdNumber === 1 || fdNumber === 2;
var PIPED_STDIO_VALUES = new Set(["pipe", "overlapped"]);
var logLines = async (linesIterable, stream2, fdNumber, verboseInfo) => {
  for await (const line of linesIterable) {
    if (!isPipingStream(stream2)) {
      logLine(line, fdNumber, verboseInfo);
    }
  }
};
var logLinesSync = (linesArray, fdNumber, verboseInfo) => {
  for (const line of linesArray) {
    logLine(line, fdNumber, verboseInfo);
  }
};
var isPipingStream = (stream2) => stream2._readableState.pipes.length > 0;
var logLine = (line, fdNumber, verboseInfo) => {
  const verboseMessage = serializeVerboseMessage(line);
  verboseLog({
    type: "output",
    verboseMessage,
    fdNumber,
    verboseInfo
  });
};

// node_modules/execa/lib/io/output-sync.js
var transformOutputSync = ({ fileDescriptors, syncResult: { output }, options, isMaxBuffer, verboseInfo }) => {
  if (output === null) {
    return { output: Array.from({ length: 3 }) };
  }
  const state = {};
  const outputFiles = new Set([]);
  const transformedOutput = output.map((result, fdNumber) => transformOutputResultSync({
    result,
    fileDescriptors,
    fdNumber,
    state,
    outputFiles,
    isMaxBuffer,
    verboseInfo
  }, options));
  return { output: transformedOutput, ...state };
};
var transformOutputResultSync = ({ result, fileDescriptors, fdNumber, state, outputFiles, isMaxBuffer, verboseInfo }, { buffer, encoding, lines, stripFinalNewline: stripFinalNewline2, maxBuffer }) => {
  if (result === null) {
    return;
  }
  const truncatedResult = truncateMaxBufferSync(result, isMaxBuffer, maxBuffer);
  const uint8ArrayResult = bufferToUint8Array(truncatedResult);
  const { stdioItems, objectMode } = fileDescriptors[fdNumber];
  const chunks = runOutputGeneratorsSync([uint8ArrayResult], stdioItems, encoding, state);
  const { serializedResult, finalResult = serializedResult } = serializeChunks({
    chunks,
    objectMode,
    encoding,
    lines,
    stripFinalNewline: stripFinalNewline2,
    fdNumber
  });
  logOutputSync({
    serializedResult,
    fdNumber,
    state,
    verboseInfo,
    encoding,
    stdioItems,
    objectMode
  });
  const returnedResult = buffer[fdNumber] ? finalResult : undefined;
  try {
    if (state.error === undefined) {
      writeToFiles(serializedResult, stdioItems, outputFiles);
    }
    return returnedResult;
  } catch (error) {
    state.error = error;
    return returnedResult;
  }
};
var runOutputGeneratorsSync = (chunks, stdioItems, encoding, state) => {
  try {
    return runGeneratorsSync(chunks, stdioItems, encoding, false);
  } catch (error) {
    state.error = error;
    return chunks;
  }
};
var serializeChunks = ({ chunks, objectMode, encoding, lines, stripFinalNewline: stripFinalNewline2, fdNumber }) => {
  if (objectMode) {
    return { serializedResult: chunks };
  }
  if (encoding === "buffer") {
    return { serializedResult: joinToUint8Array(chunks) };
  }
  const serializedResult = joinToString(chunks, encoding);
  if (lines[fdNumber]) {
    return { serializedResult, finalResult: splitLinesSync(serializedResult, !stripFinalNewline2[fdNumber], objectMode) };
  }
  return { serializedResult };
};
var logOutputSync = ({ serializedResult, fdNumber, state, verboseInfo, encoding, stdioItems, objectMode }) => {
  if (!shouldLogOutput({
    stdioItems,
    encoding,
    verboseInfo,
    fdNumber
  })) {
    return;
  }
  const linesArray = splitLinesSync(serializedResult, false, objectMode);
  try {
    logLinesSync(linesArray, fdNumber, verboseInfo);
  } catch (error) {
    state.error ??= error;
  }
};
var writeToFiles = (serializedResult, stdioItems, outputFiles) => {
  for (const { path: path6, append } of stdioItems.filter(({ type }) => FILE_TYPES.has(type))) {
    const pathString = typeof path6 === "string" ? path6 : path6.toString();
    if (append || outputFiles.has(pathString)) {
      appendFileSync(path6, serializedResult);
    } else {
      outputFiles.add(pathString);
      writeFileSync(path6, serializedResult);
    }
  }
};

// node_modules/execa/lib/resolve/all-sync.js
var getAllSync = ([, stdout, stderr], options) => {
  if (!options.all) {
    return;
  }
  if (stdout === undefined) {
    return stderr;
  }
  if (stderr === undefined) {
    return stdout;
  }
  if (Array.isArray(stdout)) {
    return Array.isArray(stderr) ? [...stdout, ...stderr] : [...stdout, stripNewline(stderr, options, "all")];
  }
  if (Array.isArray(stderr)) {
    return [stripNewline(stdout, options, "all"), ...stderr];
  }
  if (isUint8Array(stdout) && isUint8Array(stderr)) {
    return concatUint8Arrays([stdout, stderr]);
  }
  return `${stdout}${stderr}`;
};

// node_modules/execa/lib/resolve/exit-async.js
import { once as once4 } from "node:events";
var waitForExit = async (subprocess, context) => {
  const [exitCode, signal] = await waitForExitOrError(subprocess);
  context.isForcefullyTerminated ??= false;
  return [exitCode, signal];
};
var waitForExitOrError = async (subprocess) => {
  const [spawnPayload, exitPayload] = await Promise.allSettled([
    once4(subprocess, "spawn"),
    once4(subprocess, "exit")
  ]);
  if (spawnPayload.status === "rejected") {
    return [];
  }
  return exitPayload.status === "rejected" ? waitForSubprocessExit(subprocess) : exitPayload.value;
};
var waitForSubprocessExit = async (subprocess) => {
  try {
    return await once4(subprocess, "exit");
  } catch {
    return waitForSubprocessExit(subprocess);
  }
};
var waitForSuccessfulExit = async (exitPromise) => {
  const [exitCode, signal] = await exitPromise;
  if (!isSubprocessErrorExit(exitCode, signal) && isFailedExit(exitCode, signal)) {
    throw new DiscardedError;
  }
  return [exitCode, signal];
};
var isSubprocessErrorExit = (exitCode, signal) => exitCode === undefined && signal === undefined;
var isFailedExit = (exitCode, signal) => exitCode !== 0 || signal !== null;

// node_modules/execa/lib/resolve/exit-sync.js
var getExitResultSync = ({ error, status: exitCode, signal, output }, { maxBuffer }) => {
  const resultError = getResultError(error, exitCode, signal);
  const timedOut = resultError?.code === "ETIMEDOUT";
  const isMaxBuffer = isMaxBufferSync(resultError, output, maxBuffer);
  return {
    resultError,
    exitCode,
    signal,
    timedOut,
    isMaxBuffer
  };
};
var getResultError = (error, exitCode, signal) => {
  if (error !== undefined) {
    return error;
  }
  return isFailedExit(exitCode, signal) ? new DiscardedError : undefined;
};

// node_modules/execa/lib/methods/main-sync.js
var execaCoreSync = (rawFile, rawArguments, rawOptions) => {
  const { file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleSyncArguments(rawFile, rawArguments, rawOptions);
  const result = spawnSubprocessSync({
    file,
    commandArguments,
    options,
    command,
    escapedCommand,
    verboseInfo,
    fileDescriptors,
    startTime
  });
  return handleResult(result, verboseInfo, options);
};
var handleSyncArguments = (rawFile, rawArguments, rawOptions) => {
  const { command, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
  const syncOptions = normalizeSyncOptions(rawOptions);
  const { file, commandArguments, options } = normalizeOptions(rawFile, rawArguments, syncOptions);
  validateSyncOptions(options);
  const fileDescriptors = handleStdioSync(options, verboseInfo);
  return {
    file,
    commandArguments,
    command,
    escapedCommand,
    startTime,
    verboseInfo,
    options,
    fileDescriptors
  };
};
var normalizeSyncOptions = (options) => options.node && !options.ipc ? { ...options, ipc: false } : options;
var validateSyncOptions = ({ ipc, ipcInput, detached, cancelSignal }) => {
  if (ipcInput) {
    throwInvalidSyncOption("ipcInput");
  }
  if (ipc) {
    throwInvalidSyncOption("ipc: true");
  }
  if (detached) {
    throwInvalidSyncOption("detached: true");
  }
  if (cancelSignal) {
    throwInvalidSyncOption("cancelSignal");
  }
};
var throwInvalidSyncOption = (value) => {
  throw new TypeError(`The "${value}" option cannot be used with synchronous methods.`);
};
var spawnSubprocessSync = ({ file, commandArguments, options, command, escapedCommand, verboseInfo, fileDescriptors, startTime }) => {
  const syncResult = runSubprocessSync({
    file,
    commandArguments,
    options,
    command,
    escapedCommand,
    fileDescriptors,
    startTime
  });
  if (syncResult.failed) {
    return syncResult;
  }
  const { resultError, exitCode, signal, timedOut, isMaxBuffer } = getExitResultSync(syncResult, options);
  const { output, error = resultError } = transformOutputSync({
    fileDescriptors,
    syncResult,
    options,
    isMaxBuffer,
    verboseInfo
  });
  const stdio = output.map((stdioOutput, fdNumber) => stripNewline(stdioOutput, options, fdNumber));
  const all = stripNewline(getAllSync(output, options), options, "all");
  return getSyncResult({
    error,
    exitCode,
    signal,
    timedOut,
    isMaxBuffer,
    stdio,
    all,
    options,
    command,
    escapedCommand,
    startTime
  });
};
var runSubprocessSync = ({ file, commandArguments, options, command, escapedCommand, fileDescriptors, startTime }) => {
  try {
    addInputOptionsSync(fileDescriptors, options);
    const normalizedOptions = normalizeSpawnSyncOptions(options);
    return spawnSync(...concatenateShell(file, commandArguments, normalizedOptions));
  } catch (error) {
    return makeEarlyError({
      error,
      command,
      escapedCommand,
      fileDescriptors,
      options,
      startTime,
      isSync: true
    });
  }
};
var normalizeSpawnSyncOptions = ({ encoding, maxBuffer, ...options }) => ({ ...options, encoding: "buffer", maxBuffer: getMaxBufferSync(maxBuffer) });
var getSyncResult = ({ error, exitCode, signal, timedOut, isMaxBuffer, stdio, all, options, command, escapedCommand, startTime }) => error === undefined ? makeSuccessResult({
  command,
  escapedCommand,
  stdio,
  all,
  ipcOutput: [],
  options,
  startTime
}) : makeError({
  error,
  command,
  escapedCommand,
  timedOut,
  isCanceled: false,
  isGracefullyCanceled: false,
  isMaxBuffer,
  isForcefullyTerminated: false,
  exitCode,
  signal,
  stdio,
  all,
  ipcOutput: [],
  options,
  startTime,
  isSync: true
});

// node_modules/execa/lib/methods/main-async.js
import { setMaxListeners } from "node:events";
import { spawn } from "node:child_process";

// node_modules/execa/lib/ipc/methods.js
import process21 from "node:process";

// node_modules/execa/lib/ipc/get-one.js
import { once as once5, on as on2 } from "node:events";
var getOneMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference = true, filter } = {}) => {
  validateIpcMethod({
    methodName: "getOneMessage",
    isSubprocess,
    ipc,
    isConnected: isConnected(anyProcess)
  });
  return getOneMessageAsync({
    anyProcess,
    channel,
    isSubprocess,
    filter,
    reference
  });
};
var getOneMessageAsync = async ({ anyProcess, channel, isSubprocess, filter, reference }) => {
  addReference(channel, reference);
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const controller = new AbortController;
  try {
    return await Promise.race([
      getMessage(ipcEmitter, filter, controller),
      throwOnDisconnect2(ipcEmitter, isSubprocess, controller),
      throwOnStrictError(ipcEmitter, isSubprocess, controller)
    ]);
  } catch (error) {
    disconnect(anyProcess);
    throw error;
  } finally {
    controller.abort();
    removeReference(channel, reference);
  }
};
var getMessage = async (ipcEmitter, filter, { signal }) => {
  if (filter === undefined) {
    const [message] = await once5(ipcEmitter, "message", { signal });
    return message;
  }
  for await (const [message] of on2(ipcEmitter, "message", { signal })) {
    if (filter(message)) {
      return message;
    }
  }
};
var throwOnDisconnect2 = async (ipcEmitter, isSubprocess, { signal }) => {
  await once5(ipcEmitter, "disconnect", { signal });
  throwOnEarlyDisconnect(isSubprocess);
};
var throwOnStrictError = async (ipcEmitter, isSubprocess, { signal }) => {
  const [error] = await once5(ipcEmitter, "strict:error", { signal });
  throw getStrictResponseError(error, isSubprocess);
};

// node_modules/execa/lib/ipc/get-each.js
import { once as once6, on as on3 } from "node:events";
var getEachMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference = true } = {}) => loopOnMessages({
  anyProcess,
  channel,
  isSubprocess,
  ipc,
  shouldAwait: !isSubprocess,
  reference
});
var loopOnMessages = ({ anyProcess, channel, isSubprocess, ipc, shouldAwait, reference }) => {
  validateIpcMethod({
    methodName: "getEachMessage",
    isSubprocess,
    ipc,
    isConnected: isConnected(anyProcess)
  });
  addReference(channel, reference);
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const controller = new AbortController;
  const state = {};
  stopOnDisconnect(anyProcess, ipcEmitter, controller);
  abortOnStrictError({
    ipcEmitter,
    isSubprocess,
    controller,
    state
  });
  return iterateOnMessages({
    anyProcess,
    channel,
    ipcEmitter,
    isSubprocess,
    shouldAwait,
    controller,
    state,
    reference
  });
};
var stopOnDisconnect = async (anyProcess, ipcEmitter, controller) => {
  try {
    await once6(ipcEmitter, "disconnect", { signal: controller.signal });
    controller.abort();
  } catch {}
};
var abortOnStrictError = async ({ ipcEmitter, isSubprocess, controller, state }) => {
  try {
    const [error] = await once6(ipcEmitter, "strict:error", { signal: controller.signal });
    state.error = getStrictResponseError(error, isSubprocess);
    controller.abort();
  } catch {}
};
var iterateOnMessages = async function* ({ anyProcess, channel, ipcEmitter, isSubprocess, shouldAwait, controller, state, reference }) {
  try {
    for await (const [message] of on3(ipcEmitter, "message", { signal: controller.signal })) {
      throwIfStrictError(state);
      yield message;
    }
  } catch {
    throwIfStrictError(state);
  } finally {
    controller.abort();
    removeReference(channel, reference);
    if (!isSubprocess) {
      disconnect(anyProcess);
    }
    if (shouldAwait) {
      await anyProcess;
    }
  }
};
var throwIfStrictError = ({ error }) => {
  if (error) {
    throw error;
  }
};

// node_modules/execa/lib/ipc/methods.js
var addIpcMethods = (subprocess, { ipc }) => {
  Object.assign(subprocess, getIpcMethods(subprocess, false, ipc));
};
var getIpcExport = () => {
  const anyProcess = process21;
  const isSubprocess = true;
  const ipc = process21.channel !== undefined;
  return {
    ...getIpcMethods(anyProcess, isSubprocess, ipc),
    getCancelSignal: getCancelSignal.bind(undefined, {
      anyProcess,
      channel: anyProcess.channel,
      isSubprocess,
      ipc
    })
  };
};
var getIpcMethods = (anyProcess, isSubprocess, ipc) => ({
  sendMessage: sendMessage.bind(undefined, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  }),
  getOneMessage: getOneMessage.bind(undefined, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  }),
  getEachMessage: getEachMessage.bind(undefined, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  })
});

// node_modules/execa/lib/return/early-error.js
import { ChildProcess as ChildProcess2 } from "node:child_process";
import {
  PassThrough as PassThrough2,
  Readable,
  Writable,
  Duplex
} from "node:stream";
var handleEarlyError = ({ error, command, escapedCommand, fileDescriptors, options, startTime, verboseInfo }) => {
  cleanupCustomStreams(fileDescriptors);
  const subprocess = new ChildProcess2;
  createDummyStreams(subprocess, fileDescriptors);
  Object.assign(subprocess, { readable, writable, duplex });
  const earlyError = makeEarlyError({
    error,
    command,
    escapedCommand,
    fileDescriptors,
    options,
    startTime,
    isSync: false
  });
  const promise = handleDummyPromise(earlyError, verboseInfo, options);
  return { subprocess, promise };
};
var createDummyStreams = (subprocess, fileDescriptors) => {
  const stdin = createDummyStream();
  const stdout = createDummyStream();
  const stderr = createDummyStream();
  const extraStdio = Array.from({ length: fileDescriptors.length - 3 }, createDummyStream);
  const all = createDummyStream();
  const stdio = [stdin, stdout, stderr, ...extraStdio];
  Object.assign(subprocess, {
    stdin,
    stdout,
    stderr,
    all,
    stdio
  });
};
var createDummyStream = () => {
  const stream2 = new PassThrough2;
  stream2.end();
  return stream2;
};
var readable = () => new Readable({ read() {} });
var writable = () => new Writable({ write() {} });
var duplex = () => new Duplex({ read() {}, write() {} });
var handleDummyPromise = async (error, verboseInfo, options) => handleResult(error, verboseInfo, options);

// node_modules/execa/lib/stdio/handle-async.js
import { createReadStream, createWriteStream } from "node:fs";
import { Buffer as Buffer5 } from "node:buffer";
import { Readable as Readable2, Writable as Writable2, Duplex as Duplex2 } from "node:stream";
var handleStdioAsync = (options, verboseInfo) => handleStdio(addPropertiesAsync, options, verboseInfo, false);
var forbiddenIfAsync = ({ type, optionName }) => {
  throw new TypeError(`The \`${optionName}\` option cannot be ${TYPE_TO_MESSAGE[type]}.`);
};
var addProperties2 = {
  fileNumber: forbiddenIfAsync,
  generator: generatorToStream,
  asyncGenerator: generatorToStream,
  nodeStream: ({ value }) => ({ stream: value }),
  webTransform({ value: { transform, writableObjectMode, readableObjectMode } }) {
    const objectMode = writableObjectMode || readableObjectMode;
    const stream2 = Duplex2.fromWeb(transform, { objectMode });
    return { stream: stream2 };
  },
  duplex: ({ value: { transform } }) => ({ stream: transform }),
  native() {}
};
var addPropertiesAsync = {
  input: {
    ...addProperties2,
    fileUrl: ({ value }) => ({ stream: createReadStream(value) }),
    filePath: ({ value: { file } }) => ({ stream: createReadStream(file) }),
    webStream: ({ value }) => ({ stream: Readable2.fromWeb(value) }),
    iterable: ({ value }) => ({ stream: Readable2.from(value) }),
    asyncIterable: ({ value }) => ({ stream: Readable2.from(value) }),
    string: ({ value }) => ({ stream: Readable2.from(value) }),
    uint8Array: ({ value }) => ({ stream: Readable2.from(Buffer5.from(value)) })
  },
  output: {
    ...addProperties2,
    fileUrl: ({ value }) => ({ stream: createWriteStream(value) }),
    filePath: ({ value: { file, append } }) => ({ stream: createWriteStream(file, append ? { flags: "a" } : {}) }),
    webStream: ({ value }) => ({ stream: Writable2.fromWeb(value) }),
    iterable: forbiddenIfAsync,
    asyncIterable: forbiddenIfAsync,
    string: forbiddenIfAsync,
    uint8Array: forbiddenIfAsync
  }
};

// node_modules/@sindresorhus/merge-streams/index.js
import { on as on4, once as once7 } from "node:events";
import { PassThrough as PassThroughStream, getDefaultHighWaterMark as getDefaultHighWaterMark2 } from "node:stream";
import { finished as finished2 } from "node:stream/promises";
function mergeStreams(streams) {
  if (!Array.isArray(streams)) {
    throw new TypeError(`Expected an array, got \`${typeof streams}\`.`);
  }
  for (const stream2 of streams) {
    validateStream(stream2);
  }
  const objectMode = streams.some(({ readableObjectMode }) => readableObjectMode);
  const highWaterMark = getHighWaterMark(streams, objectMode);
  const passThroughStream = new MergedStream({
    objectMode,
    writableHighWaterMark: highWaterMark,
    readableHighWaterMark: highWaterMark
  });
  for (const stream2 of streams) {
    passThroughStream.add(stream2);
  }
  return passThroughStream;
}
var getHighWaterMark = (streams, objectMode) => {
  if (streams.length === 0) {
    return getDefaultHighWaterMark2(objectMode);
  }
  const highWaterMarks = streams.filter(({ readableObjectMode }) => readableObjectMode === objectMode).map(({ readableHighWaterMark }) => readableHighWaterMark);
  return Math.max(...highWaterMarks);
};

class MergedStream extends PassThroughStream {
  #streams = new Set([]);
  #ended = new Set([]);
  #aborted = new Set([]);
  #onFinished;
  #unpipeEvent = Symbol("unpipe");
  #streamPromises = new WeakMap;
  add(stream2) {
    validateStream(stream2);
    if (this.#streams.has(stream2)) {
      return;
    }
    this.#streams.add(stream2);
    this.#onFinished ??= onMergedStreamFinished(this, this.#streams, this.#unpipeEvent);
    const streamPromise = endWhenStreamsDone({
      passThroughStream: this,
      stream: stream2,
      streams: this.#streams,
      ended: this.#ended,
      aborted: this.#aborted,
      onFinished: this.#onFinished,
      unpipeEvent: this.#unpipeEvent
    });
    this.#streamPromises.set(stream2, streamPromise);
    stream2.pipe(this, { end: false });
  }
  async remove(stream2) {
    validateStream(stream2);
    if (!this.#streams.has(stream2)) {
      return false;
    }
    const streamPromise = this.#streamPromises.get(stream2);
    if (streamPromise === undefined) {
      return false;
    }
    this.#streamPromises.delete(stream2);
    stream2.unpipe(this);
    await streamPromise;
    return true;
  }
}
var onMergedStreamFinished = async (passThroughStream, streams, unpipeEvent) => {
  updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_COUNT);
  const controller = new AbortController;
  try {
    await Promise.race([
      onMergedStreamEnd(passThroughStream, controller),
      onInputStreamsUnpipe(passThroughStream, streams, unpipeEvent, controller)
    ]);
  } finally {
    controller.abort();
    updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_COUNT);
  }
};
var onMergedStreamEnd = async (passThroughStream, { signal }) => {
  try {
    await finished2(passThroughStream, { signal, cleanup: true });
  } catch (error) {
    errorOrAbortStream(passThroughStream, error);
    throw error;
  }
};
var onInputStreamsUnpipe = async (passThroughStream, streams, unpipeEvent, { signal }) => {
  for await (const [unpipedStream] of on4(passThroughStream, "unpipe", { signal })) {
    if (streams.has(unpipedStream)) {
      unpipedStream.emit(unpipeEvent);
    }
  }
};
var validateStream = (stream2) => {
  if (typeof stream2?.pipe !== "function") {
    throw new TypeError(`Expected a readable stream, got: \`${typeof stream2}\`.`);
  }
};
var endWhenStreamsDone = async ({ passThroughStream, stream: stream2, streams, ended, aborted, onFinished, unpipeEvent }) => {
  updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_PER_STREAM);
  const controller = new AbortController;
  try {
    await Promise.race([
      afterMergedStreamFinished(onFinished, stream2, controller),
      onInputStreamEnd({
        passThroughStream,
        stream: stream2,
        streams,
        ended,
        aborted,
        controller
      }),
      onInputStreamUnpipe({
        stream: stream2,
        streams,
        ended,
        aborted,
        unpipeEvent,
        controller
      })
    ]);
  } finally {
    controller.abort();
    updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_PER_STREAM);
  }
  if (streams.size > 0 && streams.size === ended.size + aborted.size) {
    if (ended.size === 0 && aborted.size > 0) {
      abortStream(passThroughStream);
    } else {
      endStream(passThroughStream);
    }
  }
};
var afterMergedStreamFinished = async (onFinished, stream2, { signal }) => {
  try {
    await onFinished;
    if (!signal.aborted) {
      abortStream(stream2);
    }
  } catch (error) {
    if (!signal.aborted) {
      errorOrAbortStream(stream2, error);
    }
  }
};
var onInputStreamEnd = async ({ passThroughStream, stream: stream2, streams, ended, aborted, controller: { signal } }) => {
  try {
    await finished2(stream2, {
      signal,
      cleanup: true,
      readable: true,
      writable: false
    });
    if (streams.has(stream2)) {
      ended.add(stream2);
    }
  } catch (error) {
    if (signal.aborted || !streams.has(stream2)) {
      return;
    }
    if (isAbortError(error)) {
      aborted.add(stream2);
    } else {
      errorStream(passThroughStream, error);
    }
  }
};
var onInputStreamUnpipe = async ({ stream: stream2, streams, ended, aborted, unpipeEvent, controller: { signal } }) => {
  await once7(stream2, unpipeEvent, { signal });
  if (!stream2.readable) {
    return once7(signal, "abort", { signal });
  }
  streams.delete(stream2);
  ended.delete(stream2);
  aborted.delete(stream2);
};
var endStream = (stream2) => {
  if (stream2.writable) {
    stream2.end();
  }
};
var errorOrAbortStream = (stream2, error) => {
  if (isAbortError(error)) {
    abortStream(stream2);
  } else {
    errorStream(stream2, error);
  }
};
var isAbortError = (error) => error?.code === "ERR_STREAM_PREMATURE_CLOSE";
var abortStream = (stream2) => {
  if (stream2.readable || stream2.writable) {
    stream2.destroy();
  }
};
var errorStream = (stream2, error) => {
  if (!stream2.destroyed) {
    stream2.once("error", noop3);
    stream2.destroy(error);
  }
};
var noop3 = () => {};
var updateMaxListeners = (passThroughStream, increment2) => {
  const maxListeners = passThroughStream.getMaxListeners();
  if (maxListeners !== 0 && maxListeners !== Number.POSITIVE_INFINITY) {
    passThroughStream.setMaxListeners(maxListeners + increment2);
  }
};
var PASSTHROUGH_LISTENERS_COUNT = 2;
var PASSTHROUGH_LISTENERS_PER_STREAM = 1;

// node_modules/execa/lib/io/pipeline.js
import { finished as finished3 } from "node:stream/promises";
var pipeStreams = (source, destination) => {
  source.pipe(destination);
  onSourceFinish(source, destination);
  onDestinationFinish(source, destination);
};
var onSourceFinish = async (source, destination) => {
  if (isStandardStream(source) || isStandardStream(destination)) {
    return;
  }
  try {
    await finished3(source, { cleanup: true, readable: true, writable: false });
  } catch {}
  endDestinationStream(destination);
};
var endDestinationStream = (destination) => {
  if (destination.writable) {
    destination.end();
  }
};
var onDestinationFinish = async (source, destination) => {
  if (isStandardStream(source) || isStandardStream(destination)) {
    return;
  }
  try {
    await finished3(destination, { cleanup: true, readable: false, writable: true });
  } catch {}
  abortSourceStream(source);
};
var abortSourceStream = (source) => {
  if (source.readable) {
    source.destroy();
  }
};

// node_modules/execa/lib/io/output-async.js
var pipeOutputAsync = (subprocess, fileDescriptors, controller) => {
  const pipeGroups = new Map;
  for (const [fdNumber, { stdioItems, direction }] of Object.entries(fileDescriptors)) {
    for (const { stream: stream2 } of stdioItems.filter(({ type }) => TRANSFORM_TYPES.has(type))) {
      pipeTransform(subprocess, stream2, direction, fdNumber);
    }
    for (const { stream: stream2 } of stdioItems.filter(({ type }) => !TRANSFORM_TYPES.has(type))) {
      pipeStdioItem({
        subprocess,
        stream: stream2,
        direction,
        fdNumber,
        pipeGroups,
        controller
      });
    }
  }
  for (const [outputStream, inputStreams] of pipeGroups.entries()) {
    const inputStream = inputStreams.length === 1 ? inputStreams[0] : mergeStreams(inputStreams);
    pipeStreams(inputStream, outputStream);
  }
};
var pipeTransform = (subprocess, stream2, direction, fdNumber) => {
  if (direction === "output") {
    pipeStreams(subprocess.stdio[fdNumber], stream2);
  } else {
    pipeStreams(stream2, subprocess.stdio[fdNumber]);
  }
  const streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];
  if (streamProperty !== undefined) {
    subprocess[streamProperty] = stream2;
  }
  subprocess.stdio[fdNumber] = stream2;
};
var SUBPROCESS_STREAM_PROPERTIES = ["stdin", "stdout", "stderr"];
var pipeStdioItem = ({ subprocess, stream: stream2, direction, fdNumber, pipeGroups, controller }) => {
  if (stream2 === undefined) {
    return;
  }
  setStandardStreamMaxListeners(stream2, controller);
  const [inputStream, outputStream] = direction === "output" ? [stream2, subprocess.stdio[fdNumber]] : [subprocess.stdio[fdNumber], stream2];
  const outputStreams = pipeGroups.get(inputStream) ?? [];
  pipeGroups.set(inputStream, [...outputStreams, outputStream]);
};
var setStandardStreamMaxListeners = (stream2, { signal }) => {
  if (isStandardStream(stream2)) {
    incrementMaxListeners(stream2, MAX_LISTENERS_INCREMENT, signal);
  }
};
var MAX_LISTENERS_INCREMENT = 2;

// node_modules/execa/lib/terminate/cleanup.js
import { addAbortListener as addAbortListener2 } from "node:events";

// node_modules/execa/node_modules/signal-exit/dist/mjs/signals.js
var signals = [];
signals.push("SIGHUP", "SIGINT", "SIGTERM");
if (process.platform !== "win32") {
  signals.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
}
if (process.platform === "linux") {
  signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
}

// node_modules/execa/node_modules/signal-exit/dist/mjs/index.js
var processOk = (process22) => !!process22 && typeof process22 === "object" && typeof process22.removeListener === "function" && typeof process22.emit === "function" && typeof process22.reallyExit === "function" && typeof process22.listeners === "function" && typeof process22.kill === "function" && typeof process22.pid === "number" && typeof process22.on === "function";
var kExitEmitter = Symbol.for("signal-exit emitter");
var global2 = globalThis;
var ObjectDefineProperty = Object.defineProperty.bind(Object);

class Emitter {
  emitted = {
    afterExit: false,
    exit: false
  };
  listeners = {
    afterExit: [],
    exit: []
  };
  count = 0;
  id = Math.random();
  constructor() {
    if (global2[kExitEmitter]) {
      return global2[kExitEmitter];
    }
    ObjectDefineProperty(global2, kExitEmitter, {
      value: this,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  on(ev, fn) {
    this.listeners[ev].push(fn);
  }
  removeListener(ev, fn) {
    const list = this.listeners[ev];
    const i2 = list.indexOf(fn);
    if (i2 === -1) {
      return;
    }
    if (i2 === 0 && list.length === 1) {
      list.length = 0;
    } else {
      list.splice(i2, 1);
    }
  }
  emit(ev, code, signal) {
    if (this.emitted[ev]) {
      return false;
    }
    this.emitted[ev] = true;
    let ret = false;
    for (const fn of this.listeners[ev]) {
      ret = fn(code, signal) === true || ret;
    }
    if (ev === "exit") {
      ret = this.emit("afterExit", code, signal) || ret;
    }
    return ret;
  }
}

class SignalExitBase {
}
var signalExitWrap = (handler) => {
  return {
    onExit(cb, opts) {
      return handler.onExit(cb, opts);
    },
    load() {
      return handler.load();
    },
    unload() {
      return handler.unload();
    }
  };
};

class SignalExitFallback extends SignalExitBase {
  onExit() {
    return () => {};
  }
  load() {}
  unload() {}
}

class SignalExit extends SignalExitBase {
  #hupSig = process22.platform === "win32" ? "SIGINT" : "SIGHUP";
  #emitter = new Emitter;
  #process;
  #originalProcessEmit;
  #originalProcessReallyExit;
  #sigListeners = {};
  #loaded = false;
  constructor(process22) {
    super();
    this.#process = process22;
    this.#sigListeners = {};
    for (const sig of signals) {
      this.#sigListeners[sig] = () => {
        const listeners = this.#process.listeners(sig);
        let { count: count2 } = this.#emitter;
        const p = process22;
        if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
          count2 += p.__signal_exit_emitter__.count;
        }
        if (listeners.length === count2) {
          this.unload();
          const ret = this.#emitter.emit("exit", null, sig);
          const s = sig === "SIGHUP" ? this.#hupSig : sig;
          if (!ret)
            process22.kill(process22.pid, s);
        }
      };
    }
    this.#originalProcessReallyExit = process22.reallyExit;
    this.#originalProcessEmit = process22.emit;
  }
  onExit(cb, opts) {
    if (!processOk(this.#process)) {
      return () => {};
    }
    if (this.#loaded === false) {
      this.load();
    }
    const ev = opts?.alwaysLast ? "afterExit" : "exit";
    this.#emitter.on(ev, cb);
    return () => {
      this.#emitter.removeListener(ev, cb);
      if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) {
        this.unload();
      }
    };
  }
  load() {
    if (this.#loaded) {
      return;
    }
    this.#loaded = true;
    this.#emitter.count += 1;
    for (const sig of signals) {
      try {
        const fn = this.#sigListeners[sig];
        if (fn)
          this.#process.on(sig, fn);
      } catch (_) {}
    }
    this.#process.emit = (ev, ...a2) => {
      return this.#processEmit(ev, ...a2);
    };
    this.#process.reallyExit = (code) => {
      return this.#processReallyExit(code);
    };
  }
  unload() {
    if (!this.#loaded) {
      return;
    }
    this.#loaded = false;
    signals.forEach((sig) => {
      const listener = this.#sigListeners[sig];
      if (!listener) {
        throw new Error("Listener not defined for signal: " + sig);
      }
      try {
        this.#process.removeListener(sig, listener);
      } catch (_) {}
    });
    this.#process.emit = this.#originalProcessEmit;
    this.#process.reallyExit = this.#originalProcessReallyExit;
    this.#emitter.count -= 1;
  }
  #processReallyExit(code) {
    if (!processOk(this.#process)) {
      return 0;
    }
    this.#process.exitCode = code || 0;
    this.#emitter.emit("exit", this.#process.exitCode, null);
    return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
  }
  #processEmit(ev, ...args) {
    const og = this.#originalProcessEmit;
    if (ev === "exit" && processOk(this.#process)) {
      if (typeof args[0] === "number") {
        this.#process.exitCode = args[0];
      }
      const ret = og.call(this.#process, ev, ...args);
      this.#emitter.emit("exit", this.#process.exitCode, null);
      return ret;
    } else {
      return og.call(this.#process, ev, ...args);
    }
  }
}
var process22 = globalThis.process;
var {
  onExit,
  load,
  unload
} = signalExitWrap(processOk(process22) ? new SignalExit(process22) : new SignalExitFallback);

// node_modules/execa/lib/terminate/cleanup.js
var cleanupOnExit = (subprocess, { cleanup, detached }, { signal }) => {
  if (!cleanup || detached) {
    return;
  }
  const removeExitHandler = onExit(() => {
    subprocess.kill();
  });
  addAbortListener2(signal, () => {
    removeExitHandler();
  });
};

// node_modules/execa/lib/pipe/pipe-arguments.js
var normalizePipeArguments = ({ source, sourcePromise, boundOptions, createNested }, ...pipeArguments) => {
  const startTime = getStartTime();
  const {
    destination,
    destinationStream,
    destinationError,
    from,
    unpipeSignal
  } = getDestinationStream(boundOptions, createNested, pipeArguments);
  const { sourceStream, sourceError } = getSourceStream(source, from);
  const { options: sourceOptions, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
  return {
    sourcePromise,
    sourceStream,
    sourceOptions,
    sourceError,
    destination,
    destinationStream,
    destinationError,
    unpipeSignal,
    fileDescriptors,
    startTime
  };
};
var getDestinationStream = (boundOptions, createNested, pipeArguments) => {
  try {
    const {
      destination,
      pipeOptions: { from, to, unpipeSignal } = {}
    } = getDestination(boundOptions, createNested, ...pipeArguments);
    const destinationStream = getToStream(destination, to);
    return {
      destination,
      destinationStream,
      from,
      unpipeSignal
    };
  } catch (error) {
    return { destinationError: error };
  }
};
var getDestination = (boundOptions, createNested, firstArgument, ...pipeArguments) => {
  if (Array.isArray(firstArgument)) {
    const destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);
    return { destination, pipeOptions: boundOptions };
  }
  if (typeof firstArgument === "string" || firstArgument instanceof URL || isDenoExecPath(firstArgument)) {
    if (Object.keys(boundOptions).length > 0) {
      throw new TypeError('Please use .pipe("file", ..., options) or .pipe(execa("file", ..., options)) instead of .pipe(options)("file", ...).');
    }
    const [rawFile, rawArguments, rawOptions] = normalizeParameters(firstArgument, ...pipeArguments);
    const destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);
    return { destination, pipeOptions: rawOptions };
  }
  if (SUBPROCESS_OPTIONS.has(firstArgument)) {
    if (Object.keys(boundOptions).length > 0) {
      throw new TypeError("Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).");
    }
    return { destination: firstArgument, pipeOptions: pipeArguments[0] };
  }
  throw new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${firstArgument}`);
};
var mapDestinationArguments = ({ options }) => ({ options: { ...options, stdin: "pipe", piped: true } });
var getSourceStream = (source, from) => {
  try {
    const sourceStream = getFromStream(source, from);
    return { sourceStream };
  } catch (error) {
    return { sourceError: error };
  }
};

// node_modules/execa/lib/pipe/throw.js
var handlePipeArgumentsError = ({
  sourceStream,
  sourceError,
  destinationStream,
  destinationError,
  fileDescriptors,
  sourceOptions,
  startTime
}) => {
  const error = getPipeArgumentsError({
    sourceStream,
    sourceError,
    destinationStream,
    destinationError
  });
  if (error !== undefined) {
    throw createNonCommandError({
      error,
      fileDescriptors,
      sourceOptions,
      startTime
    });
  }
};
var getPipeArgumentsError = ({ sourceStream, sourceError, destinationStream, destinationError }) => {
  if (sourceError !== undefined && destinationError !== undefined) {
    return destinationError;
  }
  if (destinationError !== undefined) {
    abortSourceStream(sourceStream);
    return destinationError;
  }
  if (sourceError !== undefined) {
    endDestinationStream(destinationStream);
    return sourceError;
  }
};
var createNonCommandError = ({ error, fileDescriptors, sourceOptions, startTime }) => makeEarlyError({
  error,
  command: PIPE_COMMAND_MESSAGE,
  escapedCommand: PIPE_COMMAND_MESSAGE,
  fileDescriptors,
  options: sourceOptions,
  startTime,
  isSync: false
});
var PIPE_COMMAND_MESSAGE = "source.pipe(destination)";

// node_modules/execa/lib/pipe/sequence.js
var waitForBothSubprocesses = async (subprocessPromises) => {
  const [
    { status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason },
    { status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason }
  ] = await subprocessPromises;
  if (!destinationResult.pipedFrom.includes(sourceResult)) {
    destinationResult.pipedFrom.push(sourceResult);
  }
  if (destinationStatus === "rejected") {
    throw destinationResult;
  }
  if (sourceStatus === "rejected") {
    throw sourceResult;
  }
  return destinationResult;
};

// node_modules/execa/lib/pipe/streaming.js
import { finished as finished4 } from "node:stream/promises";
var pipeSubprocessStream = (sourceStream, destinationStream, maxListenersController) => {
  const mergedStream = MERGED_STREAMS.has(destinationStream) ? pipeMoreSubprocessStream(sourceStream, destinationStream) : pipeFirstSubprocessStream(sourceStream, destinationStream);
  incrementMaxListeners(sourceStream, SOURCE_LISTENERS_PER_PIPE, maxListenersController.signal);
  incrementMaxListeners(destinationStream, DESTINATION_LISTENERS_PER_PIPE, maxListenersController.signal);
  cleanupMergedStreamsMap(destinationStream);
  return mergedStream;
};
var pipeFirstSubprocessStream = (sourceStream, destinationStream) => {
  const mergedStream = mergeStreams([sourceStream]);
  pipeStreams(mergedStream, destinationStream);
  MERGED_STREAMS.set(destinationStream, mergedStream);
  return mergedStream;
};
var pipeMoreSubprocessStream = (sourceStream, destinationStream) => {
  const mergedStream = MERGED_STREAMS.get(destinationStream);
  mergedStream.add(sourceStream);
  return mergedStream;
};
var cleanupMergedStreamsMap = async (destinationStream) => {
  try {
    await finished4(destinationStream, { cleanup: true, readable: false, writable: true });
  } catch {}
  MERGED_STREAMS.delete(destinationStream);
};
var MERGED_STREAMS = new WeakMap;
var SOURCE_LISTENERS_PER_PIPE = 2;
var DESTINATION_LISTENERS_PER_PIPE = 1;

// node_modules/execa/lib/pipe/abort.js
import { aborted } from "node:util";
var unpipeOnAbort = (unpipeSignal, unpipeContext) => unpipeSignal === undefined ? [] : [unpipeOnSignalAbort(unpipeSignal, unpipeContext)];
var unpipeOnSignalAbort = async (unpipeSignal, { sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime }) => {
  await aborted(unpipeSignal, sourceStream);
  await mergedStream.remove(sourceStream);
  const error = new Error("Pipe canceled by `unpipeSignal` option.");
  throw createNonCommandError({
    error,
    fileDescriptors,
    sourceOptions,
    startTime
  });
};

// node_modules/execa/lib/pipe/setup.js
var pipeToSubprocess = (sourceInfo, ...pipeArguments) => {
  if (isPlainObject(pipeArguments[0])) {
    return pipeToSubprocess.bind(undefined, {
      ...sourceInfo,
      boundOptions: { ...sourceInfo.boundOptions, ...pipeArguments[0] }
    });
  }
  const { destination, ...normalizedInfo } = normalizePipeArguments(sourceInfo, ...pipeArguments);
  const promise = handlePipePromise({ ...normalizedInfo, destination });
  promise.pipe = pipeToSubprocess.bind(undefined, {
    ...sourceInfo,
    source: destination,
    sourcePromise: promise,
    boundOptions: {}
  });
  return promise;
};
var handlePipePromise = async ({
  sourcePromise,
  sourceStream,
  sourceOptions,
  sourceError,
  destination,
  destinationStream,
  destinationError,
  unpipeSignal,
  fileDescriptors,
  startTime
}) => {
  const subprocessPromises = getSubprocessPromises(sourcePromise, destination);
  handlePipeArgumentsError({
    sourceStream,
    sourceError,
    destinationStream,
    destinationError,
    fileDescriptors,
    sourceOptions,
    startTime
  });
  const maxListenersController = new AbortController;
  try {
    const mergedStream = pipeSubprocessStream(sourceStream, destinationStream, maxListenersController);
    return await Promise.race([
      waitForBothSubprocesses(subprocessPromises),
      ...unpipeOnAbort(unpipeSignal, {
        sourceStream,
        mergedStream,
        sourceOptions,
        fileDescriptors,
        startTime
      })
    ]);
  } finally {
    maxListenersController.abort();
  }
};
var getSubprocessPromises = (sourcePromise, destination) => Promise.allSettled([sourcePromise, destination]);

// node_modules/execa/lib/io/contents.js
import { setImmediate as setImmediate2 } from "node:timers/promises";

// node_modules/execa/lib/io/iterate.js
import { on as on5 } from "node:events";
import { getDefaultHighWaterMark as getDefaultHighWaterMark3 } from "node:stream";
var iterateOnSubprocessStream = ({ subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines }) => {
  const controller = new AbortController;
  stopReadingOnExit(subprocess, controller);
  return iterateOnStream({
    stream: subprocessStdout,
    controller,
    binary,
    shouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,
    encoding,
    shouldSplit: !subprocessStdout.readableObjectMode,
    preserveNewlines
  });
};
var stopReadingOnExit = async (subprocess, controller) => {
  try {
    await subprocess;
  } catch {} finally {
    controller.abort();
  }
};
var iterateForResult = ({ stream: stream2, onStreamEnd, lines, encoding, stripFinalNewline: stripFinalNewline2, allMixed }) => {
  const controller = new AbortController;
  stopReadingOnStreamEnd(onStreamEnd, controller, stream2);
  const objectMode = stream2.readableObjectMode && !allMixed;
  return iterateOnStream({
    stream: stream2,
    controller,
    binary: encoding === "buffer",
    shouldEncode: !objectMode,
    encoding,
    shouldSplit: !objectMode && lines,
    preserveNewlines: !stripFinalNewline2
  });
};
var stopReadingOnStreamEnd = async (onStreamEnd, controller, stream2) => {
  try {
    await onStreamEnd;
  } catch {
    stream2.destroy();
  } finally {
    controller.abort();
  }
};
var iterateOnStream = ({ stream: stream2, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) => {
  const onStdoutChunk = on5(stream2, "data", {
    signal: controller.signal,
    highWaterMark: HIGH_WATER_MARK,
    highWatermark: HIGH_WATER_MARK
  });
  return iterateOnData({
    onStdoutChunk,
    controller,
    binary,
    shouldEncode,
    encoding,
    shouldSplit,
    preserveNewlines
  });
};
var DEFAULT_OBJECT_HIGH_WATER_MARK = getDefaultHighWaterMark3(true);
var HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;
var iterateOnData = async function* ({ onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) {
  const generators = getGenerators({
    binary,
    shouldEncode,
    encoding,
    shouldSplit,
    preserveNewlines
  });
  try {
    for await (const [chunk] of onStdoutChunk) {
      yield* transformChunkSync(chunk, generators, 0);
    }
  } catch (error) {
    if (!controller.signal.aborted) {
      throw error;
    }
  } finally {
    yield* finalChunksSync(generators);
  }
};
var getGenerators = ({ binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) => [
  getEncodingTransformGenerator(binary, encoding, !shouldEncode),
  getSplitLinesGenerator(binary, preserveNewlines, !shouldSplit, {})
].filter(Boolean);

// node_modules/execa/lib/io/contents.js
var getStreamOutput = async ({ stream: stream2, onStreamEnd, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => {
  const logPromise = logOutputAsync({
    stream: stream2,
    onStreamEnd,
    fdNumber,
    encoding,
    allMixed,
    verboseInfo,
    streamInfo
  });
  if (!buffer) {
    await Promise.all([resumeStream(stream2), logPromise]);
    return;
  }
  const stripFinalNewlineValue = getStripFinalNewline(stripFinalNewline2, fdNumber);
  const iterable = iterateForResult({
    stream: stream2,
    onStreamEnd,
    lines,
    encoding,
    stripFinalNewline: stripFinalNewlineValue,
    allMixed
  });
  const [output] = await Promise.all([
    getStreamContents2({
      stream: stream2,
      iterable,
      fdNumber,
      encoding,
      maxBuffer,
      lines
    }),
    logPromise
  ]);
  return output;
};
var logOutputAsync = async ({ stream: stream2, onStreamEnd, fdNumber, encoding, allMixed, verboseInfo, streamInfo: { fileDescriptors } }) => {
  if (!shouldLogOutput({
    stdioItems: fileDescriptors[fdNumber]?.stdioItems,
    encoding,
    verboseInfo,
    fdNumber
  })) {
    return;
  }
  const linesIterable = iterateForResult({
    stream: stream2,
    onStreamEnd,
    lines: true,
    encoding,
    stripFinalNewline: true,
    allMixed
  });
  await logLines(linesIterable, stream2, fdNumber, verboseInfo);
};
var resumeStream = async (stream2) => {
  await setImmediate2();
  if (stream2.readableFlowing === null) {
    stream2.resume();
  }
};
var getStreamContents2 = async ({ stream: stream2, stream: { readableObjectMode }, iterable, fdNumber, encoding, maxBuffer, lines }) => {
  try {
    if (readableObjectMode || lines) {
      return await getStreamAsArray(iterable, { maxBuffer });
    }
    if (encoding === "buffer") {
      return new Uint8Array(await getStreamAsArrayBuffer(iterable, { maxBuffer }));
    }
    return await getStreamAsString(iterable, { maxBuffer });
  } catch (error) {
    return handleBufferedData(handleMaxBuffer({
      error,
      stream: stream2,
      readableObjectMode,
      lines,
      encoding,
      fdNumber
    }));
  }
};
var getBufferedData = async (streamPromise) => {
  try {
    return await streamPromise;
  } catch (error) {
    return handleBufferedData(error);
  }
};
var handleBufferedData = ({ bufferedData }) => isArrayBuffer(bufferedData) ? new Uint8Array(bufferedData) : bufferedData;

// node_modules/execa/lib/resolve/wait-stream.js
import { finished as finished5 } from "node:stream/promises";
var waitForStream = async (stream2, fdNumber, streamInfo, { isSameDirection, stopOnExit = false } = {}) => {
  const state = handleStdinDestroy(stream2, streamInfo);
  const abortController = new AbortController;
  try {
    await Promise.race([
      ...stopOnExit ? [streamInfo.exitPromise] : [],
      finished5(stream2, { cleanup: true, signal: abortController.signal })
    ]);
  } catch (error) {
    if (!state.stdinCleanedUp) {
      handleStreamError(error, fdNumber, streamInfo, isSameDirection);
    }
  } finally {
    abortController.abort();
  }
};
var handleStdinDestroy = (stream2, { originalStreams: [originalStdin], subprocess }) => {
  const state = { stdinCleanedUp: false };
  if (stream2 === originalStdin) {
    spyOnStdinDestroy(stream2, subprocess, state);
  }
  return state;
};
var spyOnStdinDestroy = (subprocessStdin, subprocess, state) => {
  const { _destroy } = subprocessStdin;
  subprocessStdin._destroy = (...destroyArguments) => {
    setStdinCleanedUp(subprocess, state);
    _destroy.call(subprocessStdin, ...destroyArguments);
  };
};
var setStdinCleanedUp = ({ exitCode, signalCode }, state) => {
  if (exitCode !== null || signalCode !== null) {
    state.stdinCleanedUp = true;
  }
};
var handleStreamError = (error, fdNumber, streamInfo, isSameDirection) => {
  if (!shouldIgnoreStreamError(error, fdNumber, streamInfo, isSameDirection)) {
    throw error;
  }
};
var shouldIgnoreStreamError = (error, fdNumber, streamInfo, isSameDirection = true) => {
  if (streamInfo.propagating) {
    return isStreamEpipe(error) || isStreamAbort(error);
  }
  streamInfo.propagating = true;
  return isInputFileDescriptor(streamInfo, fdNumber) === isSameDirection ? isStreamEpipe(error) : isStreamAbort(error);
};
var isInputFileDescriptor = ({ fileDescriptors }, fdNumber) => fdNumber !== "all" && fileDescriptors[fdNumber].direction === "input";
var isStreamAbort = (error) => error?.code === "ERR_STREAM_PREMATURE_CLOSE";
var isStreamEpipe = (error) => error?.code === "EPIPE";

// node_modules/execa/lib/resolve/stdio.js
var waitForStdioStreams = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => subprocess.stdio.map((stream2, fdNumber) => waitForSubprocessStream({
  stream: stream2,
  fdNumber,
  encoding,
  buffer: buffer[fdNumber],
  maxBuffer: maxBuffer[fdNumber],
  lines: lines[fdNumber],
  allMixed: false,
  stripFinalNewline: stripFinalNewline2,
  verboseInfo,
  streamInfo
}));
var waitForSubprocessStream = async ({ stream: stream2, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => {
  if (!stream2) {
    return;
  }
  const onStreamEnd = waitForStream(stream2, fdNumber, streamInfo);
  if (isInputFileDescriptor(streamInfo, fdNumber)) {
    await onStreamEnd;
    return;
  }
  const [output] = await Promise.all([
    getStreamOutput({
      stream: stream2,
      onStreamEnd,
      fdNumber,
      encoding,
      buffer,
      maxBuffer,
      lines,
      allMixed,
      stripFinalNewline: stripFinalNewline2,
      verboseInfo,
      streamInfo
    }),
    onStreamEnd
  ]);
  return output;
};

// node_modules/execa/lib/resolve/all-async.js
var makeAllStream = ({ stdout, stderr }, { all }) => all && (stdout || stderr) ? mergeStreams([stdout, stderr].filter(Boolean)) : undefined;
var waitForAllStream = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => waitForSubprocessStream({
  ...getAllStream(subprocess, buffer),
  fdNumber: "all",
  encoding,
  maxBuffer: maxBuffer[1] + maxBuffer[2],
  lines: lines[1] || lines[2],
  allMixed: getAllMixed(subprocess),
  stripFinalNewline: stripFinalNewline2,
  verboseInfo,
  streamInfo
});
var getAllStream = ({ stdout, stderr, all }, [, bufferStdout, bufferStderr]) => {
  const buffer = bufferStdout || bufferStderr;
  if (!buffer) {
    return { stream: all, buffer };
  }
  if (!bufferStdout) {
    return { stream: stderr, buffer };
  }
  if (!bufferStderr) {
    return { stream: stdout, buffer };
  }
  return { stream: all, buffer };
};
var getAllMixed = ({ all, stdout, stderr }) => all && stdout && stderr && stdout.readableObjectMode !== stderr.readableObjectMode;

// node_modules/execa/lib/resolve/wait-subprocess.js
import { once as once8 } from "node:events";

// node_modules/execa/lib/verbose/ipc.js
var shouldLogIpc = (verboseInfo) => isFullVerbose(verboseInfo, "ipc");
var logIpcOutput = (message, verboseInfo) => {
  const verboseMessage = serializeVerboseMessage(message);
  verboseLog({
    type: "ipc",
    verboseMessage,
    fdNumber: "ipc",
    verboseInfo
  });
};

// node_modules/execa/lib/ipc/buffer-messages.js
var waitForIpcOutput = async ({
  subprocess,
  buffer: bufferArray,
  maxBuffer: maxBufferArray,
  ipc,
  ipcOutput,
  verboseInfo
}) => {
  if (!ipc) {
    return ipcOutput;
  }
  const isVerbose2 = shouldLogIpc(verboseInfo);
  const buffer = getFdSpecificValue(bufferArray, "ipc");
  const maxBuffer = getFdSpecificValue(maxBufferArray, "ipc");
  for await (const message of loopOnMessages({
    anyProcess: subprocess,
    channel: subprocess.channel,
    isSubprocess: false,
    ipc,
    shouldAwait: false,
    reference: true
  })) {
    if (buffer) {
      checkIpcMaxBuffer(subprocess, ipcOutput, maxBuffer);
      ipcOutput.push(message);
    }
    if (isVerbose2) {
      logIpcOutput(message, verboseInfo);
    }
  }
  return ipcOutput;
};
var getBufferedIpcOutput = async (ipcOutputPromise, ipcOutput) => {
  await Promise.allSettled([ipcOutputPromise]);
  return ipcOutput;
};

// node_modules/execa/lib/resolve/wait-subprocess.js
var waitForSubprocessResult = async ({
  subprocess,
  options: {
    encoding,
    buffer,
    maxBuffer,
    lines,
    timeoutDuration: timeout,
    cancelSignal,
    gracefulCancel,
    forceKillAfterDelay,
    stripFinalNewline: stripFinalNewline2,
    ipc,
    ipcInput
  },
  context,
  verboseInfo,
  fileDescriptors,
  originalStreams,
  onInternalError,
  controller
}) => {
  const exitPromise = waitForExit(subprocess, context);
  const streamInfo = {
    originalStreams,
    fileDescriptors,
    subprocess,
    exitPromise,
    propagating: false
  };
  const stdioPromises = waitForStdioStreams({
    subprocess,
    encoding,
    buffer,
    maxBuffer,
    lines,
    stripFinalNewline: stripFinalNewline2,
    verboseInfo,
    streamInfo
  });
  const allPromise = waitForAllStream({
    subprocess,
    encoding,
    buffer,
    maxBuffer,
    lines,
    stripFinalNewline: stripFinalNewline2,
    verboseInfo,
    streamInfo
  });
  const ipcOutput = [];
  const ipcOutputPromise = waitForIpcOutput({
    subprocess,
    buffer,
    maxBuffer,
    ipc,
    ipcOutput,
    verboseInfo
  });
  const originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);
  const customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);
  try {
    return await Promise.race([
      Promise.all([
        {},
        waitForSuccessfulExit(exitPromise),
        Promise.all(stdioPromises),
        allPromise,
        ipcOutputPromise,
        sendIpcInput(subprocess, ipcInput),
        ...originalPromises,
        ...customStreamsEndPromises
      ]),
      onInternalError,
      throwOnSubprocessError(subprocess, controller),
      ...throwOnTimeout(subprocess, timeout, context, controller),
      ...throwOnCancel({
        subprocess,
        cancelSignal,
        gracefulCancel,
        context,
        controller
      }),
      ...throwOnGracefulCancel({
        subprocess,
        cancelSignal,
        gracefulCancel,
        forceKillAfterDelay,
        context,
        controller
      })
    ]);
  } catch (error) {
    context.terminationReason ??= "other";
    return Promise.all([
      { error },
      exitPromise,
      Promise.all(stdioPromises.map((stdioPromise) => getBufferedData(stdioPromise))),
      getBufferedData(allPromise),
      getBufferedIpcOutput(ipcOutputPromise, ipcOutput),
      Promise.allSettled(originalPromises),
      Promise.allSettled(customStreamsEndPromises)
    ]);
  }
};
var waitForOriginalStreams = (originalStreams, subprocess, streamInfo) => originalStreams.map((stream2, fdNumber) => stream2 === subprocess.stdio[fdNumber] ? undefined : waitForStream(stream2, fdNumber, streamInfo));
var waitForCustomStreamsEnd = (fileDescriptors, streamInfo) => fileDescriptors.flatMap(({ stdioItems }, fdNumber) => stdioItems.filter(({ value, stream: stream2 = value }) => isStream(stream2, { checkOpen: false }) && !isStandardStream(stream2)).map(({ type, value, stream: stream2 = value }) => waitForStream(stream2, fdNumber, streamInfo, {
  isSameDirection: TRANSFORM_TYPES.has(type),
  stopOnExit: type === "native"
})));
var throwOnSubprocessError = async (subprocess, { signal }) => {
  const [error] = await once8(subprocess, "error", { signal });
  throw error;
};

// node_modules/execa/lib/convert/concurrent.js
var initializeConcurrentStreams = () => ({
  readableDestroy: new WeakMap,
  writableFinal: new WeakMap,
  writableDestroy: new WeakMap
});
var addConcurrentStream = (concurrentStreams, stream2, waitName) => {
  const weakMap = concurrentStreams[waitName];
  if (!weakMap.has(stream2)) {
    weakMap.set(stream2, []);
  }
  const promises = weakMap.get(stream2);
  const promise = createDeferred();
  promises.push(promise);
  const resolve2 = promise.resolve.bind(promise);
  return { resolve: resolve2, promises };
};
var waitForConcurrentStreams = async ({ resolve: resolve2, promises }, subprocess) => {
  resolve2();
  const [isSubprocessExit] = await Promise.race([
    Promise.allSettled([true, subprocess]),
    Promise.all([false, ...promises])
  ]);
  return !isSubprocessExit;
};

// node_modules/execa/lib/convert/readable.js
import { Readable as Readable3 } from "node:stream";
import { callbackify as callbackify2 } from "node:util";

// node_modules/execa/lib/convert/shared.js
import { finished as finished6 } from "node:stream/promises";
var safeWaitForSubprocessStdin = async (subprocessStdin) => {
  if (subprocessStdin === undefined) {
    return;
  }
  try {
    await waitForSubprocessStdin(subprocessStdin);
  } catch {}
};
var safeWaitForSubprocessStdout = async (subprocessStdout) => {
  if (subprocessStdout === undefined) {
    return;
  }
  try {
    await waitForSubprocessStdout(subprocessStdout);
  } catch {}
};
var waitForSubprocessStdin = async (subprocessStdin) => {
  await finished6(subprocessStdin, { cleanup: true, readable: false, writable: true });
};
var waitForSubprocessStdout = async (subprocessStdout) => {
  await finished6(subprocessStdout, { cleanup: true, readable: true, writable: false });
};
var waitForSubprocess = async (subprocess, error) => {
  await subprocess;
  if (error) {
    throw error;
  }
};
var destroyOtherStream = (stream2, isOpen, error) => {
  if (error && !isStreamAbort(error)) {
    stream2.destroy(error);
  } else if (isOpen) {
    stream2.destroy();
  }
};

// node_modules/execa/lib/convert/readable.js
var createReadable = ({ subprocess, concurrentStreams, encoding }, { from, binary: binaryOption = true, preserveNewlines = true } = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
  const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
  const { read, onStdoutDataDone } = getReadableMethods({
    subprocessStdout,
    subprocess,
    binary,
    encoding,
    preserveNewlines
  });
  const readable2 = new Readable3({
    read,
    destroy: callbackify2(onReadableDestroy.bind(undefined, { subprocessStdout, subprocess, waitReadableDestroy })),
    highWaterMark: readableHighWaterMark,
    objectMode: readableObjectMode,
    encoding: readableEncoding
  });
  onStdoutFinished({
    subprocessStdout,
    onStdoutDataDone,
    readable: readable2,
    subprocess
  });
  return readable2;
};
var getSubprocessStdout = (subprocess, from, concurrentStreams) => {
  const subprocessStdout = getFromStream(subprocess, from);
  const waitReadableDestroy = addConcurrentStream(concurrentStreams, subprocessStdout, "readableDestroy");
  return { subprocessStdout, waitReadableDestroy };
};
var getReadableOptions = ({ readableEncoding, readableObjectMode, readableHighWaterMark }, binary) => binary ? { readableEncoding, readableObjectMode, readableHighWaterMark } : { readableEncoding, readableObjectMode: true, readableHighWaterMark: DEFAULT_OBJECT_HIGH_WATER_MARK };
var getReadableMethods = ({ subprocessStdout, subprocess, binary, encoding, preserveNewlines }) => {
  const onStdoutDataDone = createDeferred();
  const onStdoutData = iterateOnSubprocessStream({
    subprocessStdout,
    subprocess,
    binary,
    shouldEncode: !binary,
    encoding,
    preserveNewlines
  });
  return {
    read() {
      onRead(this, onStdoutData, onStdoutDataDone);
    },
    onStdoutDataDone
  };
};
var onRead = async (readable2, onStdoutData, onStdoutDataDone) => {
  try {
    const { value, done } = await onStdoutData.next();
    if (done) {
      onStdoutDataDone.resolve();
    } else {
      readable2.push(value);
    }
  } catch {}
};
var onStdoutFinished = async ({ subprocessStdout, onStdoutDataDone, readable: readable2, subprocess, subprocessStdin }) => {
  try {
    await waitForSubprocessStdout(subprocessStdout);
    await subprocess;
    await safeWaitForSubprocessStdin(subprocessStdin);
    await onStdoutDataDone;
    if (readable2.readable) {
      readable2.push(null);
    }
  } catch (error) {
    await safeWaitForSubprocessStdin(subprocessStdin);
    destroyOtherReadable(readable2, error);
  }
};
var onReadableDestroy = async ({ subprocessStdout, subprocess, waitReadableDestroy }, error) => {
  if (await waitForConcurrentStreams(waitReadableDestroy, subprocess)) {
    destroyOtherReadable(subprocessStdout, error);
    await waitForSubprocess(subprocess, error);
  }
};
var destroyOtherReadable = (stream2, error) => {
  destroyOtherStream(stream2, stream2.readable, error);
};

// node_modules/execa/lib/convert/writable.js
import { Writable as Writable3 } from "node:stream";
import { callbackify as callbackify3 } from "node:util";
var createWritable = ({ subprocess, concurrentStreams }, { to } = {}) => {
  const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
  const writable2 = new Writable3({
    ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
    destroy: callbackify3(onWritableDestroy.bind(undefined, {
      subprocessStdin,
      subprocess,
      waitWritableFinal,
      waitWritableDestroy
    })),
    highWaterMark: subprocessStdin.writableHighWaterMark,
    objectMode: subprocessStdin.writableObjectMode
  });
  onStdinFinished(subprocessStdin, writable2);
  return writable2;
};
var getSubprocessStdin = (subprocess, to, concurrentStreams) => {
  const subprocessStdin = getToStream(subprocess, to);
  const waitWritableFinal = addConcurrentStream(concurrentStreams, subprocessStdin, "writableFinal");
  const waitWritableDestroy = addConcurrentStream(concurrentStreams, subprocessStdin, "writableDestroy");
  return { subprocessStdin, waitWritableFinal, waitWritableDestroy };
};
var getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal) => ({
  write: onWrite.bind(undefined, subprocessStdin),
  final: callbackify3(onWritableFinal.bind(undefined, subprocessStdin, subprocess, waitWritableFinal))
});
var onWrite = (subprocessStdin, chunk, encoding, done) => {
  if (subprocessStdin.write(chunk, encoding)) {
    done();
  } else {
    subprocessStdin.once("drain", done);
  }
};
var onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal) => {
  if (await waitForConcurrentStreams(waitWritableFinal, subprocess)) {
    if (subprocessStdin.writable) {
      subprocessStdin.end();
    }
    await subprocess;
  }
};
var onStdinFinished = async (subprocessStdin, writable2, subprocessStdout) => {
  try {
    await waitForSubprocessStdin(subprocessStdin);
    if (writable2.writable) {
      writable2.end();
    }
  } catch (error) {
    await safeWaitForSubprocessStdout(subprocessStdout);
    destroyOtherWritable(writable2, error);
  }
};
var onWritableDestroy = async ({ subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy }, error) => {
  await waitForConcurrentStreams(waitWritableFinal, subprocess);
  if (await waitForConcurrentStreams(waitWritableDestroy, subprocess)) {
    destroyOtherWritable(subprocessStdin, error);
    await waitForSubprocess(subprocess, error);
  }
};
var destroyOtherWritable = (stream2, error) => {
  destroyOtherStream(stream2, stream2.writable, error);
};

// node_modules/execa/lib/convert/duplex.js
import { Duplex as Duplex3 } from "node:stream";
import { callbackify as callbackify4 } from "node:util";
var createDuplex = ({ subprocess, concurrentStreams, encoding }, { from, to, binary: binaryOption = true, preserveNewlines = true } = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
  const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
  const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
  const { read, onStdoutDataDone } = getReadableMethods({
    subprocessStdout,
    subprocess,
    binary,
    encoding,
    preserveNewlines
  });
  const duplex2 = new Duplex3({
    read,
    ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
    destroy: callbackify4(onDuplexDestroy.bind(undefined, {
      subprocessStdout,
      subprocessStdin,
      subprocess,
      waitReadableDestroy,
      waitWritableFinal,
      waitWritableDestroy
    })),
    readableHighWaterMark,
    writableHighWaterMark: subprocessStdin.writableHighWaterMark,
    readableObjectMode,
    writableObjectMode: subprocessStdin.writableObjectMode,
    encoding: readableEncoding
  });
  onStdoutFinished({
    subprocessStdout,
    onStdoutDataDone,
    readable: duplex2,
    subprocess,
    subprocessStdin
  });
  onStdinFinished(subprocessStdin, duplex2, subprocessStdout);
  return duplex2;
};
var onDuplexDestroy = async ({ subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy }, error) => {
  await Promise.all([
    onReadableDestroy({ subprocessStdout, subprocess, waitReadableDestroy }, error),
    onWritableDestroy({
      subprocessStdin,
      subprocess,
      waitWritableFinal,
      waitWritableDestroy
    }, error)
  ]);
};

// node_modules/execa/lib/convert/iterable.js
var createIterable = (subprocess, encoding, {
  from,
  binary: binaryOption = false,
  preserveNewlines = false
} = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const subprocessStdout = getFromStream(subprocess, from);
  const onStdoutData = iterateOnSubprocessStream({
    subprocessStdout,
    subprocess,
    binary,
    shouldEncode: true,
    encoding,
    preserveNewlines
  });
  return iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);
};
var iterateOnStdoutData = async function* (onStdoutData, subprocessStdout, subprocess) {
  try {
    yield* onStdoutData;
  } finally {
    if (subprocessStdout.readable) {
      subprocessStdout.destroy();
    }
    await subprocess;
  }
};

// node_modules/execa/lib/convert/add.js
var addConvertedStreams = (subprocess, { encoding }) => {
  const concurrentStreams = initializeConcurrentStreams();
  subprocess.readable = createReadable.bind(undefined, { subprocess, concurrentStreams, encoding });
  subprocess.writable = createWritable.bind(undefined, { subprocess, concurrentStreams });
  subprocess.duplex = createDuplex.bind(undefined, { subprocess, concurrentStreams, encoding });
  subprocess.iterable = createIterable.bind(undefined, subprocess, encoding);
  subprocess[Symbol.asyncIterator] = createIterable.bind(undefined, subprocess, encoding, {});
};

// node_modules/execa/lib/methods/promise.js
var mergePromise = (subprocess, promise) => {
  for (const [property, descriptor] of descriptors) {
    const value = descriptor.value.bind(promise);
    Reflect.defineProperty(subprocess, property, { ...descriptor, value });
  }
};
var nativePromisePrototype = (async () => {})().constructor.prototype;
var descriptors = ["then", "catch", "finally"].map((property) => [
  property,
  Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
]);

// node_modules/execa/lib/methods/main-async.js
var execaCoreAsync = (rawFile, rawArguments, rawOptions, createNested) => {
  const { file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleAsyncArguments(rawFile, rawArguments, rawOptions);
  const { subprocess, promise } = spawnSubprocessAsync({
    file,
    commandArguments,
    options,
    startTime,
    verboseInfo,
    command,
    escapedCommand,
    fileDescriptors
  });
  subprocess.pipe = pipeToSubprocess.bind(undefined, {
    source: subprocess,
    sourcePromise: promise,
    boundOptions: {},
    createNested
  });
  mergePromise(subprocess, promise);
  SUBPROCESS_OPTIONS.set(subprocess, { options, fileDescriptors });
  return subprocess;
};
var handleAsyncArguments = (rawFile, rawArguments, rawOptions) => {
  const { command, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
  const { file, commandArguments, options: normalizedOptions } = normalizeOptions(rawFile, rawArguments, rawOptions);
  const options = handleAsyncOptions(normalizedOptions);
  const fileDescriptors = handleStdioAsync(options, verboseInfo);
  return {
    file,
    commandArguments,
    command,
    escapedCommand,
    startTime,
    verboseInfo,
    options,
    fileDescriptors
  };
};
var handleAsyncOptions = ({ timeout, signal, ...options }) => {
  if (signal !== undefined) {
    throw new TypeError('The "signal" option has been renamed to "cancelSignal" instead.');
  }
  return { ...options, timeoutDuration: timeout };
};
var spawnSubprocessAsync = ({ file, commandArguments, options, startTime, verboseInfo, command, escapedCommand, fileDescriptors }) => {
  let subprocess;
  try {
    subprocess = spawn(...concatenateShell(file, commandArguments, options));
  } catch (error) {
    return handleEarlyError({
      error,
      command,
      escapedCommand,
      fileDescriptors,
      options,
      startTime,
      verboseInfo
    });
  }
  const controller = new AbortController;
  setMaxListeners(Number.POSITIVE_INFINITY, controller.signal);
  const originalStreams = [...subprocess.stdio];
  pipeOutputAsync(subprocess, fileDescriptors, controller);
  cleanupOnExit(subprocess, options, controller);
  const context = {};
  const onInternalError = createDeferred();
  subprocess.kill = subprocessKill.bind(undefined, {
    kill: subprocess.kill.bind(subprocess),
    options,
    onInternalError,
    context,
    controller
  });
  subprocess.all = makeAllStream(subprocess, options);
  addConvertedStreams(subprocess, options);
  addIpcMethods(subprocess, options);
  const promise = handlePromise({
    subprocess,
    options,
    startTime,
    verboseInfo,
    fileDescriptors,
    originalStreams,
    command,
    escapedCommand,
    context,
    onInternalError,
    controller
  });
  return { subprocess, promise };
};
var handlePromise = async ({ subprocess, options, startTime, verboseInfo, fileDescriptors, originalStreams, command, escapedCommand, context, onInternalError, controller }) => {
  const [
    errorInfo,
    [exitCode, signal],
    stdioResults,
    allResult,
    ipcOutput
  ] = await waitForSubprocessResult({
    subprocess,
    options,
    context,
    verboseInfo,
    fileDescriptors,
    originalStreams,
    onInternalError,
    controller
  });
  controller.abort();
  onInternalError.resolve();
  const stdio = stdioResults.map((stdioResult, fdNumber) => stripNewline(stdioResult, options, fdNumber));
  const all = stripNewline(allResult, options, "all");
  const result = getAsyncResult({
    errorInfo,
    exitCode,
    signal,
    stdio,
    all,
    ipcOutput,
    context,
    options,
    command,
    escapedCommand,
    startTime
  });
  return handleResult(result, verboseInfo, options);
};
var getAsyncResult = ({ errorInfo, exitCode, signal, stdio, all, ipcOutput, context, options, command, escapedCommand, startTime }) => ("error" in errorInfo) ? makeError({
  error: errorInfo.error,
  command,
  escapedCommand,
  timedOut: context.terminationReason === "timeout",
  isCanceled: context.terminationReason === "cancel" || context.terminationReason === "gracefulCancel",
  isGracefullyCanceled: context.terminationReason === "gracefulCancel",
  isMaxBuffer: errorInfo.error instanceof MaxBufferError,
  isForcefullyTerminated: context.isForcefullyTerminated,
  exitCode,
  signal,
  stdio,
  all,
  ipcOutput,
  options,
  startTime,
  isSync: false
}) : makeSuccessResult({
  command,
  escapedCommand,
  stdio,
  all,
  ipcOutput,
  options,
  startTime
});

// node_modules/execa/lib/methods/bind.js
var mergeOptions = (boundOptions, options) => {
  const newOptions = Object.fromEntries(Object.entries(options).map(([optionName, optionValue]) => [
    optionName,
    mergeOption(optionName, boundOptions[optionName], optionValue)
  ]));
  return { ...boundOptions, ...newOptions };
};
var mergeOption = (optionName, boundOptionValue, optionValue) => {
  if (DEEP_OPTIONS.has(optionName) && isPlainObject(boundOptionValue) && isPlainObject(optionValue)) {
    return { ...boundOptionValue, ...optionValue };
  }
  return optionValue;
};
var DEEP_OPTIONS = new Set(["env", ...FD_SPECIFIC_OPTIONS]);

// node_modules/execa/lib/methods/create.js
var createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca) => {
  const createNested = (mapArguments2, boundOptions2, setBoundExeca2) => createExeca(mapArguments2, boundOptions2, deepOptions, setBoundExeca2);
  const boundExeca = (...execaArguments) => callBoundExeca({
    mapArguments,
    deepOptions,
    boundOptions,
    setBoundExeca,
    createNested
  }, ...execaArguments);
  if (setBoundExeca !== undefined) {
    setBoundExeca(boundExeca, createNested, boundOptions);
  }
  return boundExeca;
};
var callBoundExeca = ({ mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested }, firstArgument, ...nextArguments) => {
  if (isPlainObject(firstArgument)) {
    return createNested(mapArguments, mergeOptions(boundOptions, firstArgument), setBoundExeca);
  }
  const { file, commandArguments, options, isSync } = parseArguments({
    mapArguments,
    firstArgument,
    nextArguments,
    deepOptions,
    boundOptions
  });
  return isSync ? execaCoreSync(file, commandArguments, options) : execaCoreAsync(file, commandArguments, options, createNested);
};
var parseArguments = ({ mapArguments, firstArgument, nextArguments, deepOptions, boundOptions }) => {
  const callArguments = isTemplateString(firstArgument) ? parseTemplates(firstArgument, nextArguments) : [firstArgument, ...nextArguments];
  const [initialFile, initialArguments, initialOptions] = normalizeParameters(...callArguments);
  const mergedOptions = mergeOptions(mergeOptions(deepOptions, boundOptions), initialOptions);
  const {
    file = initialFile,
    commandArguments = initialArguments,
    options = mergedOptions,
    isSync = false
  } = mapArguments({ file: initialFile, commandArguments: initialArguments, options: mergedOptions });
  return {
    file,
    commandArguments,
    options,
    isSync
  };
};

// node_modules/execa/lib/methods/command.js
var mapCommandAsync = ({ file, commandArguments }) => parseCommand(file, commandArguments);
var mapCommandSync = ({ file, commandArguments }) => ({ ...parseCommand(file, commandArguments), isSync: true });
var parseCommand = (command, unusedArguments) => {
  if (unusedArguments.length > 0) {
    throw new TypeError(`The command and its arguments must be passed as a single string: ${command} ${unusedArguments}.`);
  }
  const [file, ...commandArguments] = parseCommandString(command);
  return { file, commandArguments };
};
var parseCommandString = (command) => {
  if (typeof command !== "string") {
    throw new TypeError(`The command must be a string: ${String(command)}.`);
  }
  const trimmedCommand = command.trim();
  if (trimmedCommand === "") {
    return [];
  }
  const tokens = [];
  for (const token of trimmedCommand.split(SPACES_REGEXP)) {
    const previousToken = tokens.at(-1);
    if (previousToken && previousToken.endsWith("\\")) {
      tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
    } else {
      tokens.push(token);
    }
  }
  return tokens;
};
var SPACES_REGEXP = / +/g;

// node_modules/execa/lib/methods/script.js
var setScriptSync = (boundExeca, createNested, boundOptions) => {
  boundExeca.sync = createNested(mapScriptSync, boundOptions);
  boundExeca.s = boundExeca.sync;
};
var mapScriptAsync = ({ options }) => getScriptOptions(options);
var mapScriptSync = ({ options }) => ({ ...getScriptOptions(options), isSync: true });
var getScriptOptions = (options) => ({ options: { ...getScriptStdinOption(options), ...options } });
var getScriptStdinOption = ({ input, inputFile, stdio }) => input === undefined && inputFile === undefined && stdio === undefined ? { stdin: "inherit" } : {};
var deepScriptOptions = { preferLocal: true };

// node_modules/execa/index.js
var execa = createExeca(() => ({}));
var execaSync = createExeca(() => ({ isSync: true }));
var execaCommand = createExeca(mapCommandAsync);
var execaCommandSync = createExeca(mapCommandSync);
var execaNode = createExeca(mapNode);
var $ = createExeca(mapScriptAsync, {}, deepScriptOptions, setScriptSync);
var {
  sendMessage: sendMessage2,
  getOneMessage: getOneMessage2,
  getEachMessage: getEachMessage2,
  getCancelSignal: getCancelSignal2
} = getIpcExport();

// node_modules/clipboardy/lib/termux.js
var handler = (error) => {
  if (error.code === "ENOENT") {
    throw new Error("Couldn't find the `termux-api` scripts. You can install them with: apt install termux-api");
  }
  throw error;
};
var clipboard = {
  async copy(options) {
    try {
      await execa("termux-clipboard-set", options);
    } catch (error) {
      handler(error);
    }
  },
  async paste(options) {
    try {
      const { stdout } = await execa("termux-clipboard-get", options);
      return stdout;
    } catch (error) {
      handler(error);
    }
  },
  copySync(options) {
    try {
      execaSync("termux-clipboard-set", options);
    } catch (error) {
      handler(error);
    }
  },
  pasteSync(options) {
    try {
      return execaSync("termux-clipboard-get", options).stdout;
    } catch (error) {
      handler(error);
    }
  }
};
var termux_default = clipboard;

// node_modules/clipboardy/lib/linux.js
import path6 from "node:path";
import { fileURLToPath as fileURLToPath3 } from "node:url";
var __dirname2 = path6.dirname(fileURLToPath3(import.meta.url));
var xsel = "xsel";
var xselFallback = path6.join(__dirname2, "../fallbacks/linux/xsel");
var copyArguments = ["--clipboard", "--input"];
var pasteArguments = ["--clipboard", "--output"];
var makeError2 = (xselError, fallbackError) => {
  const message = xselError.code === "ENOENT" ? "Couldn't find the `xsel` binary and fallback didn't work. On Debian/Ubuntu you can install xsel with: sudo apt install xsel" : "Both xsel and fallback failed";
  const error = new Error(message);
  if (xselError.code !== "ENOENT") {
    error.xselError = xselError;
  }
  error.fallbackError = fallbackError;
  return error;
};
var xselWithFallback = async (argumentList, options) => {
  try {
    const { stdout } = await execa(xsel, argumentList, options);
    return stdout;
  } catch (xselError) {
    try {
      const { stdout } = await execa(xselFallback, argumentList, options);
      return stdout;
    } catch (fallbackError) {
      throw makeError2(xselError, fallbackError);
    }
  }
};
var xselWithFallbackSync = (argumentList, options) => {
  try {
    return execaSync(xsel, argumentList, options).stdout;
  } catch (xselError) {
    try {
      return execaSync(xselFallback, argumentList, options).stdout;
    } catch (fallbackError) {
      throw makeError2(xselError, fallbackError);
    }
  }
};
var clipboard2 = {
  async copy(options) {
    await xselWithFallback(copyArguments, options);
  },
  copySync(options) {
    xselWithFallbackSync(copyArguments, options);
  },
  paste: (options) => xselWithFallback(pasteArguments, options),
  pasteSync: (options) => xselWithFallbackSync(pasteArguments, options)
};
var linux_default = clipboard2;

// node_modules/clipboardy/lib/wayland.js
var textArgs = ["--type", "text/plain"];
var makeError3 = (command, error) => {
  if (error.code === "ENOENT") {
    return new Error(`Couldn't find the \`${command}\` binary. On Debian/Ubuntu you can install wl-clipboard with: sudo apt install wl-clipboard`);
  }
  return new Error(`Command \`${command}\` failed: ${error.message}`);
};
var tryWaylandWithFallback = async (command, arguments_, options, fallbackMethod) => {
  try {
    const result = await execa(command, arguments_, options);
    return result.stdout;
  } catch (error) {
    if (command === "wl-paste" && /nothing is copied|no selection|selection owner/i.test(error.stderr || "")) {
      return "";
    }
    if (error.code === "ENOENT" || /wayland|wayland_display|failed to connect|display/i.test(error.stderr || "")) {
      return fallbackMethod(options);
    }
    throw makeError3(command, error);
  }
};
var tryWaylandWithFallbackSync = (command, arguments_, options, fallbackMethod) => {
  try {
    const result = execaSync(command, arguments_, options);
    return result.stdout;
  } catch (error) {
    if (command === "wl-paste" && /nothing is copied|no selection|selection owner/i.test(error.stderr || "")) {
      return "";
    }
    if (error.code === "ENOENT" || /wayland|wayland_display|failed to connect|display/i.test(error.stderr || "")) {
      return fallbackMethod(options);
    }
    throw makeError3(command, error);
  }
};
var clipboard3 = {
  async copy(options) {
    await tryWaylandWithFallback("wl-copy", textArgs, options, linux_default.copy);
  },
  copySync(options) {
    tryWaylandWithFallbackSync("wl-copy", textArgs, options, linux_default.copySync);
  },
  async paste(options) {
    return tryWaylandWithFallback("wl-paste", [...textArgs, "--no-newline"], options, linux_default.paste);
  },
  pasteSync(options) {
    return tryWaylandWithFallbackSync("wl-paste", [...textArgs, "--no-newline"], options, linux_default.pasteSync);
  }
};
var wayland_default = clipboard3;

// node_modules/clipboardy/lib/macos.js
var env3 = {
  LC_CTYPE: "UTF-8"
};
var clipboard4 = {
  copy: async (options) => execa("pbcopy", { ...options, env: env3 }),
  async paste(options) {
    const { stdout } = await execa("pbpaste", { ...options, env: env3 });
    return stdout;
  },
  copySync: (options) => execaSync("pbcopy", { ...options, env: env3 }),
  pasteSync: (options) => execaSync("pbpaste", { ...options, env: env3 }).stdout
};
var macos_default = clipboard4;

// node_modules/clipboardy/lib/windows.js
import { Buffer as Buffer6 } from "node:buffer";
import path7 from "node:path";
import { fileURLToPath as fileURLToPath4 } from "node:url";

// node_modules/system-architecture/index.js
import { promisify as promisify3 } from "node:util";
import process23 from "node:process";
import childProcess from "node:child_process";
var execFilePromises = promisify3(childProcess.execFile);
function systemArchitectureSync() {
  const { arch, platform: platform3, env: env4 } = process23;
  if (platform3 === "darwin" && arch === "x64") {
    const stdout = childProcess.execFileSync("sysctl", ["-inq", "sysctl.proc_translated"], { encoding: "utf8" });
    return stdout.trim() === "1" ? "arm64" : "x64";
  }
  if (arch === "arm64" || arch === "x64") {
    return arch;
  }
  if (platform3 === "win32" && Object.hasOwn(env4, "PROCESSOR_ARCHITEW6432")) {
    return "x64";
  }
  if (platform3 === "linux") {
    const stdout = childProcess.execFileSync("getconf", ["LONG_BIT"], { encoding: "utf8" });
    if (stdout.trim() === "64") {
      return "x64";
    }
  }
  return arch;
}

// node_modules/is64bit/index.js
var archtectures64bit = new Set([
  "arm64",
  "x64",
  "ppc64",
  "riscv64"
]);
function is64bitSync() {
  return archtectures64bit.has(systemArchitectureSync());
}

// node_modules/clipboardy/lib/windows.js
var __dirname3 = path7.dirname(fileURLToPath4(import.meta.url));
var binarySuffix = is64bitSync() ? "x86_64" : "i686";
var windowBinaryPath = path7.join(__dirname3, `../fallbacks/windows/clipboard_${binarySuffix}.exe`);
var powershellPath = "powershell.exe";
var psCommonArgs = [
  "-NoProfile",
  "-NonInteractive",
  "-ExecutionPolicy",
  "Bypass"
];
var createEncodedCommand = (script) => {
  const encodedCommand = Buffer6.from(script, "utf16le").toString("base64");
  return [...psCommonArgs, "-EncodedCommand", encodedCommand];
};
var psCopyScript = `
try {
	[Console]::InputEncoding = [System.Text.Encoding]::UTF8
	$input = [Console]::In.ReadToEnd()
	if ($input -eq $null) { $input = '' }
	Set-Clipboard -Value $input
} catch {
	Write-Error "Failed to set clipboard: $($_.Exception.Message)"
	exit 1
}
`.trim();
var psPasteScript = `
try {
	$content = Get-Clipboard -Raw -ErrorAction Stop
	if ($content -eq $null) { $content = '' }
	[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
	[Console]::Out.Write($content)
} catch {
	Write-Error "Failed to get clipboard: $($_.Exception.Message)"
	exit 1
}
`.trim();
var executeWithFallback = async (primaryCommand, fallbackCommand) => {
  try {
    return await primaryCommand();
  } catch {
    return fallbackCommand();
  }
};
var executeWithFallbackSync = (primaryCommand, fallbackCommand) => {
  try {
    return primaryCommand();
  } catch {
    return fallbackCommand();
  }
};
var clipboard5 = {
  copy: async (options) => executeWithFallback(async () => execa(powershellPath, createEncodedCommand(psCopyScript), options), async () => execa(windowBinaryPath, ["--copy"], options)),
  async paste(options) {
    const { stdout } = await executeWithFallback(async () => execa(powershellPath, createEncodedCommand(psPasteScript), options), async () => execa(windowBinaryPath, ["--paste"], options));
    return stdout;
  },
  copySync: (options) => executeWithFallbackSync(() => execaSync(powershellPath, createEncodedCommand(psCopyScript), options), () => execaSync(windowBinaryPath, ["--copy"], options)),
  pasteSync: (options) => executeWithFallbackSync(() => execaSync(powershellPath, createEncodedCommand(psPasteScript), options), () => execaSync(windowBinaryPath, ["--paste"], options)).stdout
};
var windows_default = clipboard5;

// node_modules/clipboardy/index.js
var platformLib = (() => {
  switch (process24.platform) {
    case "darwin": {
      return macos_default;
    }
    case "win32": {
      return windows_default;
    }
    case "android": {
      if (process24.env.TERMUX__PREFIX === undefined) {
        throw new Error("You need to install Termux for this module to work on Android: https://termux.com");
      }
      return termux_default;
    }
    default: {
      if (is_wsl_default) {
        return windows_default;
      }
      if (isWayland()) {
        return wayland_default;
      }
      return linux_default;
    }
  }
})();
var clipboard6 = {
  async write(text) {
    if (typeof text !== "string") {
      throw new TypeError(`Expected a string, got ${typeof text}`);
    }
    await platformLib.copy({ input: text });
  },
  async read() {
    return platformLib.paste({ stripFinalNewline: false });
  },
  writeSync(text) {
    if (typeof text !== "string") {
      throw new TypeError(`Expected a string, got ${typeof text}`);
    }
    platformLib.copySync({ input: text });
  },
  readSync() {
    return platformLib.pasteSync({ stripFinalNewline: false });
  }
};
var clipboardy_default = clipboard6;

// index.tsx
var import_base32_decode4 = __toESM(require_base32_decode(), 1);

// authenticator.ts
var keytar = __toESM(require_keytar2(), 1);
var import_base32_decode = __toESM(require_base32_decode(), 1);
import crypto from "crypto";

class Authenticator {
  interval = 30;
  algorithm = "sha1";
  SERVICE_NAME = "TINY_AUTHENTICATOR";
  constructor(interval = 30) {
    this.interval = interval;
  }
  async register(ACCOUNT_NAME, TOTP_SECRET) {
    try {
      await keytar.setPassword(this.SERVICE_NAME, ACCOUNT_NAME, TOTP_SECRET);
      return true;
    } catch (error) {
      return false;
    }
  }
  async deleteAuthStuff(ACCOUNT_NAME) {
    const wasDeleted = await keytar.deletePassword(this.SERVICE_NAME, ACCOUNT_NAME);
    return wasDeleted;
  }
  async retrieveSecret(ACCOUNT_NAME) {
    const retrievedSecret = await keytar.getPassword(this.SERVICE_NAME, ACCOUNT_NAME);
    return retrievedSecret;
  }
  async generateToken(secret) {
    const key = Buffer.from(import_base32_decode.default(secret, "RFC4648"));
    let TIME = Math.floor(Date.now() / (this.interval * 1000));
    const buf = Buffer.alloc(8);
    buf.writeBigInt64BE(BigInt(TIME), 0);
    const hmac = crypto.createHmac(this.algorithm, key).update(buf).digest();
    const offset = hmac[hmac.length - 1] & 15;
    const binary = (hmac[offset] & 127) << 24 | (hmac[offset + 1] & 255) << 16 | (hmac[offset + 2] & 255) << 8 | hmac[offset + 3] & 255;
    const token = binary % 1e6;
    return token.toString().padStart(6, "0");
  }
  async listAccounts() {
    const accounts = await keytar.findCredentials(this.SERVICE_NAME);
    return accounts;
  }
  async getTokenForAccount(accountName) {
    const secret = await this.retrieveSecret(accountName);
    if (secret) {
      const token = await this.generateToken(secret);
      return token;
    }
    return null;
  }
}

// import.ts
var import_protobufjs = __toESM(require_src(), 1);

// node_modules/bmp-ts/dist/esm/header-types.js
var HeaderTypes;
(function(HeaderTypes2) {
  HeaderTypes2[HeaderTypes2["BITMAP_INFO_HEADER"] = 40] = "BITMAP_INFO_HEADER";
  HeaderTypes2[HeaderTypes2["BITMAP_V2_INFO_HEADER"] = 52] = "BITMAP_V2_INFO_HEADER";
  HeaderTypes2[HeaderTypes2["BITMAP_V3_INFO_HEADER"] = 56] = "BITMAP_V3_INFO_HEADER";
  HeaderTypes2[HeaderTypes2["BITMAP_V4_HEADER"] = 108] = "BITMAP_V4_HEADER";
  HeaderTypes2[HeaderTypes2["BITMAP_V5_HEADER"] = 124] = "BITMAP_V5_HEADER";
})(HeaderTypes || (HeaderTypes = {}));
var header_types_default = HeaderTypes;

// node_modules/bmp-ts/dist/esm/mask-color.js
function maskColor(maskRed, maskGreen, maskBlue, maskAlpha) {
  const maskRedR = ~maskRed + 1 & maskRed;
  const maskGreenR = ~maskGreen + 1 & maskGreen;
  const maskBlueR = ~maskBlue + 1 & maskBlue;
  const maskAlphaR = ~maskAlpha + 1 & maskAlpha;
  const shiftedMaskRedL = maskRed / maskRedR + 1;
  const shiftedMaskGreenL = maskGreen / maskGreenR + 1;
  const shiftedMaskBlueL = maskBlue / maskBlueR + 1;
  const shiftedMaskAlphaL = maskAlpha / maskAlphaR + 1;
  return {
    shiftRed: (x) => (x & maskRed) / maskRedR * 256 / shiftedMaskRedL,
    shiftGreen: (x) => (x & maskGreen) / maskGreenR * 256 / shiftedMaskGreenL,
    shiftBlue: (x) => (x & maskBlue) / maskBlueR * 256 / shiftedMaskBlueL,
    shiftAlpha: maskAlpha !== 0 ? (x) => (x & maskAlpha) / maskAlphaR * 256 / shiftedMaskAlphaL : () => 255
  };
}

// node_modules/bmp-ts/dist/esm/types.js
var BmpCompression;
(function(BmpCompression2) {
  BmpCompression2[BmpCompression2["NONE"] = 0] = "NONE";
  BmpCompression2[BmpCompression2["BI_RLE8"] = 1] = "BI_RLE8";
  BmpCompression2[BmpCompression2["BI_RLE4"] = 2] = "BI_RLE4";
  BmpCompression2[BmpCompression2["BI_BIT_FIELDS"] = 3] = "BI_BIT_FIELDS";
  BmpCompression2[BmpCompression2["BI_ALPHA_BIT_FIELDS"] = 6] = "BI_ALPHA_BIT_FIELDS";
})(BmpCompression || (BmpCompression = {}));

// node_modules/bmp-ts/dist/esm/decoder.js
class BmpDecoder {
  flag;
  fileSize;
  reserved1;
  reserved2;
  offset;
  headerSize;
  width;
  height;
  planes;
  bitPP;
  compression;
  rawSize;
  hr;
  vr;
  colors;
  importantColors;
  palette;
  data;
  maskRed;
  maskGreen;
  maskBlue;
  maskAlpha;
  toRGBA;
  pos;
  bottomUp;
  buffer;
  locRed;
  locGreen;
  locBlue;
  locAlpha;
  shiftRed;
  shiftGreen;
  shiftBlue;
  shiftAlpha;
  constructor(buffer, { toRGBA } = { toRGBA: false }) {
    this.buffer = buffer;
    this.toRGBA = !!toRGBA;
    this.pos = 0;
    this.bottomUp = true;
    this.flag = this.buffer.toString("utf-8", 0, this.pos += 2);
    if (this.flag !== "BM") {
      throw new Error("Invalid BMP File");
    }
    this.locRed = this.toRGBA ? 0 : 3;
    this.locGreen = this.toRGBA ? 1 : 2;
    this.locBlue = this.toRGBA ? 2 : 1;
    this.locAlpha = this.toRGBA ? 3 : 0;
    this.parseHeader();
    this.parseRGBA();
  }
  parseHeader() {
    this.fileSize = this.readUInt32LE();
    this.reserved1 = this.buffer.readUInt16LE(this.pos);
    this.pos += 2;
    this.reserved2 = this.buffer.readUInt16LE(this.pos);
    this.pos += 2;
    this.offset = this.readUInt32LE();
    this.headerSize = this.readUInt32LE();
    if (!(this.headerSize in header_types_default)) {
      throw new Error(`Unsupported BMP header size ${this.headerSize}`);
    }
    this.width = this.readUInt32LE();
    this.height = this.readUInt32LE();
    this.height = this.height > 2147483647 ? this.height - 4294967296 : this.height;
    this.planes = this.buffer.readUInt16LE(this.pos);
    this.pos += 2;
    this.bitPP = this.buffer.readUInt16LE(this.pos);
    this.pos += 2;
    this.compression = this.readUInt32LE();
    this.rawSize = this.readUInt32LE();
    this.hr = this.readUInt32LE();
    this.vr = this.readUInt32LE();
    this.colors = this.readUInt32LE();
    this.importantColors = this.readUInt32LE();
    if (this.bitPP === 32) {
      this.maskAlpha = 0;
      this.maskRed = 16711680;
      this.maskGreen = 65280;
      this.maskBlue = 255;
    } else if (this.bitPP === 16) {
      this.maskAlpha = 0;
      this.maskRed = 31744;
      this.maskGreen = 992;
      this.maskBlue = 31;
    }
    if (this.headerSize > header_types_default.BITMAP_INFO_HEADER || this.compression === BmpCompression.BI_BIT_FIELDS || this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) {
      this.maskRed = this.readUInt32LE();
      this.maskGreen = this.readUInt32LE();
      this.maskBlue = this.readUInt32LE();
    }
    if (this.headerSize > header_types_default.BITMAP_V2_INFO_HEADER || this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) {
      this.maskAlpha = this.readUInt32LE();
    }
    if (this.headerSize > header_types_default.BITMAP_V3_INFO_HEADER) {
      this.pos += header_types_default.BITMAP_V4_HEADER - header_types_default.BITMAP_V3_INFO_HEADER;
    }
    if (this.headerSize > header_types_default.BITMAP_V4_HEADER) {
      this.pos += header_types_default.BITMAP_V5_HEADER - header_types_default.BITMAP_V4_HEADER;
    }
    if (this.bitPP <= 8 || this.colors > 0) {
      const len = this.colors === 0 ? 1 << this.bitPP : this.colors;
      this.palette = new Array(len);
      for (let i2 = 0;i2 < len; i2++) {
        const blue2 = this.buffer.readUInt8(this.pos++);
        const green2 = this.buffer.readUInt8(this.pos++);
        const red2 = this.buffer.readUInt8(this.pos++);
        const quad = this.buffer.readUInt8(this.pos++);
        this.palette[i2] = {
          red: red2,
          green: green2,
          blue: blue2,
          quad
        };
      }
    }
    if (this.height < 0) {
      this.height *= -1;
      this.bottomUp = false;
    }
    const coloShift = maskColor(this.maskRed, this.maskGreen, this.maskBlue, this.maskAlpha);
    this.shiftRed = coloShift.shiftRed;
    this.shiftGreen = coloShift.shiftGreen;
    this.shiftBlue = coloShift.shiftBlue;
    this.shiftAlpha = coloShift.shiftAlpha;
  }
  parseRGBA() {
    this.data = Buffer.alloc(this.width * this.height * 4);
    switch (this.bitPP) {
      case 1:
        this.bit1();
        break;
      case 4:
        this.bit4();
        break;
      case 8:
        this.bit8();
        break;
      case 16:
        this.bit16();
        break;
      case 24:
        this.bit24();
        break;
      default:
        this.bit32();
    }
  }
  bit1() {
    const xLen = Math.ceil(this.width / 8);
    const mode = xLen % 4;
    const padding = mode !== 0 ? 4 - mode : 0;
    let lastLine;
    this.scanImage(padding, xLen, (x, line) => {
      if (line !== lastLine) {
        lastLine = line;
      }
      const b = this.buffer.readUInt8(this.pos++);
      const location = line * this.width * 4 + x * 8 * 4;
      for (let i2 = 0;i2 < 8; i2++) {
        if (x * 8 + i2 < this.width) {
          const rgb = this.palette[b >> 7 - i2 & 1];
          this.data[location + i2 * this.locAlpha] = 0;
          this.data[location + i2 * 4 + this.locBlue] = rgb.blue;
          this.data[location + i2 * 4 + this.locGreen] = rgb.green;
          this.data[location + i2 * 4 + this.locRed] = rgb.red;
        } else {
          break;
        }
      }
    });
  }
  bit4() {
    if (this.compression === BmpCompression.BI_RLE4) {
      this.data.fill(0);
      let lowNibble = false;
      let lines = this.bottomUp ? this.height - 1 : 0;
      let location = 0;
      while (location < this.data.length) {
        const a2 = this.buffer.readUInt8(this.pos++);
        const b = this.buffer.readUInt8(this.pos++);
        if (a2 === 0) {
          if (b === 0) {
            lines += this.bottomUp ? -1 : 1;
            location = lines * this.width * 4;
            lowNibble = false;
            continue;
          }
          if (b === 1) {
            break;
          }
          if (b === 2) {
            const x = this.buffer.readUInt8(this.pos++);
            const y = this.buffer.readUInt8(this.pos++);
            lines += this.bottomUp ? -y : y;
            location += y * this.width * 4 + x * 4;
          } else {
            let c3 = this.buffer.readUInt8(this.pos++);
            for (let i2 = 0;i2 < b; i2++) {
              location = this.setPixelData(location, lowNibble ? c3 & 15 : (c3 & 240) >> 4);
              if (i2 & 1 && i2 + 1 < b) {
                c3 = this.buffer.readUInt8(this.pos++);
              }
              lowNibble = !lowNibble;
            }
            if ((b + 1 >> 1 & 1) === 1) {
              this.pos++;
            }
          }
        } else {
          for (let i2 = 0;i2 < a2; i2++) {
            location = this.setPixelData(location, lowNibble ? b & 15 : (b & 240) >> 4);
            lowNibble = !lowNibble;
          }
        }
      }
    } else {
      const xLen = Math.ceil(this.width / 2);
      const mode = xLen % 4;
      const padding = mode !== 0 ? 4 - mode : 0;
      this.scanImage(padding, xLen, (x, line) => {
        const b = this.buffer.readUInt8(this.pos++);
        const location = line * this.width * 4 + x * 2 * 4;
        const first4 = b >> 4;
        let rgb = this.palette[first4];
        this.data[location] = 0;
        this.data[location + 1] = rgb.blue;
        this.data[location + 2] = rgb.green;
        this.data[location + 3] = rgb.red;
        if (x * 2 + 1 >= this.width) {
          return false;
        }
        const last4 = b & 15;
        rgb = this.palette[last4];
        this.data[location + 4] = 0;
        this.data[location + 4 + 1] = rgb.blue;
        this.data[location + 4 + 2] = rgb.green;
        this.data[location + 4 + 3] = rgb.red;
      });
    }
  }
  bit8() {
    if (this.compression === BmpCompression.BI_RLE8) {
      this.data.fill(0);
      let lines = this.bottomUp ? this.height - 1 : 0;
      let location = 0;
      while (location < this.data.length) {
        const a2 = this.buffer.readUInt8(this.pos++);
        const b = this.buffer.readUInt8(this.pos++);
        if (a2 === 0) {
          if (b === 0) {
            lines += this.bottomUp ? -1 : 1;
            location = lines * this.width * 4;
            continue;
          }
          if (b === 1) {
            break;
          }
          if (b === 2) {
            const x = this.buffer.readUInt8(this.pos++);
            const y = this.buffer.readUInt8(this.pos++);
            lines += this.bottomUp ? -y : y;
            location += y * this.width * 4 + x * 4;
          } else {
            for (let i2 = 0;i2 < b; i2++) {
              const c3 = this.buffer.readUInt8(this.pos++);
              location = this.setPixelData(location, c3);
            }
            const shouldIncrement = b & true;
            if (shouldIncrement) {
              this.pos++;
            }
          }
        } else {
          for (let i2 = 0;i2 < a2; i2++) {
            location = this.setPixelData(location, b);
          }
        }
      }
    } else {
      const mode = this.width % 4;
      const padding = mode !== 0 ? 4 - mode : 0;
      this.scanImage(padding, this.width, (x, line) => {
        const b = this.buffer.readUInt8(this.pos++);
        const location = line * this.width * 4 + x * 4;
        if (b < this.palette.length) {
          const rgb = this.palette[b];
          this.data[location] = 0;
          this.data[location + 1] = rgb.blue;
          this.data[location + 2] = rgb.green;
          this.data[location + 3] = rgb.red;
        } else {
          this.data[location] = 0;
          this.data[location + 1] = 255;
          this.data[location + 2] = 255;
          this.data[location + 3] = 255;
        }
      });
    }
  }
  bit16() {
    const padding = this.width % 2 * 2;
    this.scanImage(padding, this.width, (x, line) => {
      const loc = line * this.width * 4 + x * 4;
      const px = this.buffer.readUInt16LE(this.pos);
      this.pos += 2;
      this.data[loc + this.locRed] = this.shiftRed(px);
      this.data[loc + this.locGreen] = this.shiftGreen(px);
      this.data[loc + this.locBlue] = this.shiftBlue(px);
      this.data[loc + this.locAlpha] = this.shiftAlpha(px);
    });
  }
  bit24() {
    const padding = this.width % 4;
    this.scanImage(padding, this.width, (x, line) => {
      const loc = line * this.width * 4 + x * 4;
      const blue2 = this.buffer.readUInt8(this.pos++);
      const green2 = this.buffer.readUInt8(this.pos++);
      const red2 = this.buffer.readUInt8(this.pos++);
      this.data[loc + this.locRed] = red2;
      this.data[loc + this.locGreen] = green2;
      this.data[loc + this.locBlue] = blue2;
      this.data[loc + this.locAlpha] = 0;
    });
  }
  bit32() {
    this.scanImage(0, this.width, (x, line) => {
      const loc = line * this.width * 4 + x * 4;
      const px = this.readUInt32LE();
      this.data[loc + this.locRed] = this.shiftRed(px);
      this.data[loc + this.locGreen] = this.shiftGreen(px);
      this.data[loc + this.locBlue] = this.shiftBlue(px);
      this.data[loc + this.locAlpha] = this.shiftAlpha(px);
    });
  }
  scanImage(padding = 0, width = this.width, processPixel) {
    for (let y = this.height - 1;y >= 0; y--) {
      const line = this.bottomUp ? y : this.height - 1 - y;
      for (let x = 0;x < width; x++) {
        const result = processPixel.call(this, x, line);
        if (result === false) {
          return;
        }
      }
      this.pos += padding;
    }
  }
  readUInt32LE() {
    const value = this.buffer.readUInt32LE(this.pos);
    this.pos += 4;
    return value;
  }
  setPixelData(location, rgbIndex) {
    const { blue: blue2, green: green2, red: red2 } = this.palette[rgbIndex];
    this.data[location + this.locAlpha] = 0;
    this.data[location + 1 + this.locBlue] = blue2;
    this.data[location + 2 + this.locGreen] = green2;
    this.data[location + 3 + this.locRed] = red2;
    return location + 4;
  }
}

// node_modules/bmp-ts/dist/esm/encoder.js
function createInteger(numbers) {
  return numbers.reduce((final, n2) => final << 1 | n2, 0);
}
function createColor(color) {
  return color.quad << 24 | color.red << 16 | color.green << 8 | color.blue;
}

class BmpEncoder {
  fileSize;
  reserved1;
  reserved2;
  offset;
  width;
  flag;
  height;
  planes;
  bitPP;
  compress;
  hr;
  vr;
  colors;
  importantColors;
  rawSize;
  headerSize;
  data;
  palette;
  extraBytes;
  buffer;
  bytesInColor;
  pos;
  constructor(imgData) {
    this.buffer = imgData.data;
    this.width = imgData.width;
    this.height = imgData.height;
    this.headerSize = header_types_default.BITMAP_INFO_HEADER;
    this.flag = "BM";
    this.bitPP = imgData.bitPP || 24;
    this.offset = 54;
    this.reserved1 = imgData.reserved1 || 0;
    this.reserved2 = imgData.reserved2 || 0;
    this.planes = 1;
    this.compress = 0;
    this.hr = imgData.hr || 0;
    this.vr = imgData.vr || 0;
    this.importantColors = imgData.importantColors || 0;
    this.colors = Math.min(2 ** (this.bitPP - 1 || 1), imgData.colors || Infinity);
    this.palette = imgData.palette || [];
    if (this.colors && this.bitPP < 16) {
      this.offset += this.colors * 4;
    } else {
      this.colors = 0;
    }
    switch (this.bitPP) {
      case 32:
        this.bytesInColor = 4;
        break;
      case 16:
        this.bytesInColor = 2;
        break;
      case 8:
        this.bytesInColor = 1;
        break;
      case 4:
        this.bytesInColor = 1 / 2;
        break;
      case 1:
        this.bytesInColor = 1 / 8;
        break;
      default:
        this.bytesInColor = 3;
        this.bitPP = 24;
    }
    const rowWidth = this.width * this.bitPP / 32;
    const rowBytes = Math.ceil(rowWidth);
    this.extraBytes = (rowBytes - rowWidth) * 4;
    this.rawSize = this.height * rowBytes * 4 + 2;
    this.fileSize = this.rawSize + this.offset;
    this.data = Buffer.alloc(this.fileSize, 1);
    this.pos = 0;
    this.encode();
  }
  encode() {
    this.pos = 0;
    this.writeHeader();
    switch (this.bitPP) {
      case 32:
        this.bit32();
        break;
      case 16:
        this.bit16();
        break;
      case 8:
        this.bit8();
        break;
      case 4:
        this.bit4();
        break;
      case 1:
        this.bit1();
        break;
      default:
        this.bit24();
    }
  }
  writeHeader() {
    this.data.write(this.flag, this.pos, 2);
    this.pos += 2;
    this.writeUInt32LE(this.fileSize);
    this.writeUInt32LE(this.reserved1 << 16 | this.reserved2);
    this.writeUInt32LE(this.offset);
    this.writeUInt32LE(this.headerSize);
    this.writeUInt32LE(this.width);
    this.writeUInt32LE(this.height);
    this.data.writeUInt16LE(this.planes, this.pos);
    this.pos += 2;
    this.data.writeUInt16LE(this.bitPP, this.pos);
    this.pos += 2;
    this.writeUInt32LE(this.compress);
    this.writeUInt32LE(this.rawSize);
    this.writeUInt32LE(this.hr);
    this.writeUInt32LE(this.vr);
    this.writeUInt32LE(this.colors);
    this.writeUInt32LE(this.importantColors);
  }
  bit1() {
    if (this.palette.length && this.colors === 2) {
      this.initColors(1);
    } else {
      this.writeUInt32LE(16777215);
      this.writeUInt32LE(0);
    }
    this.pos += 1;
    let lineArr = [];
    this.writeImage((p, index, x) => {
      let i2 = index;
      i2++;
      const b = this.buffer[i2++];
      const g = this.buffer[i2++];
      const r = this.buffer[i2++];
      const brightness = r * 0.2126 + g * 0.7152 + b * 0.0722;
      lineArr.push(brightness > 127 ? 0 : 1);
      if ((x + 1) % 8 === 0) {
        this.data[p - 1] = createInteger(lineArr);
        lineArr = [];
      } else if (x === this.width - 1 && lineArr.length > 0) {
        this.data[p - 1] = createInteger(lineArr) << 4;
        lineArr = [];
      }
      return i2;
    });
  }
  bit4() {
    const colors = this.initColors(4);
    let integerPair = [];
    this.writeImage((p, index, x) => {
      let i2 = index;
      const colorInt = createColor({
        quad: this.buffer[i2++],
        blue: this.buffer[i2++],
        green: this.buffer[i2++],
        red: this.buffer[i2++]
      });
      const colorExists = colors.findIndex((c3) => c3 === colorInt);
      if (colorExists !== -1) {
        integerPair.push(colorExists);
      } else {
        integerPair.push(0);
      }
      if ((x + 1) % 2 === 0) {
        this.data[p] = integerPair[0] << 4 | integerPair[1];
        integerPair = [];
      }
      return i2;
    });
  }
  bit8() {
    const colors = this.initColors(8);
    this.writeImage((p, index) => {
      let i2 = index;
      const colorInt = createColor({
        quad: this.buffer[i2++],
        blue: this.buffer[i2++],
        green: this.buffer[i2++],
        red: this.buffer[i2++]
      });
      const colorExists = colors.findIndex((c3) => c3 === colorInt);
      if (colorExists !== -1) {
        this.data[p] = colorExists;
      } else {
        this.data[p] = 0;
      }
      return i2;
    });
  }
  bit16() {
    this.writeImage((p, index) => {
      let i2 = index + 1;
      const b = this.buffer[i2++] / 8;
      const g = this.buffer[i2++] / 8;
      const r = this.buffer[i2++] / 8;
      const color = r << 10 | g << 5 | b;
      this.data[p] = color & 255;
      this.data[p + 1] = (color & 65280) >> 8;
      return i2;
    });
  }
  bit24() {
    this.writeImage((p, index) => {
      let i2 = index + 1;
      this.data[p] = this.buffer[i2++];
      this.data[p + 1] = this.buffer[i2++];
      this.data[p + 2] = this.buffer[i2++];
      return i2;
    });
  }
  bit32() {
    this.writeImage((p, index) => {
      let i2 = index;
      this.data[p + 3] = this.buffer[i2++];
      this.data[p] = this.buffer[i2++];
      this.data[p + 1] = this.buffer[i2++];
      this.data[p + 2] = this.buffer[i2++];
      return i2;
    });
  }
  writeImage(writePixel) {
    const rowBytes = this.extraBytes + this.width * this.bytesInColor;
    let i2 = 0;
    for (let y = 0;y < this.height; y++) {
      for (let x = 0;x < this.width; x++) {
        const p = Math.floor(this.pos + (this.height - 1 - y) * rowBytes + x * this.bytesInColor);
        i2 = writePixel.call(this, p, i2, x, y);
      }
    }
  }
  initColors(bit) {
    const colors = [];
    if (this.palette.length) {
      for (let i2 = 0;i2 < this.colors; i2++) {
        const rootColor = createColor(this.palette[i2]);
        this.writeUInt32LE(rootColor);
        colors.push(rootColor);
      }
    } else {
      throw new Error(`To encode ${bit}-bit BMPs a pallette is needed. Please choose up to ${this.colors} colors. Colors must be 32-bit integers.`);
    }
    return colors;
  }
  writeUInt32LE(value) {
    this.data.writeUInt32LE(value, this.pos);
    this.pos += 4;
  }
}

// node_modules/bmp-ts/dist/esm/index.js
function decode(bmpData, options) {
  return new BmpDecoder(bmpData, options);
}
function encode(imgData) {
  return new BmpEncoder(imgData);
}

// node_modules/tinycolor2/esm/tinycolor.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};
  if (color instanceof tinycolor) {
    return color;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1)
    this._r = Math.round(this._r);
  if (this._g < 1)
    this._g = Math.round(this._g);
  if (this._b < 1)
    this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928)
      R = RsRGB / 12.92;
    else
      R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928)
      G = GsRGB / 12.92;
    else
      G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928)
      B = BsRGB / 12.92;
    else
      B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h2 = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h2 + ", " + s + "%, " + v + "%)" : "hsva(" + h2 + ", " + s + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h2 = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h2 + ", " + s + "%, " + l + "%)" : "hsla(" + h2 + ", " + s + "%, " + l + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString2(format2) {
    var formatSet = !!format2;
    format2 = format2 || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i2 in color) {
      if (color.hasOwnProperty(i2)) {
        if (i2 === "a") {
          newColor[i2] = color[i2];
        } else {
          newColor[i2] = convertToPercentage(color[i2]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a2 = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format2 = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format2 = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a2 = color.a;
    }
  }
  a2 = boundAlpha(a2);
  return {
    ok,
    format: color.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a2
  };
}
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h2, s, l = (max + min) / 2;
  if (max == min) {
    h2 = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h2 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h2 = (b - r) / d + 2;
        break;
      case b:
        h2 = (r - g) / d + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: h2,
    s,
    l
  };
}
function hslToRgb(h2, s, l) {
  var r, g, b;
  h2 = bound01(h2, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  function hue2rgb(p2, q2, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p2 + (q2 - p2) * 6 * t;
    if (t < 1 / 2)
      return q2;
    if (t < 2 / 3)
      return p2 + (q2 - p2) * (2 / 3 - t) * 6;
    return p2;
  }
  if (s === 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h2 + 1 / 3);
    g = hue2rgb(p, q, h2);
    b = hue2rgb(p, q, h2 - 1 / 3);
  }
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h2, s, v = max;
  var d = max - min;
  s = max === 0 ? 0 : d / max;
  if (max == min) {
    h2 = 0;
  } else {
    switch (max) {
      case r:
        h2 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h2 = (b - r) / d + 2;
        break;
      case b:
        h2 = (r - g) / d + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: h2,
    s,
    v
  };
}
function hsvToRgb(h2, s, v) {
  h2 = bound01(h2, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i2 = Math.floor(h2), f = h2 - i2, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod2 = i2 % 6, r = [v, q, p, p, t, v][mod2], g = [t, v, v, q, p, p][mod2], b = [p, p, t, v, v, q][mod2];
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHex(r, g, b, allow3Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r, g, b, a2, allow4Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a2))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function rgbaToArgbHex(r, g, b, a2) {
  var hex = [pad2(convertDecimalToHex(a2)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2)
    return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}
function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number;
  for (var i2 = 1;i2 < number; i2++) {
    result.push(tinycolor({
      h: (hsl.h + i2 * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h2 = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h2 + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h2 + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360;--results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var { h: h2, s, v } = hsv;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h2,
      s,
      v
    }));
    v = (v + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b,
    a: (rgb2.a - rgb1.a) * p + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c22 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c22.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c22.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i2 = 0;i2 < colorList.length; i2++) {
    readability = tinycolor.readability(baseColor, colorList[i2]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i2]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o2) {
  var flipped = {};
  for (var i2 in o2) {
    if (o2.hasOwnProperty(i2)) {
      flipped[o2[i2]] = i2;
    }
  }
  return flipped;
}
function boundAlpha(a2) {
  a2 = parseFloat(a2);
  if (isNaN(a2) || a2 < 0 || a2 > 1) {
    a2 = 1;
  }
  return a2;
}
function bound01(n2, max) {
  if (isOnePointZero(n2))
    n2 = "100%";
  var processPercent = isPercentage(n2);
  n2 = Math.min(max, Math.max(0, parseFloat(n2)));
  if (processPercent) {
    n2 = parseInt(n2 * max, 10) / 100;
  }
  if (Math.abs(n2 - max) < 0.000001) {
    return 1;
  }
  return n2 % max / parseFloat(max);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n2) {
  return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") != -1;
}
function pad2(c3) {
  return c3.length == 1 ? "0" + c3 : "" + c3;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    n2 = n2 * 100 + "%";
  }
  return n2;
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
}

// node_modules/@jimp/utils/dist/esm/index.js
function clone2(image3) {
  const newBitmap = {
    width: image3.bitmap.width,
    height: image3.bitmap.height,
    data: Buffer.from(image3.bitmap.data)
  };
  return new image3.constructor(newBitmap);
}
function scan(image3, xArg, yArg, wArg, hArg, cbArg) {
  let x;
  let y;
  let w;
  let h2;
  let cb;
  if (typeof xArg === "function") {
    cb = xArg;
    x = 0;
    y = 0;
    w = image3.bitmap.width;
    h2 = image3.bitmap.height;
  } else {
    x = xArg;
    if (typeof yArg !== "number")
      throw new Error("y must be a number");
    y = yArg;
    if (typeof wArg !== "number")
      throw new Error("w must be a number");
    w = wArg;
    if (typeof hArg !== "number")
      throw new Error("h must be a number");
    h2 = hArg;
    if (typeof cbArg !== "function")
      throw new Error("cb must be a function");
    cb = cbArg;
  }
  x = Math.round(x);
  y = Math.round(y);
  w = Math.round(w);
  h2 = Math.round(h2);
  const bound = cb.bind(image3);
  for (let _y = y;_y < y + h2; _y++) {
    for (let _x = x;_x < x + w; _x++) {
      const idx = image3.bitmap.width * _y + _x << 2;
      bound(_x, _y, idx);
    }
  }
  return image3;
}
function* scanIterator(image3, x, y, w, h2) {
  x = Math.round(x);
  y = Math.round(y);
  w = Math.round(w);
  h2 = Math.round(h2);
  for (let _y = y;_y < y + h2; _y++) {
    for (let _x = x;_x < x + w; _x++) {
      const idx = image3.bitmap.width * _y + _x << 2;
      yield { x: _x, y: _y, idx, image: image3 };
    }
  }
}
function intToRGBA(i2) {
  if (typeof i2 !== "number") {
    throw new Error("i must be a number");
  }
  const rgba = {
    r: 0,
    g: 0,
    b: 0,
    a: 0
  };
  rgba.r = Math.floor(i2 / Math.pow(256, 3));
  rgba.g = Math.floor((i2 - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
  rgba.b = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
  rgba.a = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
  return rgba;
}
function colorDiff(rgba1, rgba2) {
  const sq = (n2) => Math.pow(n2, 2);
  const { max } = Math;
  const maxVal = 255 * 255 * 3;
  const rgba1A = "a" in rgba1 ? rgba1.a : 255;
  const rgba2A = "a" in rgba2 ? rgba2.a : 255;
  return (max(sq(rgba1.r - rgba2.r), sq(rgba1.r - rgba2.r - rgba1A + rgba2A)) + max(sq(rgba1.g - rgba2.g), sq(rgba1.g - rgba2.g - rgba1A + rgba2A)) + max(sq(rgba1.b - rgba2.b), sq(rgba1.b - rgba2.b - rgba1A + rgba2A))) / maxVal;
}
function limit255(n2) {
  n2 = Math.max(n2, 0);
  n2 = Math.min(n2, 255);
  return n2;
}
function cssColorToHex(cssColor) {
  if (typeof cssColor === "number") {
    return cssColor;
  }
  return parseInt(tinycolor(cssColor).toHex8(), 16);
}

// node_modules/@jimp/js-bmp/dist/esm/index.js
function encode2(image3, options = {}) {
  scan({ bitmap: image3 }, 0, 0, image3.width, image3.height, function(_, __, index) {
    const red2 = image3.data[index + 0];
    const green2 = image3.data[index + 1];
    const blue2 = image3.data[index + 2];
    const alpha = image3.data[index + 3];
    image3.data[index + 0] = alpha;
    image3.data[index + 1] = blue2;
    image3.data[index + 2] = green2;
    image3.data[index + 3] = red2;
  });
  return encode({ ...image3, ...options }).data;
}
function decode2(data, options) {
  const result = decode(data, options);
  scan({ bitmap: result }, 0, 0, result.width, result.height, function(_, __, index) {
    const blue2 = result.data[index + 1];
    const green2 = result.data[index + 2];
    const red2 = result.data[index + 3];
    result.data[index + 0] = red2;
    result.data[index + 1] = green2;
    result.data[index + 2] = blue2;
    result.data[index + 3] = 255;
  });
  return result;
}
function msBmp() {
  return {
    mime: "image/x-ms-bmp",
    encode: encode2,
    decode: decode2
  };
}
function bmp() {
  return {
    mime: "image/bmp",
    encode: encode2,
    decode: decode2
  };
}

// node_modules/@jimp/js-gif/dist/esm/index.js
var import_omggif = __toESM(require_omggif(), 1);
var import_gifwrap = __toESM(require_src2(), 1);
function gif() {
  return {
    mime: "image/gif",
    encode: async (bitmap) => {
      const gif2 = new import_gifwrap.BitmapImage(bitmap);
      import_gifwrap.GifUtil.quantizeDekker(gif2, 256);
      const newFrame = new import_gifwrap.GifFrame(bitmap);
      const gifCodec = new import_gifwrap.GifCodec;
      const newGif = await gifCodec.encodeGif([newFrame], {});
      return newGif.buffer;
    },
    decode: (data) => {
      const gifObj = new import_omggif.default.GifReader(data);
      const gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);
      gifObj.decodeAndBlitFrameRGBA(0, gifData);
      return {
        data: gifData,
        width: gifObj.width,
        height: gifObj.height
      };
    }
  };
}

// node_modules/@jimp/js-jpeg/dist/esm/index.js
var import_jpeg_js = __toESM(require_jpeg_js(), 1);
function jpeg() {
  return {
    mime: "image/jpeg",
    encode: (bitmap, { quality: quality2 = 100 } = {}) => import_jpeg_js.default.encode(bitmap, quality2).data,
    decode: (data, options) => import_jpeg_js.default.decode(data, options)
  };
}

// node_modules/@jimp/js-png/dist/esm/index.js
var import_pngjs = __toESM(require_png(), 1);

// node_modules/@jimp/js-png/dist/esm/constants.js
var PNGFilterType;
(function(PNGFilterType2) {
  PNGFilterType2[PNGFilterType2["AUTO"] = -1] = "AUTO";
  PNGFilterType2[PNGFilterType2["NONE"] = 0] = "NONE";
  PNGFilterType2[PNGFilterType2["SUB"] = 1] = "SUB";
  PNGFilterType2[PNGFilterType2["UP"] = 2] = "UP";
  PNGFilterType2[PNGFilterType2["AVERAGE"] = 3] = "AVERAGE";
  PNGFilterType2[PNGFilterType2["PATH"] = 4] = "PATH";
})(PNGFilterType || (PNGFilterType = {}));
var PNGColorType;
(function(PNGColorType2) {
  PNGColorType2[PNGColorType2["GRAYSCALE"] = 0] = "GRAYSCALE";
  PNGColorType2[PNGColorType2["COLOR"] = 2] = "COLOR";
  PNGColorType2[PNGColorType2["GRAYSCALE_ALPHA"] = 4] = "GRAYSCALE_ALPHA";
  PNGColorType2[PNGColorType2["COLOR_ALPHA"] = 6] = "COLOR_ALPHA";
})(PNGColorType || (PNGColorType = {}));

// node_modules/@jimp/js-png/dist/esm/index.js
function png() {
  return {
    mime: "image/png",
    hasAlpha: true,
    encode: (bitmap, { deflateLevel = 9, deflateStrategy = 3, filterType = PNGFilterType.AUTO, colorType, inputHasAlpha = true, ...options } = {}) => {
      const png2 = new import_pngjs.PNG({
        width: bitmap.width,
        height: bitmap.height
      });
      png2.data = bitmap.data;
      return import_pngjs.PNG.sync.write(png2, {
        ...options,
        deflateLevel,
        deflateStrategy,
        filterType,
        colorType: typeof colorType !== "undefined" ? colorType : inputHasAlpha ? PNGColorType.COLOR_ALPHA : PNGColorType.COLOR,
        inputHasAlpha
      });
    },
    decode: (data, options) => {
      const result = import_pngjs.PNG.sync.read(data, options);
      return {
        data: result.data,
        width: result.width,
        height: result.height
      };
    }
  };
}

// node_modules/@jimp/js-tiff/dist/esm/index.js
var import_utif2 = __toESM(require_UTIF(), 1);
function getDimensionValue(dimension) {
  if (typeof dimension === "number") {
    return dimension;
  }
  if (dimension instanceof Uint8Array) {
    return dimension[0];
  }
  if (typeof dimension[0] === "string") {
    return parseInt(dimension[0]);
  }
  return dimension[0];
}
function tiff() {
  return {
    mime: "image/tiff",
    encode: (bitmap) => {
      const tiff2 = import_utif2.default.encodeImage(bitmap.data, bitmap.width, bitmap.height);
      return Buffer.from(tiff2);
    },
    decode: (data) => {
      const ifds = import_utif2.default.decode(data);
      const page = ifds[0];
      if (!page) {
        throw new Error("No page found in TIFF");
      }
      if (!page.t256) {
        throw new Error("No image width found in TIFF");
      }
      if (!page.t257) {
        throw new Error("No image height found in TIFF");
      }
      ifds.forEach((ifd) => {
        import_utif2.default.decodeImage(data, ifd);
      });
      const rgba = import_utif2.default.toRGBA8(page);
      return {
        data: Buffer.from(rgba),
        width: getDimensionValue(page.t256),
        height: getDimensionValue(page.t257)
      };
    }
  };
}

// node_modules/zod/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid2,
  isDirty: () => isDirty,
  isAsync: () => isAsync,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {};
  function assertIs(_arg) {}
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path: path8, errorMaps, issueData } = params;
  const fullPath = [...path8, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? undefined : en_default
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid2 = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path8, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path8;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult2 = (ctx, result) => {
  if (isValid2(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult2(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid2(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid2(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult2(ctx, result);
  }
  refine(check2, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex3;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex2 = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex2 = `${regex2}(${opts.join("|")})`;
  return new RegExp(`^${regex2}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex3) {
          emojiRegex3 = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex3.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex2 = datetimeRegex(check2);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "date") {
        const regex2 = dateRegex;
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "time") {
        const regex2 = timeRegex(check2);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "jwt") {
        if (!isValidJWT(input.data, check2.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cidr") {
        if (!isValidCidr(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data) => regex2.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {} else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a2, b) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b);
  if (a2 === b) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base2 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid2(base2))
          return INVALID;
        const result = effect.transform(base2.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
          if (!isValid2(base2))
            return INVALID;
          return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b) {
    return new ZodPipeline({
      in: a2,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid2(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check2, _params = {}, fatal) {
  if (check2)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check2(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
// node_modules/zod/index.js
var zod_default = exports_external;

// node_modules/@jimp/types/dist/esm/index.js
var Edge2;
(function(Edge3) {
  Edge3[Edge3["EXTEND"] = 1] = "EXTEND";
  Edge3[Edge3["WRAP"] = 2] = "WRAP";
  Edge3[Edge3["CROP"] = 3] = "CROP";
})(Edge2 || (Edge2 = {}));
var JimpClassSchema = exports_external.object({
  bitmap: exports_external.object({
    data: exports_external.union([exports_external.instanceof(Buffer), exports_external.instanceof(Uint8Array)]),
    width: exports_external.number(),
    height: exports_external.number()
  })
});

// node_modules/@jimp/plugin-blit/dist/esm/index.js
var BlitOptionsSchemaComplex = exports_external.object({
  src: JimpClassSchema,
  x: exports_external.number().optional(),
  y: exports_external.number().optional(),
  srcX: exports_external.number().optional(),
  srcY: exports_external.number().optional(),
  srcW: exports_external.number().optional(),
  srcH: exports_external.number().optional()
});
var BlitOptionsSchema = exports_external.union([JimpClassSchema, BlitOptionsSchemaComplex]);
var methods = {
  blit(image3, options) {
    const parsed = BlitOptionsSchema.parse(options);
    let {
      src,
      x = 0,
      y = 0,
      srcX = 0,
      srcY = 0,
      srcW = src.bitmap.width,
      srcH = src.bitmap.height
    } = "bitmap" in parsed ? { src: parsed } : parsed;
    if (!("bitmap" in src)) {
      throw new Error("The source must be a Jimp image");
    }
    if (typeof x !== "number" || typeof y !== "number") {
      throw new Error("x and y must be numbers");
    }
    x = Math.round(x);
    y = Math.round(y);
    srcX = Math.round(srcX);
    srcY = Math.round(srcY);
    srcW = Math.round(srcW);
    srcH = Math.round(srcH);
    const maxWidth = image3.bitmap.width;
    const maxHeight = image3.bitmap.height;
    scan(src, srcX, srcY, srcW, srcH, function(sx, sy, idx) {
      const xOffset = x + sx - srcX;
      const yOffset = y + sy - srcY;
      if (xOffset >= 0 && yOffset >= 0 && maxWidth - xOffset > 0 && maxHeight - yOffset > 0) {
        const dstIdx = image3.getPixelIndex(xOffset, yOffset);
        const srcColor = {
          r: src.bitmap.data[idx] || 0,
          g: src.bitmap.data[idx + 1] || 0,
          b: src.bitmap.data[idx + 2] || 0,
          a: src.bitmap.data[idx + 3] || 0
        };
        const dst = {
          r: image3.bitmap.data[dstIdx] || 0,
          g: image3.bitmap.data[dstIdx + 1] || 0,
          b: image3.bitmap.data[dstIdx + 2] || 0,
          a: image3.bitmap.data[dstIdx + 3] || 0
        };
        image3.bitmap.data[dstIdx] = (srcColor.a * (srcColor.r - dst.r) - dst.r + 255 >> 8) + dst.r;
        image3.bitmap.data[dstIdx + 1] = (srcColor.a * (srcColor.g - dst.g) - dst.g + 255 >> 8) + dst.g;
        image3.bitmap.data[dstIdx + 2] = (srcColor.a * (srcColor.b - dst.b) - dst.b + 255 >> 8) + dst.b;
        image3.bitmap.data[dstIdx + 3] = limit255(dst.a + srcColor.a);
      }
    });
    return image3;
  }
};

// node_modules/@jimp/plugin-blur/dist/esm/blur-tables.js
var mulTable = [
  1,
  57,
  41,
  21,
  203,
  34,
  97,
  73,
  227,
  91,
  149,
  62,
  105,
  45,
  39,
  137,
  241,
  107,
  3,
  173,
  39,
  71,
  65,
  238,
  219,
  101,
  187,
  87,
  81,
  151,
  141,
  133,
  249,
  117,
  221,
  209,
  197,
  187,
  177,
  169,
  5,
  153,
  73,
  139,
  133,
  127,
  243,
  233,
  223,
  107,
  103,
  99,
  191,
  23,
  177,
  171,
  165,
  159,
  77,
  149,
  9,
  139,
  135,
  131,
  253,
  245,
  119,
  231,
  224,
  109,
  211,
  103,
  25,
  195,
  189,
  23,
  45,
  175,
  171,
  83,
  81,
  79,
  155,
  151,
  147,
  9,
  141,
  137,
  67,
  131,
  129,
  251,
  123,
  30,
  235,
  115,
  113,
  221,
  217,
  53,
  13,
  51,
  50,
  49,
  193,
  189,
  185,
  91,
  179,
  175,
  43,
  169,
  83,
  163,
  5,
  79,
  155,
  19,
  75,
  147,
  145,
  143,
  35,
  69,
  17,
  67,
  33,
  65,
  255,
  251,
  247,
  243,
  239,
  59,
  29,
  229,
  113,
  111,
  219,
  27,
  213,
  105,
  207,
  51,
  201,
  199,
  49,
  193,
  191,
  47,
  93,
  183,
  181,
  179,
  11,
  87,
  43,
  85,
  167,
  165,
  163,
  161,
  159,
  157,
  155,
  77,
  19,
  75,
  37,
  73,
  145,
  143,
  141,
  35,
  138,
  137,
  135,
  67,
  33,
  131,
  129,
  255,
  63,
  250,
  247,
  61,
  121,
  239,
  237,
  117,
  29,
  229,
  227,
  225,
  111,
  55,
  109,
  216,
  213,
  211,
  209,
  207,
  205,
  203,
  201,
  199,
  197,
  195,
  193,
  48,
  190,
  47,
  93,
  185,
  183,
  181,
  179,
  178,
  176,
  175,
  173,
  171,
  85,
  21,
  167,
  165,
  41,
  163,
  161,
  5,
  79,
  157,
  78,
  154,
  153,
  19,
  75,
  149,
  74,
  147,
  73,
  144,
  143,
  71,
  141,
  140,
  139,
  137,
  17,
  135,
  134,
  133,
  66,
  131,
  65,
  129,
  1
];
var shgTable = [
  0,
  9,
  10,
  10,
  14,
  12,
  14,
  14,
  16,
  15,
  16,
  15,
  16,
  15,
  15,
  17,
  18,
  17,
  12,
  18,
  16,
  17,
  17,
  19,
  19,
  18,
  19,
  18,
  18,
  19,
  19,
  19,
  20,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  15,
  20,
  19,
  20,
  20,
  20,
  21,
  21,
  21,
  20,
  20,
  20,
  21,
  18,
  21,
  21,
  21,
  21,
  20,
  21,
  17,
  21,
  21,
  21,
  22,
  22,
  21,
  22,
  22,
  21,
  22,
  21,
  19,
  22,
  22,
  19,
  20,
  22,
  22,
  21,
  21,
  21,
  22,
  22,
  22,
  18,
  22,
  22,
  21,
  22,
  22,
  23,
  22,
  20,
  23,
  22,
  22,
  23,
  23,
  21,
  19,
  21,
  21,
  21,
  23,
  23,
  23,
  22,
  23,
  23,
  21,
  23,
  22,
  23,
  18,
  22,
  23,
  20,
  22,
  23,
  23,
  23,
  21,
  22,
  20,
  22,
  21,
  22,
  24,
  24,
  24,
  24,
  24,
  22,
  21,
  24,
  23,
  23,
  24,
  21,
  24,
  23,
  24,
  22,
  24,
  24,
  22,
  24,
  24,
  22,
  23,
  24,
  24,
  24,
  20,
  23,
  22,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  23,
  21,
  23,
  22,
  23,
  24,
  24,
  24,
  22,
  24,
  24,
  24,
  23,
  22,
  24,
  24,
  25,
  23,
  25,
  25,
  23,
  24,
  25,
  25,
  24,
  22,
  25,
  25,
  25,
  24,
  23,
  24,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  23,
  25,
  23,
  24,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  25,
  24,
  22,
  25,
  25,
  23,
  25,
  25,
  20,
  24,
  25,
  24,
  25,
  25,
  22,
  24,
  25,
  24,
  25,
  24,
  25,
  25,
  24,
  25,
  25,
  25,
  25,
  22,
  25,
  25,
  25,
  24,
  25,
  24,
  25,
  18
];

// node_modules/@jimp/plugin-blur/dist/esm/index.js
var methods2 = {
  blur(image3, r) {
    if (typeof r !== "number") {
      throw new Error("r must be a number");
    }
    if (r < 1) {
      throw new Error("r must be greater than 0");
    }
    let rsum;
    let gsum;
    let bsum;
    let asum;
    let x;
    let y;
    let i2;
    let p;
    let p1;
    let p2;
    let yp;
    let yi;
    let yw;
    const wm = image3.bitmap.width - 1;
    const hm = image3.bitmap.height - 1;
    const rad1 = r + 1;
    const mulSum = mulTable[r];
    const shgSum = shgTable[r];
    const red2 = [];
    const green2 = [];
    const blue2 = [];
    const alpha = [];
    const vmin = [];
    const vmax = [];
    let iterations = 2;
    while (iterations-- > 0) {
      yi = 0;
      yw = 0;
      for (y = 0;y < image3.bitmap.height; y++) {
        rsum = image3.bitmap.data[yw] * rad1;
        gsum = image3.bitmap.data[yw + 1] * rad1;
        bsum = image3.bitmap.data[yw + 2] * rad1;
        asum = image3.bitmap.data[yw + 3] * rad1;
        for (i2 = 1;i2 <= r; i2++) {
          p = yw + ((i2 > wm ? wm : i2) << 2);
          rsum += image3.bitmap.data[p++];
          gsum += image3.bitmap.data[p++];
          bsum += image3.bitmap.data[p++];
          asum += image3.bitmap.data[p];
        }
        for (x = 0;x < image3.bitmap.width; x++) {
          red2[yi] = rsum;
          green2[yi] = gsum;
          blue2[yi] = bsum;
          alpha[yi] = asum;
          if (y === 0) {
            vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2;
            vmax[x] = (p = x - r) > 0 ? p << 2 : 0;
          }
          p1 = yw + vmin[x];
          p2 = yw + vmax[x];
          rsum += image3.bitmap.data[p1++] - image3.bitmap.data[p2++];
          gsum += image3.bitmap.data[p1++] - image3.bitmap.data[p2++];
          bsum += image3.bitmap.data[p1++] - image3.bitmap.data[p2++];
          asum += image3.bitmap.data[p1] - image3.bitmap.data[p2++];
          yi++;
        }
        yw += image3.bitmap.width << 2;
      }
      for (x = 0;x < image3.bitmap.width; x++) {
        yp = x;
        rsum = red2[yp] * rad1;
        gsum = green2[yp] * rad1;
        bsum = blue2[yp] * rad1;
        asum = alpha[yp] * rad1;
        for (i2 = 1;i2 <= r; i2++) {
          yp += i2 > hm ? 0 : image3.bitmap.width;
          rsum += red2[yp];
          gsum += green2[yp];
          bsum += blue2[yp];
          asum += alpha[yp];
        }
        yi = x << 2;
        for (y = 0;y < image3.bitmap.height; y++) {
          image3.bitmap.data[yi] = limit255(rsum * mulSum >>> shgSum);
          image3.bitmap.data[yi + 1] = limit255(gsum * mulSum >>> shgSum);
          image3.bitmap.data[yi + 2] = limit255(bsum * mulSum >>> shgSum);
          image3.bitmap.data[yi + 3] = limit255(asum * mulSum >>> shgSum);
          if (x === 0) {
            vmin[y] = ((p = y + rad1) < hm ? p : hm) * image3.bitmap.width;
            vmax[y] = (p = y - r) > 0 ? p * image3.bitmap.width : 0;
          }
          p1 = x + vmin[y];
          p2 = x + vmax[y];
          rsum += red2[p1] - red2[p2];
          gsum += green2[p1] - green2[p2];
          bsum += blue2[p1] - blue2[p2];
          asum += alpha[p1] - alpha[p2];
          yi += image3.bitmap.width << 2;
        }
      }
    }
    return image3;
  },
  gaussian(image3, r) {
    if (typeof r !== "number") {
      throw new Error("r must be a number");
    }
    if (r < 1) {
      throw new Error("r must be greater than 0");
    }
    const rs = Math.ceil(r * 2.57);
    const range = rs * 2 + 1;
    const rr2 = r * r * 2;
    const rr2pi = rr2 * Math.PI;
    const weights = [];
    for (let y = 0;y < range; y++) {
      const weightsRow = [];
      for (let x = 0;x < range; x++) {
        const dsq = (x - rs) ** 2 + (y - rs) ** 2;
        weightsRow[x] = Math.exp(-dsq / rr2) / rr2pi;
      }
      weights.push(weightsRow);
    }
    for (let y = 0;y < image3.bitmap.height; y++) {
      for (let x = 0;x < image3.bitmap.width; x++) {
        let red2 = 0;
        let green2 = 0;
        let blue2 = 0;
        let alpha = 0;
        let wsum = 0;
        for (let iy = 0;iy < range; iy++) {
          for (let ix = 0;ix < range; ix++) {
            const x1 = Math.min(image3.bitmap.width - 1, Math.max(0, ix + x - rs));
            const y1 = Math.min(image3.bitmap.height - 1, Math.max(0, iy + y - rs));
            const weight = weights[iy][ix];
            const idx2 = y1 * image3.bitmap.width + x1 << 2;
            red2 += image3.bitmap.data[idx2] * weight;
            green2 += image3.bitmap.data[idx2 + 1] * weight;
            blue2 += image3.bitmap.data[idx2 + 2] * weight;
            alpha += image3.bitmap.data[idx2 + 3] * weight;
            wsum += weight;
          }
          const idx = y * image3.bitmap.width + x << 2;
          image3.bitmap.data[idx] = Math.round(red2 / wsum);
          image3.bitmap.data[idx + 1] = Math.round(green2 / wsum);
          image3.bitmap.data[idx + 2] = Math.round(blue2 / wsum);
          image3.bitmap.data[idx + 3] = Math.round(alpha / wsum);
        }
      }
    }
    return image3;
  }
};

// node_modules/@jimp/plugin-circle/dist/esm/index.js
var CircleOptionsSchema = exports_external.object({
  x: exports_external.number().optional(),
  y: exports_external.number().optional(),
  radius: exports_external.number().min(0).optional()
});
var methods3 = {
  circle(image3, options = {}) {
    const parsed = CircleOptionsSchema.parse(options);
    const radius = parsed.radius || (image3.bitmap.width > image3.bitmap.height ? image3.bitmap.height : image3.bitmap.width) / 2;
    const center = {
      x: typeof parsed.x === "number" ? parsed.x : image3.bitmap.width / 2,
      y: typeof parsed.y === "number" ? parsed.y : image3.bitmap.height / 2
    };
    image3.scan((x, y, idx) => {
      const curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));
      if (radius - curR <= 0) {
        image3.bitmap.data[idx + 3] = 0;
      } else if (radius - curR < 1) {
        image3.bitmap.data[idx + 3] = 255 * (radius - curR);
      }
    });
    return image3;
  }
};

// node_modules/@jimp/plugin-color/dist/esm/index.js
var ConvolutionMatrixSchema = exports_external.array(exports_external.number()).min(1).array();
var ConvolutionComplexOptionsSchema = exports_external.object({
  kernel: ConvolutionMatrixSchema,
  edgeHandling: exports_external.nativeEnum(Edge2).optional()
});
var ConvolutionOptionsSchema = exports_external.union([
  ConvolutionMatrixSchema,
  ConvolutionComplexOptionsSchema
]);
var ConvoluteComplexOptionsSchema = exports_external.object({
  kernel: ConvolutionMatrixSchema,
  x: exports_external.number().optional(),
  y: exports_external.number().optional(),
  w: exports_external.number().optional(),
  h: exports_external.number().optional()
});
var ConvoluteOptionsSchema = exports_external.union([
  ConvolutionMatrixSchema,
  ConvoluteComplexOptionsSchema
]);
var PixelateSize = exports_external.number().min(1).max(Infinity);
var PixelateComplexOptionsSchema = exports_external.object({
  size: PixelateSize,
  x: exports_external.number().optional(),
  y: exports_external.number().optional(),
  w: exports_external.number().optional(),
  h: exports_external.number().optional()
});
var PixelateOptionsSchema = exports_external.union([
  PixelateSize,
  PixelateComplexOptionsSchema
]);
function applyKernel(image3, kernel, x, y) {
  const value = [0, 0, 0, 0];
  const size = (kernel.length - 1) / 2;
  for (let kx = 0;kx < kernel.length; kx += 1) {
    for (let ky = 0;ky < kernel[kx].length; ky += 1) {
      const idx = image3.getPixelIndex(x + kx - size, y + ky - size);
      value[0] += image3.bitmap.data[idx] * kernel[kx][ky];
      value[1] += image3.bitmap.data[idx + 1] * kernel[kx][ky];
      value[2] += image3.bitmap.data[idx + 2] * kernel[kx][ky];
      value[3] += image3.bitmap.data[idx + 3] * kernel[kx][ky];
    }
  }
  return value;
}
function mix(clr, clr2, p = 50) {
  return {
    r: (clr2.r - clr.r) * (p / 100) + clr.r,
    g: (clr2.g - clr.g) * (p / 100) + clr.g,
    b: (clr2.b - clr.b) * (p / 100) + clr.b
  };
}
var HueActionSchema = exports_external.object({
  apply: exports_external.literal("hue"),
  params: exports_external.tuple([exports_external.number().min(-360).max(360)])
});
var SpinActionSchema = exports_external.object({
  apply: exports_external.literal("spin"),
  params: exports_external.tuple([exports_external.number().min(-360).max(360)])
});
var LightenActionSchema = exports_external.object({
  apply: exports_external.literal("lighten"),
  params: exports_external.tuple([exports_external.number().min(0).max(100)]).optional()
});
var RGBColorSchema = exports_external.object({
  r: exports_external.number().min(0).max(255),
  g: exports_external.number().min(0).max(255),
  b: exports_external.number().min(0).max(255)
});
var MixActionSchema = exports_external.object({
  apply: exports_external.literal("mix"),
  params: exports_external.union([
    exports_external.tuple([RGBColorSchema]),
    exports_external.tuple([RGBColorSchema, exports_external.number().min(0).max(100)])
  ])
});
var TintActionSchema = exports_external.object({
  apply: exports_external.literal("tint"),
  params: exports_external.tuple([exports_external.number().min(0).max(100)]).optional()
});
var ShadeActionSchema = exports_external.object({
  apply: exports_external.literal("shade"),
  params: exports_external.tuple([exports_external.number().min(0).max(100)]).optional()
});
var XorActionSchema = exports_external.object({
  apply: exports_external.literal("xor"),
  params: exports_external.tuple([RGBColorSchema])
});
var RedActionSchema = exports_external.object({
  apply: exports_external.literal("red"),
  params: exports_external.tuple([exports_external.number().min(-255).max(255)])
});
var GreenActionSchema = exports_external.object({
  apply: exports_external.literal("green"),
  params: exports_external.tuple([exports_external.number().min(-255).max(255)])
});
var BlueActionSchema = exports_external.object({
  apply: exports_external.literal("blue"),
  params: exports_external.tuple([exports_external.number().min(-255).max(255)])
});
var BrightenActionSchema = exports_external.object({
  apply: exports_external.literal("brighten"),
  params: exports_external.tuple([exports_external.number().min(0).max(100)]).optional()
});
var DarkenActionSchema = exports_external.object({
  apply: exports_external.literal("darken"),
  params: exports_external.tuple([exports_external.number().min(0).max(100)]).optional()
});
var DesaturateActionSchema = exports_external.object({
  apply: exports_external.literal("desaturate"),
  params: exports_external.tuple([exports_external.number().min(0).max(100)]).optional()
});
var SaturateActionSchema = exports_external.object({
  apply: exports_external.literal("saturate"),
  params: exports_external.tuple([exports_external.number().min(0).max(100)]).optional()
});
var GrayscaleActionSchema = exports_external.object({
  apply: exports_external.literal("greyscale"),
  params: exports_external.tuple([]).optional()
});
var ColorActionNameSchema = exports_external.union([
  HueActionSchema,
  SpinActionSchema,
  LightenActionSchema,
  MixActionSchema,
  TintActionSchema,
  ShadeActionSchema,
  XorActionSchema,
  RedActionSchema,
  GreenActionSchema,
  BlueActionSchema,
  BrightenActionSchema,
  DarkenActionSchema,
  DesaturateActionSchema,
  SaturateActionSchema,
  GrayscaleActionSchema
]);
var ColorActionName = Object.freeze({
  LIGHTEN: "lighten",
  BRIGHTEN: "brighten",
  DARKEN: "darken",
  DESATURATE: "desaturate",
  SATURATE: "saturate",
  GREYSCALE: "greyscale",
  SPIN: "spin",
  HUE: "hue",
  MIX: "mix",
  TINT: "tint",
  SHADE: "shade",
  XOR: "xor",
  RED: "red",
  GREEN: "green",
  BLUE: "blue"
});
function histogram(image3) {
  const histogram2 = {
    r: new Array(256).fill(0),
    g: new Array(256).fill(0),
    b: new Array(256).fill(0)
  };
  image3.scan((_, __, index) => {
    histogram2.r[image3.bitmap.data[index + 0]]++;
    histogram2.g[image3.bitmap.data[index + 1]]++;
    histogram2.b[image3.bitmap.data[index + 2]]++;
  });
  return histogram2;
}
var normalizeValue = function(value, min, max) {
  return (value - min) * 255 / (max - min);
};
var getBounds = function(histogramChannel) {
  return [
    histogramChannel.findIndex((value) => value > 0),
    255 - histogramChannel.slice().reverse().findIndex((value) => value > 0)
  ];
};
var methods4 = {
  normalize(image3) {
    const h2 = histogram(image3);
    const bounds = {
      r: getBounds(h2.r),
      g: getBounds(h2.g),
      b: getBounds(h2.b)
    };
    image3.scan((_, __, idx) => {
      const r = image3.bitmap.data[idx + 0];
      const g = image3.bitmap.data[idx + 1];
      const b = image3.bitmap.data[idx + 2];
      image3.bitmap.data[idx + 0] = normalizeValue(r, bounds.r[0], bounds.r[1]);
      image3.bitmap.data[idx + 1] = normalizeValue(g, bounds.g[0], bounds.g[1]);
      image3.bitmap.data[idx + 2] = normalizeValue(b, bounds.b[0], bounds.b[1]);
    });
    return image3;
  },
  invert(image3) {
    image3.scan((_, __, idx) => {
      image3.bitmap.data[idx] = 255 - image3.bitmap.data[idx];
      image3.bitmap.data[idx + 1] = 255 - image3.bitmap.data[idx + 1];
      image3.bitmap.data[idx + 2] = 255 - image3.bitmap.data[idx + 2];
    });
    return image3;
  },
  brightness(image3, val) {
    if (typeof val !== "number") {
      throw new Error("val must be numbers");
    }
    image3.scan((_, __, idx) => {
      image3.bitmap.data[idx] = limit255(image3.bitmap.data[idx] * val);
      image3.bitmap.data[idx + 1] = limit255(image3.bitmap.data[idx + 1] * val);
      image3.bitmap.data[idx + 2] = limit255(image3.bitmap.data[idx + 2] * val);
    });
    return image3;
  },
  contrast(image3, val) {
    if (typeof val !== "number") {
      throw new Error("val must be numbers");
    }
    if (val < -1 || val > 1) {
      throw new Error("val must be a number between -1 and +1");
    }
    const factor = (val + 1) / (1 - val);
    function adjust(value) {
      value = Math.floor(factor * (value - 127) + 127);
      return value < 0 ? 0 : value > 255 ? 255 : value;
    }
    image3.scan((_, __, idx) => {
      image3.bitmap.data[idx] = adjust(image3.bitmap.data[idx]);
      image3.bitmap.data[idx + 1] = adjust(image3.bitmap.data[idx + 1]);
      image3.bitmap.data[idx + 2] = adjust(image3.bitmap.data[idx + 2]);
    });
    return image3;
  },
  posterize(image3, n2) {
    if (typeof n2 !== "number") {
      throw new Error("n must be numbers");
    }
    if (n2 < 2) {
      n2 = 2;
    }
    image3.scan((_, __, idx) => {
      const r = image3.bitmap.data[idx];
      const g = image3.bitmap.data[idx + 1];
      const b = image3.bitmap.data[idx + 2];
      image3.bitmap.data[idx] = Math.floor(r / 255 * (n2 - 1)) / (n2 - 1) * 255;
      image3.bitmap.data[idx + 1] = Math.floor(g / 255 * (n2 - 1)) / (n2 - 1) * 255;
      image3.bitmap.data[idx + 2] = Math.floor(b / 255 * (n2 - 1)) / (n2 - 1) * 255;
    });
    return image3;
  },
  greyscale(image3) {
    image3.scan((_, __, idx) => {
      const grey = 0.2126 * image3.bitmap.data[idx] + 0.7152 * image3.bitmap.data[idx + 1] + 0.0722 * image3.bitmap.data[idx + 2];
      image3.bitmap.data[idx] = grey;
      image3.bitmap.data[idx + 1] = grey;
      image3.bitmap.data[idx + 2] = grey;
    });
    return image3;
  },
  opacity(image3, f) {
    if (typeof f !== "number") {
      throw new Error("f must be a number");
    }
    if (f < 0 || f > 1) {
      throw new Error("f must be a number from 0 to 1");
    }
    image3.scan((_, __, idx) => {
      const v = image3.bitmap.data[idx + 3] * f;
      image3.bitmap.data[idx + 3] = v;
    });
    return image3;
  },
  sepia(image3) {
    image3.scan((_, __, idx) => {
      let red2 = image3.bitmap.data[idx];
      let green2 = image3.bitmap.data[idx + 1];
      let blue2 = image3.bitmap.data[idx + 2];
      red2 = red2 * 0.393 + green2 * 0.769 + blue2 * 0.189;
      green2 = red2 * 0.349 + green2 * 0.686 + blue2 * 0.168;
      blue2 = red2 * 0.272 + green2 * 0.534 + blue2 * 0.131;
      image3.bitmap.data[idx] = red2 < 255 ? red2 : 255;
      image3.bitmap.data[idx + 1] = green2 < 255 ? green2 : 255;
      image3.bitmap.data[idx + 2] = blue2 < 255 ? blue2 : 255;
    });
    return image3;
  },
  fade(image3, f) {
    if (typeof f !== "number") {
      throw new Error("f must be a number");
    }
    if (f < 0 || f > 1) {
      throw new Error("f must be a number from 0 to 1");
    }
    return this.opacity(image3, 1 - f);
  },
  convolution(image3, options) {
    const parsed = ConvolutionOptionsSchema.parse(options);
    const { kernel, edgeHandling = Edge2.EXTEND } = "kernel" in parsed ? parsed : { kernel: parsed, edgeHandling: undefined };
    if (!kernel[0]) {
      throw new Error("kernel must be a matrix");
    }
    const newData = Buffer.from(image3.bitmap.data);
    const kRows = kernel.length;
    const kCols = kernel[0].length;
    const rowEnd = Math.floor(kRows / 2);
    const colEnd = Math.floor(kCols / 2);
    const rowIni = -rowEnd;
    const colIni = -colEnd;
    let weight;
    let rSum;
    let gSum;
    let bSum;
    let ri;
    let gi;
    let bi;
    let xi;
    let yi;
    let idxi;
    image3.scan((x, y, idx) => {
      bSum = 0;
      gSum = 0;
      rSum = 0;
      for (let row = rowIni;row <= rowEnd; row++) {
        for (let col = colIni;col <= colEnd; col++) {
          xi = x + col;
          yi = y + row;
          weight = kernel[row + rowEnd][col + colEnd];
          idxi = image3.getPixelIndex(xi, yi, edgeHandling);
          if (idxi === -1) {
            bi = 0;
            gi = 0;
            ri = 0;
          } else {
            ri = image3.bitmap.data[idxi + 0];
            gi = image3.bitmap.data[idxi + 1];
            bi = image3.bitmap.data[idxi + 2];
          }
          rSum += weight * ri;
          gSum += weight * gi;
          bSum += weight * bi;
        }
      }
      if (rSum < 0) {
        rSum = 0;
      }
      if (gSum < 0) {
        gSum = 0;
      }
      if (bSum < 0) {
        bSum = 0;
      }
      if (rSum > 255) {
        rSum = 255;
      }
      if (gSum > 255) {
        gSum = 255;
      }
      if (bSum > 255) {
        bSum = 255;
      }
      newData[idx + 0] = rSum;
      newData[idx + 1] = gSum;
      newData[idx + 2] = bSum;
    });
    image3.bitmap.data = newData;
    return image3;
  },
  opaque(image3) {
    image3.scan((_, __, idx) => {
      image3.bitmap.data[idx + 3] = 255;
    });
    return image3;
  },
  pixelate(image3, options) {
    const parsed = PixelateOptionsSchema.parse(options);
    const { size, x = 0, y = 0, w = image3.bitmap.width - x, h: h2 = image3.bitmap.height - y } = typeof parsed === "number" ? { size: parsed } : parsed;
    const kernel = [
      [1 / 16, 2 / 16, 1 / 16],
      [2 / 16, 4 / 16, 2 / 16],
      [1 / 16, 2 / 16, 1 / 16]
    ];
    const source = clone2(image3);
    scan(source, x, y, w, h2, (xx, yx, idx) => {
      xx = size * Math.floor(xx / size);
      yx = size * Math.floor(yx / size);
      const value = applyKernel(source, kernel, xx, yx);
      image3.bitmap.data[idx] = value[0];
      image3.bitmap.data[idx + 1] = value[1];
      image3.bitmap.data[idx + 2] = value[2];
      image3.bitmap.data[idx + 3] = value[3];
    });
    return image3;
  },
  convolute(image3, options) {
    const parsed = ConvoluteOptionsSchema.parse(options);
    const { kernel, x = 0, y = 0, w = image3.bitmap.width - x, h: h2 = image3.bitmap.height - y } = "kernel" in parsed ? parsed : { kernel: parsed };
    const source = clone2(image3);
    scan(source, x, y, w, h2, (xx, yx, idx) => {
      const value = applyKernel(source, kernel, xx, yx);
      image3.bitmap.data[idx] = limit255(value[0]);
      image3.bitmap.data[idx + 1] = limit255(value[1]);
      image3.bitmap.data[idx + 2] = limit255(value[2]);
      image3.bitmap.data[idx + 3] = limit255(value[3]);
    });
    return image3;
  },
  color(image3, actions) {
    if (!actions || !Array.isArray(actions)) {
      throw new Error("actions must be an array");
    }
    actions.forEach((action) => ColorActionNameSchema.parse(action));
    actions = actions.map((action) => {
      if (action.apply === "xor" || action.apply === "mix") {
        action.params[0] = tinycolor(action.params[0]).toRgb();
      }
      return action;
    });
    image3.scan((_, __, idx) => {
      let clr = {
        r: image3.bitmap.data[idx],
        g: image3.bitmap.data[idx + 1],
        b: image3.bitmap.data[idx + 2]
      };
      const colorModifier = (i2, amount) => limit255(clr[i2] + amount);
      actions.forEach((action) => {
        if (action.apply === "mix") {
          clr = mix(clr, action.params[0], action.params[1]);
        } else if (action.apply === "tint") {
          clr = mix(clr, { r: 255, g: 255, b: 255 }, action.params?.[0]);
        } else if (action.apply === "shade") {
          clr = mix(clr, { r: 0, g: 0, b: 0 }, action.params?.[0]);
        } else if (action.apply === "xor") {
          clr = {
            r: clr.r ^ action.params[0].r,
            g: clr.g ^ action.params[0].g,
            b: clr.b ^ action.params[0].b
          };
        } else if (action.apply === "red") {
          clr.r = colorModifier("r", action.params[0]);
        } else if (action.apply === "green") {
          clr.g = colorModifier("g", action.params[0]);
        } else if (action.apply === "blue") {
          clr.b = colorModifier("b", action.params[0]);
        } else {
          if (action.apply === "hue") {
            action.apply = "spin";
          }
          const tnyClr = tinycolor(clr);
          const fn = tnyClr[action.apply].bind(tnyClr);
          if (!fn) {
            throw new Error("action " + action.apply + " not supported");
          }
          clr = fn(...action.params || []).toRgb();
        }
      });
      image3.bitmap.data[idx] = clr.r;
      image3.bitmap.data[idx + 1] = clr.g;
      image3.bitmap.data[idx + 2] = clr.b;
    });
    return image3;
  }
};

// node_modules/@jimp/core/dist/esm/index.js
var import_core2 = __toESM(require_core2(), 1);
var import_await_to_js = __toESM(require_await_to_js_umd(), 1);

// node_modules/@jimp/file-ops/dist/esm/index.js
import { promises as fs5 } from "fs";
import { existsSync as existsSync2 } from "fs";
var readFile = fs5.readFile;
var writeFile = fs5.writeFile;

// node_modules/@jimp/core/dist/esm/index.js
var import_lite = __toESM(require_lite(), 1);

// node_modules/@jimp/core/dist/esm/utils/constants.js
var HorizontalAlign;
(function(HorizontalAlign2) {
  HorizontalAlign2[HorizontalAlign2["LEFT"] = 1] = "LEFT";
  HorizontalAlign2[HorizontalAlign2["CENTER"] = 2] = "CENTER";
  HorizontalAlign2[HorizontalAlign2["RIGHT"] = 4] = "RIGHT";
})(HorizontalAlign || (HorizontalAlign = {}));
var VerticalAlign;
(function(VerticalAlign2) {
  VerticalAlign2[VerticalAlign2["TOP"] = 8] = "TOP";
  VerticalAlign2[VerticalAlign2["MIDDLE"] = 16] = "MIDDLE";
  VerticalAlign2[VerticalAlign2["BOTTOM"] = 32] = "BOTTOM";
})(VerticalAlign || (VerticalAlign = {}));
var BlendMode;
(function(BlendMode2) {
  BlendMode2["SRC_OVER"] = "srcOver";
  BlendMode2["DST_OVER"] = "dstOver";
  BlendMode2["MULTIPLY"] = "multiply";
  BlendMode2["ADD"] = "add";
  BlendMode2["SCREEN"] = "screen";
  BlendMode2["OVERLAY"] = "overlay";
  BlendMode2["DARKEN"] = "darken";
  BlendMode2["LIGHTEN"] = "lighten";
  BlendMode2["HARD_LIGHT"] = "hardLight";
  BlendMode2["DIFFERENCE"] = "difference";
  BlendMode2["EXCLUSION"] = "exclusion";
})(BlendMode || (BlendMode = {}));

// node_modules/@jimp/core/dist/esm/utils/composite-modes.js
var exports_composite_modes = {};
__export(exports_composite_modes, {
  srcOver: () => srcOver,
  screen: () => screen,
  overlay: () => overlay,
  names: () => names2,
  multiply: () => multiply,
  lighten: () => lighten2,
  hardLight: () => hardLight,
  exclusion: () => exclusion,
  dstOver: () => dstOver,
  difference: () => difference,
  darken: () => darken2,
  add: () => add
});
function srcOver(src, dst, ops = 1) {
  src.a *= ops;
  const a2 = dst.a + src.a - dst.a * src.a;
  const r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a2;
  const g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a2;
  const b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a2;
  return { r, g, b, a: a2 };
}
function dstOver(src, dst, ops = 1) {
  src.a *= ops;
  const a2 = dst.a + src.a - dst.a * src.a;
  const r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a2;
  const g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a2;
  const b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a2;
  return { r, g, b, a: a2 };
}
function multiply(src, dst, ops = 1) {
  src.a *= ops;
  const a2 = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a2;
  const g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a2;
  const b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a2;
  return { r, g, b, a: a2 };
}
function add(src, dst, ops = 1) {
  src.a *= ops;
  const a2 = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra + dra) / a2;
  const g = (sga + dga) / a2;
  const b = (sba + dba) / a2;
  return { r, g, b, a: a2 };
}
function screen(src, dst, ops = 1) {
  src.a *= ops;
  const a2 = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra * dst.a + dra * src.a - sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a2;
  const g = (sga * dst.a + dga * src.a - sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a2;
  const b = (sba * dst.a + dba * src.a - sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a2;
  return { r, g, b, a: a2 };
}
function overlay(src, dst, ops = 1) {
  src.a *= ops;
  const a2 = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (2 * dra <= dst.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a2;
  const g = (2 * dga <= dst.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a2;
  const b = (2 * dba <= dst.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a2;
  return { r, g, b, a: a2 };
}
function darken2(src, dst, ops = 1) {
  src.a *= ops;
  const a2 = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (Math.min(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a2;
  const g = (Math.min(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a2;
  const b = (Math.min(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a2;
  return { r, g, b, a: a2 };
}
function lighten2(src, dst, ops = 1) {
  src.a *= ops;
  const a2 = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (Math.max(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a2;
  const g = (Math.max(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a2;
  const b = (Math.max(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a2;
  return { r, g, b, a: a2 };
}
function hardLight(src, dst, ops = 1) {
  src.a *= ops;
  const a2 = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (2 * sra <= src.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a2;
  const g = (2 * sga <= src.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a2;
  const b = (2 * sba <= src.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a2;
  return { r, g, b, a: a2 };
}
function difference(src, dst, ops = 1) {
  src.a *= ops;
  const a2 = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a2;
  const g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a2;
  const b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a2;
  return { r, g, b, a: a2 };
}
function exclusion(src, dst, ops = 1) {
  src.a *= ops;
  const a2 = dst.a + src.a - dst.a * src.a;
  const sra = src.r * src.a;
  const sga = src.g * src.a;
  const sba = src.b * src.a;
  const dra = dst.r * dst.a;
  const dga = dst.g * dst.a;
  const dba = dst.b * dst.a;
  const r = (sra * dst.a + dra * src.a - 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a2;
  const g = (sga * dst.a + dga * src.a - 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a2;
  const b = (sba * dst.a + dba * src.a - 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a2;
  return { r, g, b, a: a2 };
}
var names2 = [
  srcOver,
  dstOver,
  multiply,
  add,
  screen,
  overlay,
  darken2,
  lighten2,
  hardLight,
  difference,
  exclusion
];

// node_modules/@jimp/core/dist/esm/utils/composite.js
function composite(baseImage, src, x = 0, y = 0, options = {}) {
  if (!(src instanceof baseImage.constructor)) {
    throw new Error("The source must be a Jimp image");
  }
  if (typeof x !== "number" || typeof y !== "number") {
    throw new Error("x and y must be numbers");
  }
  const { mode = BlendMode.SRC_OVER } = options;
  let { opacitySource = 1, opacityDest = 1 } = options;
  if (typeof opacitySource !== "number" || opacitySource < 0 || opacitySource > 1) {
    opacitySource = 1;
  }
  if (typeof opacityDest !== "number" || opacityDest < 0 || opacityDest > 1) {
    opacityDest = 1;
  }
  const blendmode = exports_composite_modes[mode];
  x = Math.round(x);
  y = Math.round(y);
  if (opacityDest !== 1) {
    baseImage.scan((_, __, idx) => {
      const v = baseImage.bitmap.data[idx + 3] * opacityDest;
      baseImage.bitmap.data[idx + 3] = v;
    });
  }
  src.scan((sx, sy, idx) => {
    const dstIdx = baseImage.getPixelIndex(x + sx, y + sy, Edge2.CROP);
    if (dstIdx === -1) {
      return;
    }
    const blended = blendmode({
      r: src.bitmap.data[idx + 0] / 255,
      g: src.bitmap.data[idx + 1] / 255,
      b: src.bitmap.data[idx + 2] / 255,
      a: src.bitmap.data[idx + 3] / 255
    }, {
      r: baseImage.bitmap.data[dstIdx + 0] / 255,
      g: baseImage.bitmap.data[dstIdx + 1] / 255,
      b: baseImage.bitmap.data[dstIdx + 2] / 255,
      a: baseImage.bitmap.data[dstIdx + 3] / 255
    }, opacitySource);
    baseImage.bitmap.data[dstIdx + 0] = limit255(blended.r * 255);
    baseImage.bitmap.data[dstIdx + 1] = limit255(blended.g * 255);
    baseImage.bitmap.data[dstIdx + 2] = limit255(blended.b * 255);
    baseImage.bitmap.data[dstIdx + 3] = limit255(blended.a * 255);
  });
  return baseImage;
}

// node_modules/@jimp/core/dist/esm/utils/image-bitmap.js
var import_exif_parser = __toESM(require_exif_parser(), 1);
function getExifOrientation(img) {
  const _exif = img._exif;
  return _exif && _exif.tags && _exif.tags.Orientation || 1;
}
function getExifOrientationTransformation(img) {
  const w = img.bitmap.width;
  const h2 = img.bitmap.height;
  switch (getExifOrientation(img)) {
    case 1:
      return null;
    case 2:
      return function(x, y) {
        return [w - x - 1, y];
      };
    case 3:
      return function(x, y) {
        return [w - x - 1, h2 - y - 1];
      };
    case 4:
      return function(x, y) {
        return [x, h2 - y - 1];
      };
    case 5:
      return function(x, y) {
        return [y, x];
      };
    case 6:
      return function(x, y) {
        return [y, h2 - x - 1];
      };
    case 7:
      return function(x, y) {
        return [w - y - 1, h2 - x - 1];
      };
    case 8:
      return function(x, y) {
        return [w - y - 1, x];
      };
    default:
      return null;
  }
}
function transformBitmap(img, width, height, transformation) {
  const _data = img.bitmap.data;
  const _width = img.bitmap.width;
  const data = Buffer.alloc(_data.length);
  for (let x = 0;x < width; x++) {
    for (let y = 0;y < height; y++) {
      const [_x, _y] = transformation(x, y);
      const idx = width * y + x << 2;
      const _idx = _width * _y + _x << 2;
      const pixel = _data.readUInt32BE(_idx);
      data.writeUInt32BE(pixel, idx);
    }
  }
  img.bitmap.data = data;
  img.bitmap.width = width;
  img.bitmap.height = height;
  img._exif.tags.Orientation = 1;
}
function exifRotate(img) {
  if (getExifOrientation(img) < 2) {
    return;
  }
  const transformation = getExifOrientationTransformation(img);
  const swapDimensions = getExifOrientation(img) > 4;
  const newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;
  const newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;
  if (transformation) {
    transformBitmap(img, newWidth, newHeight, transformation);
  }
}
async function attemptExifRotate(image3, buffer) {
  try {
    image3._exif = import_exif_parser.default.create(buffer).parse();
    exifRotate(image3);
  } catch {}
}

// node_modules/@jimp/core/dist/esm/index.js
var emptyBitmap = {
  data: Buffer.alloc(0),
  width: 0,
  height: 0
};
function bufferFromArrayBuffer(arrayBuffer) {
  const buffer = Buffer.alloc(arrayBuffer.byteLength);
  const view = new Uint8Array(arrayBuffer);
  for (let i2 = 0;i2 < buffer.length; ++i2) {
    buffer[i2] = view[i2];
  }
  return buffer;
}
function createJimp({ plugins: pluginsArg, formats: formatsArg } = {}) {
  const plugins = pluginsArg || [];
  const formats = (formatsArg || []).map((format2) => format2());
  const CustomJimp = class Jimp {
    bitmap = emptyBitmap;
    background = 0;
    formats = [];
    mime;
    constructor(options = emptyBitmap) {
      this.formats = formats;
      if ("data" in options) {
        this.bitmap = options;
      } else {
        this.bitmap = {
          data: Buffer.alloc(options.width * options.height * 4),
          width: options.width,
          height: options.height
        };
        if (options.color) {
          this.background = typeof options.color === "string" ? cssColorToHex(options.color) : options.color;
          for (let i2 = 0;i2 < this.bitmap.data.length; i2 += 4) {
            this.bitmap.data.writeUInt32BE(this.background, i2);
          }
        }
      }
      for (const methods5 of plugins) {
        for (const key in methods5) {
          this[key] = (...args) => {
            const result = methods5[key]?.(this, ...args);
            if (typeof result === "object" && "bitmap" in result) {
              this.bitmap = result.bitmap;
              return this;
            }
            return result;
          };
        }
      }
    }
    static async read(url, options) {
      if (Buffer.isBuffer(url) || url instanceof ArrayBuffer) {
        return this.fromBuffer(url);
      }
      if (existsSync2(url)) {
        return this.fromBuffer(await readFile(url));
      }
      const [fetchErr, response] = await import_await_to_js.to(fetch(url));
      if (fetchErr) {
        throw new Error(`Could not load Buffer from URL: ${url}`);
      }
      if (!response.ok) {
        throw new Error(`HTTP Status ${response.status} for url ${url}`);
      }
      const [arrayBufferErr, data] = await import_await_to_js.to(response.arrayBuffer());
      if (arrayBufferErr) {
        throw new Error(`Could not load Buffer from ${url}`);
      }
      const buffer = bufferFromArrayBuffer(data);
      return this.fromBuffer(buffer, options);
    }
    static fromBitmap(bitmap) {
      let data;
      if (bitmap.data instanceof Buffer) {
        data = Buffer.from(bitmap.data);
      }
      if (bitmap.data instanceof Uint8Array || bitmap.data instanceof Uint8ClampedArray) {
        data = Buffer.from(bitmap.data.buffer);
      }
      if (Array.isArray(bitmap.data)) {
        data = Buffer.concat(bitmap.data.map((hex) => Buffer.from(hex.toString(16).padStart(8, "0"), "hex")));
      }
      if (!data) {
        throw new Error("data must be a Buffer");
      }
      if (typeof bitmap.height !== "number" || typeof bitmap.width !== "number") {
        throw new Error("bitmap must have width and height");
      }
      return new CustomJimp({
        height: bitmap.height,
        width: bitmap.width,
        data
      });
    }
    static async fromBuffer(buffer, options) {
      const actualBuffer = buffer instanceof ArrayBuffer ? bufferFromArrayBuffer(buffer) : buffer;
      const mime2 = await import_core2.default.fromBuffer(actualBuffer);
      if (!mime2 || !mime2.mime) {
        throw new Error("Could not find MIME for Buffer");
      }
      const format2 = formats.find((format3) => format3.mime === mime2.mime);
      if (!format2 || !format2.decode) {
        throw new Error(`Mime type ${mime2.mime} does not support decoding`);
      }
      const image3 = new CustomJimp(await format2.decode(actualBuffer, options?.[format2.mime]));
      image3.mime = mime2.mime;
      attemptExifRotate(image3, actualBuffer);
      return image3;
    }
    inspect() {
      return "<Jimp " + (this.bitmap === emptyBitmap ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
    }
    toString() {
      return "[object Jimp]";
    }
    get width() {
      return this.bitmap.width;
    }
    get height() {
      return this.bitmap.height;
    }
    async getBuffer(mime2, options) {
      const format2 = this.formats.find((format3) => format3.mime === mime2);
      if (!format2 || !format2.encode) {
        throw new Error(`Unsupported MIME type: ${mime2}`);
      }
      let outputImage;
      if (format2.hasAlpha) {
        outputImage = this;
      } else {
        outputImage = new CustomJimp({
          width: this.bitmap.width,
          height: this.bitmap.height,
          color: this.background
        });
        composite(outputImage, this);
      }
      return format2.encode(outputImage.bitmap, options);
    }
    async getBase64(mime2, options) {
      const data = await this.getBuffer(mime2, options);
      return "data:" + mime2 + ";base64," + data.toString("base64");
    }
    async write(path8, options) {
      const mimeType = import_lite.default.getType(path8);
      await writeFile(path8, await this.getBuffer(mimeType, options));
    }
    clone() {
      return new CustomJimp({
        ...this.bitmap,
        data: Buffer.from(this.bitmap.data)
      });
    }
    getPixelIndex(x, y, edgeHandling) {
      let xi;
      let yi;
      if (!edgeHandling) {
        edgeHandling = Edge2.EXTEND;
      }
      if (typeof x !== "number" || typeof y !== "number") {
        throw new Error("x and y must be numbers");
      }
      x = Math.round(x);
      y = Math.round(y);
      xi = x;
      yi = y;
      if (edgeHandling === Edge2.EXTEND) {
        if (x < 0)
          xi = 0;
        if (x >= this.bitmap.width)
          xi = this.bitmap.width - 1;
        if (y < 0)
          yi = 0;
        if (y >= this.bitmap.height)
          yi = this.bitmap.height - 1;
      }
      if (edgeHandling === Edge2.WRAP) {
        if (x < 0) {
          xi = this.bitmap.width + x;
        }
        if (x >= this.bitmap.width) {
          xi = x % this.bitmap.width;
        }
        if (y < 0) {
          yi = this.bitmap.height + y;
        }
        if (y >= this.bitmap.height) {
          yi = y % this.bitmap.height;
        }
      }
      let i2 = this.bitmap.width * yi + xi << 2;
      if (xi < 0 || xi >= this.bitmap.width) {
        i2 = -1;
      }
      if (yi < 0 || yi >= this.bitmap.height) {
        i2 = -1;
      }
      return i2;
    }
    getPixelColor(x, y) {
      if (typeof x !== "number" || typeof y !== "number") {
        throw new Error("x and y must be numbers");
      }
      const idx = this.getPixelIndex(x, y);
      return this.bitmap.data.readUInt32BE(idx);
    }
    setPixelColor(hex, x, y) {
      if (typeof hex !== "number" || typeof x !== "number" || typeof y !== "number") {
        throw new Error("hex, x and y must be numbers");
      }
      const idx = this.getPixelIndex(x, y);
      this.bitmap.data.writeUInt32BE(hex, idx);
      return this;
    }
    hasAlpha() {
      const { width, height, data } = this.bitmap;
      const byteLen = width * height << 2;
      for (let idx = 3;idx < byteLen; idx += 4) {
        if (data[idx] !== 255) {
          return true;
        }
      }
      return false;
    }
    composite(src, x = 0, y = 0, options = {}) {
      return composite(this, src, x, y, options);
    }
    scan(x, y, w, h2, f) {
      return scan(this, x, y, w, h2, f);
    }
    scanIterator(x = 0, y = 0, w = this.bitmap.width, h2 = this.bitmap.height) {
      if (typeof x !== "number" || typeof y !== "number") {
        throw new Error("x and y must be numbers");
      }
      if (typeof w !== "number" || typeof h2 !== "number") {
        throw new Error("w and h must be numbers");
      }
      return scanIterator(this, x, y, w, h2);
    }
  };
  return CustomJimp;
}

// node_modules/@jimp/plugin-resize/dist/esm/constants.js
var ResizeStrategy;
(function(ResizeStrategy2) {
  ResizeStrategy2["NEAREST_NEIGHBOR"] = "nearestNeighbor";
  ResizeStrategy2["BILINEAR"] = "bilinearInterpolation";
  ResizeStrategy2["BICUBIC"] = "bicubicInterpolation";
  ResizeStrategy2["HERMITE"] = "hermiteInterpolation";
  ResizeStrategy2["BEZIER"] = "bezierInterpolation";
})(ResizeStrategy || (ResizeStrategy = {}));

// node_modules/@jimp/plugin-resize/dist/esm/modules/resize.js
function Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
  this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);
  this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);
  this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);
  this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);
  this.colorChannels = blendAlpha ? 4 : 3;
  this.interpolationPass = Boolean(interpolationPass);
  this.resizeCallback = typeof resizeCallback === "function" ? resizeCallback : function() {};
  this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;
  this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;
  this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;
  this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;
  this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;
  this.initialize();
}
Resize.prototype.initialize = function() {
  if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0) {
    this.configurePasses();
  } else {
    console.log(this);
    throw new Error("Invalid settings specified for the resizer.");
  }
};
Resize.prototype.configurePasses = function() {
  if (this.widthOriginal === this.targetWidth) {
    this.resizeWidth = this.bypassResizer;
  } else {
    this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;
    if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {
      this.initializeFirstPassBuffers(true);
      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;
    } else {
      this.initializeFirstPassBuffers(false);
      this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;
    }
  }
  if (this.heightOriginal === this.targetHeight) {
    this.resizeHeight = this.bypassResizer;
  } else {
    this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;
    if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {
      this.initializeSecondPassBuffers(true);
      this.resizeHeight = this.resizeHeightInterpolated;
    } else {
      this.initializeSecondPassBuffers(false);
      this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;
    }
  }
};
Resize.prototype._resizeWidthInterpolatedRGBChannels = function(buffer, fourthChannel) {
  const channelsNum = fourthChannel ? 4 : 3;
  const ratioWeight = this.ratioWeightWidthPass;
  const outputBuffer = this.widthBuffer;
  let weight = 0;
  let finalOffset = 0;
  let pixelOffset = 0;
  let firstWeight = 0;
  let secondWeight = 0;
  let targetPosition;
  for (targetPosition = 0;weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {
    for (finalOffset = targetPosition, pixelOffset = 0;finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
      outputBuffer[finalOffset] = buffer[pixelOffset];
      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
      if (fourthChannel)
        outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
    }
  }
  weight -= 1 / 3;
  let interpolationWidthSourceReadStop;
  for (interpolationWidthSourceReadStop = this.widthOriginal - 1;weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {
    secondWeight = weight % 1;
    firstWeight = 1 - secondWeight;
    for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * channelsNum;finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
      outputBuffer[finalOffset + 0] = buffer[pixelOffset + 0] * firstWeight + buffer[pixelOffset + channelsNum + 0] * secondWeight;
      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1] * firstWeight + buffer[pixelOffset + channelsNum + 1] * secondWeight;
      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2] * firstWeight + buffer[pixelOffset + channelsNum + 2] * secondWeight;
      if (fourthChannel)
        outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3] * firstWeight + buffer[pixelOffset + channelsNum + 3] * secondWeight;
    }
  }
  for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - channelsNum;targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {
    for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop;finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
      outputBuffer[finalOffset] = buffer[pixelOffset];
      outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
      outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
      if (fourthChannel)
        outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
    }
  }
  return outputBuffer;
};
Resize.prototype._resizeWidthRGBChannels = function(buffer, fourthChannel) {
  const channelsNum = fourthChannel ? 4 : 3;
  const ratioWeight = this.ratioWeightWidthPass;
  const ratioWeightDivisor = 1 / ratioWeight;
  const nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;
  const nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;
  const output = this.outputWidthWorkBench;
  const outputBuffer = this.widthBuffer;
  const trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;
  let weight = 0;
  let amountToNext = 0;
  let actualPosition = 0;
  let currentPosition = 0;
  let line = 0;
  let pixelOffset = 0;
  let outputOffset = 0;
  let multiplier = 1;
  let r = 0;
  let g = 0;
  let b = 0;
  let a2 = 0;
  do {
    for (line = 0;line < this.originalHeightMultipliedByChannels; ) {
      output[line++] = 0;
      output[line++] = 0;
      output[line++] = 0;
      if (fourthChannel) {
        output[line++] = 0;
        trustworthyColorsCount[line / channelsNum - 1] = 0;
      }
    }
    weight = ratioWeight;
    do {
      amountToNext = 1 + actualPosition - currentPosition;
      multiplier = Math.min(weight, amountToNext);
      for (line = 0, pixelOffset = actualPosition;line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
        r = buffer[pixelOffset];
        g = buffer[++pixelOffset];
        b = buffer[++pixelOffset];
        a2 = fourthChannel ? buffer[++pixelOffset] : 255;
        output[line++] += (a2 ? r : 0) * multiplier;
        output[line++] += (a2 ? g : 0) * multiplier;
        output[line++] += (a2 ? b : 0) * multiplier;
        if (fourthChannel) {
          output[line++] += a2 * multiplier;
          trustworthyColorsCount[line / channelsNum - 1] += a2 ? multiplier : 0;
        }
      }
      if (weight >= amountToNext) {
        actualPosition += channelsNum;
        currentPosition = actualPosition;
        weight -= amountToNext;
      } else {
        currentPosition += weight;
        break;
      }
    } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);
    for (line = 0, pixelOffset = outputOffset;line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {
      weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;
      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
      outputBuffer[pixelOffset] = output[line++] * multiplier;
      outputBuffer[++pixelOffset] = output[line++] * multiplier;
      outputBuffer[++pixelOffset] = output[line++] * multiplier;
      if (fourthChannel)
        outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;
    }
    outputOffset += channelsNum;
  } while (outputOffset < this.targetWidthMultipliedByChannels);
  return outputBuffer;
};
Resize.prototype._resizeHeightRGBChannels = function(buffer, fourthChannel) {
  const ratioWeight = this.ratioWeightHeightPass;
  const ratioWeightDivisor = 1 / ratioWeight;
  const output = this.outputHeightWorkBench;
  const outputBuffer = this.heightBuffer;
  const trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;
  let weight = 0;
  let amountToNext = 0;
  let actualPosition = 0;
  let currentPosition = 0;
  let pixelOffset = 0;
  let outputOffset = 0;
  let caret = 0;
  let multiplier = 1;
  let r = 0;
  let g = 0;
  let b = 0;
  let a2 = 0;
  do {
    for (pixelOffset = 0;pixelOffset < this.targetWidthMultipliedByChannels; ) {
      output[pixelOffset++] = 0;
      output[pixelOffset++] = 0;
      output[pixelOffset++] = 0;
      if (fourthChannel) {
        output[pixelOffset++] = 0;
        trustworthyColorsCount[pixelOffset / 4 - 1] = 0;
      }
    }
    weight = ratioWeight;
    do {
      amountToNext = 1 + actualPosition - currentPosition;
      multiplier = Math.min(weight, amountToNext);
      caret = actualPosition;
      for (pixelOffset = 0;pixelOffset < this.targetWidthMultipliedByChannels; ) {
        r = buffer[caret++];
        g = buffer[caret++];
        b = buffer[caret++];
        a2 = fourthChannel ? buffer[caret++] : 255;
        output[pixelOffset++] += (a2 ? r : 0) * multiplier;
        output[pixelOffset++] += (a2 ? g : 0) * multiplier;
        output[pixelOffset++] += (a2 ? b : 0) * multiplier;
        if (fourthChannel) {
          output[pixelOffset++] += a2 * multiplier;
          trustworthyColorsCount[pixelOffset / 4 - 1] += a2 ? multiplier : 0;
        }
      }
      if (weight >= amountToNext) {
        actualPosition = caret;
        currentPosition = actualPosition;
        weight -= amountToNext;
      } else {
        currentPosition += weight;
        break;
      }
    } while (weight > 0 && actualPosition < this.widthPassResultSize);
    for (pixelOffset = 0;pixelOffset < this.targetWidthMultipliedByChannels; ) {
      weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;
      multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
      outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
      if (fourthChannel) {
        outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
      }
    }
  } while (outputOffset < this.finalResultSize);
  return outputBuffer;
};
Resize.prototype.resizeWidthInterpolatedRGB = function(buffer) {
  return this._resizeWidthInterpolatedRGBChannels(buffer, false);
};
Resize.prototype.resizeWidthInterpolatedRGBA = function(buffer) {
  return this._resizeWidthInterpolatedRGBChannels(buffer, true);
};
Resize.prototype.resizeWidthRGB = function(buffer) {
  return this._resizeWidthRGBChannels(buffer, false);
};
Resize.prototype.resizeWidthRGBA = function(buffer) {
  return this._resizeWidthRGBChannels(buffer, true);
};
Resize.prototype.resizeHeightInterpolated = function(buffer) {
  const ratioWeight = this.ratioWeightHeightPass;
  const outputBuffer = this.heightBuffer;
  let weight = 0;
  let finalOffset = 0;
  let pixelOffset = 0;
  let pixelOffsetAccumulated = 0;
  let pixelOffsetAccumulated2 = 0;
  let firstWeight = 0;
  let secondWeight = 0;
  let interpolationHeightSourceReadStop;
  for (;weight < 1 / 3; weight += ratioWeight) {
    for (pixelOffset = 0;pixelOffset < this.targetWidthMultipliedByChannels; ) {
      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);
    }
  }
  weight -= 1 / 3;
  for (interpolationHeightSourceReadStop = this.heightOriginal - 1;weight < interpolationHeightSourceReadStop; weight += ratioWeight) {
    secondWeight = weight % 1;
    firstWeight = 1 - secondWeight;
    pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels;
    pixelOffsetAccumulated2 = pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;
    for (pixelOffset = 0;pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight + buffer[pixelOffsetAccumulated2++] * secondWeight);
    }
  }
  while (finalOffset < this.finalResultSize) {
    for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels;pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
      outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);
    }
  }
  return outputBuffer;
};
Resize.prototype.resizeHeightRGB = function(buffer) {
  return this._resizeHeightRGBChannels(buffer, false);
};
Resize.prototype.resizeHeightRGBA = function(buffer) {
  return this._resizeHeightRGBChannels(buffer, true);
};
Resize.prototype.resize = function(buffer) {
  this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));
};
Resize.prototype.bypassResizer = function(buffer) {
  return buffer;
};
Resize.prototype.initializeFirstPassBuffers = function(BILINEARAlgo) {
  this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);
  if (!BILINEARAlgo) {
    this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);
    if (this.colorChannels > 3) {
      this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);
    }
  }
};
Resize.prototype.initializeSecondPassBuffers = function(BILINEARAlgo) {
  this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);
  if (!BILINEARAlgo) {
    this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);
    if (this.colorChannels > 3) {
      this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);
    }
  }
};
Resize.prototype.generateFloatBuffer = function(bufferLength) {
  try {
    return new Float32Array(bufferLength);
  } catch (error) {
    console.error(error);
    return [];
  }
};
Resize.prototype.generateFloat64Buffer = function(bufferLength) {
  try {
    return new Float64Array(bufferLength);
  } catch (error) {
    console.error(error);
    return [];
  }
};
Resize.prototype.generateUint8Buffer = function(bufferLength) {
  try {
    return new Uint8Array(bufferLength);
  } catch (error) {
    console.error(error);
    return [];
  }
};
var resize_default = Resize;

// node_modules/@jimp/plugin-resize/dist/esm/modules/resize2.js
var operations = {
  nearestNeighbor(src, dst) {
    const wSrc = src.width;
    const hSrc = src.height;
    const wDst = dst.width;
    const hDst = dst.height;
    const bufSrc = src.data;
    const bufDst = dst.data;
    for (let i2 = 0;i2 < hDst; i2++) {
      for (let j = 0;j < wDst; j++) {
        let posDst = (i2 * wDst + j) * 4;
        const iSrc = Math.floor(i2 * hSrc / hDst);
        const jSrc = Math.floor(j * wSrc / wDst);
        let posSrc = (iSrc * wSrc + jSrc) * 4;
        bufDst[posDst++] = bufSrc[posSrc++];
        bufDst[posDst++] = bufSrc[posSrc++];
        bufDst[posDst++] = bufSrc[posSrc++];
        bufDst[posDst++] = bufSrc[posSrc++];
      }
    }
  },
  bilinearInterpolation(src, dst) {
    const wSrc = src.width;
    const hSrc = src.height;
    const wDst = dst.width;
    const hDst = dst.height;
    const bufSrc = src.data;
    const bufDst = dst.data;
    const interpolate = function(k, kMin, vMin, kMax, vMax) {
      if (kMin === kMax) {
        return vMin;
      }
      return Math.round((k - kMin) * vMax + (kMax - k) * vMin);
    };
    const assign = function(pos, offset, x, xMin, xMax, y, yMin, yMax) {
      let posMin = (yMin * wSrc + xMin) * 4 + offset;
      let posMax = (yMin * wSrc + xMax) * 4 + offset;
      const vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
      if (yMax === yMin) {
        bufDst[pos + offset] = vMin;
      } else {
        posMin = (yMax * wSrc + xMin) * 4 + offset;
        posMax = (yMax * wSrc + xMax) * 4 + offset;
        const vMax = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
        bufDst[pos + offset] = interpolate(y, yMin, vMin, yMax, vMax);
      }
    };
    for (let i2 = 0;i2 < hDst; i2++) {
      for (let j = 0;j < wDst; j++) {
        const posDst = (i2 * wDst + j) * 4;
        const x = j * wSrc / wDst;
        const xMin = Math.floor(x);
        const xMax = Math.min(Math.ceil(x), wSrc - 1);
        const y = i2 * hSrc / hDst;
        const yMin = Math.floor(y);
        const yMax = Math.min(Math.ceil(y), hSrc - 1);
        assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);
        assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);
        assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);
        assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);
      }
    }
  },
  _interpolate2D(src, dst, options, interpolate) {
    const bufSrc = src.data;
    const bufDst = dst.data;
    const wSrc = src.width;
    const hSrc = src.height;
    const wDst = dst.width;
    const hDst = dst.height;
    const wM = Math.max(1, Math.floor(wSrc / wDst));
    const wDst2 = wDst * wM;
    const hM = Math.max(1, Math.floor(hSrc / hDst));
    const hDst2 = hDst * hM;
    const buf1 = Buffer.alloc(wDst2 * hSrc * 4);
    for (let i2 = 0;i2 < hSrc; i2++) {
      for (let j = 0;j < wDst2; j++) {
        const x = j * (wSrc - 1) / wDst2;
        const xPos = Math.floor(x);
        const t = x - xPos;
        const srcPos = (i2 * wSrc + xPos) * 4;
        const buf1Pos = (i2 * wDst2 + j) * 4;
        for (let k = 0;k < 4; k++) {
          const kPos = srcPos + k;
          const x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];
          const x1 = bufSrc[kPos];
          const x2 = bufSrc[kPos + 4];
          const x3 = xPos < wSrc - 2 ? bufSrc[kPos + 8] : 2 * bufSrc[kPos + 4] - bufSrc[kPos];
          buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);
        }
      }
    }
    const buf2 = Buffer.alloc(wDst2 * hDst2 * 4);
    for (let i2 = 0;i2 < hDst2; i2++) {
      for (let j = 0;j < wDst2; j++) {
        const y = i2 * (hSrc - 1) / hDst2;
        const yPos = Math.floor(y);
        const t = y - yPos;
        const buf1Pos = (yPos * wDst2 + j) * 4;
        const buf2Pos = (i2 * wDst2 + j) * 4;
        for (let k = 0;k < 4; k++) {
          const kPos = buf1Pos + k;
          const y0 = yPos > 0 ? buf1[kPos - wDst2 * 4] : 2 * buf1[kPos] - buf1[kPos + wDst2 * 4];
          const y1 = buf1[kPos];
          const y2 = buf1[kPos + wDst2 * 4];
          const y3 = yPos < hSrc - 2 ? buf1[kPos + wDst2 * 8] : 2 * buf1[kPos + wDst2 * 4] - buf1[kPos];
          buf2[buf2Pos + k] = interpolate(y0, y1, y2, y3, t);
        }
      }
    }
    const m = wM * hM;
    if (m > 1) {
      for (let i2 = 0;i2 < hDst; i2++) {
        for (let j = 0;j < wDst; j++) {
          let r = 0;
          let g = 0;
          let b = 0;
          let a2 = 0;
          let realColors = 0;
          for (let y = 0;y < hM; y++) {
            const yPos = i2 * hM + y;
            for (let x = 0;x < wM; x++) {
              const xPos = j * wM + x;
              const xyPos = (yPos * wDst2 + xPos) * 4;
              const pixelAlpha = buf2[xyPos + 3];
              if (pixelAlpha) {
                r += buf2[xyPos];
                g += buf2[xyPos + 1];
                b += buf2[xyPos + 2];
                realColors++;
              }
              a2 += pixelAlpha;
            }
          }
          const pos = (i2 * wDst + j) * 4;
          bufDst[pos] = realColors ? Math.round(r / realColors) : 0;
          bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;
          bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;
          bufDst[pos + 3] = Math.round(a2 / m);
        }
      }
    } else {
      dst.data = buf2;
    }
  },
  bicubicInterpolation(src, dst, options) {
    const interpolateCubic = function(x0, x1, x2, x3, t) {
      const a0 = x3 - x2 - x0 + x1;
      const a1 = x0 - x1 - a0;
      const a2 = x2 - x0;
      const a3 = x1;
      return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));
    };
    return this._interpolate2D(src, dst, options, interpolateCubic);
  },
  hermiteInterpolation(src, dst, options) {
    const interpolateHermite = function(x0, x1, x2, x3, t) {
      const c0 = x1;
      const c1 = 0.5 * (x2 - x0);
      const c22 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;
      const c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);
      return Math.max(0, Math.min(255, Math.round(((c3 * t + c22) * t + c1) * t + c0)));
    };
    return this._interpolate2D(src, dst, options, interpolateHermite);
  },
  bezierInterpolation(src, dst, options) {
    const interpolateBezier = function(x0, x1, x2, x3, t) {
      const cp1 = x1 + (x2 - x0) / 4;
      const cp2 = x2 - (x3 - x1) / 4;
      const nt = 1 - t;
      const c0 = x1 * nt * nt * nt;
      const c1 = 3 * cp1 * nt * nt * t;
      const c22 = 3 * cp2 * nt * t * t;
      const c3 = x2 * t * t * t;
      return Math.max(0, Math.min(255, Math.round(c0 + c1 + c22 + c3)));
    };
    return this._interpolate2D(src, dst, options, interpolateBezier);
  }
};

// node_modules/@jimp/plugin-resize/dist/esm/index.js
var ResizeOptionsSchema = exports_external.union([
  exports_external.object({
    w: exports_external.number().min(0),
    h: exports_external.number().min(0).optional(),
    mode: exports_external.nativeEnum(ResizeStrategy).optional()
  }),
  exports_external.object({
    w: exports_external.number().min(0).optional(),
    h: exports_external.number().min(0),
    mode: exports_external.nativeEnum(ResizeStrategy).optional()
  })
]);
var ScaleToFitOptionsSchema = exports_external.object({
  w: exports_external.number().min(0),
  h: exports_external.number().min(0),
  mode: exports_external.nativeEnum(ResizeStrategy).optional()
});
var ScaleComplexOptionsSchema = exports_external.object({
  f: exports_external.number().min(0),
  mode: exports_external.nativeEnum(ResizeStrategy).optional()
});
var methods5 = {
  resize(image3, options) {
    const { mode } = ResizeOptionsSchema.parse(options);
    let w;
    let h2;
    if (typeof options.w === "number") {
      w = options.w;
      h2 = options.h ?? image3.bitmap.height * (w / image3.bitmap.width);
    } else if (typeof options.h === "number") {
      h2 = options.h;
      w = options.w ?? image3.bitmap.width * (h2 / image3.bitmap.height);
    } else {
      throw new Error("w must be a number");
    }
    w = Math.round(w) || 1;
    h2 = Math.round(h2) || 1;
    if (mode && typeof operations[mode] === "function") {
      const dst = {
        data: Buffer.alloc(w * h2 * 4),
        width: w,
        height: h2
      };
      operations[mode](image3.bitmap, dst);
      image3.bitmap = dst;
    } else {
      const resize = new resize_default(image3.bitmap.width, image3.bitmap.height, w, h2, true, true, (buffer) => {
        image3.bitmap.data = Buffer.from(buffer);
        image3.bitmap.width = w;
        image3.bitmap.height = h2;
      });
      resize.resize(image3.bitmap.data);
    }
    return image3;
  },
  scale(image3, options) {
    const { f, mode } = typeof options === "number" ? { f: options } : ScaleComplexOptionsSchema.parse(options);
    const w = image3.bitmap.width * f;
    const h2 = image3.bitmap.height * f;
    return this.resize(image3, { w, h: h2, mode });
  },
  scaleToFit(image3, options) {
    const { h: h2, w, mode } = ScaleToFitOptionsSchema.parse(options);
    const f = w / h2 > image3.bitmap.width / image3.bitmap.height ? h2 / image3.bitmap.height : w / image3.bitmap.width;
    return this.scale(image3, { f, mode });
  }
};

// node_modules/@jimp/plugin-contain/dist/esm/index.js
var ContainOptionsSchema = exports_external.object({
  w: exports_external.number(),
  h: exports_external.number(),
  align: exports_external.number().optional(),
  mode: exports_external.nativeEnum(ResizeStrategy).optional()
});
var methods6 = {
  contain(image3, options) {
    const { w, h: h2, align = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode } = ContainOptionsSchema.parse(options);
    const hbits = align & (1 << 3) - 1;
    const vbits = align >> 3;
    if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) {
      throw new Error("only use one flag per alignment direction");
    }
    const alignH = hbits >> 1;
    const alignV = vbits >> 1;
    const f = w / h2 > image3.bitmap.width / image3.bitmap.height ? h2 / image3.bitmap.height : w / image3.bitmap.width;
    const c3 = methods5.scale(clone2(image3), { f, mode });
    image3 = methods5.resize(image3, { w, h: h2, mode });
    image3.scan((_, __, idx) => {
      image3.bitmap.data.writeUInt32BE(image3.background, idx);
    });
    image3 = methods.blit(image3, {
      src: c3,
      x: (image3.bitmap.width - c3.bitmap.width) / 2 * alignH,
      y: (image3.bitmap.height - c3.bitmap.height) / 2 * alignV
    });
    return image3;
  }
};

// node_modules/@jimp/plugin-crop/dist/esm/index.js
var CropOptionsSchema = exports_external.object({
  x: exports_external.number(),
  y: exports_external.number(),
  w: exports_external.number(),
  h: exports_external.number()
});
var AutocropComplexOptionsSchema = exports_external.object({
  tolerance: exports_external.number().min(0).max(1).optional(),
  cropOnlyFrames: exports_external.boolean().optional(),
  cropSymmetric: exports_external.boolean().optional(),
  leaveBorder: exports_external.number().optional(),
  ignoreSides: exports_external.object({
    north: exports_external.boolean().optional(),
    south: exports_external.boolean().optional(),
    east: exports_external.boolean().optional(),
    west: exports_external.boolean().optional()
  }).optional()
});
var methods7 = {
  crop(image3, options) {
    let { x, y, w, h: h2 } = CropOptionsSchema.parse(options);
    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w);
    h2 = Math.round(h2);
    if (x === 0 && w === image3.bitmap.width) {
      const start = w * y + x << 2;
      const end = start + (h2 * w << 2);
      image3.bitmap.data = image3.bitmap.data.slice(start, end);
    } else {
      const bitmap = Buffer.allocUnsafe(w * h2 * 4);
      let offset = 0;
      scan(image3, x, y, w, h2, function(_, __, idx) {
        const data = image3.bitmap.data.readUInt32BE(idx);
        bitmap.writeUInt32BE(data, offset);
        offset += 4;
      });
      image3.bitmap.data = bitmap;
    }
    image3.bitmap.width = w;
    image3.bitmap.height = h2;
    return image3;
  },
  autocrop(image3, options = {}) {
    const { tolerance = 0.0002, cropOnlyFrames = true, cropSymmetric = false, leaveBorder = 0, ignoreSides: ignoreSidesArg } = typeof options === "number" ? { tolerance: options } : AutocropComplexOptionsSchema.parse(options);
    const w = image3.bitmap.width;
    const h2 = image3.bitmap.height;
    const minPixelsPerSide = 1;
    const ignoreSides = {
      north: false,
      south: false,
      east: false,
      west: false,
      ...ignoreSidesArg
    };
    let colorTarget = image3.getPixelColor(0, 0);
    const rgba1 = intToRGBA(colorTarget);
    let northPixelsToCrop = 0;
    let eastPixelsToCrop = 0;
    let southPixelsToCrop = 0;
    let westPixelsToCrop = 0;
    colorTarget = image3.getPixelColor(0, 0);
    if (!ignoreSides.north) {
      north:
        for (let y = 0;y < h2 - minPixelsPerSide; y++) {
          for (let x = 0;x < w; x++) {
            const colorXY = image3.getPixelColor(x, y);
            const rgba2 = intToRGBA(colorXY);
            if (colorDiff(rgba1, rgba2) > tolerance) {
              break north;
            }
          }
          northPixelsToCrop++;
        }
    }
    colorTarget = image3.getPixelColor(w, 0);
    if (!ignoreSides.west) {
      west:
        for (let x = 0;x < w - minPixelsPerSide; x++) {
          for (let y = 0 + northPixelsToCrop;y < h2; y++) {
            const colorXY = image3.getPixelColor(x, y);
            const rgba2 = intToRGBA(colorXY);
            if (colorDiff(rgba1, rgba2) > tolerance) {
              break west;
            }
          }
          westPixelsToCrop++;
        }
    }
    colorTarget = image3.getPixelColor(0, h2);
    if (!ignoreSides.south) {
      south:
        for (let y = h2 - 1;y >= northPixelsToCrop + minPixelsPerSide; y--) {
          for (let x = w - eastPixelsToCrop - 1;x >= 0; x--) {
            const colorXY = image3.getPixelColor(x, y);
            const rgba2 = intToRGBA(colorXY);
            if (colorDiff(rgba1, rgba2) > tolerance) {
              break south;
            }
          }
          southPixelsToCrop++;
        }
    }
    colorTarget = image3.getPixelColor(w, h2);
    if (!ignoreSides.east) {
      east:
        for (let x = w - 1;x >= 0 + westPixelsToCrop + minPixelsPerSide; x--) {
          for (let y = h2 - 1;y >= 0 + northPixelsToCrop; y--) {
            const colorXY = image3.getPixelColor(x, y);
            const rgba2 = intToRGBA(colorXY);
            if (colorDiff(rgba1, rgba2) > tolerance) {
              break east;
            }
          }
          eastPixelsToCrop++;
        }
    }
    let doCrop = false;
    westPixelsToCrop -= leaveBorder;
    eastPixelsToCrop -= leaveBorder;
    northPixelsToCrop -= leaveBorder;
    southPixelsToCrop -= leaveBorder;
    if (cropSymmetric) {
      const horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);
      const vertical = Math.min(northPixelsToCrop, southPixelsToCrop);
      westPixelsToCrop = horizontal;
      eastPixelsToCrop = horizontal;
      northPixelsToCrop = vertical;
      southPixelsToCrop = vertical;
    }
    westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;
    eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;
    northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;
    southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0;
    const widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);
    const heightOfRemainingPixels = h2 - (southPixelsToCrop + northPixelsToCrop);
    if (cropOnlyFrames) {
      doCrop = eastPixelsToCrop !== 0 && northPixelsToCrop !== 0 && westPixelsToCrop !== 0 && southPixelsToCrop !== 0;
    } else {
      doCrop = eastPixelsToCrop !== 0 || northPixelsToCrop !== 0 || westPixelsToCrop !== 0 || southPixelsToCrop !== 0;
    }
    if (doCrop) {
      this.crop(image3, {
        x: westPixelsToCrop,
        y: northPixelsToCrop,
        w: widthOfRemainingPixels,
        h: heightOfRemainingPixels
      });
    }
    return image3;
  }
};

// node_modules/@jimp/plugin-cover/dist/esm/index.js
var CoverOptionsSchema = exports_external.object({
  w: exports_external.number(),
  h: exports_external.number(),
  align: exports_external.number().optional(),
  mode: exports_external.nativeEnum(ResizeStrategy).optional()
});
var methods8 = {
  cover(image3, options) {
    const { w, h: h2, align = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode } = CoverOptionsSchema.parse(options);
    const hbits = align & (1 << 3) - 1;
    const vbits = align >> 3;
    if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) {
      throw new Error("only use one flag per alignment direction");
    }
    const alignH = hbits >> 1;
    const alignV = vbits >> 1;
    const f = w / h2 > image3.bitmap.width / image3.bitmap.height ? w / image3.bitmap.width : h2 / image3.bitmap.height;
    image3 = methods5.scale(image3, {
      f,
      mode
    });
    image3 = methods7.crop(image3, {
      x: (image3.bitmap.width - w) / 2 * alignH,
      y: (image3.bitmap.height - h2) / 2 * alignV,
      w,
      h: h2
    });
    return image3;
  }
};

// node_modules/@jimp/plugin-displace/dist/esm/index.js
var DisplaceOptionsSchema = exports_external.object({
  map: JimpClassSchema,
  offset: exports_external.number()
});
var methods9 = {
  displace(image3, options) {
    const { map, offset } = DisplaceOptionsSchema.parse(options);
    const source = clone2(image3);
    image3.scan((x, y, idx) => {
      let displacement = map.bitmap.data[idx] / 256 * offset;
      displacement = Math.round(displacement);
      const ids = image3.getPixelIndex(x + displacement, y);
      image3.bitmap.data[ids] = source.bitmap.data[idx];
      image3.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];
      image3.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];
    });
    return image3;
  }
};

// node_modules/@jimp/plugin-dither/dist/esm/index.js
var methods10 = {
  dither(image3) {
    const rgb565Matrix = [
      1,
      9,
      3,
      11,
      13,
      5,
      15,
      7,
      4,
      12,
      2,
      10,
      16,
      8,
      14,
      6
    ];
    image3.scan((x, y, idx) => {
      const thresholdId = ((y & 3) << 2) + x % 4;
      const dither = rgb565Matrix[thresholdId];
      image3.bitmap.data[idx] = Math.min(image3.bitmap.data[idx] + dither, 255);
      image3.bitmap.data[idx + 1] = Math.min(image3.bitmap.data[idx + 1] + dither, 255);
      image3.bitmap.data[idx + 2] = Math.min(image3.bitmap.data[idx + 2] + dither, 255);
    });
    return image3;
  }
};

// node_modules/@jimp/plugin-fisheye/dist/esm/index.js
var FisheyeOptionsSchema = exports_external.object({
  radius: exports_external.number().min(0).optional()
});
var methods11 = {
  fisheye(image3, options = {}) {
    const { radius = 2.5 } = FisheyeOptionsSchema.parse(options);
    const source = clone2(image3);
    const { width, height } = source.bitmap;
    source.scan((x, y) => {
      const hx = x / width;
      const hy = y / height;
      const rActual = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2));
      const rn = 2 * Math.pow(rActual, radius);
      const cosA = (hx - 0.5) / rActual;
      const sinA = (hy - 0.5) / rActual;
      const newX = Math.round((rn * cosA + 0.5) * width);
      const newY = Math.round((rn * sinA + 0.5) * height);
      const color = source.getPixelColor(newX, newY);
      image3.setPixelColor(color, x, y);
    });
    image3.setPixelColor(source.getPixelColor(width / 2, height / 2), width / 2, height / 2);
    return image3;
  }
};

// node_modules/@jimp/plugin-flip/dist/esm/index.js
var FlipOptionsSchema = exports_external.object({
  horizontal: exports_external.boolean().optional(),
  vertical: exports_external.boolean().optional()
});
var methods12 = {
  flip(image3, options) {
    const { horizontal, vertical } = FlipOptionsSchema.parse(options);
    const bitmap = Buffer.alloc(image3.bitmap.data.length);
    image3.scan((x, y, idx) => {
      const _x = horizontal ? image3.bitmap.width - 1 - x : x;
      const _y = vertical ? image3.bitmap.height - 1 - y : y;
      const _idx = image3.bitmap.width * _y + _x << 2;
      const data = image3.bitmap.data.readUInt32BE(idx);
      bitmap.writeUInt32BE(data, _idx);
    });
    image3.bitmap.data = Buffer.from(bitmap);
    return image3;
  }
};

// node_modules/@jimp/plugin-hash/dist/esm/index.js
var import_any_base = __toESM(require_any_base(), 1);

// node_modules/@jimp/plugin-hash/dist/esm/phash.js
class ImagePHash {
  size;
  smallerSize;
  constructor(size, smallerSize) {
    this.size = size || 32;
    this.smallerSize = smallerSize || 8;
    initCoefficients(this.size);
  }
  distance(s1, s2) {
    let counter = 0;
    for (let k = 0;k < s1.length; k++) {
      if (s1[k] !== s2[k]) {
        counter++;
      }
    }
    return counter / s1.length;
  }
  getHash(img) {
    img = methods5.resize(clone2(img), { w: this.size, h: this.size });
    img = methods4.greyscale(img);
    const vals = [];
    for (let x = 0;x < img.bitmap.width; x++) {
      const row = [];
      for (let y = 0;y < img.bitmap.height; y++) {
        row[y] = intToRGBA2(img.getPixelColor(x, y)).b;
      }
      vals[x] = row;
    }
    const dctVals = applyDCT(vals, this.size);
    let total = 0;
    for (let x = 0;x < this.smallerSize; x++) {
      for (let y = 0;y < this.smallerSize; y++) {
        total += dctVals[x][y];
      }
    }
    const avg = total / (this.smallerSize * this.smallerSize);
    let hash = "";
    for (let x = 0;x < this.smallerSize; x++) {
      for (let y = 0;y < this.smallerSize; y++) {
        hash += dctVals[x][y] > avg ? "1" : "0";
      }
    }
    return hash;
  }
}
function intToRGBA2(i2) {
  const a2 = i2 & 255;
  i2 >>>= 8;
  const b = i2 & 255;
  i2 >>>= 8;
  const g = i2 & 255;
  i2 >>>= 8;
  const r = i2 & 255;
  return { r, g, b, a: a2 };
}
var c3 = [];
function initCoefficients(size) {
  for (let i2 = 1;i2 < size; i2++) {
    c3[i2] = 1;
  }
  c3[0] = 1 / Math.sqrt(2);
}
function applyDCT(f, size) {
  const N = size;
  const F = [];
  for (let u2 = 0;u2 < N; u2++) {
    const row = [];
    for (let v = 0;v < N; v++) {
      let sum = 0;
      for (let i2 = 0;i2 < N; i2++) {
        for (let j = 0;j < N; j++) {
          sum += Math.cos((2 * i2 + 1) / (2 * N) * u2 * Math.PI) * Math.cos((2 * j + 1) / (2 * N) * v * Math.PI) * f[i2][j];
        }
      }
      sum *= c3[u2] * c3[v] / 4;
      row[v] = sum;
      F[u2] = row;
    }
  }
  return F;
}
var phash_default = ImagePHash;

// node_modules/@jimp/plugin-hash/dist/esm/index.js
var alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_";
var maxHashLength = [NaN, NaN];
for (let i2 = 2;i2 < 65; i2++) {
  const maxHash = import_any_base.default(import_any_base.default.BIN, alphabet.slice(0, i2))(new Array(64 + 1).join("1"));
  maxHashLength.push(maxHash.length);
}
var methods13 = {
  pHash(image3) {
    const pHash = new phash_default;
    return pHash.getHash(image3);
  },
  hash(image3, base2 = 64) {
    if (base2 < 2 || base2 > 64) {
      throw new Error("base must be a number between 2 and 64");
    }
    const subAlphabet = alphabet.slice(0, base2);
    const pHash = this.pHash(image3);
    const maxLength = maxHashLength[base2];
    return import_any_base.default(import_any_base.default.BIN, subAlphabet)(pHash).padStart(maxLength, "0");
  },
  distanceFromHash(image3, compareHash) {
    const pHash = new phash_default;
    const currentHash = pHash.getHash(image3);
    return pHash.distance(currentHash, compareHash);
  }
};

// node_modules/@jimp/plugin-mask/dist/esm/index.js
var MaskOptionsObjectSchema = exports_external.object({
  src: JimpClassSchema,
  x: exports_external.number().optional(),
  y: exports_external.number().optional()
});
var MaskOptionsSchema = exports_external.union([JimpClassSchema, MaskOptionsObjectSchema]);
var methods14 = {
  mask(image3, options) {
    MaskOptionsSchema.parse(options);
    let src;
    let x;
    let y;
    if ("bitmap" in options) {
      src = options;
      x = 0;
      y = 0;
    } else {
      src = options.src;
      x = options.x ?? 0;
      y = options.y ?? 0;
    }
    x = Math.round(x);
    y = Math.round(y);
    const w = image3.bitmap.width;
    const h2 = image3.bitmap.height;
    src.scan(function(sx, sy, idx) {
      const destX = x + sx;
      const destY = y + sy;
      if (destX >= 0 && destY >= 0 && destX < w && destY < h2) {
        const dstIdx = image3.getPixelIndex(destX, destY);
        const { data } = src.bitmap;
        const avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;
        image3.bitmap.data[dstIdx + 3] *= avg / 255;
      }
    });
    return image3;
  }
};

// node_modules/@jimp/plugin-print/dist/esm/measure-text.js
function measureText2(font, text) {
  let x = 0;
  for (let i2 = 0;i2 < text.length; i2++) {
    const char = text[i2];
    const fontChar = font.chars[char];
    if (fontChar) {
      const fontKerning = font.kernings[char];
      const nextChar = text[i2 + 1];
      const kerning = fontKerning && nextChar && fontKerning[nextChar] ? fontKerning[nextChar] || 0 : 0;
      x += (fontChar.xadvance || 0) + kerning;
    }
  }
  return x;
}
function splitLines(font, text, maxWidth) {
  const words = text.replace(/[\r\n]+/g, ` 
`).split(" ");
  const lines = [];
  let currentLine = [];
  let longestLine = 0;
  words.forEach((word) => {
    const wordWidth = measureText2(font, word + (words.length > 1 ? " " : ""));
    if (wordWidth > maxWidth) {
      const characterIterator = word[Symbol.iterator]();
      let current = "";
      for (const char of characterIterator) {
        const nextLine = [...currentLine, current + char].join(" ");
        const length2 = measureText2(font, nextLine);
        if (length2 < maxWidth) {
          current += char;
        } else if (length2 > maxWidth) {
          lines.push([...currentLine, current]);
          currentLine = [];
          current = char;
        } else {
          lines.push([...currentLine, current + char]);
          currentLine = [];
          current = "";
        }
      }
      return;
    }
    const line = [...currentLine, word].join(" ");
    const length = measureText2(font, line);
    if (length <= maxWidth && !word.includes(`
`)) {
      if (length > longestLine) {
        longestLine = length;
      }
      currentLine.push(word);
    } else {
      lines.push(currentLine);
      currentLine = [word.replace(`
`, "")];
    }
  });
  lines.push(currentLine);
  return {
    lines,
    longestLine
  };
}
function measureTextHeight(font, text, maxWidth) {
  const { lines } = splitLines(font, text, maxWidth);
  return lines.length * font.common.lineHeight;
}

// node_modules/@jimp/plugin-print/dist/esm/index.js
var PrintOptionsSchema = exports_external.object({
  x: exports_external.number(),
  y: exports_external.number(),
  text: exports_external.union([
    exports_external.union([exports_external.string(), exports_external.number()]),
    exports_external.object({
      text: exports_external.union([exports_external.string(), exports_external.number()]),
      alignmentX: exports_external.nativeEnum(HorizontalAlign).optional(),
      alignmentY: exports_external.nativeEnum(VerticalAlign).optional()
    })
  ]),
  maxWidth: exports_external.number().optional(),
  maxHeight: exports_external.number().optional(),
  cb: exports_external.function(exports_external.tuple([exports_external.object({ x: exports_external.number(), y: exports_external.number() })])).optional()
});
function xOffsetBasedOnAlignment(font, line, maxWidth, alignment) {
  if (alignment === HorizontalAlign.LEFT) {
    return 0;
  }
  if (alignment === HorizontalAlign.CENTER) {
    return (maxWidth - measureText2(font, line)) / 2;
  }
  return maxWidth - measureText2(font, line);
}
function drawCharacter(image3, font, x, y, char) {
  if (char.width > 0 && char.height > 0) {
    const characterPage = font.pages[char.page];
    if (characterPage) {
      image3 = methods.blit(image3, {
        src: characterPage,
        x: x + char.xoffset,
        y: y + char.yoffset,
        srcX: char.x,
        srcY: char.y,
        srcW: char.width,
        srcH: char.height
      });
    }
  }
  return image3;
}
function printText(image3, font, x, y, text, defaultCharWidth) {
  for (let i2 = 0;i2 < text.length; i2++) {
    const stringChar = text[i2];
    let char;
    if (font.chars[stringChar]) {
      char = stringChar;
    } else if (/\s/.test(stringChar)) {
      char = "";
    } else {
      char = "?";
    }
    const fontChar = font.chars[char] || { xadvance: undefined };
    const fontKerning = font.kernings[char];
    if (fontChar) {
      drawCharacter(image3, font, x, y, fontChar);
    }
    const nextChar = text[i2 + 1];
    const kerning = fontKerning && nextChar && fontKerning[nextChar] ? fontKerning[nextChar] || 0 : 0;
    x += kerning + (fontChar.xadvance || defaultCharWidth);
  }
}
var methods15 = {
  print(image3, { font, ...options }) {
    let {
      x,
      y,
      text,
      maxWidth = Infinity,
      maxHeight = Infinity,
      cb = () => {}
    } = PrintOptionsSchema.parse(options);
    let alignmentX;
    let alignmentY;
    if (typeof text === "object" && text.text !== null && text.text !== undefined) {
      alignmentX = text.alignmentX || HorizontalAlign.LEFT;
      alignmentY = text.alignmentY || VerticalAlign.TOP;
      ({ text } = text);
    } else {
      alignmentX = HorizontalAlign.LEFT;
      alignmentY = VerticalAlign.TOP;
      text = text.toString();
    }
    if (typeof text === "number") {
      text = text.toString();
    }
    if (maxHeight !== Infinity && alignmentY === VerticalAlign.BOTTOM) {
      y += maxHeight - measureTextHeight(font, text, maxWidth);
    } else if (maxHeight !== Infinity && alignmentY === VerticalAlign.MIDDLE) {
      y += maxHeight / 2 - measureTextHeight(font, text, maxWidth) / 2;
    }
    const defaultCharWidth = Object.entries(font.chars).find((c4) => c4[1].xadvance)?.[1].xadvance;
    if (typeof defaultCharWidth !== "number") {
      throw new Error("Could not find default character width");
    }
    const { lines, longestLine } = splitLines(font, text, maxWidth);
    lines.forEach((line) => {
      const lineString = line.join(" ");
      const alignmentWidth = xOffsetBasedOnAlignment(font, lineString, maxWidth, alignmentX);
      printText(image3, font, x + alignmentWidth, y, lineString, defaultCharWidth);
      y += font.common.lineHeight;
    });
    cb.bind(image3)({ x: x + longestLine, y });
    return image3;
  }
};

// node_modules/@jimp/plugin-rotate/dist/esm/index.js
var RotateOptionsSchema = exports_external.union([
  exports_external.number(),
  exports_external.object({
    deg: exports_external.number(),
    mode: exports_external.union([exports_external.boolean(), exports_external.nativeEnum(ResizeStrategy)]).optional()
  })
]);
function createIdxTranslationFunction(w) {
  return function(x, y) {
    return y * w + x << 2;
  };
}
function matrixRotate(image3, deg) {
  if (Math.abs(deg) % 90 !== 0) {
    throw new Error("Unsupported matrix rotation degree");
  }
  const w = image3.bitmap.width;
  const h2 = image3.bitmap.height;
  let angle;
  switch (deg) {
    case 90:
    case -270:
      angle = 90;
      break;
    case 180:
    case -180:
      angle = 180;
      break;
    case 270:
    case -90:
      angle = -90;
      break;
    default:
      throw new Error("Unsupported matrix rotation degree");
  }
  const nW = angle === 180 ? w : h2;
  const nH = angle === 180 ? h2 : w;
  const dstBuffer = Buffer.alloc(image3.bitmap.data.length);
  const srcIdxFunction = createIdxTranslationFunction(w);
  const dstIdxFunction = createIdxTranslationFunction(nW);
  for (let x = 0;x < w; x++) {
    for (let y = 0;y < h2; y++) {
      const srcIdx = srcIdxFunction(x, y);
      const pixelRGBA = image3.bitmap.data.readUInt32BE(srcIdx);
      let dstIdx;
      switch (angle) {
        case 90:
          dstIdx = dstIdxFunction(y, w - x - 1);
          break;
        case -90:
          dstIdx = dstIdxFunction(h2 - y - 1, x);
          break;
        case 180:
          dstIdx = dstIdxFunction(w - x - 1, h2 - y - 1);
          break;
        default:
          throw new Error("Unsupported matrix rotation angle");
      }
      dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
    }
  }
  image3.bitmap.data = dstBuffer;
  image3.bitmap.width = nW;
  image3.bitmap.height = nH;
}
function createTranslationFunction(deltaX, deltaY) {
  return function(x, y) {
    return {
      x: x + deltaX,
      y: y + deltaY
    };
  };
}
function advancedRotate(image3, deg, mode) {
  const rad = deg * Math.PI / 180;
  const cosine = Math.cos(rad);
  const sine = Math.sin(rad);
  let w = image3.bitmap.width;
  let h2 = image3.bitmap.height;
  if (mode === true || typeof mode === "string") {
    w = Math.ceil(Math.abs(image3.bitmap.width * cosine) + Math.abs(image3.bitmap.height * sine)) + 1;
    h2 = Math.ceil(Math.abs(image3.bitmap.width * sine) + Math.abs(image3.bitmap.height * cosine)) + 1;
    if (w % 2 !== 0) {
      w++;
    }
    if (h2 % 2 !== 0) {
      h2++;
    }
    const c4 = clone2(image3);
    image3.scan((_, __, idx) => {
      image3.bitmap.data.writeUInt32BE(image3.background, idx);
    });
    const max = Math.max(w, h2, image3.bitmap.width, image3.bitmap.height);
    image3 = methods5.resize(image3, {
      h: max,
      w: max,
      mode: mode === true ? undefined : mode
    });
    image3 = composite(image3, c4, image3.bitmap.width / 2 - c4.bitmap.width / 2, image3.bitmap.height / 2 - c4.bitmap.height / 2);
  }
  const bW = image3.bitmap.width;
  const bH = image3.bitmap.height;
  const dstBuffer = Buffer.alloc(image3.bitmap.data.length);
  const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));
  const translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);
  for (let y = 1;y <= bH; y++) {
    for (let x = 1;x <= bW; x++) {
      const cartesian = translate2Cartesian(x, y);
      const source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);
      const dstIdx = bW * (y - 1) + x - 1 << 2;
      if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {
        const srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;
        const pixelRGBA = image3.bitmap.data.readUInt32BE(srcIdx);
        dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
      } else {
        dstBuffer.writeUInt32BE(image3.background, dstIdx);
      }
    }
  }
  image3.bitmap.data = dstBuffer;
  if (mode === true || typeof mode === "string") {
    const x = Math.max(bW / 2 - w / 2, 0);
    const y = Math.max(bH / 2 - h2 / 2, 0);
    image3 = methods7.crop(image3, { x, y, w, h: h2 });
  }
}
var methods16 = {
  rotate(image3, options) {
    const parsed = RotateOptionsSchema.parse(options);
    const actualOptions = typeof parsed === "number" ? { deg: parsed } : parsed;
    const { mode = true } = actualOptions;
    let { deg } = actualOptions;
    deg %= 360;
    if (deg % 360 === 0) {
      return image3;
    }
    const matrixRotateAllowed = deg % 90 === 0 && (mode || image3.bitmap.width === image3.bitmap.height || deg % 180 === 0);
    if (matrixRotateAllowed) {
      matrixRotate(image3, deg);
    } else {
      advancedRotate(image3, deg, mode);
    }
    return image3;
  }
};

// node_modules/@jimp/plugin-threshold/dist/esm/index.js
var ThresholdOptionsSchema = exports_external.object({
  max: exports_external.number().min(0).max(255),
  replace: exports_external.number().min(0).max(255).optional(),
  autoGreyscale: exports_external.boolean().optional()
});
var methods17 = {
  threshold(image3, options) {
    let {
      max,
      replace = 255,
      autoGreyscale = true
    } = ThresholdOptionsSchema.parse(options);
    max = limit255(max);
    replace = limit255(replace);
    if (autoGreyscale) {
      methods4.greyscale(image3);
    }
    image3.scan((_, __, idx) => {
      const grey = image3.bitmap.data[idx] < max ? image3.bitmap.data[idx] : replace;
      image3.bitmap.data[idx] = grey;
      image3.bitmap.data[idx + 1] = grey;
      image3.bitmap.data[idx + 2] = grey;
    });
    return image3;
  }
};

// node_modules/image-q/dist/esm/image-q.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var constants_exports = {};
__export2(constants_exports, {
  bt709: () => bt709_exports
});
var bt709_exports = {};
__export2(bt709_exports, {
  Y: () => Y,
  x: () => x,
  y: () => y
});
var Y = /* @__PURE__ */ ((Y2) => {
  Y2[Y2["RED"] = 0.2126] = "RED";
  Y2[Y2["GREEN"] = 0.7152] = "GREEN";
  Y2[Y2["BLUE"] = 0.0722] = "BLUE";
  Y2[Y2["WHITE"] = 1] = "WHITE";
  return Y2;
})(Y || {});
var x = /* @__PURE__ */ ((x2) => {
  x2[x2["RED"] = 0.64] = "RED";
  x2[x2["GREEN"] = 0.3] = "GREEN";
  x2[x2["BLUE"] = 0.15] = "BLUE";
  x2[x2["WHITE"] = 0.3127] = "WHITE";
  return x2;
})(x || {});
var y = /* @__PURE__ */ ((y2) => {
  y2[y2["RED"] = 0.33] = "RED";
  y2[y2["GREEN"] = 0.6] = "GREEN";
  y2[y2["BLUE"] = 0.06] = "BLUE";
  y2[y2["WHITE"] = 0.329] = "WHITE";
  return y2;
})(y || {});
var conversion_exports = {};
__export2(conversion_exports, {
  lab2rgb: () => lab2rgb,
  lab2xyz: () => lab2xyz,
  rgb2hsl: () => rgb2hsl,
  rgb2lab: () => rgb2lab,
  rgb2xyz: () => rgb2xyz,
  xyz2lab: () => xyz2lab,
  xyz2rgb: () => xyz2rgb
});
function correctGamma(n2) {
  return n2 > 0.04045 ? ((n2 + 0.055) / 1.055) ** 2.4 : n2 / 12.92;
}
function rgb2xyz(r, g, b) {
  r = correctGamma(r / 255);
  g = correctGamma(g / 255);
  b = correctGamma(b / 255);
  return {
    x: r * 0.4124 + g * 0.3576 + b * 0.1805,
    y: r * 0.2126 + g * 0.7152 + b * 0.0722,
    z: r * 0.0193 + g * 0.1192 + b * 0.9505
  };
}
var arithmetic_exports = {};
__export2(arithmetic_exports, {
  degrees2radians: () => degrees2radians,
  inRange0to255: () => inRange0to255,
  inRange0to255Rounded: () => inRange0to255Rounded,
  intInRange: () => intInRange,
  max3: () => max3,
  min3: () => min3,
  stableSort: () => stableSort
});
function degrees2radians(n2) {
  return n2 * (Math.PI / 180);
}
function max3(a2, b, c4) {
  let m = a2;
  if (m < b)
    m = b;
  if (m < c4)
    m = c4;
  return m;
}
function min3(a2, b, c4) {
  let m = a2;
  if (m > b)
    m = b;
  if (m > c4)
    m = c4;
  return m;
}
function intInRange(value, low, high) {
  if (value > high)
    value = high;
  if (value < low)
    value = low;
  return value | 0;
}
function inRange0to255Rounded(n2) {
  n2 = Math.round(n2);
  if (n2 > 255)
    n2 = 255;
  else if (n2 < 0)
    n2 = 0;
  return n2;
}
function inRange0to255(n2) {
  if (n2 > 255)
    n2 = 255;
  else if (n2 < 0)
    n2 = 0;
  return n2;
}
function stableSort(arrayToSort, callback) {
  const type = typeof arrayToSort[0];
  let sorted;
  if (type === "number" || type === "string") {
    const ord = /* @__PURE__ */ Object.create(null);
    for (let i2 = 0, l = arrayToSort.length;i2 < l; i2++) {
      const val = arrayToSort[i2];
      if (ord[val] || ord[val] === 0)
        continue;
      ord[val] = i2;
    }
    sorted = arrayToSort.sort((a2, b) => callback(a2, b) || ord[a2] - ord[b]);
  } else {
    const ord2 = arrayToSort.slice(0);
    sorted = arrayToSort.sort((a2, b) => callback(a2, b) || ord2.indexOf(a2) - ord2.indexOf(b));
  }
  return sorted;
}
function rgb2hsl(r, g, b) {
  const min = min3(r, g, b);
  const max = max3(r, g, b);
  const delta = max - min;
  const l = (min + max) / 510;
  let s = 0;
  if (l > 0 && l < 1)
    s = delta / (l < 0.5 ? max + min : 510 - max - min);
  let h2 = 0;
  if (delta > 0) {
    if (max === r) {
      h2 = (g - b) / delta;
    } else if (max === g) {
      h2 = 2 + (b - r) / delta;
    } else {
      h2 = 4 + (r - g) / delta;
    }
    h2 *= 60;
    if (h2 < 0)
      h2 += 360;
  }
  return { h: h2, s, l };
}
var refX = 0.95047;
var refY = 1;
var refZ = 1.08883;
function pivot(n2) {
  return n2 > 0.008856 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116;
}
function xyz2lab(x2, y2, z) {
  x2 = pivot(x2 / refX);
  y2 = pivot(y2 / refY);
  z = pivot(z / refZ);
  if (116 * y2 - 16 < 0)
    throw new Error("xxx");
  return {
    L: Math.max(0, 116 * y2 - 16),
    a: 500 * (x2 - y2),
    b: 200 * (y2 - z)
  };
}
function rgb2lab(r, g, b) {
  const xyz = rgb2xyz(r, g, b);
  return xyz2lab(xyz.x, xyz.y, xyz.z);
}
var refX2 = 0.95047;
var refY2 = 1;
var refZ2 = 1.08883;
function pivot2(n2) {
  return n2 > 0.206893034 ? n2 ** 3 : (n2 - 16 / 116) / 7.787;
}
function lab2xyz(L, a2, b) {
  const y2 = (L + 16) / 116;
  const x2 = a2 / 500 + y2;
  const z = y2 - b / 200;
  return {
    x: refX2 * pivot2(x2),
    y: refY2 * pivot2(y2),
    z: refZ2 * pivot2(z)
  };
}
function correctGamma2(n2) {
  return n2 > 0.0031308 ? 1.055 * n2 ** (1 / 2.4) - 0.055 : 12.92 * n2;
}
function xyz2rgb(x2, y2, z) {
  const r = correctGamma2(x2 * 3.2406 + y2 * -1.5372 + z * -0.4986);
  const g = correctGamma2(x2 * -0.9689 + y2 * 1.8758 + z * 0.0415);
  const b = correctGamma2(x2 * 0.0557 + y2 * -0.204 + z * 1.057);
  return {
    r: inRange0to255Rounded(r * 255),
    g: inRange0to255Rounded(g * 255),
    b: inRange0to255Rounded(b * 255)
  };
}
function lab2rgb(L, a2, b) {
  const xyz = lab2xyz(L, a2, b);
  return xyz2rgb(xyz.x, xyz.y, xyz.z);
}
var distance_exports = {};
__export2(distance_exports, {
  AbstractDistanceCalculator: () => AbstractDistanceCalculator,
  AbstractEuclidean: () => AbstractEuclidean,
  AbstractManhattan: () => AbstractManhattan,
  CIE94GraphicArts: () => CIE94GraphicArts,
  CIE94Textiles: () => CIE94Textiles,
  CIEDE2000: () => CIEDE2000,
  CMetric: () => CMetric,
  Euclidean: () => Euclidean,
  EuclideanBT709: () => EuclideanBT709,
  EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,
  Manhattan: () => Manhattan,
  ManhattanBT709: () => ManhattanBT709,
  ManhattanNommyde: () => ManhattanNommyde,
  PNGQuant: () => PNGQuant
});
var AbstractDistanceCalculator = class {
  constructor() {
    __publicField(this, "_maxDistance");
    __publicField(this, "_whitePoint");
    this._setDefaults();
    this.setWhitePoint(255, 255, 255, 255);
  }
  setWhitePoint(r, g, b, a2) {
    this._whitePoint = {
      r: r > 0 ? 255 / r : 0,
      g: g > 0 ? 255 / g : 0,
      b: b > 0 ? 255 / b : 0,
      a: a2 > 0 ? 255 / a2 : 0
    };
    this._maxDistance = this.calculateRaw(r, g, b, a2, 0, 0, 0, 0);
  }
  calculateNormalized(colorA, colorB) {
    return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
  }
};
var AbstractCIE94 = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
    const dL = lab1.L - lab2.L;
    const dA = lab1.a - lab2.a;
    const dB = lab1.b - lab2.b;
    const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);
    const c22 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);
    const dC = c1 - c22;
    let deltaH = dA * dA + dB * dB - dC * dC;
    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
    const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
    return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);
  }
};
var CIE94Textiles = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 2;
    this._K1 = 0.048;
    this._K2 = 0.014;
    this._kA = 0.25 * 50 / 255;
  }
};
var CIE94GraphicArts = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 1;
    this._K1 = 0.045;
    this._K2 = 0.015;
    this._kA = 0.25 * 100 / 255;
  }
};
var _CIEDE2000 = class extends AbstractDistanceCalculator {
  _setDefaults() {}
  static _calculatehp(b, ap) {
    const hp = Math.atan2(b, ap);
    if (hp >= 0)
      return hp;
    return hp + _CIEDE2000._deg360InRad;
  }
  static _calculateRT(ahp, aCp) {
    const aCp_to_7 = aCp ** 7;
    const R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7));
    const delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
    return -Math.sin(2 * delta_theta) * R_C;
  }
  static _calculateT(ahp) {
    return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(ahp * 4 - _CIEDE2000._deg63InRad);
  }
  static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {
    const hpSum = h1p + h2p;
    if (C1pC2p === 0)
      return hpSum;
    if (h_bar <= _CIEDE2000._deg180InRad)
      return hpSum / 2;
    if (hpSum < _CIEDE2000._deg360InRad) {
      return (hpSum + _CIEDE2000._deg360InRad) / 2;
    }
    return (hpSum - _CIEDE2000._deg360InRad) / 2;
  }
  static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {
    let dhp;
    if (C1pC2p === 0) {
      dhp = 0;
    } else if (h_bar <= _CIEDE2000._deg180InRad) {
      dhp = h2p - h1p;
    } else if (h2p <= h1p) {
      dhp = h2p - h1p + _CIEDE2000._deg360InRad;
    } else {
      dhp = h2p - h1p - _CIEDE2000._deg360InRad;
    }
    return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
  }
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
    const dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA;
    const dE2 = this.calculateRawInLab(lab1, lab2);
    return Math.sqrt(dE2 + dA * dA);
  }
  calculateRawInLab(Lab1, Lab2) {
    const L1 = Lab1.L;
    const a1 = Lab1.a;
    const b1 = Lab1.b;
    const L2 = Lab2.L;
    const a2 = Lab2.a;
    const b2 = Lab2.b;
    const C1 = Math.sqrt(a1 * a1 + b1 * b1);
    const C2 = Math.sqrt(a2 * a2 + b2 * b2);
    const pow_a_C1_C2_to_7 = ((C1 + C2) / 2) ** 7;
    const G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7)));
    const a1p = (1 + G) * a1;
    const a2p = (1 + G) * a2;
    const C1p = Math.sqrt(a1p * a1p + b1 * b1);
    const C2p = Math.sqrt(a2p * a2p + b2 * b2);
    const C1pC2p = C1p * C2p;
    const h1p = _CIEDE2000._calculatehp(b1, a1p);
    const h2p = _CIEDE2000._calculatehp(b2, a2p);
    const h_bar = Math.abs(h1p - h2p);
    const dLp = L2 - L1;
    const dCp = C2p - C1p;
    const dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);
    const ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);
    const T = _CIEDE2000._calculateT(ahp);
    const aCp = (C1p + C2p) / 2;
    const aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2;
    const S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square);
    const S_C = 1 + 0.045 * aCp;
    const S_H = 1 + 0.015 * T * aCp;
    const R_T = _CIEDE2000._calculateRT(ahp, aCp);
    const dLpSL = dLp / S_L;
    const dCpSC = dCp / S_C;
    const dHpSH = dHp / S_H;
    return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;
  }
};
var CIEDE2000 = _CIEDE2000;
__publicField(CIEDE2000, "_kA", 0.25 * 100 / 255);
__publicField(CIEDE2000, "_pow25to7", 25 ** 7);
__publicField(CIEDE2000, "_deg360InRad", degrees2radians(360));
__publicField(CIEDE2000, "_deg180InRad", degrees2radians(180));
__publicField(CIEDE2000, "_deg30InRad", degrees2radians(30));
__publicField(CIEDE2000, "_deg6InRad", degrees2radians(6));
__publicField(CIEDE2000, "_deg63InRad", degrees2radians(63));
__publicField(CIEDE2000, "_deg275InRad", degrees2radians(275));
__publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));
var CMetric = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const rmean = (r1 + r2) / 2 * this._whitePoint.r;
    const r = (r1 - r2) * this._whitePoint.r;
    const g = (g1 - g2) * this._whitePoint.g;
    const b = (b1 - b2) * this._whitePoint.b;
    const dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8);
    const dA = (a2 - a1) * this._whitePoint.a;
    return Math.sqrt(dE + dA * dA);
  }
  _setDefaults() {}
};
var AbstractEuclidean = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const dR = r2 - r1;
    const dG = g2 - g1;
    const dB = b2 - b1;
    const dA = a2 - a1;
    return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
  }
};
var Euclidean = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 1;
    this._kG = 1;
    this._kB = 1;
    this._kA = 1;
  }
};
var EuclideanBT709 = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126;
    this._kG = 0.7152;
    this._kB = 0.0722;
    this._kA = 1;
  }
};
var EuclideanBT709NoAlpha = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126;
    this._kG = 0.7152;
    this._kB = 0.0722;
    this._kA = 0;
  }
};
var AbstractManhattan = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    let dR = r2 - r1;
    let dG = g2 - g1;
    let dB = b2 - b1;
    let dA = a2 - a1;
    if (dR < 0)
      dR = 0 - dR;
    if (dG < 0)
      dG = 0 - dG;
    if (dB < 0)
      dB = 0 - dB;
    if (dA < 0)
      dA = 0 - dA;
    return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
  }
};
var Manhattan = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 1;
    this._kG = 1;
    this._kB = 1;
    this._kA = 1;
  }
};
var ManhattanNommyde = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.4984;
    this._kG = 0.8625;
    this._kB = 0.2979;
    this._kA = 1;
  }
};
var ManhattanBT709 = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.2126;
    this._kG = 0.7152;
    this._kB = 0.0722;
    this._kA = 1;
  }
};
var PNGQuant = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const alphas = (a2 - a1) * this._whitePoint.a;
    return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
  }
  _colordifferenceCh(x2, y2, alphas) {
    const black2 = x2 - y2;
    const white2 = black2 + alphas;
    return black2 * black2 + white2 * white2;
  }
  _setDefaults() {}
};
var palette_exports = {};
__export2(palette_exports, {
  AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,
  ColorHistogram: () => ColorHistogram,
  NeuQuant: () => NeuQuant,
  NeuQuantFloat: () => NeuQuantFloat,
  RGBQuant: () => RGBQuant,
  WuColorCube: () => WuColorCube,
  WuQuant: () => WuQuant
});
var AbstractPaletteQuantizer = class {
  quantizeSync() {
    for (const value of this.quantize()) {
      if (value.palette) {
        return value.palette;
      }
    }
    throw new Error("unreachable");
  }
};
var Point = class {
  constructor() {
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    __publicField(this, "uint32");
    __publicField(this, "rgba");
    this.uint32 = -1 >>> 0;
    this.r = this.g = this.b = this.a = 0;
    this.rgba = new Array(4);
    this.rgba[0] = 0;
    this.rgba[1] = 0;
    this.rgba[2] = 0;
    this.rgba[3] = 0;
  }
  static createByQuadruplet(quadruplet) {
    const point = new Point;
    point.r = quadruplet[0] | 0;
    point.g = quadruplet[1] | 0;
    point.b = quadruplet[2] | 0;
    point.a = quadruplet[3] | 0;
    point._loadUINT32();
    point._loadQuadruplet();
    return point;
  }
  static createByRGBA(red2, green2, blue2, alpha) {
    const point = new Point;
    point.r = red2 | 0;
    point.g = green2 | 0;
    point.b = blue2 | 0;
    point.a = alpha | 0;
    point._loadUINT32();
    point._loadQuadruplet();
    return point;
  }
  static createByUint32(uint32) {
    const point = new Point;
    point.uint32 = uint32 >>> 0;
    point._loadRGBA();
    point._loadQuadruplet();
    return point;
  }
  from(point) {
    this.r = point.r;
    this.g = point.g;
    this.b = point.b;
    this.a = point.a;
    this.uint32 = point.uint32;
    this.rgba[0] = point.r;
    this.rgba[1] = point.g;
    this.rgba[2] = point.b;
    this.rgba[3] = point.a;
  }
  getLuminosity(useAlphaChannel) {
    let r = this.r;
    let g = this.g;
    let b = this.b;
    if (useAlphaChannel) {
      r = Math.min(255, 255 - this.a + this.a * r / 255);
      g = Math.min(255, 255 - this.a + this.a * g / 255);
      b = Math.min(255, 255 - this.a + this.a * b / 255);
    }
    return r * 0.2126 + g * 0.7152 + b * 0.0722;
  }
  _loadUINT32() {
    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
  }
  _loadRGBA() {
    this.r = this.uint32 & 255;
    this.g = this.uint32 >>> 8 & 255;
    this.b = this.uint32 >>> 16 & 255;
    this.a = this.uint32 >>> 24 & 255;
  }
  _loadQuadruplet() {
    this.rgba[0] = this.r;
    this.rgba[1] = this.g;
    this.rgba[2] = this.b;
    this.rgba[3] = this.a;
  }
};
var PointContainer = class {
  constructor() {
    __publicField(this, "_pointArray");
    __publicField(this, "_width");
    __publicField(this, "_height");
    this._width = 0;
    this._height = 0;
    this._pointArray = [];
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  setWidth(width) {
    this._width = width;
  }
  setHeight(height) {
    this._height = height;
  }
  getPointArray() {
    return this._pointArray;
  }
  clone() {
    const clone3 = new PointContainer;
    clone3._width = this._width;
    clone3._height = this._height;
    for (let i2 = 0, l = this._pointArray.length;i2 < l; i2++) {
      clone3._pointArray[i2] = Point.createByUint32(this._pointArray[i2].uint32 | 0);
    }
    return clone3;
  }
  toUint32Array() {
    const l = this._pointArray.length;
    const uint32Array = new Uint32Array(l);
    for (let i2 = 0;i2 < l; i2++) {
      uint32Array[i2] = this._pointArray[i2].uint32;
    }
    return uint32Array;
  }
  toUint8Array() {
    return new Uint8Array(this.toUint32Array().buffer);
  }
  static fromHTMLImageElement(img) {
    const width = img.naturalWidth;
    const height = img.naturalHeight;
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
    return PointContainer.fromHTMLCanvasElement(canvas);
  }
  static fromHTMLCanvasElement(canvas) {
    const width = canvas.width;
    const height = canvas.height;
    const ctx = canvas.getContext("2d");
    const imgData = ctx.getImageData(0, 0, width, height);
    return PointContainer.fromImageData(imgData);
  }
  static fromImageData(imageData) {
    const width = imageData.width;
    const height = imageData.height;
    return PointContainer.fromUint8Array(imageData.data, width, height);
  }
  static fromUint8Array(uint8Array, width, height) {
    switch (Object.prototype.toString.call(uint8Array)) {
      case "[object Uint8ClampedArray]":
      case "[object Uint8Array]":
        break;
      default:
        uint8Array = new Uint8Array(uint8Array);
    }
    const uint32Array = new Uint32Array(uint8Array.buffer);
    return PointContainer.fromUint32Array(uint32Array, width, height);
  }
  static fromUint32Array(uint32Array, width, height) {
    const container = new PointContainer;
    container._width = width;
    container._height = height;
    for (let i2 = 0, l = uint32Array.length;i2 < l; i2++) {
      container._pointArray[i2] = Point.createByUint32(uint32Array[i2] | 0);
    }
    return container;
  }
  static fromBuffer(buffer, width, height) {
    const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);
    return PointContainer.fromUint32Array(uint32Array, width, height);
  }
};
var hueGroups = 10;
function hueGroup(hue, segmentsNumber) {
  const maxHue = 360;
  const seg = maxHue / segmentsNumber;
  const half = seg / 2;
  for (let i2 = 1, mid = seg - half;i2 < segmentsNumber; i2++, mid += seg) {
    if (hue >= mid && hue < mid + seg)
      return i2;
  }
  return 0;
}
var Palette = class {
  constructor() {
    __publicField(this, "_pointContainer");
    __publicField(this, "_pointArray", []);
    __publicField(this, "_i32idx", {});
    this._pointContainer = new PointContainer;
    this._pointContainer.setHeight(1);
    this._pointArray = this._pointContainer.getPointArray();
  }
  add(color) {
    this._pointArray.push(color);
    this._pointContainer.setWidth(this._pointArray.length);
  }
  has(color) {
    for (let i2 = this._pointArray.length - 1;i2 >= 0; i2--) {
      if (color.uint32 === this._pointArray[i2].uint32)
        return true;
    }
    return false;
  }
  getNearestColor(colorDistanceCalculator, color) {
    return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];
  }
  getPointContainer() {
    return this._pointContainer;
  }
  _nearestPointFromCache(key) {
    return typeof this._i32idx[key] === "number" ? this._i32idx[key] : -1;
  }
  _getNearestIndex(colorDistanceCalculator, point) {
    let idx = this._nearestPointFromCache("" + point.uint32);
    if (idx >= 0)
      return idx;
    let minimalDistance = Number.MAX_VALUE;
    idx = 0;
    for (let i2 = 0, l = this._pointArray.length;i2 < l; i2++) {
      const p = this._pointArray[i2];
      const distance2 = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
      if (distance2 < minimalDistance) {
        minimalDistance = distance2;
        idx = i2;
      }
    }
    this._i32idx[point.uint32] = idx;
    return idx;
  }
  sort() {
    this._i32idx = {};
    this._pointArray.sort((a2, b) => {
      const hslA = rgb2hsl(a2.r, a2.g, a2.b);
      const hslB = rgb2hsl(b.r, b.g, b.b);
      const hueA = a2.r === a2.g && a2.g === a2.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);
      const hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);
      const hueDiff = hueB - hueA;
      if (hueDiff)
        return -hueDiff;
      const lA = a2.getLuminosity(true);
      const lB = b.getLuminosity(true);
      if (lB - lA !== 0)
        return lB - lA;
      const satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);
      if (satDiff)
        return -satDiff;
      return 0;
    });
  }
};
var utils_exports = {};
__export2(utils_exports, {
  HueStatistics: () => HueStatistics,
  Palette: () => Palette,
  Point: () => Point,
  PointContainer: () => PointContainer,
  ProgressTracker: () => ProgressTracker,
  arithmetic: () => arithmetic_exports
});
var HueGroup = class {
  constructor() {
    __publicField(this, "num", 0);
    __publicField(this, "cols", []);
  }
};
var HueStatistics = class {
  constructor(numGroups, minCols) {
    __publicField(this, "_numGroups");
    __publicField(this, "_minCols");
    __publicField(this, "_stats");
    __publicField(this, "_groupsFull");
    this._numGroups = numGroups;
    this._minCols = minCols;
    this._stats = [];
    for (let i2 = 0;i2 <= numGroups; i2++) {
      this._stats[i2] = new HueGroup;
    }
    this._groupsFull = 0;
  }
  check(i32) {
    if (this._groupsFull === this._numGroups + 1) {
      this.check = () => {};
    }
    const r = i32 & 255;
    const g = i32 >>> 8 & 255;
    const b = i32 >>> 16 & 255;
    const hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);
    const gr = this._stats[hg];
    const min = this._minCols;
    gr.num++;
    if (gr.num > min) {
      return;
    }
    if (gr.num === min) {
      this._groupsFull++;
    }
    if (gr.num <= min) {
      this._stats[hg].cols.push(i32);
    }
  }
  injectIntoDictionary(histG) {
    for (let i2 = 0;i2 <= this._numGroups; i2++) {
      if (this._stats[i2].num <= this._minCols) {
        this._stats[i2].cols.forEach((col) => {
          if (!histG[col]) {
            histG[col] = 1;
          } else {
            histG[col]++;
          }
        });
      }
    }
  }
  injectIntoArray(histG) {
    for (let i2 = 0;i2 <= this._numGroups; i2++) {
      if (this._stats[i2].num <= this._minCols) {
        this._stats[i2].cols.forEach((col) => {
          if (histG.indexOf(col) === -1) {
            histG.push(col);
          }
        });
      }
    }
  }
};
var _ProgressTracker = class {
  constructor(valueRange, progressRange) {
    __publicField(this, "progress");
    __publicField(this, "_step");
    __publicField(this, "_range");
    __publicField(this, "_last");
    __publicField(this, "_progressRange");
    this._range = valueRange;
    this._progressRange = progressRange;
    this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0);
    this._last = -this._step;
    this.progress = 0;
  }
  shouldNotify(current) {
    if (current - this._last >= this._step) {
      this._last = current;
      this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);
      return true;
    }
    return false;
  }
};
var ProgressTracker = _ProgressTracker;
__publicField(ProgressTracker, "steps", 100);
var networkBiasShift = 3;
var Neuron = class {
  constructor(defaultValue) {
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    this.r = this.g = this.b = this.a = defaultValue;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
  }
  subtract(r, g, b, a2) {
    this.r -= r | 0;
    this.g -= g | 0;
    this.b -= b | 0;
    this.a -= a2 | 0;
  }
};
var _NeuQuant = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256) {
    super();
    __publicField(this, "_pointArray");
    __publicField(this, "_networkSize");
    __publicField(this, "_network");
    __publicField(this, "_sampleFactor");
    __publicField(this, "_radPower");
    __publicField(this, "_freq");
    __publicField(this, "_bias");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._pointArray = [];
    this._sampleFactor = 1;
    this._networkSize = colors;
    this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
  }
  sample(pointContainer) {
    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
  }
  *quantize() {
    this._init();
    yield* this._learn();
    yield {
      palette: this._buildPalette(),
      progress: 100
    };
  }
  _init() {
    this._freq = [];
    this._bias = [];
    this._radPower = [];
    this._network = [];
    for (let i2 = 0;i2 < this._networkSize; i2++) {
      this._network[i2] = new Neuron((i2 << networkBiasShift + 8) / this._networkSize | 0);
      this._freq[i2] = _NeuQuant._initialBias / this._networkSize | 0;
      this._bias[i2] = 0;
    }
  }
  *_learn() {
    let sampleFactor = this._sampleFactor;
    const pointsNumber = this._pointArray.length;
    if (pointsNumber < _NeuQuant._minpicturebytes)
      sampleFactor = 1;
    const alphadec = 30 + (sampleFactor - 1) / 3 | 0;
    const pointsToSample = pointsNumber / sampleFactor | 0;
    let delta = pointsToSample / _NeuQuant._nCycles | 0;
    let alpha = _NeuQuant._initAlpha;
    let radius = (this._networkSize >> 3) * _NeuQuant._radiusBias;
    let rad = radius >> _NeuQuant._radiusBiasShift;
    if (rad <= 1)
      rad = 0;
    for (let i2 = 0;i2 < rad; i2++) {
      this._radPower[i2] = alpha * ((rad * rad - i2 * i2) * _NeuQuant._radBias / (rad * rad)) >>> 0;
    }
    let step;
    if (pointsNumber < _NeuQuant._minpicturebytes) {
      step = 1;
    } else if (pointsNumber % _NeuQuant._prime1 !== 0) {
      step = _NeuQuant._prime1;
    } else if (pointsNumber % _NeuQuant._prime2 !== 0) {
      step = _NeuQuant._prime2;
    } else if (pointsNumber % _NeuQuant._prime3 !== 0) {
      step = _NeuQuant._prime3;
    } else {
      step = _NeuQuant._prime4;
    }
    const tracker = new ProgressTracker(pointsToSample, 99);
    for (let i2 = 0, pointIndex = 0;i2 < pointsToSample; ) {
      if (tracker.shouldNotify(i2)) {
        yield {
          progress: tracker.progress
        };
      }
      const point = this._pointArray[pointIndex];
      const b = point.b << networkBiasShift;
      const g = point.g << networkBiasShift;
      const r = point.r << networkBiasShift;
      const a2 = point.a << networkBiasShift;
      const neuronIndex = this._contest(b, g, r, a2);
      this._alterSingle(alpha, neuronIndex, b, g, r, a2);
      if (rad !== 0)
        this._alterNeighbour(rad, neuronIndex, b, g, r, a2);
      pointIndex += step;
      if (pointIndex >= pointsNumber)
        pointIndex -= pointsNumber;
      i2++;
      if (delta === 0)
        delta = 1;
      if (i2 % delta === 0) {
        alpha -= alpha / alphadec | 0;
        radius -= radius / _NeuQuant._radiusDecrease | 0;
        rad = radius >> _NeuQuant._radiusBiasShift;
        if (rad <= 1)
          rad = 0;
        for (let j = 0;j < rad; j++) {
          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;
        }
      }
    }
  }
  _buildPalette() {
    const palette2 = new Palette;
    this._network.forEach((neuron) => {
      palette2.add(neuron.toPoint());
    });
    palette2.sort();
    return palette2;
  }
  _alterNeighbour(rad, i2, b, g, r, al) {
    let lo = i2 - rad;
    if (lo < -1)
      lo = -1;
    let hi = i2 + rad;
    if (hi > this._networkSize)
      hi = this._networkSize;
    let j = i2 + 1;
    let k = i2 - 1;
    let m = 1;
    while (j < hi || k > lo) {
      const a2 = this._radPower[m++] / _NeuQuant._alphaRadBias;
      if (j < hi) {
        const p = this._network[j++];
        p.subtract(a2 * (p.r - r), a2 * (p.g - g), a2 * (p.b - b), a2 * (p.a - al));
      }
      if (k > lo) {
        const p = this._network[k--];
        p.subtract(a2 * (p.r - r), a2 * (p.g - g), a2 * (p.b - b), a2 * (p.a - al));
      }
    }
  }
  _alterSingle(alpha, i2, b, g, r, a2) {
    alpha /= _NeuQuant._initAlpha;
    const n2 = this._network[i2];
    n2.subtract(alpha * (n2.r - r), alpha * (n2.g - g), alpha * (n2.b - b), alpha * (n2.a - a2));
  }
  _contest(b, g, r, a2) {
    const multiplier = 255 * 4 << networkBiasShift;
    let bestd = ~(1 << 31);
    let bestbiasd = bestd;
    let bestpos = -1;
    let bestbiaspos = bestpos;
    for (let i2 = 0;i2 < this._networkSize; i2++) {
      const n2 = this._network[i2];
      const dist = this._distance.calculateNormalized(n2, { r, g, b, a: a2 }) * multiplier | 0;
      if (dist < bestd) {
        bestd = dist;
        bestpos = i2;
      }
      const biasdist = dist - (this._bias[i2] >> _NeuQuant._initialBiasShift - networkBiasShift);
      if (biasdist < bestbiasd) {
        bestbiasd = biasdist;
        bestbiaspos = i2;
      }
      const betafreq = this._freq[i2] >> _NeuQuant._betaShift;
      this._freq[i2] -= betafreq;
      this._bias[i2] += betafreq << _NeuQuant._gammaShift;
    }
    this._freq[bestpos] += _NeuQuant._beta;
    this._bias[bestpos] -= _NeuQuant._betaGamma;
    return bestbiaspos;
  }
};
var NeuQuant = _NeuQuant;
__publicField(NeuQuant, "_prime1", 499);
__publicField(NeuQuant, "_prime2", 491);
__publicField(NeuQuant, "_prime3", 487);
__publicField(NeuQuant, "_prime4", 503);
__publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4);
__publicField(NeuQuant, "_nCycles", 100);
__publicField(NeuQuant, "_initialBiasShift", 16);
__publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift);
__publicField(NeuQuant, "_gammaShift", 10);
__publicField(NeuQuant, "_betaShift", 10);
__publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift);
__publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift);
__publicField(NeuQuant, "_radiusBiasShift", 6);
__publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift);
__publicField(NeuQuant, "_radiusDecrease", 30);
__publicField(NeuQuant, "_alphaBiasShift", 10);
__publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift);
__publicField(NeuQuant, "_radBiasShift", 8);
__publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift);
__publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift);
__publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);
var networkBiasShift2 = 3;
var NeuronFloat = class {
  constructor(defaultValue) {
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    this.r = this.g = this.b = this.a = defaultValue;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
  }
  subtract(r, g, b, a2) {
    this.r -= r;
    this.g -= g;
    this.b -= b;
    this.a -= a2;
  }
};
var _NeuQuantFloat = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256) {
    super();
    __publicField(this, "_pointArray");
    __publicField(this, "_networkSize");
    __publicField(this, "_network");
    __publicField(this, "_sampleFactor");
    __publicField(this, "_radPower");
    __publicField(this, "_freq");
    __publicField(this, "_bias");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._pointArray = [];
    this._sampleFactor = 1;
    this._networkSize = colors;
    this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
  }
  sample(pointContainer) {
    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
  }
  *quantize() {
    this._init();
    yield* this._learn();
    yield {
      palette: this._buildPalette(),
      progress: 100
    };
  }
  _init() {
    this._freq = [];
    this._bias = [];
    this._radPower = [];
    this._network = [];
    for (let i2 = 0;i2 < this._networkSize; i2++) {
      this._network[i2] = new NeuronFloat((i2 << networkBiasShift2 + 8) / this._networkSize);
      this._freq[i2] = _NeuQuantFloat._initialBias / this._networkSize;
      this._bias[i2] = 0;
    }
  }
  *_learn() {
    let sampleFactor = this._sampleFactor;
    const pointsNumber = this._pointArray.length;
    if (pointsNumber < _NeuQuantFloat._minpicturebytes)
      sampleFactor = 1;
    const alphadec = 30 + (sampleFactor - 1) / 3;
    const pointsToSample = pointsNumber / sampleFactor;
    let delta = pointsToSample / _NeuQuantFloat._nCycles | 0;
    let alpha = _NeuQuantFloat._initAlpha;
    let radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias;
    let rad = radius >> _NeuQuantFloat._radiusBiasShift;
    if (rad <= 1)
      rad = 0;
    for (let i2 = 0;i2 < rad; i2++) {
      this._radPower[i2] = alpha * ((rad * rad - i2 * i2) * _NeuQuantFloat._radBias / (rad * rad));
    }
    let step;
    if (pointsNumber < _NeuQuantFloat._minpicturebytes) {
      step = 1;
    } else if (pointsNumber % _NeuQuantFloat._prime1 !== 0) {
      step = _NeuQuantFloat._prime1;
    } else if (pointsNumber % _NeuQuantFloat._prime2 !== 0) {
      step = _NeuQuantFloat._prime2;
    } else if (pointsNumber % _NeuQuantFloat._prime3 !== 0) {
      step = _NeuQuantFloat._prime3;
    } else {
      step = _NeuQuantFloat._prime4;
    }
    const tracker = new ProgressTracker(pointsToSample, 99);
    for (let i2 = 0, pointIndex = 0;i2 < pointsToSample; ) {
      if (tracker.shouldNotify(i2)) {
        yield {
          progress: tracker.progress
        };
      }
      const point = this._pointArray[pointIndex];
      const b = point.b << networkBiasShift2;
      const g = point.g << networkBiasShift2;
      const r = point.r << networkBiasShift2;
      const a2 = point.a << networkBiasShift2;
      const neuronIndex = this._contest(b, g, r, a2);
      this._alterSingle(alpha, neuronIndex, b, g, r, a2);
      if (rad !== 0)
        this._alterNeighbour(rad, neuronIndex, b, g, r, a2);
      pointIndex += step;
      if (pointIndex >= pointsNumber)
        pointIndex -= pointsNumber;
      i2++;
      if (delta === 0)
        delta = 1;
      if (i2 % delta === 0) {
        alpha -= alpha / alphadec;
        radius -= radius / _NeuQuantFloat._radiusDecrease;
        rad = radius >> _NeuQuantFloat._radiusBiasShift;
        if (rad <= 1)
          rad = 0;
        for (let j = 0;j < rad; j++) {
          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));
        }
      }
    }
  }
  _buildPalette() {
    const palette2 = new Palette;
    this._network.forEach((neuron) => {
      palette2.add(neuron.toPoint());
    });
    palette2.sort();
    return palette2;
  }
  _alterNeighbour(rad, i2, b, g, r, al) {
    let lo = i2 - rad;
    if (lo < -1)
      lo = -1;
    let hi = i2 + rad;
    if (hi > this._networkSize)
      hi = this._networkSize;
    let j = i2 + 1;
    let k = i2 - 1;
    let m = 1;
    while (j < hi || k > lo) {
      const a2 = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;
      if (j < hi) {
        const p = this._network[j++];
        p.subtract(a2 * (p.r - r), a2 * (p.g - g), a2 * (p.b - b), a2 * (p.a - al));
      }
      if (k > lo) {
        const p = this._network[k--];
        p.subtract(a2 * (p.r - r), a2 * (p.g - g), a2 * (p.b - b), a2 * (p.a - al));
      }
    }
  }
  _alterSingle(alpha, i2, b, g, r, a2) {
    alpha /= _NeuQuantFloat._initAlpha;
    const n2 = this._network[i2];
    n2.subtract(alpha * (n2.r - r), alpha * (n2.g - g), alpha * (n2.b - b), alpha * (n2.a - a2));
  }
  _contest(b, g, r, al) {
    const multiplier = 255 * 4 << networkBiasShift2;
    let bestd = ~(1 << 31);
    let bestbiasd = bestd;
    let bestpos = -1;
    let bestbiaspos = bestpos;
    for (let i2 = 0;i2 < this._networkSize; i2++) {
      const n2 = this._network[i2];
      const dist = this._distance.calculateNormalized(n2, { r, g, b, a: al }) * multiplier;
      if (dist < bestd) {
        bestd = dist;
        bestpos = i2;
      }
      const biasdist = dist - (this._bias[i2] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
      if (biasdist < bestbiasd) {
        bestbiasd = biasdist;
        bestbiaspos = i2;
      }
      const betafreq = this._freq[i2] >> _NeuQuantFloat._betaShift;
      this._freq[i2] -= betafreq;
      this._bias[i2] += betafreq << _NeuQuantFloat._gammaShift;
    }
    this._freq[bestpos] += _NeuQuantFloat._beta;
    this._bias[bestpos] -= _NeuQuantFloat._betaGamma;
    return bestbiaspos;
  }
};
var NeuQuantFloat = _NeuQuantFloat;
__publicField(NeuQuantFloat, "_prime1", 499);
__publicField(NeuQuantFloat, "_prime2", 491);
__publicField(NeuQuantFloat, "_prime3", 487);
__publicField(NeuQuantFloat, "_prime4", 503);
__publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4);
__publicField(NeuQuantFloat, "_nCycles", 100);
__publicField(NeuQuantFloat, "_initialBiasShift", 16);
__publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift);
__publicField(NeuQuantFloat, "_gammaShift", 10);
__publicField(NeuQuantFloat, "_betaShift", 10);
__publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift);
__publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift);
__publicField(NeuQuantFloat, "_radiusBiasShift", 6);
__publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift);
__publicField(NeuQuantFloat, "_radiusDecrease", 30);
__publicField(NeuQuantFloat, "_alphaBiasShift", 10);
__publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift);
__publicField(NeuQuantFloat, "_radBiasShift", 8);
__publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift);
__publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift);
__publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);
var _ColorHistogram = class {
  constructor(method, colors) {
    __publicField(this, "_method");
    __publicField(this, "_hueStats");
    __publicField(this, "_histogram");
    __publicField(this, "_initColors");
    __publicField(this, "_minHueCols");
    this._method = method;
    this._minHueCols = colors << 2;
    this._initColors = colors << 2;
    this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols);
    this._histogram = /* @__PURE__ */ Object.create(null);
  }
  sample(pointContainer) {
    switch (this._method) {
      case 1:
        this._colorStats1D(pointContainer);
        break;
      case 2:
        this._colorStats2D(pointContainer);
        break;
    }
  }
  getImportanceSortedColorsIDXI32() {
    const sorted = stableSort(Object.keys(this._histogram), (a2, b) => this._histogram[b] - this._histogram[a2]);
    if (sorted.length === 0) {
      return [];
    }
    let idxi32;
    switch (this._method) {
      case 1:
        const initialColorsLimit = Math.min(sorted.length, this._initColors);
        const last = sorted[initialColorsLimit - 1];
        const freq = this._histogram[last];
        idxi32 = sorted.slice(0, initialColorsLimit);
        let pos = initialColorsLimit;
        const len = sorted.length;
        while (pos < len && this._histogram[sorted[pos]] === freq) {
          idxi32.push(sorted[pos++]);
        }
        this._hueStats.injectIntoArray(idxi32);
        break;
      case 2:
        idxi32 = sorted;
        break;
      default:
        throw new Error("Incorrect method");
    }
    return idxi32.map((v) => +v);
  }
  _colorStats1D(pointContainer) {
    const histG = this._histogram;
    const pointArray = pointContainer.getPointArray();
    const len = pointArray.length;
    for (let i2 = 0;i2 < len; i2++) {
      const col = pointArray[i2].uint32;
      this._hueStats.check(col);
      if (col in histG) {
        histG[col]++;
      } else {
        histG[col] = 1;
      }
    }
  }
  _colorStats2D(pointContainer) {
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const pointArray = pointContainer.getPointArray();
    const boxW = _ColorHistogram._boxSize[0];
    const boxH = _ColorHistogram._boxSize[1];
    const area = boxW * boxH;
    const boxes = this._makeBoxes(width, height, boxW, boxH);
    const histG = this._histogram;
    boxes.forEach((box) => {
      let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;
      if (effc < 2)
        effc = 2;
      const histL = {};
      this._iterateBox(box, width, (i2) => {
        const col = pointArray[i2].uint32;
        this._hueStats.check(col);
        if (col in histG) {
          histG[col]++;
        } else if (col in histL) {
          if (++histL[col] >= effc) {
            histG[col] = histL[col];
          }
        } else {
          histL[col] = 1;
        }
      });
    });
    this._hueStats.injectIntoDictionary(histG);
  }
  _iterateBox(bbox, wid, fn) {
    const b = bbox;
    const i0 = b.y * wid + b.x;
    const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);
    const incr = wid - b.w + 1;
    let cnt = 0;
    let i2 = i0;
    do {
      fn.call(this, i2);
      i2 += ++cnt % b.w === 0 ? incr : 1;
    } while (i2 <= i1);
  }
  _makeBoxes(width, height, stepX, stepY) {
    const wrem = width % stepX;
    const hrem = height % stepY;
    const xend = width - wrem;
    const yend = height - hrem;
    const boxesArray = [];
    for (let y2 = 0;y2 < height; y2 += stepY) {
      for (let x2 = 0;x2 < width; x2 += stepX) {
        boxesArray.push({
          x: x2,
          y: y2,
          w: x2 === xend ? wrem : stepX,
          h: y2 === yend ? hrem : stepY
        });
      }
    }
    return boxesArray;
  }
};
var ColorHistogram = _ColorHistogram;
__publicField(ColorHistogram, "_boxSize", [64, 64]);
__publicField(ColorHistogram, "_boxPixels", 2);
__publicField(ColorHistogram, "_hueGroups", 10);
var RemovedColor = class {
  constructor(index, color, distance2) {
    __publicField(this, "index");
    __publicField(this, "color");
    __publicField(this, "distance");
    this.index = index;
    this.color = color;
    this.distance = distance2;
  }
};
var RGBQuant = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256, method = 2) {
    super();
    __publicField(this, "_colors");
    __publicField(this, "_initialDistance");
    __publicField(this, "_distanceIncrement");
    __publicField(this, "_histogram");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._colors = colors;
    this._histogram = new ColorHistogram(method, colors);
    this._initialDistance = 0.01;
    this._distanceIncrement = 0.005;
  }
  sample(image3) {
    this._histogram.sample(image3);
  }
  *quantize() {
    const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
    if (idxi32.length === 0) {
      throw new Error("No colors in image");
    }
    yield* this._buildPalette(idxi32);
  }
  *_buildPalette(idxi32) {
    const palette2 = new Palette;
    const colorArray = palette2.getPointContainer().getPointArray();
    const usageArray = new Array(idxi32.length);
    for (let i2 = 0;i2 < idxi32.length; i2++) {
      colorArray.push(Point.createByUint32(idxi32[i2]));
      usageArray[i2] = 1;
    }
    const len = colorArray.length;
    const memDist = [];
    let palLen = len;
    let thold = this._initialDistance;
    const tracker = new ProgressTracker(palLen - this._colors, 99);
    while (palLen > this._colors) {
      memDist.length = 0;
      for (let i2 = 0;i2 < len; i2++) {
        if (tracker.shouldNotify(len - palLen)) {
          yield {
            progress: tracker.progress
          };
        }
        if (usageArray[i2] === 0)
          continue;
        const pxi = colorArray[i2];
        for (let j = i2 + 1;j < len; j++) {
          if (usageArray[j] === 0)
            continue;
          const pxj = colorArray[j];
          const dist = this._distance.calculateNormalized(pxi, pxj);
          if (dist < thold) {
            memDist.push(new RemovedColor(j, pxj, dist));
            usageArray[j] = 0;
            palLen--;
          }
        }
      }
      thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
    }
    if (palLen < this._colors) {
      stableSort(memDist, (a2, b) => b.distance - a2.distance);
      let k = 0;
      while (palLen < this._colors && k < memDist.length) {
        const removedColor = memDist[k];
        usageArray[removedColor.index] = 1;
        palLen++;
        k++;
      }
    }
    let colors = colorArray.length;
    for (let colorIndex = colors - 1;colorIndex >= 0; colorIndex--) {
      if (usageArray[colorIndex] === 0) {
        if (colorIndex !== colors - 1) {
          colorArray[colorIndex] = colorArray[colors - 1];
        }
        --colors;
      }
    }
    colorArray.length = colors;
    palette2.sort();
    yield {
      palette: palette2,
      progress: 100
    };
  }
};
function createArray1D(dimension1) {
  const a2 = [];
  for (let k = 0;k < dimension1; k++) {
    a2[k] = 0;
  }
  return a2;
}
function createArray4D(dimension1, dimension2, dimension3, dimension4) {
  const a2 = new Array(dimension1);
  for (let i2 = 0;i2 < dimension1; i2++) {
    a2[i2] = new Array(dimension2);
    for (let j = 0;j < dimension2; j++) {
      a2[i2][j] = new Array(dimension3);
      for (let k = 0;k < dimension3; k++) {
        a2[i2][j][k] = new Array(dimension4);
        for (let l = 0;l < dimension4; l++) {
          a2[i2][j][k][l] = 0;
        }
      }
    }
  }
  return a2;
}
function createArray3D(dimension1, dimension2, dimension3) {
  const a2 = new Array(dimension1);
  for (let i2 = 0;i2 < dimension1; i2++) {
    a2[i2] = new Array(dimension2);
    for (let j = 0;j < dimension2; j++) {
      a2[i2][j] = new Array(dimension3);
      for (let k = 0;k < dimension3; k++) {
        a2[i2][j][k] = 0;
      }
    }
  }
  return a2;
}
function fillArray3D(a2, dimension1, dimension2, dimension3, value) {
  for (let i2 = 0;i2 < dimension1; i2++) {
    a2[i2] = [];
    for (let j = 0;j < dimension2; j++) {
      a2[i2][j] = [];
      for (let k = 0;k < dimension3; k++) {
        a2[i2][j][k] = value;
      }
    }
  }
}
function fillArray1D(a2, dimension1, value) {
  for (let i2 = 0;i2 < dimension1; i2++) {
    a2[i2] = value;
  }
}
var WuColorCube = class {
  constructor() {
    __publicField(this, "redMinimum");
    __publicField(this, "redMaximum");
    __publicField(this, "greenMinimum");
    __publicField(this, "greenMaximum");
    __publicField(this, "blueMinimum");
    __publicField(this, "blueMaximum");
    __publicField(this, "volume");
    __publicField(this, "alphaMinimum");
    __publicField(this, "alphaMaximum");
  }
};
var _WuQuant = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {
    super();
    __publicField(this, "_reds");
    __publicField(this, "_greens");
    __publicField(this, "_blues");
    __publicField(this, "_alphas");
    __publicField(this, "_sums");
    __publicField(this, "_weights");
    __publicField(this, "_momentsRed");
    __publicField(this, "_momentsGreen");
    __publicField(this, "_momentsBlue");
    __publicField(this, "_momentsAlpha");
    __publicField(this, "_moments");
    __publicField(this, "_table");
    __publicField(this, "_pixels");
    __publicField(this, "_cubes");
    __publicField(this, "_colors");
    __publicField(this, "_significantBitsPerChannel");
    __publicField(this, "_maxSideIndex");
    __publicField(this, "_alphaMaxSideIndex");
    __publicField(this, "_sideSize");
    __publicField(this, "_alphaSideSize");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._setQuality(significantBitsPerChannel);
    this._initialize(colors);
  }
  sample(image3) {
    const pointArray = image3.getPointArray();
    for (let i2 = 0, l = pointArray.length;i2 < l; i2++) {
      this._addColor(pointArray[i2]);
    }
    this._pixels = this._pixels.concat(pointArray);
  }
  *quantize() {
    yield* this._preparePalette();
    const palette2 = new Palette;
    for (let paletteIndex = 0;paletteIndex < this._colors; paletteIndex++) {
      if (this._sums[paletteIndex] > 0) {
        const sum = this._sums[paletteIndex];
        const r = this._reds[paletteIndex] / sum;
        const g = this._greens[paletteIndex] / sum;
        const b = this._blues[paletteIndex] / sum;
        const a2 = this._alphas[paletteIndex] / sum;
        const color = Point.createByRGBA(r | 0, g | 0, b | 0, a2 | 0);
        palette2.add(color);
      }
    }
    palette2.sort();
    yield {
      palette: palette2,
      progress: 100
    };
  }
  *_preparePalette() {
    yield* this._calculateMoments();
    let next = 0;
    const volumeVariance = createArray1D(this._colors);
    for (let cubeIndex = 1;cubeIndex < this._colors; ++cubeIndex) {
      if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
        volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;
        volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;
      } else {
        volumeVariance[next] = 0;
        cubeIndex--;
      }
      next = 0;
      let temp = volumeVariance[0];
      for (let index = 1;index <= cubeIndex; ++index) {
        if (volumeVariance[index] > temp) {
          temp = volumeVariance[index];
          next = index;
        }
      }
      if (temp <= 0) {
        this._colors = cubeIndex + 1;
        break;
      }
    }
    const lookupRed = [];
    const lookupGreen = [];
    const lookupBlue = [];
    const lookupAlpha = [];
    for (let k = 0;k < this._colors; ++k) {
      const weight = _WuQuant._volume(this._cubes[k], this._weights);
      if (weight > 0) {
        lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0;
        lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0;
        lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0;
        lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0;
      } else {
        lookupRed[k] = 0;
        lookupGreen[k] = 0;
        lookupBlue[k] = 0;
        lookupAlpha[k] = 0;
      }
    }
    this._reds = createArray1D(this._colors + 1);
    this._greens = createArray1D(this._colors + 1);
    this._blues = createArray1D(this._colors + 1);
    this._alphas = createArray1D(this._colors + 1);
    this._sums = createArray1D(this._colors + 1);
    for (let index = 0, l = this._pixels.length;index < l; index++) {
      const color = this._pixels[index];
      const match = -1;
      let bestMatch = match;
      let bestDistance = Number.MAX_VALUE;
      for (let lookup = 0;lookup < this._colors; lookup++) {
        const foundRed = lookupRed[lookup];
        const foundGreen = lookupGreen[lookup];
        const foundBlue = lookupBlue[lookup];
        const foundAlpha = lookupAlpha[lookup];
        const distance2 = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
        if (distance2 < bestDistance) {
          bestDistance = distance2;
          bestMatch = lookup;
        }
      }
      this._reds[bestMatch] += color.r;
      this._greens[bestMatch] += color.g;
      this._blues[bestMatch] += color.b;
      this._alphas[bestMatch] += color.a;
      this._sums[bestMatch]++;
    }
  }
  _addColor(color) {
    const bitsToRemove = 8 - this._significantBitsPerChannel;
    const indexRed = (color.r >> bitsToRemove) + 1;
    const indexGreen = (color.g >> bitsToRemove) + 1;
    const indexBlue = (color.b >> bitsToRemove) + 1;
    const indexAlpha = (color.a >> bitsToRemove) + 1;
    this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
    this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
    this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
    this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
    this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
    this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
  }
  *_calculateMoments() {
    const area = [];
    const areaRed = [];
    const areaGreen = [];
    const areaBlue = [];
    const areaAlpha = [];
    const area2 = [];
    const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    let trackerProgress = 0;
    const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
    for (let alphaIndex = 1;alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
      fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
      for (let redIndex = 1;redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {
        if (tracker.shouldNotify(trackerProgress)) {
          yield {
            progress: tracker.progress
          };
        }
        fillArray1D(area, this._sideSize, 0);
        fillArray1D(areaRed, this._sideSize, 0);
        fillArray1D(areaGreen, this._sideSize, 0);
        fillArray1D(areaBlue, this._sideSize, 0);
        fillArray1D(areaAlpha, this._sideSize, 0);
        fillArray1D(area2, this._sideSize, 0);
        for (let greenIndex = 1;greenIndex <= this._maxSideIndex; ++greenIndex) {
          let line = 0;
          let lineRed = 0;
          let lineGreen = 0;
          let lineBlue = 0;
          let lineAlpha = 0;
          let line2 = 0;
          for (let blueIndex = 1;blueIndex <= this._maxSideIndex; ++blueIndex) {
            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
            lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
            lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
            lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
            lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
            area[blueIndex] += line;
            areaRed[blueIndex] += lineRed;
            areaGreen[blueIndex] += lineGreen;
            areaBlue[blueIndex] += lineBlue;
            areaAlpha[blueIndex] += lineAlpha;
            area2[blueIndex] += line2;
            xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
            xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
            xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
            xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
            xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
            xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
          }
        }
      }
    }
  }
  static _volumeFloat(cube, moment) {
    return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
  }
  static _volume(cube, moment) {
    return _WuQuant._volumeFloat(cube, moment) | 0;
  }
  static _top(cube, direction, position, moment) {
    let result;
    switch (direction) {
      case _WuQuant._alpha:
        result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
        break;
      case _WuQuant._red:
        result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
        break;
      case _WuQuant._green:
        result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
        break;
      case _WuQuant._blue:
        result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
        break;
      default:
        throw new Error("impossible");
    }
    return result | 0;
  }
  static _bottom(cube, direction, moment) {
    switch (direction) {
      case _WuQuant._alpha:
        return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      case _WuQuant._red:
        return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      case _WuQuant._green:
        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      case _WuQuant._blue:
        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      default:
        return 0;
    }
  }
  _calculateVariance(cube) {
    const volumeRed = _WuQuant._volume(cube, this._momentsRed);
    const volumeGreen = _WuQuant._volume(cube, this._momentsGreen);
    const volumeBlue = _WuQuant._volume(cube, this._momentsBlue);
    const volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);
    const volumeMoment = _WuQuant._volumeFloat(cube, this._moments);
    const volumeWeight = _WuQuant._volume(cube, this._weights);
    const distance2 = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
    return volumeMoment - distance2 / volumeWeight;
  }
  _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
    const bottomRed = _WuQuant._bottom(cube, direction, this._momentsRed) | 0;
    const bottomGreen = _WuQuant._bottom(cube, direction, this._momentsGreen) | 0;
    const bottomBlue = _WuQuant._bottom(cube, direction, this._momentsBlue) | 0;
    const bottomAlpha = _WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;
    const bottomWeight = _WuQuant._bottom(cube, direction, this._weights) | 0;
    let result = 0;
    let cutPosition = -1;
    for (let position = first;position < last; ++position) {
      let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed);
      let halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen);
      let halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue);
      let halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha);
      let halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);
      if (halfWeight !== 0) {
        let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
        let temp = halfDistance / halfWeight;
        halfRed = wholeRed - halfRed;
        halfGreen = wholeGreen - halfGreen;
        halfBlue = wholeBlue - halfBlue;
        halfAlpha = wholeAlpha - halfAlpha;
        halfWeight = wholeWeight - halfWeight;
        if (halfWeight !== 0) {
          halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
          temp += halfDistance / halfWeight;
          if (temp > result) {
            result = temp;
            cutPosition = position;
          }
        }
      }
    }
    return { max: result, position: cutPosition };
  }
  _cut(first, second) {
    let direction;
    const wholeRed = _WuQuant._volume(first, this._momentsRed);
    const wholeGreen = _WuQuant._volume(first, this._momentsGreen);
    const wholeBlue = _WuQuant._volume(first, this._momentsBlue);
    const wholeAlpha = _WuQuant._volume(first, this._momentsAlpha);
    const wholeWeight = _WuQuant._volume(first, this._weights);
    const red2 = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    const green2 = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    const blue2 = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    const alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    if (alpha.max >= red2.max && alpha.max >= green2.max && alpha.max >= blue2.max) {
      direction = _WuQuant._alpha;
      if (alpha.position < 0)
        return false;
    } else if (red2.max >= alpha.max && red2.max >= green2.max && red2.max >= blue2.max) {
      direction = _WuQuant._red;
    } else if (green2.max >= alpha.max && green2.max >= red2.max && green2.max >= blue2.max) {
      direction = _WuQuant._green;
    } else {
      direction = _WuQuant._blue;
    }
    second.redMaximum = first.redMaximum;
    second.greenMaximum = first.greenMaximum;
    second.blueMaximum = first.blueMaximum;
    second.alphaMaximum = first.alphaMaximum;
    switch (direction) {
      case _WuQuant._red:
        second.redMinimum = first.redMaximum = red2.position;
        second.greenMinimum = first.greenMinimum;
        second.blueMinimum = first.blueMinimum;
        second.alphaMinimum = first.alphaMinimum;
        break;
      case _WuQuant._green:
        second.greenMinimum = first.greenMaximum = green2.position;
        second.redMinimum = first.redMinimum;
        second.blueMinimum = first.blueMinimum;
        second.alphaMinimum = first.alphaMinimum;
        break;
      case _WuQuant._blue:
        second.blueMinimum = first.blueMaximum = blue2.position;
        second.redMinimum = first.redMinimum;
        second.greenMinimum = first.greenMinimum;
        second.alphaMinimum = first.alphaMinimum;
        break;
      case _WuQuant._alpha:
        second.alphaMinimum = first.alphaMaximum = alpha.position;
        second.blueMinimum = first.blueMinimum;
        second.redMinimum = first.redMinimum;
        second.greenMinimum = first.greenMinimum;
        break;
    }
    first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
    second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
    return true;
  }
  _initialize(colors) {
    this._colors = colors;
    this._cubes = [];
    for (let cubeIndex = 0;cubeIndex < colors; cubeIndex++) {
      this._cubes[cubeIndex] = new WuColorCube;
    }
    this._cubes[0].redMinimum = 0;
    this._cubes[0].greenMinimum = 0;
    this._cubes[0].blueMinimum = 0;
    this._cubes[0].alphaMinimum = 0;
    this._cubes[0].redMaximum = this._maxSideIndex;
    this._cubes[0].greenMaximum = this._maxSideIndex;
    this._cubes[0].blueMaximum = this._maxSideIndex;
    this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
    this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._table = [];
    for (let tableIndex = 0;tableIndex < 256; ++tableIndex) {
      this._table[tableIndex] = tableIndex * tableIndex;
    }
    this._pixels = [];
  }
  _setQuality(significantBitsPerChannel = 5) {
    this._significantBitsPerChannel = significantBitsPerChannel;
    this._maxSideIndex = 1 << this._significantBitsPerChannel;
    this._alphaMaxSideIndex = this._maxSideIndex;
    this._sideSize = this._maxSideIndex + 1;
    this._alphaSideSize = this._alphaMaxSideIndex + 1;
  }
};
var WuQuant = _WuQuant;
__publicField(WuQuant, "_alpha", 3);
__publicField(WuQuant, "_red", 2);
__publicField(WuQuant, "_green", 1);
__publicField(WuQuant, "_blue", 0);
var image_exports = {};
__export2(image_exports, {
  AbstractImageQuantizer: () => AbstractImageQuantizer,
  ErrorDiffusionArray: () => ErrorDiffusionArray,
  ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,
  ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,
  NearestColor: () => NearestColor
});
var AbstractImageQuantizer = class {
  quantizeSync(pointContainer, palette2) {
    for (const value of this.quantize(pointContainer, palette2)) {
      if (value.pointContainer) {
        return value.pointContainer;
      }
    }
    throw new Error("unreachable");
  }
};
var NearestColor = class extends AbstractImageQuantizer {
  constructor(colorDistanceCalculator) {
    super();
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
  }
  *quantize(pointContainer, palette2) {
    const pointArray = pointContainer.getPointArray();
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const tracker = new ProgressTracker(height, 99);
    for (let y2 = 0;y2 < height; y2++) {
      if (tracker.shouldNotify(y2)) {
        yield {
          progress: tracker.progress
        };
      }
      for (let x2 = 0, idx = y2 * width;x2 < width; x2++, idx++) {
        const point = pointArray[idx];
        point.from(palette2.getNearestColor(this._distance, point));
      }
    }
    yield {
      pointContainer,
      progress: 100
    };
  }
};
var ErrorDiffusionArrayKernel = /* @__PURE__ */ ((ErrorDiffusionArrayKernel2) => {
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FloydSteinberg"] = 0] = "FloydSteinberg";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Stucki"] = 2] = "Stucki";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Atkinson"] = 3] = "Atkinson";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Jarvis"] = 4] = "Jarvis";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Burkes"] = 5] = "Burkes";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Sierra"] = 6] = "Sierra";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["TwoSierra"] = 7] = "TwoSierra";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["SierraLite"] = 8] = "SierraLite";
  return ErrorDiffusionArrayKernel2;
})(ErrorDiffusionArrayKernel || {});
var ErrorDiffusionArray = class extends AbstractImageQuantizer {
  constructor(colorDistanceCalculator, kernel, serpentine = true, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = false) {
    super();
    __publicField(this, "_minColorDistance");
    __publicField(this, "_serpentine");
    __publicField(this, "_kernel");
    __publicField(this, "_calculateErrorLikeGIMP");
    __publicField(this, "_distance");
    this._setKernel(kernel);
    this._distance = colorDistanceCalculator;
    this._minColorDistance = minimumColorDistanceToDither;
    this._serpentine = serpentine;
    this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
  }
  *quantize(pointContainer, palette2) {
    const pointArray = pointContainer.getPointArray();
    const originalPoint = new Point;
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const errorLines = [];
    let dir = 1;
    let maxErrorLines = 1;
    for (const kernel of this._kernel) {
      const kernelErrorLines = kernel[2] + 1;
      if (maxErrorLines < kernelErrorLines)
        maxErrorLines = kernelErrorLines;
    }
    for (let i2 = 0;i2 < maxErrorLines; i2++) {
      this._fillErrorLine(errorLines[i2] = [], width);
    }
    const tracker = new ProgressTracker(height, 99);
    for (let y2 = 0;y2 < height; y2++) {
      if (tracker.shouldNotify(y2)) {
        yield {
          progress: tracker.progress
        };
      }
      if (this._serpentine)
        dir *= -1;
      const lni = y2 * width;
      const xStart = dir === 1 ? 0 : width - 1;
      const xEnd = dir === 1 ? width : -1;
      this._fillErrorLine(errorLines[0], width);
      errorLines.push(errorLines.shift());
      const errorLine = errorLines[0];
      for (let x2 = xStart, idx = lni + xStart;x2 !== xEnd; x2 += dir, idx += dir) {
        const point = pointArray[idx];
        const error = errorLine[x2];
        originalPoint.from(point);
        const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3]));
        const palettePoint = palette2.getNearestColor(this._distance, correctedPoint);
        point.from(palettePoint);
        if (this._minColorDistance) {
          const dist = this._distance.calculateNormalized(originalPoint, palettePoint);
          if (dist < this._minColorDistance)
            continue;
        }
        let er;
        let eg;
        let eb;
        let ea;
        if (this._calculateErrorLikeGIMP) {
          er = correctedPoint.r - palettePoint.r;
          eg = correctedPoint.g - palettePoint.g;
          eb = correctedPoint.b - palettePoint.b;
          ea = correctedPoint.a - palettePoint.a;
        } else {
          er = originalPoint.r - palettePoint.r;
          eg = originalPoint.g - palettePoint.g;
          eb = originalPoint.b - palettePoint.b;
          ea = originalPoint.a - palettePoint.a;
        }
        const dStart = dir === 1 ? 0 : this._kernel.length - 1;
        const dEnd = dir === 1 ? this._kernel.length : -1;
        for (let i2 = dStart;i2 !== dEnd; i2 += dir) {
          const x1 = this._kernel[i2][1] * dir;
          const y1 = this._kernel[i2][2];
          if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {
            const d = this._kernel[i2][0];
            const e = errorLines[y1][x1 + x2];
            e[0] += er * d;
            e[1] += eg * d;
            e[2] += eb * d;
            e[3] += ea * d;
          }
        }
      }
    }
    yield {
      pointContainer,
      progress: 100
    };
  }
  _fillErrorLine(errorLine, width) {
    if (errorLine.length > width) {
      errorLine.length = width;
    }
    const l = errorLine.length;
    for (let i2 = 0;i2 < l; i2++) {
      const error = errorLine[i2];
      error[0] = error[1] = error[2] = error[3] = 0;
    }
    for (let i2 = l;i2 < width; i2++) {
      errorLine[i2] = [0, 0, 0, 0];
    }
  }
  _setKernel(kernel) {
    switch (kernel) {
      case 0:
        this._kernel = [
          [7 / 16, 1, 0],
          [3 / 16, -1, 1],
          [5 / 16, 0, 1],
          [1 / 16, 1, 1]
        ];
        break;
      case 1:
        this._kernel = [
          [3 / 8, 1, 0],
          [3 / 8, 0, 1],
          [2 / 8, 1, 1]
        ];
        break;
      case 2:
        this._kernel = [
          [8 / 42, 1, 0],
          [4 / 42, 2, 0],
          [2 / 42, -2, 1],
          [4 / 42, -1, 1],
          [8 / 42, 0, 1],
          [4 / 42, 1, 1],
          [2 / 42, 2, 1],
          [1 / 42, -2, 2],
          [2 / 42, -1, 2],
          [4 / 42, 0, 2],
          [2 / 42, 1, 2],
          [1 / 42, 2, 2]
        ];
        break;
      case 3:
        this._kernel = [
          [1 / 8, 1, 0],
          [1 / 8, 2, 0],
          [1 / 8, -1, 1],
          [1 / 8, 0, 1],
          [1 / 8, 1, 1],
          [1 / 8, 0, 2]
        ];
        break;
      case 4:
        this._kernel = [
          [7 / 48, 1, 0],
          [5 / 48, 2, 0],
          [3 / 48, -2, 1],
          [5 / 48, -1, 1],
          [7 / 48, 0, 1],
          [5 / 48, 1, 1],
          [3 / 48, 2, 1],
          [1 / 48, -2, 2],
          [3 / 48, -1, 2],
          [5 / 48, 0, 2],
          [3 / 48, 1, 2],
          [1 / 48, 2, 2]
        ];
        break;
      case 5:
        this._kernel = [
          [8 / 32, 1, 0],
          [4 / 32, 2, 0],
          [2 / 32, -2, 1],
          [4 / 32, -1, 1],
          [8 / 32, 0, 1],
          [4 / 32, 1, 1],
          [2 / 32, 2, 1]
        ];
        break;
      case 6:
        this._kernel = [
          [5 / 32, 1, 0],
          [3 / 32, 2, 0],
          [2 / 32, -2, 1],
          [4 / 32, -1, 1],
          [5 / 32, 0, 1],
          [4 / 32, 1, 1],
          [2 / 32, 2, 1],
          [2 / 32, -1, 2],
          [3 / 32, 0, 2],
          [2 / 32, 1, 2]
        ];
        break;
      case 7:
        this._kernel = [
          [4 / 16, 1, 0],
          [3 / 16, 2, 0],
          [1 / 16, -2, 1],
          [2 / 16, -1, 1],
          [3 / 16, 0, 1],
          [2 / 16, 1, 1],
          [1 / 16, 2, 1]
        ];
        break;
      case 8:
        this._kernel = [
          [2 / 4, 1, 0],
          [1 / 4, -1, 1],
          [1 / 4, 0, 1]
        ];
        break;
      default:
        throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);
    }
  }
};
function* hilbertCurve(width, height, callback) {
  const maxBound = Math.max(width, height);
  const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);
  const tracker = new ProgressTracker(width * height, 99);
  const data = {
    width,
    height,
    level,
    callback,
    tracker,
    index: 0,
    x: 0,
    y: 0
  };
  yield* walkHilbert(data, 1);
  visit(data, 0);
}
function* walkHilbert(data, direction) {
  if (data.level < 1)
    return;
  if (data.tracker.shouldNotify(data.index)) {
    yield { progress: data.tracker.progress };
  }
  data.level--;
  switch (direction) {
    case 2:
      yield* walkHilbert(data, 1);
      visit(data, 3);
      yield* walkHilbert(data, 2);
      visit(data, 4);
      yield* walkHilbert(data, 2);
      visit(data, 2);
      yield* walkHilbert(data, 4);
      break;
    case 3:
      yield* walkHilbert(data, 4);
      visit(data, 2);
      yield* walkHilbert(data, 3);
      visit(data, 1);
      yield* walkHilbert(data, 3);
      visit(data, 3);
      yield* walkHilbert(data, 1);
      break;
    case 1:
      yield* walkHilbert(data, 2);
      visit(data, 4);
      yield* walkHilbert(data, 1);
      visit(data, 3);
      yield* walkHilbert(data, 1);
      visit(data, 1);
      yield* walkHilbert(data, 3);
      break;
    case 4:
      yield* walkHilbert(data, 3);
      visit(data, 1);
      yield* walkHilbert(data, 4);
      visit(data, 2);
      yield* walkHilbert(data, 4);
      visit(data, 4);
      yield* walkHilbert(data, 2);
      break;
    default:
      break;
  }
  data.level++;
}
function visit(data, direction) {
  if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {
    data.callback(data.x, data.y);
    data.index++;
  }
  switch (direction) {
    case 2:
      data.x--;
      break;
    case 3:
      data.x++;
      break;
    case 1:
      data.y--;
      break;
    case 4:
      data.y++;
      break;
  }
}
var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
  constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {
    super();
    __publicField(this, "_distance");
    __publicField(this, "_weights");
    __publicField(this, "_errorQueueSize");
    this._distance = colorDistanceCalculator;
    this._errorQueueSize = errorQueueSize;
    this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);
  }
  *quantize(pointContainer, palette2) {
    const pointArray = pointContainer.getPointArray();
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const errorQueue = [];
    let head = 0;
    for (let i2 = 0;i2 < this._errorQueueSize; i2++) {
      errorQueue[i2] = { r: 0, g: 0, b: 0, a: 0 };
    }
    yield* hilbertCurve(width, height, (x2, y2) => {
      const p = pointArray[x2 + y2 * width];
      let { r, g, b, a: a2 } = p;
      for (let i2 = 0;i2 < this._errorQueueSize; i2++) {
        const weight = this._weights[i2];
        const e = errorQueue[(i2 + head) % this._errorQueueSize];
        r += e.r * weight;
        g += e.g * weight;
        b += e.b * weight;
        a2 += e.a * weight;
      }
      const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a2));
      const quantizedPoint = palette2.getNearestColor(this._distance, correctedPoint);
      head = (head + 1) % this._errorQueueSize;
      const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;
      errorQueue[tail].r = p.r - quantizedPoint.r;
      errorQueue[tail].g = p.g - quantizedPoint.g;
      errorQueue[tail].b = p.b - quantizedPoint.b;
      errorQueue[tail].a = p.a - quantizedPoint.a;
      p.from(quantizedPoint);
    });
    yield {
      pointContainer,
      progress: 100
    };
  }
  static _createWeights(errorPropagation, errorQueueSize) {
    const weights = [];
    const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));
    for (let i2 = 0, next = 1;i2 < errorQueueSize; i2++) {
      weights[i2] = (next + 0.5 | 0) / errorQueueSize * errorPropagation;
      next *= multiplier;
    }
    return weights;
  }
};
var quality_exports = {};
__export2(quality_exports, {
  ssim: () => ssim
});
var K1 = 0.01;
var K2 = 0.03;
function ssim(image1, image22) {
  if (image1.getHeight() !== image22.getHeight() || image1.getWidth() !== image22.getWidth()) {
    throw new Error("Images have different sizes!");
  }
  const bitsPerComponent = 8;
  const L = (1 << bitsPerComponent) - 1;
  const c1 = (K1 * L) ** 2;
  const c22 = (K2 * L) ** 2;
  let numWindows = 0;
  let mssim = 0;
  iterate(image1, image22, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {
    let sigxy = 0;
    let sigsqx = 0;
    let sigsqy = 0;
    for (let i2 = 0;i2 < lumaValues1.length; i2++) {
      sigsqx += (lumaValues1[i2] - averageLumaValue1) ** 2;
      sigsqy += (lumaValues2[i2] - averageLumaValue2) ** 2;
      sigxy += (lumaValues1[i2] - averageLumaValue1) * (lumaValues2[i2] - averageLumaValue2);
    }
    const numPixelsInWin = lumaValues1.length - 1;
    sigsqx /= numPixelsInWin;
    sigsqy /= numPixelsInWin;
    sigxy /= numPixelsInWin;
    const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c22);
    const denominator = (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c22);
    const ssim2 = numerator / denominator;
    mssim += ssim2;
    numWindows++;
  });
  return mssim / numWindows;
}
function iterate(image1, image22, callback) {
  const windowSize = 8;
  const width = image1.getWidth();
  const height = image1.getHeight();
  for (let y2 = 0;y2 < height; y2 += windowSize) {
    for (let x2 = 0;x2 < width; x2 += windowSize) {
      const windowWidth = Math.min(windowSize, width - x2);
      const windowHeight = Math.min(windowSize, height - y2);
      const lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight);
      const lumaValues2 = calculateLumaValuesForWindow(image22, x2, y2, windowWidth, windowHeight);
      const averageLuma1 = calculateAverageLuma(lumaValues1);
      const averageLuma2 = calculateAverageLuma(lumaValues2);
      callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
    }
  }
}
function calculateLumaValuesForWindow(image3, x2, y2, width, height) {
  const pointArray = image3.getPointArray();
  const lumaValues = [];
  let counter = 0;
  for (let j = y2;j < y2 + height; j++) {
    const offset = j * image3.getWidth();
    for (let i2 = x2;i2 < x2 + width; i2++) {
      const point = pointArray[offset + i2];
      lumaValues[counter] = point.r * 0.2126 + point.g * 0.7152 + point.b * 0.0722;
      counter++;
    }
  }
  return lumaValues;
}
function calculateAverageLuma(lumaValues) {
  let sumLuma = 0;
  for (const luma of lumaValues) {
    sumLuma += luma;
  }
  return sumLuma / lumaValues.length;
}
var setImmediateImpl = typeof setImmediate === "function" ? setImmediate : typeof process !== "undefined" && typeof (process == null ? undefined : process.nextTick) === "function" ? (callback) => process.nextTick(callback) : (callback) => setTimeout(callback, 0);
function buildPaletteSync(images, {
  colorDistanceFormula,
  paletteQuantization,
  colors
} = {}) {
  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
  const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
  images.forEach((image3) => paletteQuantizer.sample(image3));
  return paletteQuantizer.quantizeSync();
}
function applyPaletteSync(image3, palette2, { colorDistanceFormula, imageQuantization } = {}) {
  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
  const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
  return imageQuantizer.quantizeSync(image3, palette2);
}
function colorDistanceFormulaToColorDistance(colorDistanceFormula = "euclidean-bt709") {
  switch (colorDistanceFormula) {
    case "cie94-graphic-arts":
      return new CIE94GraphicArts;
    case "cie94-textiles":
      return new CIE94Textiles;
    case "ciede2000":
      return new CIEDE2000;
    case "color-metric":
      return new CMetric;
    case "euclidean":
      return new Euclidean;
    case "euclidean-bt709":
      return new EuclideanBT709;
    case "euclidean-bt709-noalpha":
      return new EuclideanBT709NoAlpha;
    case "manhattan":
      return new Manhattan;
    case "manhattan-bt709":
      return new ManhattanBT709;
    case "manhattan-nommyde":
      return new ManhattanNommyde;
    case "pngquant":
      return new PNGQuant;
    default:
      throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);
  }
}
function imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = "floyd-steinberg") {
  switch (imageQuantization) {
    case "nearest":
      return new NearestColor(distanceCalculator);
    case "riemersma":
      return new ErrorDiffusionRiemersma(distanceCalculator);
    case "floyd-steinberg":
      return new ErrorDiffusionArray(distanceCalculator, 0);
    case "false-floyd-steinberg":
      return new ErrorDiffusionArray(distanceCalculator, 1);
    case "stucki":
      return new ErrorDiffusionArray(distanceCalculator, 2);
    case "atkinson":
      return new ErrorDiffusionArray(distanceCalculator, 3);
    case "jarvis":
      return new ErrorDiffusionArray(distanceCalculator, 4);
    case "burkes":
      return new ErrorDiffusionArray(distanceCalculator, 5);
    case "sierra":
      return new ErrorDiffusionArray(distanceCalculator, 6);
    case "two-sierra":
      return new ErrorDiffusionArray(distanceCalculator, 7);
    case "sierra-lite":
      return new ErrorDiffusionArray(distanceCalculator, 8);
    default:
      throw new Error(`Unknown imageQuantization ${imageQuantization}`);
  }
}
function paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = "wuquant", colors = 256) {
  switch (paletteQuantization) {
    case "neuquant":
      return new NeuQuant(distanceCalculator, colors);
    case "rgbquant":
      return new RGBQuant(distanceCalculator, colors);
    case "wuquant":
      return new WuQuant(distanceCalculator, colors);
    case "neuquant-float":
      return new NeuQuantFloat(distanceCalculator, colors);
    default:
      throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);
  }
}

// node_modules/@jimp/plugin-quantize/dist/esm/index.js
var QuantizeOptionsSchema = zod_default.object({
  colors: zod_default.number().optional(),
  colorDistanceFormula: zod_default.union([
    zod_default.literal("cie94-textiles"),
    zod_default.literal("cie94-graphic-arts"),
    zod_default.literal("ciede2000"),
    zod_default.literal("color-metric"),
    zod_default.literal("euclidean"),
    zod_default.literal("euclidean-bt709-noalpha"),
    zod_default.literal("euclidean-bt709"),
    zod_default.literal("manhattan"),
    zod_default.literal("manhattan-bt709"),
    zod_default.literal("manhattan-nommyde"),
    zod_default.literal("pngquant")
  ]).optional(),
  paletteQuantization: zod_default.union([
    zod_default.literal("neuquant"),
    zod_default.literal("neuquant-float"),
    zod_default.literal("rgbquant"),
    zod_default.literal("wuquant")
  ]).optional(),
  imageQuantization: zod_default.union([
    zod_default.literal("nearest"),
    zod_default.literal("riemersma"),
    zod_default.literal("floyd-steinberg"),
    zod_default.literal("false-floyd-steinberg"),
    zod_default.literal("stucki"),
    zod_default.literal("atkinson"),
    zod_default.literal("jarvis"),
    zod_default.literal("burkes"),
    zod_default.literal("sierra"),
    zod_default.literal("two-sierra"),
    zod_default.literal("sierra-lite")
  ]).optional()
});
var methods18 = {
  quantize(image3, options) {
    const { colors, colorDistanceFormula, paletteQuantization, imageQuantization } = QuantizeOptionsSchema.parse(options);
    const inPointContainer = utils_exports.PointContainer.fromUint8Array(image3.bitmap.data, image3.bitmap.width, image3.bitmap.height);
    const palette2 = buildPaletteSync([inPointContainer], {
      colors,
      colorDistanceFormula,
      paletteQuantization
    });
    const outPointContainer = applyPaletteSync(inPointContainer, palette2, {
      colorDistanceFormula,
      imageQuantization
    });
    image3.bitmap.data = Buffer.from(outPointContainer.toUint8Array());
    return image3;
  }
};

// node_modules/jimp/dist/esm/index.js
var defaultPlugins = [
  methods,
  methods2,
  methods3,
  methods4,
  methods6,
  methods8,
  methods7,
  methods9,
  methods10,
  methods11,
  methods12,
  methods13,
  methods14,
  methods15,
  methods5,
  methods16,
  methods17,
  methods18
];
var defaultFormats = [bmp, msBmp, gif, jpeg, png, tiff];
var JimpMime = {
  bmp: bmp().mime,
  gif: gif().mime,
  jpeg: jpeg().mime,
  png: png().mime,
  tiff: tiff().mime
};
var Jimp = createJimp({
  formats: defaultFormats,
  plugins: defaultPlugins
});

// import.ts
var import_jsqr = __toESM(require_jsQR(), 1);
var import_qrcode_terminal = __toESM(require_main(), 1);
var import_base32_decode2 = __toESM(require_base32_decode(), 1);
import { exec as exec2 } from "child_process";
import { promisify as promisify4 } from "util";
import fs6 from "fs";
import os4 from "os";
import path8 from "path";
var __dirname = "/Users/macbookpro/Documents/projects/tiny.authenticator";
var execAsync = promisify4(exec2);
var typeDefs = `
syntax = "proto3";
message MigrationPayload {
  repeated OtpParameters otp_parameters = 1;
  int32 version = 2;
  int32 batch_size = 3;
  int32 batch_index = 4;
  int32 batch_id = 5;

  message OtpParameters {
    bytes secret = 1;
    string name = 2;
    string issuer = 3;
    Algorithm algorithm = 4;
    int32 digits = 5;
    OtpType type = 6;
    int64 counter = 7;
  }

  enum Algorithm {
    ALGORITHM_UNSPECIFIED = 0;
    ALGORITHM_SHA1 = 1;
    ALGORITHM_SHA256 = 2;
    ALGORITHM_SHA512 = 3;
    ALGORITHM_MD5 = 4;
  }

  enum OtpType {
    OTP_TYPE_UNSPECIFIED = 0;
    OTP_TYPE_HOTP = 1;
    OTP_TYPE_TOTP = 2;
  }
}
`;
function toBase32(buffer) {
  const alphabet2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  let bits = 0;
  let value = 0;
  let output = "";
  for (let i2 = 0;i2 < buffer.length; i2++) {
    value = value << 8 | buffer[i2];
    bits += 8;
    while (bits >= 5) {
      output += alphabet2[value >>> bits - 5 & 31];
      bits -= 5;
    }
  }
  if (bits > 0) {
    output += alphabet2[value << 5 - bits & 31];
  }
  return output;
}
async function readQRCode(imagePath) {
  const image3 = await Jimp.read(imagePath);
  const { data, width, height } = image3.bitmap;
  const code = import_jsqr.default(data, width, height);
  if (!code) {
    throw new Error("No QR code found in image");
  }
  return code.data;
}
async function readQRFromSelection() {
  const tempPath = path8.join(os4.tmpdir(), "auth_screenshot.png");
  console.log("Select the QR code area on screen...");
  if (process.platform === "win32") {
    console.log("(Drag to select area with mouse, release to capture)");
  } else {
    console.log("(Use mouse to drag selection, then press Enter/Space to capture)");
  }
  try {
    if (process.platform === "darwin") {
      await execAsync(`screencapture -i "${tempPath}"`);
    } else if (process.platform === "linux") {
      await execAsync(`scrot -s "${tempPath}"`);
    } else if (process.platform === "win32") {
      const scriptPath = path8.join(__dirname, "windows_selection.ps1");
      await execAsync(`powershell -ExecutionPolicy Bypass -File "${scriptPath}" "${tempPath}"`);
    } else {
      throw new Error("Selection screenshot not supported on this platform");
    }
    if (!fs6.existsSync(tempPath)) {
      throw new Error("Screenshot cancelled or failed");
    }
    const uri = await readQRCode(tempPath);
    fs6.unlinkSync(tempPath);
    return uri;
  } catch (error) {
    if (fs6.existsSync(tempPath)) {
      fs6.unlinkSync(tempPath);
    }
    throw error;
  }
}
async function decode3(uriString) {
  const root = import_protobufjs.default.parse(typeDefs).root;
  const MigrationPayload = root.lookupType("MigrationPayload");
  try {
    const urlParams = new URLSearchParams(uriString.split("?")[1]);
    const dataParam = urlParams.get("data");
    const base64 = dataParam.replace(/-/g, "+").replace(/_/g, "/");
    const buffer = Buffer.from(base64, "base64");
    const message = MigrationPayload.decode(buffer);
    const accounts = message.otpParameters.map((otp) => {
      const secretBase32 = toBase32(otp.secret);
      const type = otp.type === 2 ? "TOTP" : "HOTP";
      return {
        name: otp.name,
        issuer: otp.issuer,
        secret: secretBase32,
        type
      };
    });
    return accounts;
  } catch (e) {
    throw new Error("Error decoding: " + e?.message);
  }
}
function parseOtpAuthUri(uri) {
  const url = new URL(uri);
  if (url.protocol !== "otpauth:" || url.host !== "totp") {
    throw new Error("Invalid otpauth URI");
  }
  const path9 = url.pathname.slice(1);
  const params = new URLSearchParams(url.search);
  const secret = params.get("secret");
  const issuer = params.get("issuer") || path9.split(":")[0];
  const name = path9.split(":").slice(1).join(":") || path9;
  if (!secret) {
    throw new Error("No secret in URI");
  }
  return { issuer, name, secret };
}

// export.ts
var import_protobufjs2 = __toESM(require_src(), 1);
var import_qrcode_terminal2 = __toESM(require_main(), 1);
var import_base32_decode3 = __toESM(require_base32_decode(), 1);
var typeDefs2 = `
syntax = "proto3";
message MigrationPayload {
  repeated OtpParameters otp_parameters = 1;
  int32 version = 2;
  int32 batch_size = 3;
  int32 batch_index = 4;
  int32 batch_id = 5;

  message OtpParameters {
    bytes secret = 1;
    string name = 2;
    string issuer = 3;
    Algorithm algorithm = 4;
    int32 digits = 5;
    OtpType type = 6;
    int64 counter = 7;
  }

  enum Algorithm {
    ALGORITHM_UNSPECIFIED = 0;
    ALGORITHM_SHA1 = 1;
    ALGORITHM_SHA256 = 2;
    ALGORITHM_SHA512 = 3;
    ALGORITHM_MD5 = 4;
  }

  enum OtpType {
    OTP_TYPE_UNSPECIFIED = 0;
    OTP_TYPE_HOTP = 1;
    OTP_TYPE_TOTP = 2;
  }
}
`;
function generateOtpAuthUri(issuer, name, secret) {
  const label = `${issuer}:${name}`;
  return `otpauth://totp/${encodeURIComponent(label)}?secret=${secret}&issuer=${encodeURIComponent(issuer)}`;
}
async function generateGoogleMigrationQR(accounts) {
  const root = import_protobufjs2.default.parse(typeDefs2).root;
  const MigrationPayload = root.lookupType("MigrationPayload");
  const otpParameters = accounts.map((acc) => ({
    secret: Buffer.from(import_base32_decode3.default(acc.secret, "RFC4648")),
    name: acc.name,
    issuer: acc.issuer,
    algorithm: 1,
    digits: 6,
    type: 2
  }));
  const payload = {
    otpParameters,
    version: 1,
    batchSize: accounts.length,
    batchIndex: 0,
    batchId: Math.floor(Math.random() * 1e6)
  };
  const message = MigrationPayload.create(payload);
  const buffer = MigrationPayload.encode(message).finish();
  const dataParam = buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  const uri = `otpauth-migration://offline?data=${dataParam}`;
  console.log("Scan this QR code with Google Authenticator to import all accounts:");
  console.log(uri);
  import_qrcode_terminal2.default.generate(uri, { small: true });
}
function exportSingleAccountQR(issuer, name, secret) {
  const uri = generateOtpAuthUri(issuer, name, secret);
  console.log(`QR code for ${issuer}:${name}:`);
  import_qrcode_terminal2.default.generate(uri, { small: true });
}
// tiny.json
var tiny_default = {
  name: "tiny",
  version: "0.2.0",
  homepage: "https://github.com/dominikwilkowski/cfonts",
  colors: 1,
  lines: 2,
  buffer: [
    "",
    ""
  ],
  letterspace: [
    " ",
    " "
  ],
  letterspace_size: 1,
  chars: {
    A: [
      "",
      ""
    ],
    B: [
      "",
      ""
    ],
    C: [
      "",
      ""
    ],
    D: [
      "",
      ""
    ],
    E: [
      "",
      ""
    ],
    F: [
      "",
      " "
    ],
    G: [
      "",
      ""
    ],
    H: [
      " ",
      ""
    ],
    I: [
      "",
      ""
    ],
    J: [
      "  ",
      ""
    ],
    K: [
      "",
      " "
    ],
    L: [
      "  ",
      ""
    ],
    M: [
      "",
      "  "
    ],
    N: [
      " ",
      " "
    ],
    O: [
      "",
      ""
    ],
    P: [
      "",
      ""
    ],
    Q: [
      "",
      ""
    ],
    R: [
      "",
      ""
    ],
    S: [
      "",
      ""
    ],
    T: [
      "",
      "  "
    ],
    U: [
      " ",
      ""
    ],
    V: [
      " ",
      ""
    ],
    W: [
      "  ",
      ""
    ],
    X: [
      "",
      " "
    ],
    Y: [
      "",
      "  "
    ],
    Z: [
      "",
      ""
    ],
    "0": [
      "",
      ""
    ],
    "1": [
      "",
      " "
    ],
    "2": [
      "",
      ""
    ],
    "3": [
      "",
      ""
    ],
    "4": [
      " ",
      ""
    ],
    "5": [
      "",
      ""
    ],
    "6": [
      "",
      ""
    ],
    "7": [
      "",
      "  "
    ],
    "8": [
      "",
      ""
    ],
    "9": [
      "",
      ""
    ],
    "!": [
      "",
      ""
    ],
    "?": [
      "",
      " "
    ],
    ".": [
      " ",
      ""
    ],
    "+": [
      "",
      "  "
    ],
    "-": [
      "",
      "  "
    ],
    _: [
      "  ",
      ""
    ],
    "=": [
      "",
      ""
    ],
    "@": [
      "",
      ""
    ],
    "#": [
      "",
      ""
    ],
    $: [
      "",
      ""
    ],
    "%": [
      " ",
      " "
    ],
    "&": [
      "",
      ""
    ],
    "(": [
      "",
      ""
    ],
    ")": [
      "",
      ""
    ],
    "/": [
      "  ",
      "  "
    ],
    ":": [
      "",
      ""
    ],
    ";": [
      "  ",
      ""
    ],
    ",": [
      " ",
      ""
    ],
    "'": [
      "",
      " "
    ],
    '"': [
      " ",
      "   "
    ],
    " ": [
      " ",
      " "
    ]
  }
};

// BigText.tsx
var jsx_dev_runtime = __toESM(require_jsx_dev_runtime(), 1);
var fontData = tiny_default;
var renderTinyText = (text) => {
  const { lines, letterspace, chars } = fontData;
  let result = "";
  for (let line = 0;line < lines; line++) {
    for (let i2 = 0;i2 < text.length; i2++) {
      const char = text[i2].toUpperCase();
      const charData = chars[char] || chars[" "];
      if (charData && charData[line]) {
        result += charData[line];
      }
      if (i2 < text.length - 1 && letterspace[line]) {
        result += letterspace[line];
      }
    }
    if (line < lines - 1) {
      result += `
`;
    }
  }
  return result;
};
var BigText = ({ text, font, colors, ...props }) => {
  const activeColor = colors && colors.length > 0 ? colors[0] : undefined;
  if (font === "tiny") {
    const asciiArt = renderTinyText(text);
    return /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Box_default, {
      paddingX: 1,
      paddingY: 2,
      ...props,
      children: /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Text, {
        color: activeColor,
        children: asciiArt
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  return /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Text, {
    color: activeColor,
    ...props,
    children: text
  }, undefined, false, undefined, this);
};
var BigText_default = BigText;

// index.tsx
var jsx_dev_runtime2 = __toESM(require_jsx_dev_runtime(), 1);
var ACCENT_COLOR = "#FF69B4";
var RegisterComponent = ({ onDone }) => {
  const [step, setStep] = import_react27.useState("secret");
  const [secret, setSecret] = import_react27.useState("");
  const [account, setAccount] = import_react27.useState("");
  const [error, setError] = import_react27.useState("");
  const tiny = tiny_default;
  use_input_default((_, key) => {
    if (key.return) {
      if (step === "secret") {
        if (!secret.trim())
          return setError("Secret is required");
        try {
          import_base32_decode4.default(secret.trim(), "RFC4648");
        } catch (e) {
          return setError("Invalid base32 secret");
        }
        setStep("account");
        setError("");
      } else if (step === "account") {
        if (!account.trim())
          return setError("Account name is required");
        const auth = new Authenticator;
        auth.register(account.trim(), secret.trim()).then(async (success) => {
          if (success) {
            onDone(account.trim());
          } else {
            setError("Registration failed");
          }
        });
      }
    }
  });
  if (step === "done") {
    return /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
      padding: 1,
      flexDirection: "column",
      children: /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
        color: "green",
        children: "Registering..."
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  return /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
    flexDirection: "column",
    padding: 1,
    children: [
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(BigText_default, {
        text: "REGISTER",
        font: "tiny",
        colors: [ACCENT_COLOR]
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
        marginTop: 1,
        flexDirection: "column",
        children: [
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
                color: "gray",
                bold: step === "secret",
                children: [
                  step === "secret" ? " " : "  ",
                  "Secret:",
                  " "
                ]
              }, undefined, true, undefined, this),
              step === "secret" ? /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(build_default, {
                value: secret,
                onChange: setSecret,
                placeholder: "token string"
              }, undefined, false, undefined, this) : /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
                color: "gray",
                children: "********"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          (step === "account" || step === "done") && /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
            children: [
              /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
                color: "gray",
                bold: step === "account",
                children: [
                  step === "account" ? " " : "  ",
                  "Account:",
                  " "
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(build_default, {
                value: account,
                onChange: setAccount,
                placeholder: "name@example.com"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      error && /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
        marginTop: 1,
        children: /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
          color: "red",
          children: [
            "! ",
            error
          ]
        }, undefined, true, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var ImportComponent = ({ onDone }) => {
  const [step, setStep] = import_react27.useState("uri");
  const [uri, setUri] = import_react27.useState("");
  const [accounts, setAccounts] = import_react27.useState([]);
  const [error, setError] = import_react27.useState("");
  const [selectedIndex, setSelectedIndex] = import_react27.useState(0);
  const { exit } = use_app_default();
  use_input_default((input, key) => {
    if (key.return) {
      if (step === "uri") {
        console.log("this is the uri", uri);
        if (!uri.trim())
          return setError("URI is required");
        decode3(uri.trim()).then((decoded) => {
          setAccounts(decoded);
          setStep("accounts");
          setError("");
        }).catch((e) => {
          setError(e.message);
        });
      } else if (step === "accounts") {
        const account = accounts[selectedIndex];
        if (account) {
          const auth = new Authenticator;
          const accountName = `${account.issuer}:${account.name}`;
          auth.register(accountName, account.secret).then((success) => {
            if (success) {
              setStep("done");
              setTimeout(onDone, 1000);
            } else {
              setError("Registration failed");
            }
          });
        }
      }
    } else if (key.upArrow) {
      setSelectedIndex(Math.max(0, selectedIndex - 1));
    } else if (key.downArrow) {
      setSelectedIndex(Math.min(accounts.length - 1, selectedIndex + 1));
    } else if (key.escape) {
      exit();
    }
  });
  if (step === "done") {
    return /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
      padding: 1,
      flexDirection: "column",
      children: /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
        color: "green",
        children: " Account registered successfully."
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  if (step === "accounts") {
    return /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
      flexDirection: "column",
      padding: 1,
      children: [
        /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(BigText_default, {
          text: "IMPORT",
          font: "tiny",
          colors: ["magenta"]
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
          children: [
            "Found ",
            accounts.length,
            " accounts. Select one to register:"
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
          marginTop: 1,
          flexDirection: "column",
          children: accounts.map((account, index) => /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
            children: /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
              color: selectedIndex === index ? "cyan" : "gray",
              children: [
                selectedIndex === index ? " " : "  ",
                account.issuer,
                ":",
                account.name,
                " (",
                account.type,
                ")"
              ]
            }, undefined, true, undefined, this)
          }, index, false, undefined, this))
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
          color: "gray",
          children: " to navigate, Enter to register, Esc to exit"
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this);
  }
  return /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
    flexDirection: "column",
    padding: 1,
    children: [
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(BigText_default, {
        text: "IMPORT",
        font: "tiny",
        colors: ["magenta"]
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
        marginTop: 1,
        flexDirection: "column",
        children: [
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
            children: "Paste your Google Authenticator migration URI:"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(build_default, {
            value: uri,
            onChange: setUri,
            placeholder: "otpauth-migration://..."
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      error && /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
        marginTop: 1,
        children: /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
          color: "red",
          children: [
            "! ",
            error
          ]
        }, undefined, true, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var ShowAllComponent = ({ initialAccounts, initialTokens, auth }) => {
  const { exit } = use_app_default();
  const [accounts, setAccounts] = import_react27.useState(initialAccounts);
  const [tokens, setTokens] = import_react27.useState(initialTokens);
  const [selectedIndex, setSelectedIndex] = import_react27.useState(0);
  const [copiedId, setCopiedId] = import_react27.useState(null);
  const [isConfirmingDelete, setIsConfirmingDelete] = import_react27.useState(false);
  const [deleteActionIndex, setDeleteActionIndex] = import_react27.useState(0);
  import_react27.useEffect(() => {
    const timer = setInterval(async () => {
      const nextTokens = {};
      for (const item of accounts) {
        nextTokens[item.account] = await auth.getTokenForAccount(item.account);
      }
      setTokens(nextTokens);
    }, 1000);
    return () => clearInterval(timer);
  }, [accounts, auth]);
  import_react27.useEffect(() => {
    if (copiedId) {
      const timer = setTimeout(() => {
        setCopiedId(null);
      }, 1000);
      return () => clearTimeout(timer);
    }
  }, [copiedId]);
  use_input_default(async (input, key) => {
    if (isConfirmingDelete) {
      if (key.upArrow || key.downArrow) {
        setDeleteActionIndex((prev) => prev === 0 ? 1 : 0);
      }
      if (key.return) {
        if (deleteActionIndex === 1) {
          const accountToDelete = accounts[selectedIndex].account;
          try {
            await auth.deleteAuthStuff(accountToDelete);
            const newAccounts = accounts.filter((_, i2) => i2 !== selectedIndex);
            setAccounts(newAccounts);
            if (selectedIndex >= newAccounts.length) {
              setSelectedIndex(Math.max(0, newAccounts.length - 1));
            }
          } catch (err) {}
        }
        setIsConfirmingDelete(false);
      }
      if (key.escape) {
        setIsConfirmingDelete(false);
      }
      return;
    }
    if (key.upArrow) {
      setSelectedIndex((prev) => Math.max(0, prev - 1));
      setCopiedId(null);
    }
    if (key.downArrow) {
      setSelectedIndex((prev) => Math.min(accounts.length - 1, prev + 1));
      setCopiedId(null);
    }
    if (key.return) {
      const currentAccount = accounts[selectedIndex].account;
      const token = tokens[currentAccount];
      if (token) {
        clipboardy_default.writeSync(token);
        setCopiedId(currentAccount);
      }
    }
    if (input === "d") {
      setIsConfirmingDelete(true);
      setDeleteActionIndex(0);
    }
    if (key.escape || input === "q") {
      exit();
    }
  });
  if (accounts.length === 0) {
    setTimeout(exit, 10);
    return /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
      padding: 1,
      children: /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
        color: "yellow",
        children: "No accounts found."
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  const currentAccountName = accounts[selectedIndex]?.account || "";
  return /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
    flexDirection: "column",
    paddingX: 2,
    paddingY: 1,
    children: [
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
        marginBottom: 1,
        flexDirection: "column",
        alignItems: "flex-start",
        children: [
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(BigText_default, {
            text: "TINY.AUTH",
            font: "tiny",
            colors: [ACCENT_COLOR, ACCENT_COLOR]
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
            color: "gray",
            dimColor: true,
            children: [
              " ",
              "(Enter to copy, 'd' to delete, 'q' to quit)"
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      isConfirmingDelete ? /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
        flexDirection: "column",
        borderStyle: "round",
        borderColor: "red",
        paddingX: 1,
        marginBottom: 1,
        children: [
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
            color: "red",
            bold: true,
            children: [
              'Delete "',
              currentAccountName.toUpperCase(),
              '"?'
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
            marginTop: 1,
            flexDirection: "column",
            children: [
              /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
                children: [
                  /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
                    color: ACCENT_COLOR,
                    bold: deleteActionIndex === 0,
                    children: deleteActionIndex === 0 ? " " : "  "
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
                    color: deleteActionIndex === 0 ? "white" : "gray",
                    children: "Cancel"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
                children: [
                  /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
                    color: ACCENT_COLOR,
                    bold: deleteActionIndex === 1,
                    children: deleteActionIndex === 1 ? " " : "  "
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
                    color: deleteActionIndex === 1 ? "red" : "gray",
                    children: "Yes, Delete"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this) : /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
        flexDirection: "column",
        gap: 1,
        children: accounts.map((item, index) => {
          const isSelected = index === selectedIndex;
          const isCopied = copiedId === item.account;
          const token = tokens[item.account];
          return /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
            flexDirection: "column",
            children: [
              /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
                marginLeft: 2,
                children: /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
                  color: isSelected ? ACCENT_COLOR : "gray",
                  bold: isSelected,
                  children: item.account.toUpperCase()
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
                children: [
                  /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
                    color: ACCENT_COLOR,
                    bold: isSelected,
                    children: isSelected ? " " : "  "
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
                    color: isCopied ? "green" : isSelected ? "green" : "gray",
                    bold: isSelected,
                    dimColor: !isSelected,
                    children: isCopied ? "Copied to clipboard!" : token || "Error"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, item.account, true, undefined, this);
        })
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var ExitComponent = () => {
  const { exit } = use_app_default();
  setTimeout(exit);
  return /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
    flexDirection: "column",
    padding: 1,
    children: [
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(BigText_default, {
        text: "HELP",
        font: "tiny",
        colors: [ACCENT_COLOR]
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
        bold: true,
        color: "yellow",
        children: "Usage:"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Box_default, {
        marginLeft: 2,
        flexDirection: "column",
        children: [
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
            children: "bun run index.ts register"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
            children: "bun run index.ts register cc"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
            children: "bun run index.ts import google [uri]"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
            children: "bun run index.ts import qr <image_path>"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
            children: "bun run index.ts export google"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
            children: "bun run index.ts export qr <account>"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
            children: "bun run index.ts show"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Text, {
            children: "bun run index.ts show <account>"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
async function main() {
  const args = process.argv.slice(2);
  const auth = new Authenticator;
  const run = async (component) => {
    const { waitUntilExit } = render_default(component);
    await waitUntilExit();
    process.exit(0);
  };
  if (args[0] === "register") {
    if (args[1] === "cc") {
      readQRFromSelection().then((uri) => {
        const { issuer, name, secret } = parseOtpAuthUri(uri);
        console.log(`Detected: ${issuer}:${name}`);
        const accountName = `${issuer}:${name}`;
        const auth2 = new Authenticator;
        auth2.register(accountName, secret).then((success) => {
          if (success) {
            console.log(` Registered: ${accountName}`);
            auth2.getTokenForAccount(accountName).then((token) => {
              console.log(`Current token: ${token}`);
              process.exit(0);
            });
          } else {
            console.error("Registration failed");
            process.exit(1);
          }
        });
      }).catch((e) => {
        console.error("Error:", e.message);
        process.exit(1);
      });
    } else {
      await run(/* @__PURE__ */ jsx_dev_runtime2.jsxDEV(RegisterComponent, {
        onDone: (account) => {
          if (account) {
            const auth2 = new Authenticator;
            auth2.listAccounts().then((accounts) => {
              const filtered = accounts.filter((a2) => a2.account === account);
              const tokens = {};
              auth2.getTokenForAccount(account).then((token) => {
                tokens[account] = token;
                run(/* @__PURE__ */ jsx_dev_runtime2.jsxDEV(ShowAllComponent, {
                  initialAccounts: filtered,
                  initialTokens: tokens,
                  auth: auth2
                }, undefined, false, undefined, this));
              });
            });
          } else {
            process.exit(0);
          }
        }
      }, undefined, false, undefined, this));
    }
  } else if (args[0] === "export") {
    if (args[1] === "google") {
      const auth2 = new Authenticator;
      auth2.listAccounts().then(async (accounts) => {
        const accountDetails = [];
        for (const { account } of accounts) {
          const secret = await auth2.retrieveSecret(account);
          if (secret) {
            const [issuer, name] = account.split(":");
            accountDetails.push({ issuer: issuer || "", name: name || account, secret });
          }
        }
        if (accountDetails.length > 0) {
          await generateGoogleMigrationQR(accountDetails);
        } else {
          console.log("No accounts to export");
        }
        process.exit(0);
      }).catch((e) => {
        console.error("Error:", e.message);
        process.exit(1);
      });
    } else if (args[1] === "qr" && args[2]) {
      const auth2 = new Authenticator;
      auth2.retrieveSecret(args[2]).then((secret) => {
        if (secret) {
          const [issuer, name] = args[2].split(":");
          exportSingleAccountQR(issuer || "", name || args[2], secret);
        } else {
          console.error("Account not found");
        }
        process.exit(0);
      }).catch((e) => {
        console.error("Error:", e.message);
        process.exit(1);
      });
    } else {
      console.error("Usage: bun run index.tsx export google or export qr <account>");
      process.exit(1);
    }
  } else if (args[0] === "import") {
    if (args[1] === "google") {
      if (args[2]) {
        decode3(args[2]).then(async (accounts) => {
          console.log("Decoded accounts:");
          const auth2 = new Authenticator;
          for (const acc of accounts) {
            const accountName = `${acc.issuer}:${acc.name}`;
            console.log(`${accountName} - ***`);
            const success = await auth2.register(accountName, acc.secret);
            if (success) {
              console.log(` Registered: ${accountName}`);
            } else {
              console.log(` Failed: ${accountName}`);
            }
          }
          console.log("Import complete!");
          process.exit(0);
        }).catch((e) => {
          console.error("Error:", e.message);
          process.exit(1);
        });
      } else {
        await run(/* @__PURE__ */ jsx_dev_runtime2.jsxDEV(ImportComponent, {
          onDone: () => process.exit(0)
        }, undefined, false, undefined, this));
      }
    } else if (args[1] === "qr") {
      if (args[2]) {
        readQRCode(args[2]).then((uri) => {
          console.log("QR Code decoded to URI");
          return decode3(uri);
        }).then(async (accounts) => {
          console.log("Decoded accounts:");
          const auth2 = new Authenticator;
          for (const acc of accounts) {
            const accountName = `${acc.issuer}:${acc.name}`;
            console.log(`${accountName} - ***`);
            const success = await auth2.register(accountName, acc.secret);
            if (success) {
              console.log(` Registered: ${accountName}`);
            } else {
              console.log(` Failed: ${accountName}`);
            }
          }
          console.log("Import complete!");
          process.exit(0);
        }).catch((e) => {
          console.error("Error:", e.message);
          process.exit(1);
        });
      } else {
        console.error("Error: Please provide path to QR code image");
        process.exit(1);
      }
    } else {
      console.error("Usage: bun run index.tsx import google [uri] or import qr <image_path>");
      process.exit(1);
    }
  } else if (args[0] === "show") {
    const accounts = await auth.listAccounts();
    let filteredAccounts = accounts;
    if (args[1]) {
      filteredAccounts = accounts.filter((a2) => a2.account.toLowerCase() === args[1].toLowerCase());
    }
    const tokens = {};
    for (const { account } of filteredAccounts) {
      tokens[account] = await auth.getTokenForAccount(account);
    }
    await run(/* @__PURE__ */ jsx_dev_runtime2.jsxDEV(ShowAllComponent, {
      initialAccounts: filteredAccounts,
      initialTokens: tokens,
      auth
    }, undefined, false, undefined, this));
  } else {
    await run(/* @__PURE__ */ jsx_dev_runtime2.jsxDEV(ExitComponent, {}, undefined, false, undefined, this));
  }
}
main();
